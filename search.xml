<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>迭代思维与MVP产品的规划方法</title>
    <url>/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>​              </p>
<a id="more"></a>

<h3 id="快速迭代的价值与挑战"><a href="#快速迭代的价值与挑战" class="headerlink" title="快速迭代的价值与挑战"></a>快速迭代的价值与挑战</h3><p>快速迭代：以天或者小时为单位，持续的完善产品，交付到用户的循环过程</p>
<h4 id="快速迭代的价值："><a href="#快速迭代的价值：" class="headerlink" title="快速迭代的价值："></a>快速迭代的价值：</h4><ul>
<li>时间是最大的成本，机会转瞬即逝，赢得市场先机。</li>
<li>快速验证需求，减少不对用户产生价值的投入（Fail fast, Fail better）。</li>
<li>快速验证方案，提高研发效率。</li>
<li>加速反馈回路，给到团队和自己及时的激励。</li>
</ul>
<h4 id="快速迭代的挑战："><a href="#快速迭代的挑战：" class="headerlink" title="快速迭代的挑战："></a>快速迭代的挑战：</h4><ul>
<li>产品设计者：能梳理清楚业务流程，抓住用户的重点需求，能把客户需求转换为系统的需求。</li>
<li>开发者：充分理解用户需求，有足够的能力，能用简洁的方案来设计出易维护的系统。</li>
</ul>
<h4 id="根本挑战："><a href="#根本挑战：" class="headerlink" title="根本挑战："></a>根本挑战：</h4><ul>
<li><p>市场、用户、技术、环境变化太快，产品开发跟不上节奏。</p>
</li>
<li><p>几乎不能从一开始就设计一个完美的，能够使用未来长时间变化的方案</p>
</li>
<li><p>几乎没有人愿意承认，自己没有足够的力（或条件）设计一个完美的产品（系统）。</p>
</li>
</ul>
<h3 id="OOPD-方法识别产品的核心功能"><a href="#OOPD-方法识别产品的核心功能" class="headerlink" title="OOPD 方法识别产品的核心功能"></a>OOPD 方法识别产品的核心功能</h3><p>OOPD：Online and Offline integrated Product Development  </p>
<p><img src="/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/OOPD.png"></p>
<p>OOPD迭代的原则：</p>
<ul>
<li>自助原则：做自己的产品，自己用自己的产品，吃自己的狗食。</li>
<li>0day：找到明确的核心问题，拆解目标，抓住核心的问题，忽略掉一切细节，0day发布。</li>
<li>时限原则：设定时限，挑战自我，不给自己写BUG的时间。</li>
<li>不完美原则：不做完美的产品。（没有完美的产品，不去为了完美而浪费宝贵的资源）</li>
<li>谦卑原则：能够看到自己的局限性，获取用户反馈，持续迭代，听取用户的声音。</li>
</ul>
<p>MVP：minimum viable product 最小可用产品</p>
<ul>
<li>内裤原则 ： MVP 包括了产品的轮廓，核心的功能，让业务可以运转。</li>
<li>优先线下：能够走线下的 优先走线下的流程，让核心的功能先跑起来，快速的做用户验证和方案验证。</li>
<li>MVP的核心：忽略掉一切技术的细枝末节，做最合适的假设和简化，使用最短的时间开发出来。</li>
</ul>
<p>迭代思维最强大的是产品思维逻辑，互联网唯快不破的秘诀。</p>
<h3 id="如何做好技术方案设计与工作拆解"><a href="#如何做好技术方案设计与工作拆解" class="headerlink" title="如何做好技术方案设计与工作拆解"></a>如何做好技术方案设计与工作拆解</h3><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h4><ul>
<li>做技术方案设计的前提条件<ul>
<li>有明确的的用户场景，用户如何和产品进行交互，期望拿到什么预期结果。</li>
<li>有清晰定义的业务流程</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li><p>用什么工具设计？</p>
<ul>
<li>Visual Paradigm</li>
<li>Lucid Chart</li>
<li>Visio</li>
<li>Gliffy</li>
<li>Draw.io</li>
<li>Astash</li>
<li>StarUML</li>
<li>…..</li>
</ul>
<p>推荐使用<strong>白纸</strong>，不用工具就是最好的工具。</p>
</li>
<li><p>产出的技术方案文档要素</p>
<ul>
<li>产品背景（用户场景、产品目标、引用到的业务流畅、产品需求文档）</li>
<li>要解决的问题列表，系统不解决的问题列表，系统的限制。</li>
<li>对于问题的不同的解决方案的对比，阐述各个主要的问题如何被解决。</li>
<li>所选的整体的流程图（序列图），模块关系图，重要的接口，实体的概念定义。</li>
<li>除了功能之外的其他方面的设计，包括安全、性能、可维护性、稳定性、监控、扩展性、易用性等。</li>
</ul>
</li>
</ul>
<h4 id="工作拆解"><a href="#工作拆解" class="headerlink" title="工作拆解"></a>工作拆解</h4><p>​    任何事情，只要把它拆解的够细，都能够完成它。</p>
<ul>
<li>工作拆解的原则：<ul>
<li>优先级：主流程上，不确定的工作先完成（建议提前一个迭代做调研）。</li>
<li>核心流程优先：核心工作优先，先把主流程跑通。</li>
<li>依赖：减少不同人之间的工作依赖，并且保持团队工作拆解的透明，预留20%Buffer。</li>
<li>拆解粒度：拆解到每项子任务0.5-1天的粒度，最长不要超过两天。</li>
</ul>
</li>
</ul>
<h3 id="如何保证交付质量和可持续迭代"><a href="#如何保证交付质量和可持续迭代" class="headerlink" title="如何保证交付质量和可持续迭代"></a>如何保证交付质量和可持续迭代</h3><p>定义好产品需求，产品需求从根本上决定了产品的质量。</p>
<p>系统上有整体架构方案的设计，评估，评审，系统决定了软件实现的质量。</p>
<p>工程的角度持续交付的最佳实践推荐：</p>
<ul>
<li> Code Review：每一次提交都有CR，每次commit 代码量控制在200行y以内。尽量频繁的commit。</li>
<li>单元集成：项目开始简历单元测试的机制，在持续集成中自动运行。</li>
<li>自动化回归：对预发/线上系统做KPI/页面自动化测试（Postman/Robot Framework）</li>
<li>使用CICD机制对心痛进行自动化的打包，测试，部署，线上验证。</li>
<li>发布过程做到可监控，可回滚。</li>
<li>对于大量用户使用的产品，使用灰度机制。</li>
<li>架构上对于意外的并发访问，进行限流，降级。</li>
<li>架构上使用配置开关，对系统功能能提供实时的开启/关闭的服务。</li>
<li>对产品简历A/B Test 机制，通过数据快速对比不同的版本，不同的方案。</li>
<li>自动化所有的事情，代码化所有过程：代码化配置，代码化部署流程，代码化基础设置。<ul>
<li>声明式API，CICD Pipeline，K8S，Helm , Terraform</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>产品思维</category>
      </categories>
      <tags>
        <tag>OOPD</tag>
      </tags>
  </entry>
  <entry>
    <title>开发前的基础工作之系统环境篇【Pythonista】</title>
    <url>/2023/04/06/%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C%E4%B9%8B%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E7%AF%87/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="开发前的基础工作之系统环境篇"><a href="#开发前的基础工作之系统环境篇" class="headerlink" title="开发前的基础工作之系统环境篇"></a>开发前的基础工作之系统环境篇</h1><p>当我们进入到一个新的环境，或者是拿到一个新的操作系统，往往都需要我们配置自己的开发环境，系统软件环境等。</p>
<p>本次以Python开发者为例，介绍一个<strong>Pythonista</strong>需要做哪些准备工作。</p>
<p>个人常用的操作系统为Windows和Ubuntu, 所以以下的所有环境配置和软件都是基于Windows和Ubutu的。</p>
<h2 id="1-windwos系统软件"><a href="#1-windwos系统软件" class="headerlink" title="1 windwos系统软件"></a>1 windwos系统软件</h2><p>windows系统层面一般不需要太多的设置，只需要安装一些自己的开发软件。</p>
<p>首先作为开发者的必备的软件：</p>
<ul>
<li><p>Python 不装不行的软件</p>
</li>
<li><p>Git 代码版本控制系统</p>
</li>
<li><p>PyCharm - Pythonista Python编辑器利器 (针对Python项目)</p>
</li>
<li><p>Visual - Studio Code 同样是编辑器利器 （作为轻量化文本编辑器）</p>
</li>
<li><p>WebStorm - Pythoneer写个前端项目也不是不行</p>
</li>
<li><p>Navicat - 数据库可视化管理软件</p>
</li>
<li><p>Another Redis Desktop Manager - Redis可视化管理工具</p>
</li>
<li><p>ApiPost7 - 接口测试管理利器 同类型的有Apifox、Postman</p>
</li>
<li><p>WindTerm - 轻量开源的终端管理工具</p>
</li>
<li><p>chrome - 必备浏览器</p>
</li>
<li><p>Docker Desktop - windwos系统的中的docker</p>
</li>
<li><p>WSL - 本地Linux开发王炸</p>
</li>
<li><p>Windows Terminal - 比CMD好用一万倍的终端</p>
</li>
<li><p>Miniconda - Python多环境管理的佼佼者</p>
</li>
</ul>
<p>其他的一些软件（非开发者必备）：</p>
<ul>
<li>ToDesk - 远程桌面 (半夜远程修改BUG必备)</li>
<li>WizTree - 扫描磁盘空间文件利器</li>
<li>VMware Workstation - 虚拟机，保证测试环境的纯(测试用的较多)</li>
<li>IDM - 结合油猴脚本可以成为下载神器</li>
<li>Fiddler Classic - 抓包利器</li>
<li>Barrier - 跨平台共享使用鼠标和键盘利器。</li>
<li>Typora - Markdown写作工具</li>
<li>Snipaste - 桌面截图贴图利器。</li>
</ul>
<h2 id="2-Windows开发环境配置"><a href="#2-Windows开发环境配置" class="headerlink" title="2 Windows开发环境配置"></a>2 Windows开发环境配置</h2><h3 id="2-1-配置Miniconda"><a href="#2-1-配置Miniconda" class="headerlink" title="2.1 配置Miniconda"></a>2.1 配置Miniconda</h3><p><a href="https://docs.conda.io/en/latest/miniconda.html#windows-installers">官网</a>下载exe可执行文件，直接安装即可。然后需要做的就是切换miniconda的源。Miniconda 的基本配置:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消base环境的显示</span></span><br><span class="line">conda config -<span class="literal">-set</span> auto_activate_base False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置显示下载连接 </span></span><br><span class="line">conda config -<span class="literal">-set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换清华源：</span></span><br><span class="line">conda config -<span class="literal">-add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config -<span class="literal">-add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure>
<p>如果要在Linux上开发，一般有好几种情况 (我一般使用第一种方式，使用WSL)：</p>
<ol>
<li><p>在Windows上安装WSL, 使用Ubuntu子系统</p>
</li>
<li><p>使用虚拟机，在虚拟机中安装系统各个发行版的Linux系统。 (本地构建分布式使用)</p>
</li>
<li><p>直接使用Linux系统 (基本很少使用，缺少常用的办公软件生态)</p>
</li>
</ol>
<h3 id="2-2-配置Windows-Terminal"><a href="#2-2-配置Windows-Terminal" class="headerlink" title="2.2 配置Windows Terminal"></a>2.2 配置Windows Terminal</h3><p>在微软商店即可直接下载，此软件也不需要什么配置，可以根据自己的使用习惯配置默认打开的配置文件，我这里使用的是PowerShell。</p>
<p><img src="https://tc.chaizz.com/tc/image-20230406152440738.png" alt="image-20230406152440738"></p>
<h3 id="2-3-配置WSL"><a href="#2-3-配置WSL" class="headerlink" title="2.3 配置WSL"></a>2.3 配置WSL</h3><p>直接在微软应用商店，下载需要的Linux版本， 这里我常用的是Ubuntu, 一般选择最新版22.04或者是20.04。</p>
<p>安装完毕后在windwos菜单中可以直接找到安装的ubuntu图标。可以直接打开使用。但是这里有一个点是默认安装的系统在C盘。我们可以手动更改为其他的盘符。</p>
<p>步骤如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、以管理员身份打开Windows Terminal 或者 PowerShell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、 查看当前WSL服务应用</span></span><br><span class="line">wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br><span class="line"><span class="comment"># 展示结果如下，Ubuntu-20.04是上一步安装的LInux子系统名称 （名称可能不一样） </span></span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* docker<span class="literal">-desktop</span><span class="literal">-data</span>    Stopped         <span class="number">2</span></span><br><span class="line">  Ubuntu<span class="literal">-20</span>.<span class="number">04</span>           Running         <span class="number">2</span></span><br><span class="line">  docker<span class="literal">-desktop</span>         Stopped         <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、关闭wsl</span></span><br><span class="line">wsl -<span class="literal">-shutdown</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4、 卸载刚刚安装的系统</span></span><br><span class="line">wsl -<span class="literal">-unregister</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、 导出到别的文件夹，此处导出到D盘下的WSL_Ubuntu</span></span><br><span class="line">wsl -<span class="literal">-export</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span> D:\WSL_Ubuntu\ubuntu.rar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、 导入到指定的文件夹，同样在D盘D盘下的WSL_Ubuntu</span></span><br><span class="line">wsl -<span class="literal">-import</span> Ubuntu D:\WSL_Ubuntu D:\WSL_Ubuntu\ubuntu.rar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7、启动Ubutnu</span></span><br><span class="line">wsl <span class="literal">-d</span> ubuntu</span><br></pre></td></tr></table></figure>
<p>讲过上述布置后我们就可以得到一个在windwos下的Linux子系统，我们可以直接通过命令行进入该系统，就像操作Linux一样。</p>
<h3 id="2-4-WSL-文件传输配置"><a href="#2-4-WSL-文件传输配置" class="headerlink" title="2.4 WSL 文件传输配置"></a>2.4 WSL 文件传输配置</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、打开Windows Terminal 或者 PowerShell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、进入Linux子系统，执行</span></span><br><span class="line">explorer.exe .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、此时终端会自动打开一个文件夹，就是在终端执行上一步命令的文件夹。</span></span><br><span class="line"><span class="comment"># 我们可以像操作本地文件一样操作Linux文件夹。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、如果不想每次都执行 explorer.exe . 可以将Linux的文件位置，添加到盘符中。</span></span><br><span class="line"><span class="comment"># 4.1、将第2步弹出的文件夹路径复制出来 ：例如 \\wsl$\Ubuntu\root</span></span><br><span class="line"><span class="comment"># 4.2、打开windwos 此电脑--&gt; 添加一个网络位置--&gt;下一页--&gt;指定网站的位置。</span></span><br><span class="line"><span class="comment"># 4.3、将4.2 复制的地址输入。此时在我的电脑网络位置中，就会出现刚刚设置的文件夹。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://tc.chaizz.com/tc/image-20230406155044674.png" alt="image-20230406155044674"></p>
<h2 id="3-Linux开发环境配置"><a href="#3-Linux开发环境配置" class="headerlink" title="3 Linux开发环境配置"></a>3 Linux开发环境配置</h2><p>此处以WSL子系统为例。</p>
<p>配置apt源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份源文件</span></span><br><span class="line">sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  使用目录替换源地址</span></span><br><span class="line">sudo sed -i &quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">sudo sed -i &quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新 apt</span></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>


<p>此处列出几个镜像站</p>
<table>
<thead>
<tr>
<th>华为云</th>
<th><a href="https://mirrors.huaweicloud.com/home">https://mirrors.huaweicloud.com/home</a></th>
</tr>
</thead>
<tbody><tr>
<td>清华大学</td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></td>
</tr>
<tr>
<td>阿里云</td>
<td><a href="https://developer.aliyun.com/mirror/">https://developer.aliyun.com/mirror/</a></td>
</tr>
<tr>
<td>腾讯云</td>
<td><a href="https://mirrors.cloud.tencent.com/">https://mirrors.cloud.tencent.com/</a></td>
</tr>
<tr>
<td>网易网</td>
<td><a href="http://mirrors.163.com/">http://mirrors.163.com/</a></td>
</tr>
<tr>
<td>北大</td>
<td><a href="https://mirrors.pku.edu.cn/Mirrors">https://mirrors.pku.edu.cn/Mirrors</a></td>
</tr>
</tbody></table>
<p>配置pip源</p>
<p>Linux 默认安装的python的pip源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者手动更改 pip.conf 配置文件 /root/.config/pip/pip.conf</span></span><br></pre></td></tr></table></figure>
<p>安装 minicaonda 和在windows上安装一致。</p>
]]></content>
      <categories>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>系统设置</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(三)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%B8%89)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-三"><a href="#js笔记之Promise-三" class="headerlink" title="js笔记之Promise(三)"></a>js笔记之Promise(三)</h1><h2 id="1-使用-promise-进行错误处理"><a href="#1-使用-promise-进行错误处理" class="headerlink" title="1 使用 promise 进行错误处理"></a>1 使用 promise 进行错误处理</h2><p>promise链在错误中处理中非常强大，当一个 promise 被 reject 时，控制权将移交至最近的 rejection 处理程序。这在实际开发中非常方便。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://no-such-server.blabla&#x27;</span>) <span class="comment">// reject</span></span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// TypeError: Failed to fetch（这里的文字可能有所不同）</span></span><br></pre></td></tr></table></figure>


<h2 id="2-隐式的try…catch"><a href="#2-隐式的try…catch" class="headerlink" title="2 隐式的try…catch"></a>2 隐式的try…catch</h2><p>在 executor 周围的“隐式 <code>try..catch</code>”自动捕获了 error，并将其变为 rejected promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>); <span class="comment">// reject 这个 promise</span></span><br><span class="line">&#125;).catch(alert); <span class="comment">// Error: Whoops!</span></span><br></pre></td></tr></table></figure>


<h2 id="2-再次抛出（Rethrowing）"><a href="#2-再次抛出（Rethrowing）" class="headerlink" title="2 再次抛出（Rethrowing）"></a>2 再次抛出（Rethrowing）</h2><p>在平常的try…catch中，在catch中遇到我们无法处理的错误我们可以再次的抛出异常，对于promise来 说也是可以的。</p>
<p>如果在promise的.catch中使用throw， 那么控制权就会移交到下一个error的处理程序，如果正常处理error并且正常完成，那么就会到最近的then处理程序。下面是一个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行流：catch -&gt; then</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;The error is handled, continue normally&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Next successful handler runs&quot;</span>));</span><br></pre></td></tr></table></figure>


<h2 id="3-未处理的-rejection"><a href="#3-未处理的-rejection" class="headerlink" title="3 未处理的 rejection"></a>3 未处理的 rejection</h2><p>如果一个error没有被处理，会发生什么？此时程序就会像正常开发中抛出了一个错误一样，脚本停止，然后生成一个全局的异常。</p>
<p>如果出现了一个 error，并且在这没有 .catch，那么 unhandledrejection 处理程序就会被触发，并获取具有 error 相关信息的 event 对象，所以我们就能做一些后续处理了。</p>
<p>通常此类 error 是无法恢复的，所以我们最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。</p>
<p>在 Node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。</p>
<h2 id="4-Promise-all"><a href="#4-Promise-all" class="headerlink" title="4 Promise.all"></a>4 Promise.all</h2><p>并行执行多个promise, 并等待所有的promise都准备就绪，例如并行下载几个url。</p>
<p>语法：<code>let promise = Promise.all(iterable);</code>，他接受一个可迭代对象，通常是一个项为promise的数组。并返回一个新的promise，当所有的promise 都 resolve时，新的promise才会resolve。并且其结果数组就是将成为新的promise的结果。</p>
<p>注意：结果数组中元素的顺序和在源promise中的顺序相同，不管每个promise执行时间的长短。</p>
<p>一个常见的技巧是：讲一个任务数组映射到一个promise, 然后将其包裹到promise.all。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/iliakan&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/remy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/jeresig&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个 url 映射（map）到 fetch 的 promise 中</span></span><br><span class="line"><span class="keyword">let</span> requests = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.all 等待所有任务都 resolved</span></span><br><span class="line"><span class="built_in">Promise</span>.all(requests)</span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> responses.forEach(</span><br><span class="line">        response =&gt; alert(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>: <span class="subst">$&#123;response.status&#125;</span>`</span>)</span><br><span class="line">    ));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>又或者另外一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;iliakan&#x27;</span>, <span class="string">&#x27;remy&#x27;</span>, <span class="string">&#x27;jeresig&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requests = names.map(<span class="function"><span class="params">name</span> =&gt;</span> fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;name&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(requests)</span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 所有响应都被成功 resolved</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> response <span class="keyword">of</span> responses) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>: <span class="subst">$&#123;response.status&#125;</span>`</span>); <span class="comment">// 对应每个 url 都显示 200</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> responses;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 将响应数组映射（map）到 response.json() 数组中以读取它们的内容</span></span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> <span class="built_in">Promise</span>.all(responses.map(<span class="function"><span class="params">r</span> =&gt;</span> r.json())))</span><br><span class="line">    <span class="comment">// 所有 JSON 结果都被解析：&quot;users&quot; 是它们的数组</span></span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> users.forEach(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(user.name)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果任意一个 promise 被 reject，由 <code>Promise.all</code> 返回的 promise 就会立即 reject，并且带有的就是这个 error。</strong></p>
<p>且其他的promise也会被忽略，它们的结果也被忽略。</p>
</blockquote>
<h2 id="5-Promise-allSettled"><a href="#5-Promise-allSettled" class="headerlink" title="5 Promise.allSettled"></a>5 Promise.allSettled</h2><p>此API等待所有的 promise 都被 settle，无论结果如何，结果数组都具有一下：</p>
<ul>
<li><code>&#123;status:&quot;fulfilled&quot;, value:result&#125;</code> 对于成功的响应，</li>
<li><code>&#123;status:&quot;rejected&quot;, reason:error&#125;</code> 对于 error。</li>
</ul>
<p>一个例子：我们想要获取（fetch）多个用户的信息。即使其中一个请求失败，我们仍然对其他的感兴趣。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/iliakan&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/remy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://no-such-url&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url)))</span><br><span class="line">    .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123; <span class="comment">// (*)</span></span><br><span class="line">        results.forEach(<span class="function">(<span class="params">result, num</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.status == <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">                alert(<span class="string">`<span class="subst">$&#123;urls[num]&#125;</span>: <span class="subst">$&#123;result.value.status&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.status == <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">                alert(<span class="string">`<span class="subst">$&#123;urls[num]&#125;</span>: <span class="subst">$&#123;result.reason&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>对于以上的每个 promise，我们都得到了其状态（status）和 <code>value/reason</code>。</p>
<h2 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6 Promise.race"></a>6 Promise.race</h2><p>与 <code>Promise.all</code> 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">2000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">3</span>), <span class="number">3000</span>))</span><br><span class="line">]).then(alert); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>在这里第一个 promise 最快，所以它变成了结果。第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。</p>
<h2 id="7-Pomise-any"><a href="#7-Pomise-any" class="headerlink" title="7 Pomise.any"></a>7 Pomise.any</h2><p>与 Promise.race 类似，区别在于 Promise.any 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回。如果给出的 promise 都 rejected，那么返回的 promise 会带有 AggregateError —— 一个特殊的 error 对象，在其 errors 属性中存储着所有 promise error。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">1000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">2000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">3</span>), <span class="number">3000</span>))</span><br><span class="line">]).then(alert); <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的第一个 promise 是最快的，但 rejected 了，所以第二个 promise 则成为了结果。在第一个 fulfilled 的 promise “赢得比赛”后，所有进一步的结果都将被忽略。</p>
<h2 id="8-Promise-resolve"><a href="#8-Promise-resolve" class="headerlink" title="8 Promise.resolve"></a>8 Promise.resolve</h2><p>在现代的代码中，很少需要使用 Promise.resolve 和 Promise.reject 方法，因为 async/await 语法使它们变得有些过时了。</p>
<p><code>Promise.resolve(value)</code> 用结果 <code>value</code> 创建一个 resolved 的 promise。</p>
<p>语法：<code>let promise = new Promise(resolve =&gt; resolve(value));</code></p>
<p>大概的使用场景：当一个函数被期望返回一个 promise 时，这个方法用于兼容性。（译注：这里的兼容性是指，我们直接从缓存中获取了当前操作的结果 <code>value</code>，但是期望返回的是一个 promise，所以可以使用 <code>Promise.resolve(value)</code> 将 <code>value</code> “封装”进 promise，以满足期望返回一个 promise 的这个需求。）</p>
<h2 id="9-Promise-reject"><a href="#9-Promise-reject" class="headerlink" title="9 Promise.reject"></a>9 Promise.reject</h2><p><code>Promise.reject(error)</code> 用 <code>error</code> 创建一个 rejected 的 promise。</p>
<p>语法：<code>let promise = new Promise((resolve, reject) =&gt; reject(error));</code></p>
<p>实际上，这个方法几乎从未被使用过。</p>
<p>总结：</p>
<ul>
<li><code>catch</code> 处理 promise 中的各种 error：在 <code>reject()</code> 调用中的，或者在处理程序中抛出的 error。</li>
<li>如果给定 <code>.then</code> 的第二个参数（即 error 处理程序），那么 <code>.then</code> 也会以相同的方式捕获 error。</li>
<li>在任何情况下我们都应该有 <code>unhandledrejection</code> 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。</li>
</ul>
<p>​    </p>
<ul>
<li><code>Promise</code> 类有 6 种静态方法：<code>Promise.all</code> 可能是在实战中使用最多的。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(五)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%BA%94)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-五"><a href="#js笔记之Promise-五" class="headerlink" title="js笔记之Promise(五)"></a>js笔记之Promise(五)</h1><h2 id="1-微任务"><a href="#1-微任务" class="headerlink" title="1 微任务"></a>1 微任务</h2><p>promise 的处理程序 <code>.then</code>、<code>.catch</code> 和 <code>.finally</code> 都是异步的。</p>
<p>即便一个 promise 立即被 resolve，<code>.then</code>、<code>.catch</code> 和 <code>.finally</code> <strong>下面</strong> 的代码也会在这些处理程序之前被执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;promise done!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;code finished&quot;</span>); <span class="comment">// 这个 console.log 先显示</span></span><br></pre></td></tr></table></figure>


<p>异步任务需要适当的管理，为此ECMA规定了一个内部队列，PromiseJobs，通常被称为“微任务队列（microtask queue）”（V8 术语）。</p>
<p>如 <a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">规范</a> 中所述：</p>
<ul>
<li>队列（queue）是先进先出的：首先进入队列的任务会首先运行。</li>
<li>只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务。</li>
</ul>
<p>简单的说就是当一个promise 准备就绪时，它的 <code>.then/catch/finally</code> 处理程序就会被放入队列中：但是它们不会立即被执行。当 JavaScript 引擎执行完当前的代码，它会从队列中获取任务并执行它。</p>
<p>如果有一个包含多个 <code>.then/catch/finally</code> 的链，那么它们中的每一个都是异步执行的。也就是说，它会首先进入队列，然后在当前代码执行完成并且先前排队的处理程序都完成时才会被执行。</p>
<p><strong>如果执行顺序对我们很重要该怎么办？我们怎么才能让 <code>code finished</code> 在 <code>promise done</code> 之后出现呢？</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> alert(<span class="string">&quot;promise done!&quot;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> alert(<span class="string">&quot;code finished&quot;</span>));</span><br></pre></td></tr></table></figure>


<h2 id="2-未处理的-rejection"><a href="#2-未处理的-rejection" class="headerlink" title="2 未处理的 rejection"></a>2 未处理的 rejection</h2><p>在js笔记之Promise(三)中说明了，如果一个 promise 的 error 未被在微任务队列的末尾进行处理，则会出现“未处理的 rejection”。现在我们知道<code>.then/catch/finally</code> 处理程序就会被放入队列中,</p>
<p>任务队列清空后，avaScript 引擎会触发下面这事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise Failed!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise Failed!</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> alert(event.reason));</span><br></pre></td></tr></table></figure>
<p>当微任务队列中的任务都完成时，才会生成 <code>unhandledrejection</code>：引擎会检查 promise，如果 promise 中的任意一个出现 “rejected” 状态，<code>unhandledrejection</code> 事件就会被触发。</p>
<h2 id="3-总结："><a href="#3-总结：" class="headerlink" title="3 总结："></a>3 总结：</h2><p>Promise 处理始终是异步的，因为所有 promise 行为都会通过内部的 “promise jobs” 队列，也被称为“微任务队列”（V8 术语）。</p>
<p>因此，<code>.then/catch/finally</code> 处理程序总是在当前代码完成后才会被调用。</p>
<p>如果我们需要确保一段代码在 <code>.then/catch/finally</code> 之后被执行，我们可以将它添加到链式调用的 <code>.then</code> 中。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(六)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E5%85%AD)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-六"><a href="#js笔记之Promise-六" class="headerlink" title="js笔记之Promise(六)"></a>js笔记之Promise(六)</h1><p>async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。</p>
<h2 id="1-async-function"><a href="#1-async-function" class="headerlink" title="1 async function"></a>1 async function</h2><p>语法：他可以被放置当在一个函数前面，他表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们显式的返回一个promise结果也是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="built_in">console</span>.log); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以说async确保了函数返回一个promise，也会将非 promise 的值包装进去。</p>
<h2 id="2-await"><a href="#2-await" class="headerlink" title="2 await"></a>2 await</h2><p>语法：只在 async 函数内工作, 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="keyword">await</span> promise;</span><br></pre></td></tr></table></figure>
<p>例如一个一秒后的resolve的promise:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done!&quot;</span>), <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> promise; <span class="comment">// 等待，直到 promise resolve (*)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &quot;done!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>


<p>上面的这个函数在执行的时候，“暂停”在了 <code>(*)</code> 那一行，并在 promise settle 时，拿到 <code>result</code> 作为结果继续往下执行。所以上面这段代码在一秒后显示 “done!”。</p>
<blockquote>
<p>Tips：<code>await</code> 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p>
</blockquote>
<p>相比于 <code>promise.then</code>，它只是获取 promise 的结果的一个更优雅的语法。并且也更易于读写。</p>
<blockquote>
<p>如果我们尝试在非 async 函数中使用 <code>await</code>，则会报语法错误。</p>
</blockquote>
<p>在现代浏览器中可以在一个modules，那么在顶层使用await也是可以的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">*<span class="comment">// 我们假设此代码在 module 中的顶层运行*</span></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/promise-chaining/user.json&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line"><span class="built_in">console</span>.log(user);</span><br></pre></td></tr></table></figure>


<p>如果我们没有使用 modules，或者必须兼容 旧版本浏览器 ，那么这儿还有一个通用的方法：包装到匿名的异步函数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/promise-chaining/user.json&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>


<blockquote>
<p>像 <code>promise.then</code> 那样，<code>await</code> 允许我们使用 thenable 对象（那些具有可调用的 <code>then</code> 方法的对象）。这里的想法是，第三方对象可能不是一个 promise，但却是 promise 兼容的：如果这些对象支持 <code>.then</code>，那么就可以对它们使用 <code>await</code>。</p>
</blockquote>
<h2 id="3-在类class中使用async方法"><a href="#3-在类class中使用async方法" class="headerlink" title="3 在类class中使用async方法"></a>3 在类class中使用async方法</h2><p>在类Class中使用async方法，只需在对应方法前面加上 <code>async</code> 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">wait</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Waiter()</span><br><span class="line">    .wait()</span><br><span class="line">    .then(alert); <span class="comment">// 1（alert 等同于 result =&gt; alert(result)）</span></span><br></pre></td></tr></table></figure>


<h2 id="4-Error-处理"><a href="#4-Error-处理" class="headerlink" title="4 Error 处理"></a>4 Error 处理</h2><p>如果一个 promise 正常 resolve，<code>await promise</code> 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 <code>throw</code> 语句那样。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面的是一样的</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在真实开发中，promise 可能需要一点时间后才 reject。在这种情况下，在 <code>await</code> 抛出（throw）一个 error 之前会有一个延时。</p>
<p>我们可以用 <code>try..catch</code> 来捕获上面提到的那个 error，与常规的 <code>throw</code> 使用的是一样的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://no-such-url&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err); <span class="comment">// TypeError: failed to fetch</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>如果有 error 发生，执行控制权马上就会被移交至 <code>catch</code> 块。我们也可以用 <code>try</code> 包装多行 <code>await</code> 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/no-user-here&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 捕获到 fetch 和 response.json 中的错误</span></span><br><span class="line">        alert(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>如果我们没有 <code>try..catch</code>，那么由异步函数 <code>f()</code> 的调用生成的 promise 将变为 rejected。我们可以在函数调用后面添加 <code>.catch</code> 来处理这个 error：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://no-such-url&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f() 变成了一个 rejected 的 promise</span></span><br><span class="line">f().catch(alert); <span class="comment">// TypeError: failed to fetch // (*)</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong><code>async/await</code> 和 <code>promise.then/catch</code></strong></p>
<p>当我们使用 <code>async/await</code> 时，几乎就不会用到 <code>.then</code> 了，因为 <code>await</code> 为我们处理了等待。并且我们使用常规的 <code>try..catch</code> 而不是 <code>.catch</code>。这通常（但不总是）更加方便。</p>
<p>但是当我们在代码的顶层时，也就是在所有 <code>async</code> 函数之外，我们在语法上就不能使用 <code>await</code> 了，所以这时候通常的做法是添加 <code>.then/catch</code> 来处理最终的结果（result）或掉出来的（falling-through）error，例如像上面那个例子中的 <code>(*)</code> 行那样。</p>
</blockquote>
<blockquote>
<p><strong><code>async/await</code> 可以和 <code>Promise.all</code> 一起使用</strong></p>
<p>当我们需要同时等待多个 promise 时，我们可以用 <code>Promise.all</code> 把它们包装起来，然后使用 <code>await</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待结果数组</span></span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">  fetch(url1),</span><br><span class="line">  fetch(url2),</span><br><span class="line">  ...</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>如果出现 error，也会正常传递，从失败了的 promise 传到 <code>Promise.all</code>，然后变成我们能通过使用 <code>try..catch</code> 在调用周围捕获到的异常（exception）。</p>
</blockquote>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>函数前面的关键字 <code>async</code> 有两个作用：</p>
<ol>
<li>让这个函数总是返回一个 promise。</li>
<li>允许在该函数内使用 <code>await</code>。</li>
</ol>
<p>Promise 前的关键字 <code>await</code> 使 JavaScript 引擎等待该 promise settle，然后：</p>
<ol>
<li>如果有 error，就会抛出异常 —— 就像那里调用了 <code>throw error</code> 一样。</li>
<li>否则，就返回结果。</li>
</ol>
<p>这两个关键字一起提供了一个很好的用来编写异步代码的框架，这种代码易于阅读也易于编写。</p>
<p>有了 <code>async/await</code> 之后，我们就几乎不需要使用 <code>promise.then/catch</code>，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法。并且，当我们需要同时等待需要任务时，<code>Promise.all</code> 是很好用的。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(四)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-四"><a href="#js笔记之Promise-四" class="headerlink" title="js笔记之Promise(四)"></a>js笔记之Promise(四)</h1><h2 id="1-Promisification"><a href="#1-Promisification" class="headerlink" title="1 Promisification"></a>1 Promisification</h2><p>Promisification 它指将一个接受回调的函数转换为一个返回 promise 的函数。由于许多的函数都是基于回调的，因此在实际的开发中经常会遇到这种转化。一个简单的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    script.onload = <span class="function">() =&gt;</span> callback(<span class="literal">null</span>, script);</span><br><span class="line">    script.onerror = <span class="function">() =&gt;</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.append(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用法：</span></span><br><span class="line">  <span class="comment">// loadScript(&#x27;path/script.js&#x27;, (err, script) =&gt; &#123;...&#125;)</span></span><br></pre></td></tr></table></figure>
<p>上面的例子 通过给定的src加载脚本，然后再出现错误是调用callback(err)，或者在加载成功时，调用callback(null，script) 。</p>
<p>接下来我们将这个函数promise化。</p>
<p>我们要做的就是将这个函数返回一个promise,而不是使用回调。换句话就是我们只传入src, 然后再函数中return一个promise。加载成功时该 promise 将以 <code>script</code> 为结果 resolve，否则将以出现的 error 为结果 reject。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptPromise</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        loadScript(src, <span class="function">(<span class="params">err, script</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            <span class="keyword">else</span> resolve(script)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，我们可能需要 promise 化很多函数，所以使用一个 helper（辅助函数）很有意义。</p>
<p>我们将其称为 <code>promisify(f)</code>：它接受一个需要被 promise 化的函数 <code>f</code>，并返回一个包装（wrapper）函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promisify(f, true) 来获取结果数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">f, manyArgs = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err, ...results</span>) </span>&#123; <span class="comment">// 我们自定义的 f 的回调</span></span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 manyArgs 被指定，则使用所有回调的结果 resolve</span></span><br><span class="line">                    resolve(manyArgs ? results : results[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            args.push(callback);</span><br><span class="line"></span><br><span class="line">            f.call(<span class="built_in">this</span>, ...args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line">f = promisify(f, <span class="literal">true</span>);</span><br><span class="line">f(...).then(<span class="function"><span class="params">arrayOfResults</span> =&gt;</span> ..., <span class="function"><span class="params">err</span> =&gt;</span> ...);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之Generator(一)</title>
    <url>/2023/03/27/JS%E7%AC%94%E8%AE%B0%E4%B9%8BGenerator(%E4%B8%80)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之Generator-一"><a href="#JS笔记之Generator-一" class="headerlink" title="JS笔记之Generator(一)"></a>JS笔记之Generator(一)</h1><p>在JS中常规函数只会返回一个单一值，或者不返回值。而generator可以按需一个接一个的返回（yield）多个值。</p>
<h2 id="1-generator-函数"><a href="#1-generator-函数" class="headerlink" title="1 generator 函数"></a>1 generator 函数</h2><p>要创建一个generator，我们需要创建一个特殊的语法结构：function*，即所谓的“generator function”。它看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator 函数与常规函数的行为不同。在此类函数被调用时，它不会运行其代码。而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;generator function&quot; 创建了一个 &quot;generator object&quot;</span></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"><span class="built_in">console</span>.log(generator); <span class="comment">// [object Generator] &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>一个generator的主要的方法就是next()，当调用next()方法时，函数会执行到最近的一个yield，然后函数执行暂停，并将产出的（yielded）值返回到外部代码。</p>
<p><code>next()</code> 的结果始终是一个具有两个属性的对象：</p>
<ul>
<li><code>value</code>: 产出的（yielded）的值。</li>
<li><code>done</code>: 如果 generator 函数已执行完成则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>
<p>例如我们获取第一个值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"><span class="keyword">let</span> one = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(one)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以到现在函数只执行到了 <code>yield 1;</code>  如果再次调用就会返回{value: 2, done: false}, 继续调用 就会返回{value: 3, done: true}，代表函数执行完毕，如果在次调用next()，没有任何意义。只会返回{done: true}</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> one = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(one)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> two = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(two)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(t)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(f)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>function* f(…)</code> 或 <code>function *f(…)</code>？</strong></p>
<p>这两种语法都是对的。</p>
<p>但是通常更倾向于第一种语法，因为星号 <code>*</code> 表示它是一个 generator 函数，它描述的是函数种类而不是名称，因此 <code>*</code> 应该和 <code>function</code> 关键字紧贴一起。</p>
</blockquote>
<h2 id="2-generator-是可迭代的"><a href="#2-generator-是可迭代的" class="headerlink" title="2 generator 是可迭代的"></a>2 generator 是可迭代的</h2><p>我们可以用for…of 循环遍历生成器的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> generator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1，然后是 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>但是</strong>上面的例子不会返回3，这是因为当 done: true 时，for..of 循环会忽略最后一个 value。因此，如果我们想要通过 for..of 循环显示所有的结果，我们必须使用 yield 返回它们：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>因为 generator 是可迭代的，我们可以使用 iterator 的所有相关功能，例如：spread 语法 <code>...</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence = [<span class="number">0</span>, ...generateSequence()];</span><br><span class="line"></span><br><span class="line">alert(sequence); <span class="comment">// 0, 1, 2, 3</span></span><br></pre></td></tr></table></figure>


<h2 id="3-使用-generator-进行迭代"><a href="#3-使用-generator-进行迭代" class="headerlink" title="3 使用 generator 进行迭代"></a>3 使用 generator 进行迭代</h2><p>在之前的文章中，我们手动创建了一个可迭代对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">    to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for..of range 在一开始就调用一次这个方法</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="comment">// ...它返回 iterator object：</span></span><br><span class="line">        <span class="comment">// 后续的操作中，for..of 将只针对这个对象，并使用 next() 向它请求下一个值</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            current: <span class="built_in">this</span>.from,</span><br><span class="line">            last: <span class="built_in">this</span>.to,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// for..of 循环在每次迭代时都会调用 next()</span></span><br><span class="line">            <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 它应该以对象 &#123;done:.., value :...&#125; 的形式返回值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代整个 range 对象，返回从 `range.from` 到 `range.to` 范围的所有数字</span></span><br><span class="line">alert([...range]); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以使用生成器来改造它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">    to: <span class="number">5</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;  <span class="comment">// [Symbol.iterator]: function*() 的简写形式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> value = <span class="built_in">this</span>.from; value &lt;= <span class="built_in">this</span>.to; value++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代整个 range 对象，返回从 `range.from` 到 `range.to` 范围的所有数字</span></span><br><span class="line"><span class="built_in">console</span>.log([...range]); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>


<h2 id="4-generator-组合"><a href="#4-generator-组合" class="headerlink" title="4 generator 组合"></a>4 generator 组合</h2><p>generator 组合（composition）是 generator 的一个特殊功能，它允许透明地（transparently）将 generator 彼此“嵌入（embed）”到一起。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatePasswordCodes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0..9</span></span><br><span class="line">    <span class="keyword">yield</span>* generateSequence(<span class="number">48</span>, <span class="number">57</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A..Z</span></span><br><span class="line">    <span class="keyword">yield</span>* generateSequence(<span class="number">65</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a..z</span></span><br><span class="line">    <span class="keyword">yield</span>* generateSequence(<span class="number">97</span>, <span class="number">122</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> code <span class="keyword">of</span> generatePasswordCodes()) &#123;</span><br><span class="line">    str += <span class="built_in">String</span>.fromCharCode(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 0..9A..Za..z</span></span><br></pre></td></tr></table></figure>
<p>在上述的代码中使用了yield*指令，<code>yield*</code> 指令将执行 <strong>委托</strong> 给另一个 generator。这个术语意味着 <code>yield* gen</code> 在 generator <code>gen</code> 上进行迭代，并将其产出（yield）的值透明地（transparently）转发到外部。就好像这些值就是由外部的 generator yield 的一样。</p>
<blockquote>
<p>generator 组合（composition）是将一个 generator 流插入到另一个 generator 流的自然的方式。它不需要使用额外的内存来存储中间结果。</p>
</blockquote>
<h2 id="5-yield-是一条双向路"><a href="#5-yield-是一条双向路" class="headerlink" title="5 yield 是一条双向路"></a>5 yield 是一条双向路</h2><p>generator和可迭代对象很相似，但是generator更加的强大和灵活。其中generator不仅可以向外部返回结果，也可以将外部的值传递给generator内。通过调用generator.next(arg)，就能给generator添加值。这个arg就会变成yield的结果，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向外部代码传递一个问题并等待答案</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> <span class="string">&quot;2 + 2 = ?&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"><span class="keyword">let</span> question = generator.next().value; <span class="comment">// &lt;-- yield 返回的 value, question= 2 + 2 = ?</span></span><br><span class="line"></span><br><span class="line">generator.next(<span class="number">4</span>); <span class="comment">// --&gt; 将结果传递到 generator 中</span></span><br></pre></td></tr></table></figure>


<h2 id="6-generator-throw"><a href="#6-generator-throw" class="headerlink" title="6 generator.throw"></a>6 generator.throw</h2><p>在generator中也有可能抛出一个异常，error本身也是一个结果。如果要向 <code>yield</code> 传递一个 error，我们应该调用 <code>generator.throw(err)</code>。</p>
<p>正常的错误像之前的错误一样，会调出generator, 使脚本停止。</p>
<h2 id="7-generator-return"><a href="#7-generator-return" class="headerlink" title="7 generator.return"></a>7 generator.return</h2><p><code>generator.return(value)</code> 完成 generator 的执行并返回给定的 <code>value</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next());        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="string">&#x27;foo&#x27;</span>));; <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());;        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>


<p>如果我们在已完成的 generator 上再次使用 <code>generator.return()</code>，它将再次返回该值（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return">MDN</a>）。</p>
<p>通常我们不使用它，因为大多数时候我们想要获取所有的返回值，但是当我们想要在特定条件下停止 generator 时它会很有用。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><ul>
<li>generator 是通过 generator 函数 <code>function* f(…) &#123;…&#125;</code> 创建的。</li>
<li>在 generator（仅在）内部，存在 <code>yield</code> 操作。</li>
<li>外部代码和 generator 可能会通过 <code>next/yield</code> 调用交换结果。</li>
</ul>
<p>在现代 JavaScript 中，generator 很少被使用。但有时它们会派上用场，因为函数在执行过程中与调用代码交换数据的能力是非常独特的。而且，当然，它们非常适合创建可迭代对象。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(二)</title>
    <url>/2023/03/25/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-二"><a href="#js笔记之Promise-二" class="headerlink" title="js笔记之Promise(二)"></a>js笔记之Promise(二)</h1><h2 id="1-Promise链"><a href="#1-Promise链" class="headerlink" title="1 Promise链"></a>1 Promise链</h2><p>Promise链的想法是通过.then处理程序链进行传递result。一个例子是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>); <span class="comment">// (*)</span></span><br><span class="line">    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">// (**)</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">// (***)</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>他的运行流程如下：</p>
<ol>
<li>初始程reomise在一秒后执行resolve。</li>
<li>然后.then处理程序被调用，然后又创建了一个新的promise.</li>
<li>下一个 <code>then</code> <code>(***)</code> 得到了前一个 <code>then</code> 的值，对该值进行处理（*2）并将其传递给下一个处理程序。</li>
<li>以此类推…</li>
</ol>
<p>这样之所以是可行的，是因为每个对 <code>.then</code> 的调用都会返回了一个新的 promise，因此我们可以在其之上调用下一个 <code>.then</code>。</p>
<p>当处理程序返回一个值时，它将成为该 promise 的 result，所以将使用它调用下一个 <code>.then</code>。</p>
<p><strong>新手常犯的一个经典错误：从技术上讲，我们也可以将多个 <code>.then</code> 添加到一个 promise 上。但这并不是 promise 链（chaining）。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    alert(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    alert(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    alert(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="2-返回Promise"><a href="#2-返回Promise" class="headerlink" title="2 返回Promise"></a>2 返回Promise</h2><p><code>.then(handler)</code> 中所使用的处理程序（handler）可以创建并返回一个 promise。</p>
<p>在这种情况下，其他的处理程序将等待它 settled 后再获得其结果。 </p>
<blockquote>
<p>确切地说，处理程序返回的不完全是一个 promise，而是返回的被称为 “thenable” 对象 —— 一个具有方法 <code>.then</code> 的任意对象。它会被当做一个 promise 来对待。</p>
<p>这个想法是，第三方库可以实现自己的“promise 兼容（promise-compatible）”对象。它们可以具有扩展的方法集，但也与原生的 promise 兼容，因为它们实现了 <code>.then</code> 方法。</p>
</blockquote>
<p>如果 <code>.then</code>（或 <code>catch/finally</code> 都可以）处理程序返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。当它被 settled 后，其 result（或 error）将被进一步传递下去。</p>
<h2 id="3-总结："><a href="#3-总结：" class="headerlink" title="3 总结："></a>3 总结：</h2><p><img src="https://tc.chaizz.com/tc/image-20230325231946264.png" alt="image-20230325231946264"></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python环境管理Poetry的使用</title>
    <url>/2023/03/23/Python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86Poetry%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="Python环境管理Poetry的使用"><a href="#Python环境管理Poetry的使用" class="headerlink" title="Python环境管理Poetry的使用"></a>Python环境管理Poetry的使用</h1><blockquote>
<p>Poetry 是 Python 中依赖管理和打包的工具。他可以管理项目中的第三包的依赖（安装/更新）。T同时也提供了一个锁定文件以确保可重复安装，并且可以构建项目以供分发。</p>
</blockquote>
<p>poetry的Python版本要求为 3.7+，且是多平台的。</p>
<h2 id="1-安装-在windows平台下"><a href="#1-安装-在windows平台下" class="headerlink" title="1 安装 (在windows平台下)"></a>1 安装 (在windows平台下)</h2><h3 id="1-1-安装Poetry"><a href="#1-1-安装Poetry" class="headerlink" title="1.1 安装Poetry"></a>1.1 安装Poetry</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://install.python<span class="literal">-poetry</span>.org <span class="literal">-UseBasicParsing</span>).Content | python -</span><br></pre></td></tr></table></figure>
<p>根据官网安装的提示：如果是在Microsoft Store上安装的python，需要将上面的py替换为python，但是我直接安装，提示 <code>py : 无法将“py”项识别为 cmdlet、函数、脚本文件或可运行程序的名称</code>。必须要把py替换为python。</p>
<p>使用 <code>poetry --version</code> 检查版本， 如果提示版本号则安装成功。</p>
<h3 id="1-2-更新Poetry"><a href="#1-2-更新Poetry" class="headerlink" title="1.2 更新Poetry"></a>1.2 更新Poetry</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry self update</span><br></pre></td></tr></table></figure>
<h3 id="1-3-卸载Poetry"><a href="#1-3-卸载Poetry" class="headerlink" title="1.3 卸载Poetry"></a>1.3 卸载Poetry</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://install.python<span class="literal">-poetry</span>.org <span class="literal">-UseBasicParsing</span>).Content | python - -<span class="literal">-uninstall</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-配置poetry"><a href="#1-4-配置poetry" class="headerlink" title="1.4 配置poetry"></a>1.4 配置poetry</h3><p>poetry 安装后默认的缓存路径个虚拟环境路径在:</p>
<p><code>C:\Users\&lt;your name&gt;\AppData\Local\pypoetry\Cache</code> 为了不占用C盘空间，修改默认的虚拟环境的目录。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此处直接修改 cache-dir 就会修改 cache-dir 和 virtualenvs.path 的路径</span></span><br><span class="line">poetry config cache<span class="literal">-dir</span> D:\\poetry_enev </span><br></pre></td></tr></table></figure>
<p>通过 <code>poetry config --list</code> 查看已经修改成功</p>
<p><img src="https://tc.chaizz.com/33b9dcacca2011ed8b330242ac190002.png"></p>
<blockquote>
<p>取消之前的修改：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry config cache<span class="literal">-dir</span> -<span class="literal">-unset</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-使用poetry创建一个新项目"><a href="#2-使用poetry创建一个新项目" class="headerlink" title="2 使用poetry创建一个新项目"></a>2 使用poetry创建一个新项目</h2><ol>
<li><p>直接使用poetry 创建项目 </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry new project_name </span><br></pre></td></tr></table></figure>
<p>自动创建一个project_name的文件件，项目名称也叫做project_name。</p>
</li>
<li><p>添加python依赖</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在pyproject.toml 同目录下</span></span><br><span class="line">poetry add numpy </span><br></pre></td></tr></table></figure>
<p>安装的包和版本都会在  pyproject.toml 中</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.9&quot;</span></span><br><span class="line"><span class="attr">numpy</span> = <span class="string">&quot;^1.24.2&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>运行项目或者文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry run python run.py </span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="3-在现有项目中使用poetry"><a href="#3-在现有项目中使用poetry" class="headerlink" title="3 在现有项目中使用poetry"></a>3 在现有项目中使用poetry</h2><ol>
<li><p>在某个目录下 使用poetry init</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry init</span><br></pre></td></tr></table></figure>
<p>使用这种交互式的方式创建项目，根据选项设置完成之后，在对应的目录下同样会生成 pyproject.toml 文件。</p>
</li>
<li><p>添加依赖和运行项目和==使用poetry创建一个新项目==与一致。</p>
</li>
</ol>
<h2 id="4-拿到一个使用poetry管理依赖的新项目"><a href="#4-拿到一个使用poetry管理依赖的新项目" class="headerlink" title="4 拿到一个使用poetry管理依赖的新项目"></a>4 拿到一个使用poetry管理依赖的新项目</h2><ol>
<li><p>在pyproject.toml同目录下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry install</span><br></pre></td></tr></table></figure></li>
<li><p>如果要将依赖跟新到最新版本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry update</span><br></pre></td></tr></table></figure>


</li>
</ol>
<blockquote>
<p>Tips: 使用poetry时会生成 poetry.lock，此文件推荐上传到git版本控制中，</p>
</blockquote>
<h2 id="5-手动管理依赖"><a href="#5-手动管理依赖" class="headerlink" title="5 手动管理依赖"></a>5 手动管理依赖</h2><ol>
<li><p>在 pyproject.toml文件同目录下，进入虚拟环境</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></table></figure>
<p>使用此命令，进入当前的项目虚拟环境，接下来就像平常使用python一样了。</p>
</li>
<li><p>退出</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">deactivate </span><br><span class="line"><span class="comment"># 或者直接退出 这个是shell</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="6-管理环境"><a href="#6-管理环境" class="headerlink" title="6 管理环境"></a>6 管理环境</h2><ol>
<li><p>获取当前的虚拟环境的基本信息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry env info</span><br></pre></td></tr></table></figure></li>
<li><p>切换虚拟环境</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry env use 具体的环境的python可执行文件路径</span><br></pre></td></tr></table></figure></li>
<li><p>删除环境</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry env remove </span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="7-在Pycharm中配置poetry环境"><a href="#7-在Pycharm中配置poetry环境" class="headerlink" title="7 在Pycharm中配置poetry环境"></a>7 在Pycharm中配置poetry环境</h2><ol>
<li><p>一般拿到一个含有poetry环境的项目，使用pycharm打开，会自动识别poetry解释器。如果没有识别 需要手动添加，如下图所示：</p>
<ol>
<li>基础解释器：选择对应虚拟环境的Python可执行文件。</li>
<li>Poetry可执行文件，选择安装在本地的Poetry可执行文件。</li>
</ol>
<p><img src="https://tc.chaizz.com/tc/image-20230327103659866.png"></p>
</li>
<li><p>配置完毕，打开pycharm底部导航栏控制台，即可显示当前虚拟环境前缀，接下来就可以操作就按照正常的流程执行了。</p>
</li>
</ol>
<h2 id="8-更改poetry的pypi源"><a href="#8-更改poetry的pypi源" class="headerlink" title="8 更改poetry的pypi源"></a>8 更改poetry的pypi源</h2><p>通常国内下载一些包比较慢，这时我们可以更新poetry的源来使用国内的镜像。默认的情况下poetry使用的是pypi来下载包.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --default 设置为默认源</span></span><br><span class="line"><span class="comment"># 阿里源：</span></span><br><span class="line">poetry source add ali https://mirrors.aliyun.com/pypi/simple/ -<span class="literal">-default</span></span><br><span class="line"><span class="comment"># 腾讯源：</span></span><br><span class="line">poetry source add tencent https://mirrors.cloud.tencent.com/pypi/simple/ </span><br><span class="line"><span class="comment"># 清华源：</span></span><br><span class="line">poetry source add  tsinghua  https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</span><br></pre></td></tr></table></figure>
<p>删除源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry source remove 源的名字</span><br></pre></td></tr></table></figure>




<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>一般情况下我们使用poetry管理项目，无非就是两种情况：新建项目，可以使用<code>poetry new 项目名称</code>, 或者是在旧的项目上使用poetry，那么就是用<code>poetry init </code> 使用交互式初始化一个项目。</p>
<p>平常安装依赖或者是更新依赖 就使用 <code>poetry add/update 依赖名</code></p>
]]></content>
      <categories>
        <category>Poetry</category>
      </categories>
      <tags>
        <tag>Poetry</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(一)</title>
    <url>/2023/03/22/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%B8%80)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-一"><a href="#js笔记之Promise-一" class="headerlink" title="js笔记之Promise(一)"></a>js笔记之Promise(一)</h1><h2 id="1-Promise-对象的构造器语法"><a href="#1-Promise-对象的构造器语法" class="headerlink" title="1 Promise 对象的构造器语法"></a>1 Promise 对象的构造器语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor（生产者代码，“歌手”）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>传递给Promise的函数被称为 executor，当 new Promise 被创建时，executor 会自动运行，它包含最终应产生结果的生产者代码。</p>
<p>函数的参数 resolve，reject 是由JS自身提供的回调，我们的代码仅在executor的内部，当executor得到的结果，无论早晚，他应该调用一下的回调之一：</p>
<ul>
<li><code>resolve(value)</code> —— 如果任务成功完成并带有结果 <code>value</code>。</li>
<li><code>reject(error)</code> —— 如果出现了 error，<code>error</code> 即为 error 对象。</li>
</ul>
<p>所以总结一下就是executor会自动运行并尝试执行一项工作，尝试结束后，如果成功则调用resolve，如果出现error则调用reject。</p>
<p>由new Promise 构造器返回的promise对象具有以下的属性：</p>
<ul>
<li>state 最初是padding 然后再 resolve被调用时，变为fulfilled, 或者在reject被调用时变为rejected。</li>
<li>result 最初是 undefined 然后在resolve(value)  被调用时变为value，或者在 reject(error) 被调用时变为 error。</li>
</ul>
<p>所以executor最终将promise移至一下状态之一：</p>
<p><img src="https://tc.chaizz.com/tc/image-20230322204449440.png" alt="image-20230322204449440"></p>
<p>一个简单的例子：</p>
<p>下面的new Promise 构造器和一个简单的函数，该executor具有包含事件的生产者代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 promise 被构造完成时，自动执行此函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 秒后发出工作已经被完成的信号，并带有结果 &quot;done&quot;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>executor 只能调用一个 <code>resolve</code> 或一个 <code>reject</code>。任何状态的更改都是最终的。所有其他的再对 resolve 和 reject 的调用都会被忽略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一个被 executor 完成的工作只能有一个结果或一个 error。并且，<code>resolve/reject</code> 只需要一个参数（或不包含任何参数），并且将忽略额外的参数。</p>
<p>reject接受的参数，可已接收任何类型， 但是建议使用Error对象或者继承Error的对象，因为这样做也是正常的做法。</p>
<p>实际上executor是异步执行的某些操作，并且在一段事件之后调用resolve/reject，但是这不是必须的，我们还可以立即调用他们，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不花时间去做这项工作</span></span><br><span class="line">    resolve(<span class="number">123</span>); <span class="comment">// 立即给出结果：123</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="2-then"><a href="#2-then" class="headerlink" title="2 then"></a>2 then</h2><p>Promise对象的state和result属性都是内部的，我们无法直接访问他们，但是我们可以对他们使用.then/ .catch/ .finally </p>
<p>Promise的executor接受结果可以通过 .then .catch 方法注册消费函数。</p>
<p>then </p>
<p>首先最重要最基础的就是.then，语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">/* handle a successful result */</span> &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">/* handle an error */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>.then</code> 的第一个参数是一个函数，该函数将在 promise resolved 且接收到结果后执行。</p>
<p><code>.then</code> 的第二个参数也是一个函数，该函数将在 promise rejected 且接收到 error 信息后执行。</p>
<p>例如在成功的情况下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done!&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 运行 .then 中的第一个函数</span></span><br><span class="line">promise.then(</span><br><span class="line">    result =&gt; alert(result), <span class="comment">// 1 秒后显示 &quot;done!&quot;</span></span><br><span class="line">    error =&gt; alert(error) <span class="comment">// 不运行</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者在失败的情况下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 运行 .then 中的第二个函数</span></span><br><span class="line">promise.then(</span><br><span class="line">    result =&gt; alert(result), <span class="comment">// 不运行</span></span><br><span class="line">    error =&gt; alert(error) <span class="comment">// 1 秒后显示 &quot;Error: Whoops!&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="3-catch"><a href="#3-catch" class="headerlink" title="3 catch"></a>3 catch</h2><p>如果我们只对error感兴趣，那么我们可以使用null作为第一个参数：.then(null, errorHandlingFunction)，或者我们也可以使用.catch(errorHandlingFunction)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .catch(f) 与 promise.then(null, f) 一样</span></span><br><span class="line">promise.catch(alert); <span class="comment">// 1 秒后显示 &quot;Error: Whoops!&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="4-finally-清理"><a href="#4-finally-清理" class="headerlink" title="4 finally 清理"></a>4 finally 清理</h2><p>想常规的try…catch…finally 一样， promise中也有finally，调用.finally类似于.then(f, f) 因为当 promise settled 时 f 就会执行：无论 promise 被 resolve 还是 reject。<code>finally</code> 的功能是设置一个处理程序在前面的操作完成后，执行清理/终结。例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 做一些需要时间的事，之后调用可能会 resolve 也可能会 reject */</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 在 promise 为 settled 时运行，无论成功与否</span></span><br><span class="line">    .finally(<span class="function">() =&gt;</span> stop loading indicator)</span><br><span class="line">    <span class="comment">// 所以，加载指示器（loading indicator）始终会在我们继续之前停止</span></span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> show result, <span class="function"><span class="params">err</span> =&gt;</span> show error)</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>finally(f)</code> 并不完全是 <code>then(f,f)</code> 的别名。</p>
<ol>
<li><p>finally处理程序没有参数，在finnally中我们不知道promise是否成功，没关系，因为我们的任务通常是执行常规的完成程序。就比如上面的例子，<code>finally</code> 处理程序没有参数，promise 的结果由下一个处理程序处理。</p>
</li>
<li><p>finally处理程序将结果或者是error传递给下一个合适的处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;value&quot;</span>), <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">    .finally(<span class="function">() =&gt;</span> alert(<span class="string">&quot;Promise ready&quot;</span>)) <span class="comment">// 先触发</span></span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> alert(result)); <span class="comment">// &lt;-- .then 显示 &quot;value&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，promise返回的value通过finally传递给了then。当然也有失败的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .finally(<span class="function">() =&gt;</span> alert(<span class="string">&quot;Promise ready&quot;</span>)) <span class="comment">// 先触发</span></span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> alert(err));  <span class="comment">// &lt;-- .catch 显示这个 error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>finally 处理程序也不应该返回任何的内容，如果他返回了 返回的值也会被忽略。唯一例外的是当finally抛出error时， 这个error会被转到下一个处理程序。</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li><code>finally</code> 处理程序没有得到前一个处理程序的结果（它没有参数）。而这个结果被传递给了下一个合适的处理程序。</li>
<li>如果 <code>finally</code> 处理程序返回了一些内容，那么这些内容会被忽略。</li>
<li>当 <code>finally</code> 抛出 error 时，执行将转到最近的 error 的处理程序。</li>
</ul>
</blockquote>
<p>Promise 可以随时添加处理程序（handler）：如果结果已经在了，它们就会执行。</p>
<p>例如Promise编写异步代码的更多的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = src;</span><br><span class="line"></span><br><span class="line">        script.onload = <span class="function">() =&gt;</span> resolve(script);</span><br><span class="line">        script.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.head.append(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以这样使用这个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    script =&gt; alert(<span class="string">`<span class="subst">$&#123;script.src&#125;</span> is loaded!`</span>),</span><br><span class="line">    error =&gt; alert(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">script</span> =&gt;</span> alert(<span class="string">&#x27;Another handler...&#x27;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS错误处理(二).md</title>
    <url>/2023/03/21/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS错误处理-二"><a href="#JS笔记之JS错误处理-二" class="headerlink" title="JS笔记之JS错误处理(二)"></a>JS笔记之JS错误处理(二)</h1><p>在我们开发的时候 经常需要我们自己定义的类来反应我们在程序中遇到的错误。比如在网络请求中我们是用HttpError，在操作数据库中我么使用DbError等等。</p>
<p>我们一般都会创建自己的自定义异常，他们都支持最基本的Error属性，例如 message、name、并且最好有stack。但是他们也有自己的属性，例如HttpError队形可能有一个statusCode属性。</p>
<p>JavaScript 允许将 throw 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 Error 中继承。但是，如果我们继承，那么就可以使用 obj instanceof Error 来识别 error 对象。因此，最好继承它。</p>
<p>随着项目的增大，我们定义的异常，可能会越来越细分， 形成一个层次结构，例如：HttpTimeoutError 可能继承自 HttpError，等等。</p>
<h2 id="1-扩展Error"><a href="#1-扩展Error" class="headerlink" title="1 扩展Error"></a>1 扩展Error</h2><p>例如当我们读一个一个用户的信息的json数据，有时候即使JSON的数据格式是正确的，但是数据却不一定是是我们想要的得到的数据，可能会缺少些必要的数据。</p>
<p>我们可以定义一个函数，来解析数据并且验证数据，如果没有得到我们要求的数据，那么就会抛出一个error，但是这个error不是 语法错误等，而是类似 ValidationError的错误对象。且是一个类，他可能继承自Error，且包含具体的错误信息等。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了父类的 constructor。JavaScript 要求我们在子类的 constructor 中调用 super，所以这是必须的。</span></span><br><span class="line">    <span class="comment">// 父类的 constructor 设置了 message 属性。</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message); <span class="comment">// (1)</span></span><br><span class="line">        <span class="comment">// 父类的 constructor 还将 name 属性的值设置为了 &quot;Error&quot;，</span></span><br><span class="line">        <span class="comment">// 所以在这一行中，我们将其重置为了ValidationError</span></span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;ValidationError&quot;</span>; <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在解析json中使用它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readUser</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.age) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ValidationError(<span class="string">&quot;No field: age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ValidationError(<span class="string">&quot;No field: name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try..catch 的工作示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = readUser(<span class="string">&#x27;&#123; &quot;age&quot;: 25 &#125;&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> ValidationError) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Invalid data: &quot;</span> + err.message); <span class="comment">// Invalid data: No field: name</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123; <span class="comment">// (*)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;JSON Syntax Error: &quot;</span> + err.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err; <span class="comment">// 未知的 error，再次抛出 (**)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的try…cacth中既捕获了json解析的错误。也能捕获我们自定义的异常。在最后一中，，我们再次抛出了err。</p>
<h2 id="2-深入继承"><a href="#2-深入继承" class="headerlink" title="2 深入继承"></a>2 深入继承</h2><p>在数据中很多数据都有可能出错，我们可以为错误创建根据的异常对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;ValidationError&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;PropertyRequiredError&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.property = property;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readUser</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.age) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try..catch 的工作示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = readUser(<span class="string">&#x27;&#123; &quot;age&quot;: 25 &#125;&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> ValidationError) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Invalid data: &quot;</span> + err.message); <span class="comment">// Invalid data: No property: name</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.name); <span class="comment">// PropertyRequiredError</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.property); <span class="comment">// name</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;JSON Syntax Error: &quot;</span> + err.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err; <span class="comment">// 未知 error，将其再次抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类 PropertyRequiredError 使用起开很简单，我们只需要传递属性名， new PropertyRequiredError(property)， 人类刻度的message是 constructor 生成的。</p>
<blockquote>
<p>​    Tips：在 PropertyRequiredError constructor 中的 this.name 是通过手动重新赋值的。这可能会变得有些乏味 —— 在每个自定义 error 类中都要进行 this.name = <class name> 赋值操作。可以通过创建自己的“基础错误（basic error）”类来避免这种情况，在基础错误类上进行 <code>this.name = this.constructor.name</code> 赋值，然后让我们的所有的异常类 都继承自这个基础错误类。</class></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="built_in">this</span>.constructor.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">MyError</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">        <span class="built_in">this</span>.property = property;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 是对的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;field&quot;</span>).name); <span class="comment">// PropertyRequiredError</span></span><br></pre></td></tr></table></figure>


<h2 id="3-包装异常"><a href="#3-包装异常" class="headerlink" title="3 包装异常"></a>3 包装异常</h2><p>我们扩展了ValidationError，PropertyRequiredError 未来可能会有其他的更多的类，try…catch.. 中使用了多个if else语句进行检查，这种方法并不是很优雅，那么有没有哟中比较高级的方法。答案是有的， 这种方法叫做包装异常。例如将上面的读取数据的例子进行包装：</p>
<ol>
<li>创建一个新的类ReadError，来表示一般的数据读取Error。</li>
<li>函数readUser 将捕获内部发生的数据读取 error，例如 ValidationError 和 SyntaxError，并生成一个 ReadError 来进行替代。</li>
<li>对象ReadError 会把原始的error 的引用，保存在其cause中。</li>
</ol>
<p>经过上面的包装之后，再次调用 上面的 readUser 只需要检查 ReadError，而不必检查每种数据读取 error。并且，如果需要更多 error 细节，那么可以检查 readUser 的 cause 属性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message, cause</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.cause = cause;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;ReadError&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!user.age) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readUser</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ReadError(<span class="string">&quot;Syntax Error&quot;</span>, err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        validateUser(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err <span class="keyword">instanceof</span> ValidationError) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ReadError(<span class="string">&quot;Validation Error&quot;</span>, err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    readUser(<span class="string">&#x27;&#123;bad json&#125;&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ReadError) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        <span class="comment">// Original error: SyntaxError: Unexpected token b in JSON at position 1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Original error: &quot;</span> + e.cause);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><ol>
<li>我们可以从Error和其他的内建error中进行继承，我们只需要注意name属性，以及调用super。</li>
<li>我们可以使用 instanceof 来检查特定的 error。但有时我们有来自第三方库的 error 对象，并且在这儿没有简单的方法来获取它的类。那么可以将 name 属性用于这一类的检查。</li>
<li>包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数。在上面的示例中，低级别异常有时会成为该对象的属性，例如 err.cause，但这不是严格要求的。</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS错误处理(一).md</title>
    <url>/2023/03/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86(%E4%B8%80)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS错误处理-一"><a href="#JS笔记之JS错误处理-一" class="headerlink" title="JS笔记之JS错误处理(一)"></a>JS笔记之JS错误处理(一)</h1><p>在编程中很难能够一次性写出完美的代码，错误确实经常性的，在JS中可以使用try…catch能够使我们捕获错误。</p>
<h2 id="1-try…catch语法"><a href="#1-try…catch语法" class="headerlink" title="1 try…catch语法"></a>1 try…catch语法</h2><p>try…catch 结构由两部分组成：try 和 catch：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误捕获</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的执行步骤是：</p>
<ol>
<li>首先执行try…的代码。</li>
<li>如果第一步没有错误，则忽略catch(err)…的代码，跳过catch…的代码，执行try的末尾继续执行。</li>
<li>如果第一步错误，则try…停止执行，代码则跳转带catch(err)的开头，变量err(可以是任何名称)将包含一个error对象，该对象包含了所发生事件的详细信息。</li>
</ol>
<p>所以 try…catch(err)… try后面的代码不会导致程序停止。一些例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有 error 的例子：显示 alert (1) 和 (2)：</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始执行 try 中的内容&#x27;</span>);  <span class="comment">// (1) &lt;--</span></span><br><span class="line">    <span class="comment">// ...这里没有 error</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;try 中的内容执行完毕&#x27;</span>);   <span class="comment">// (2) &lt;--</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch 被忽略，因为没有 error&#x27;</span>); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 error 的例子：显示 (1) 和 (3) 行的 alert 中的内容：</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始执行 try 中的内容&#x27;</span>);  <span class="comment">// (1) &lt;--</span></span><br><span class="line">    lalala; <span class="comment">// error，变量未定义！</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;try 的末尾（未执行到此处）&#x27;</span>);  <span class="comment">// (2)</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`出现了 error！`</span>); <span class="comment">// (3) &lt;--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：try…catch… 仅仅对运行时的error有效，也就是说要想try…catch能够工作，代码必须是可执行的，如果包含语法错误，那么try..catch将无法工作。</p>
<p>JS引擎首先会读取代码，然后运行它，在读取阶段发生的错误，被称为解析时间（parse-time）错误，并且无法修复，因为引擎无法理解代码。</p>
</blockquote>
<p>所以try…catch只能处理有效代码中出现的错误，这列错误成为运行时的错误(runtime errors)，也被称为异常。</p>
<p>如果在”计划的”代码中发生异常，例如在setTimeout中，则try…catch不会捕获到异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        noSuchVariable; <span class="comment">// 脚本将在这里停止运行</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;不工作&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 try…catch 包裹了计划要执行的函数，该函数本身要稍后才执行，这时引擎已经离开了try…catch 结构。</p>
<p>如果要捕获到计划的函数的异常，那么try…catch 必须在这个函数内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        noSuchVariable; <span class="comment">// try...catch 处理 error 了！</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error 被在这里捕获了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-Error对象"><a href="#2-Error对象" class="headerlink" title="2 Error对象"></a>2 Error对象</h2><p>发生错误时JS会生成一个包含此error的详细信息的对象，然后将该对象作为参数传递给catch，对于所有的内建的 error对象有两个主要的属性: name、message。 </p>
<p>name:error的名称，例如对于一个未定义的变量，名称是“ReferenceError”。</p>
<p>message: 关于error的详细文字描述。</p>
<p>还有其他的非标准的属性，在大多数环境下可用，其中被广泛使用和支持的是：</p>
<p>stack: 代表当前的调用栈，用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lalala; <span class="comment">// error, variable is not defined!</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.name); <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">console</span>.log(err.message); <span class="comment">// lalala is not defined</span></span><br><span class="line">    <span class="built_in">console</span>.log(err.stack); <span class="comment">// ReferenceError: lalala is not defined at (...call stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以将一个 error 作为整体显示出来</span></span><br><span class="line">    <span class="comment">// error 信息被转换为像 &quot;name: message&quot; 这样的字符串</span></span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError: lalala is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可选的catch绑定</p>
<p>这是一个新的特性，如果我们不需要error的信息，catch也可以忽略他。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; <span class="comment">// &lt;-- 没有 (err)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-try…catch的真实用例"><a href="#3-try…catch的真实用例" class="headerlink" title="3 try…catch的真实用例"></a>3 try…catch的真实用例</h2><p>当我们接受来自网络、服务器或是其他来源的json数据，我们会使用 JSON.parse(str)来讲字符串解析为JS对象。</p>
<p>但是如果json字符串无法解析，那么就会生成一个error，所以这个时候就需要try…catch来尝试解析这个json字符串，即使发生了错误我们也能主动的捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&quot;&#123; bad json &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json); <span class="comment">// &lt;-- 当出现 error 时...</span></span><br><span class="line">    <span class="built_in">console</span>.log(user.name); <span class="comment">// 不工作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// ...执行会跳转到这里并继续执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;很抱歉，数据有错误，我们会尝试再请求一次。&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err.name);</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里我们将错误输出了，我们可以做更多的事情，例如新发送一个网络请求，或者将日志发送到记录日志的设备。</p>
<h2 id="4-输出自定义的错误"><a href="#4-输出自定义的错误" class="headerlink" title="4 输出自定义的错误"></a>4 输出自定义的错误</h2><p>有时候我们可能知道这里容易出问题，那么如何输出我们自定义的错误呢？</p>
<p>使用 throw 操作符， 语法：<code>throw &lt;object error&gt;</code>技术上我们可以将任何东西用作于error，甚至可以是一个原型类型数据，又或者是字符串或数字，但是最好使用对象，最好具有name和message属性的对象。 某种程度上和内建的Error对象保持兼容。</p>
<p>JS中有很多内建的标准 error 的构造器：Error，SyntaxError，ReferenceError，TypeError 等。我们也可以使用它们来创建 error 对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(message);</span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(message);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>内建的error对象， name属性刚刚好就是构造器的名字，message 就是构造器的参数。</p>
<p>例如我们使用内建的错误对象，构造一个我们自己的错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>; <span class="comment">// 不完整的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json); <span class="comment">// &lt;-- 没有 error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">&quot;数据不全：没有 name&quot;</span>); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(user.name);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;JSON Error: &quot;</span> + err.message); <span class="comment">// JSON Error: 数据不全：没有 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-再次抛出error"><a href="#5-再次抛出error" class="headerlink" title="5 再次抛出error"></a>5 再次抛出error</h2><p>在上述的例子中 try…catch 用于捕获 数据不正确的error, 但是 try…代码块可能会继续抛出其他的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>; <span class="comment">// 不完整的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    user = <span class="built_in">JSON</span>.parse(json); <span class="comment">// &lt;-- 忘记在 user 前放置 &quot;let&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;JSON Error: &quot;</span> + err); <span class="comment">// JSON Error: ReferenceError: user is not defined</span></span><br><span class="line">    <span class="comment">// (实际上并没有 JSON Error)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，catch会捕获到所有来自于try…代码块的error，上面的代码中 错误已经不再是 json error 了， 是其他的错误，但是错误信息还是 JSON Error。</p>
<p>为了避免此类的问题，我们采用“重新抛出技术”，规则很简单：</p>
<p>catch 只处理他知道的error，并抛出其他的error。</p>
<p>再次抛出的技术可以理解为：</p>
<ol>
<li>catch 捕获所有的error。</li>
<li>在catch(err){…} 块中，我们对error对象err进行分析。</li>
<li>如果我们不知道如何处理它，那么我们就throw err。</li>
</ol>
<p>通常我们可以使用instanceif 操作符判断错误类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    user = &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">ReferenceError</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;ReferenceError&#x27;</span>); <span class="comment">// 访问一个未定义（undefined）的变量产生了 &quot;ReferenceError&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以从err.name 属性中获取错误类型的类名，所有的原生的错误都有这个类型，另一种方式是读取err.constructor.name。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>; <span class="comment">// 不完整的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">&quot;数据不全：没有 name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blabla(); <span class="comment">// 预料之外的 error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(user.name);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="comment">//     if (err.constructor.name == &quot;SyntaxError&quot;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;JSON Error: &quot;</span> + err.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err; <span class="comment">// 再次抛出 (*)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-try…catch…finally"><a href="#6-try…catch…finally" class="headerlink" title="6 try…catch…finally"></a>6 try…catch…finally</h2><p>try…catch 还有一个代码结构， finally的代码所有的情况都会被执行，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ... 尝试执行的代码 ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">   ... 处理 error ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   ... 总是会执行的代码 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = +prompt(<span class="string">&quot;输入一个正整数？&quot;</span>, <span class="number">35</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> diff, result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || <span class="built_in">Math</span>.trunc(n) != n) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;不能是负数，并且必须是整数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? n : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = fib(num);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    diff = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result || <span class="string">&quot;出现了 error&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`执行花费了 <span class="subst">$&#123;diff&#125;</span>ms`</span>);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips: 变量和 try…catch…finally 中的局部变量</p>
<p>请注意，上面代码中的 result 和 diff 变量都是在 try…catch 之前 声明的。</p>
<p>否则，如果我们使用 let 在 try 块中声明变量，那么该变量将只在 try 块中可见。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// 先执行 finally 中的 console.log，然后执行这个 console.log</span></span><br></pre></td></tr></table></figure>


<p>没有catch…finally 结构也很有用，当我们不想在这处理error，但是需要确保我们启动的处理需要被完成。</p>
<h2 id="7-全局的catch"><a href="#7-全局的catch" class="headerlink" title="7 全局的catch"></a>7 全局的catch</h2><p>在浏览器中我们可以讲一个函数赋值给特殊的 window.onerror 属性，该函数在发生未捕获的error时执行。</p>
<p>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, col, error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// message: error 信息。</span></span><br><span class="line"><span class="comment">// url :发生 error 的脚本的 URL。</span></span><br><span class="line"><span class="comment">// line，col: 发生 error 处的代码的行号和列号。</span></span><br><span class="line"><span class="comment">//  error:error 对象。</span></span><br></pre></td></tr></table></figure>


<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, col, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">`<span class="subst">$&#123;message&#125;</span>\n At <span class="subst">$&#123;line&#125;</span>:<span class="subst">$&#123;col&#125;</span> of <span class="subst">$&#123;url&#125;</span>`</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        badFunc(); <span class="comment">// 啊，出问题了！</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readData();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>全局错误处理程序的作用通常不是回复程序的方法，而是在程序发生错误的时候，将错误消息发送给开发者。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>try…catch 结构允许我们处理执行过程中出现的error, 从字面上拉看他允许尝试运行代码，并捕获其中可能发生的error。</p>
<p>error 对象包括以下属性：</p>
<ol>
<li>name error名称的字符串。</li>
<li>message 人类可读的错误信息。</li>
<li>stack error发生时的调用栈。</li>
</ol>
<p>如果需要error对象，也可以直接使用 try{…}catch {…}。</p>
<p>我们可以使用throw 抛出自己根据内建对象定义的错误对象。</p>
<p>再次抛出  throwing 是一种错误处理的常用模式。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(六)</title>
    <url>/2023/03/18/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E5%85%AD)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-六"><a href="#JS笔记之JS类-六" class="headerlink" title="JS笔记之JS类(六)"></a>JS笔记之JS类(六)</h1><p>在JS中类只能扩展一个类， 每个对象只能有一个[[prototype]],但是有些时候，会让人感到限制，例如我们有一个User类和一个EventEmitter类来实现事件生成，并且想将EventEmitter的功能添加到User类中，以便用户可以触发事件。</p>
<p>有一个概念可以帮我们， 叫做 mixins， 在维基百科中 mixin是一个可以被其他的类使用，而无需继承的方法的类。</p>
<p>换句话说就是 mixin 提供了一些特殊的方法，但是我们不单独使用它，而是用它来将这些行为添加到其他的类中，</p>
<h2 id="1-一个Mixin实例"><a href="#1-一个Mixin实例" class="headerlink" title="1 一个Mixin实例"></a>1 一个Mixin实例</h2><p>在JS中构造一个mixin最简单的方法就是构造一个拥有使用方法的对象，以便我们可以轻松的将这些实用的方法合并到任何类的原型中。例如这个名为sayHiMixin的mixin用于给User添加一些语言功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>(<span class="string">`Hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>(<span class="string">`Bye <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 User 可以打招呼了</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&quot;Dude&quot;</span>).sayHi(); <span class="comment">// Hello Dude!</span></span><br></pre></td></tr></table></figure>
<p>在这里没有使用继承，而只是一个简单的拷贝，所以User可以从另一个类继承，还可以包括mixin来”mix-in”其他的方法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br></pre></td></tr></table></figure>
<p>Mixin可以在自己的内部进行继承，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayMixin = &#123;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params">phrase</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>(phrase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">    __proto__: sayMixin, <span class="comment">// (或者，我们可以在这儿使用 Object.setPrototypeOf 来设置原型)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.say(<span class="string">`Hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>); <span class="comment">// (*)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.say(<span class="string">`Bye <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 User 可以打招呼了</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&quot;Dude&quot;</span>).sayHi(); <span class="comment">// Hello Dude!</span></span><br></pre></td></tr></table></figure>


<p>在sayHiMixin内部对父类的方法，super.say()的调用会在mixin的原型中查找方法，而不是在class中查找。</p>
<p><img src="https://tc.chaizz.com/tc/image-20230318164932986.png" alt="image-20230318164932986"></p>
<p>这是因为方法sayHi和sayBye最初是在sayHiMixin中创建的，因此即使复制了他们，但是他们的[[homeObject]]内部属性扔引用的sayHiMixin。</p>
<p>当 super 在 [[HomeObject]].[[Prototype]] 中寻找父方法时，意味着它搜索的是 sayHiMixin.[[Prototype]]，而不是 User.[[Prototype]]。</p>
<h2 id="2-EventMixin"><a href="#2-EventMixin" class="headerlink" title="2 EventMixin"></a>2 EventMixin</h2><p>许多浏览器对象的一个重要功能就是可以生成事件，事件是向任何有需要的人“广播信息”的好方法。</p>
<p>我们将构造一个对象，能够轻松的将与事件相关的函数添加到任意的calss或者是object中。</p>
<ol>
<li>Mixin提供.trigger(name,[…data])方法，以在发生重要的事情时，生成一个事件。name参数（arguments）是事件的名称，[…data] 是可选的带有事件数据的其他参数。</li>
<li>此外还有.on(name,handler)方法，他为具有给定名称的事件添加了handler函数作为监听器，（listener）当具有给定name的事件触发时将调用该方法，并从.trigger调用中参数（arguments）。</li>
<li>还有.off(name, handler)方法，他会删除handler监听器（listener）。</li>
</ol>
<p>田家湾mixin后，对象user能够在访客登录时，生成事件login, 另一个对象，例如calender可能希望监听此类事件以便为登录的人添加日历。</p>
<p>或者当一个菜单选项被选中时，menu可以生成select事件，其他对象可以分配处理程序以对该事件作出反应。诸如此类。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> eventMixin = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件，用法：</span></span><br><span class="line"><span class="comment">     *  menu.on(&#x27;select&#x27;, function(item) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers) <span class="built_in">this</span>._eventHandlers = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers[eventName]) &#123;</span><br><span class="line">            <span class="built_in">this</span>._eventHandlers[eventName] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._eventHandlers[eventName].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅，用法：</span></span><br><span class="line"><span class="comment">     *  menu.off(&#x27;select&#x27;, handler)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">off</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> handlers = <span class="built_in">this</span>._eventHandlers?.[eventName];</span><br><span class="line">        <span class="keyword">if</span> (!handlers) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlers[i] === handler) &#123;</span><br><span class="line">                handlers.splice(i--, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成具有给定名称和数据的事件</span></span><br><span class="line"><span class="comment">     *  this.trigger(&#x27;select&#x27;, data1, data2);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">trigger</span>(<span class="params">eventName, ...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers?.[eventName]) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 该事件名称没有对应的事件处理程序（handler）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用事件处理程序（handler）</span></span><br><span class="line">        <span class="built_in">this</span>._eventHandlers[eventName].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler.apply(<span class="built_in">this</span>, args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">choose</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.trigger(<span class="string">&quot;select&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加带有事件相关方法的 mixin</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Menu.prototype, eventMixin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> menu = <span class="keyword">new</span> Menu();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个事件处理程序（handler），在被选择时被调用：</span></span><br><span class="line">menu.on(<span class="string">&quot;select&quot;</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Value selected: <span class="subst">$&#123;value&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件 =&gt; 运行上述的事件处理程序（handler）并显示：</span></span><br><span class="line"><span class="comment">// 被选中的值：123</span></span><br><span class="line">menu.choose(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>




<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>Mixin是一个通用的面向对象的变成术语，一个包含其他类的方法的类。</p>
<p>JS不支持多继承，但是可以通过将方法拷贝到原型中来实现，mixin。我们可以使用mixin作为一种通过添加多种行为来扩充类的方法。</p>
<p>如果 Mixins 意外覆盖了现有类的方法，那么它们可能会成为一个冲突点。因此，通常应该仔细考虑 mixin 的命名方法，以最大程度地降低发生这种冲突的可能性。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(四)</title>
    <url>/2023/03/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-四"><a href="#JS笔记之JS类-四" class="headerlink" title="JS笔记之JS类(四)"></a>JS笔记之JS类(四)</h1><h2 id="1-私有的和受保护的属性和方法"><a href="#1-私有的和受保护的属性和方法" class="headerlink" title="1 私有的和受保护的属性和方法"></a>1 私有的和受保护的属性和方法</h2><p>面向对象编程最重要的原则之一 —— 将内部接口与外部接口分隔开来。</p>
<p>在 JavaScript 中，有两种类型的对象字段（属性和方法）：</p>
<ul>
<li>公共的：可从任何地方访问。它们构成了外部接口。到目前为止，我们只使用了公共的属性和方法。</li>
<li>私有的：只能从类的内部访问。这些用于内部接口。</li>
</ul>
<p>首先创建一个咖啡机类:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    waterAmount = <span class="number">0</span>; <span class="comment">// 内部的水量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">power</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.power = power;</span><br><span class="line">        alert(<span class="string">`Created a coffee-machine, power: <span class="subst">$&#123;power&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加水</span></span><br><span class="line">coffeeMachine.waterAmount = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p>现在咖啡机的 waterAmount 和  power 是公共的属性，我们可以从外部轻易的修改，我们将 <code>waterAmount</code> 属性更改为受保护的属性，以对其进行更多控制。</p>
<h2 id="2-受保护的属性"><a href="#2-受保护的属性" class="headerlink" title="2 受保护的属性"></a>2 受保护的属性</h2><p><strong>受保护的属性通常以下划线 <code>_</code> 作为前缀。</strong>这并不是强制的，但是是程序的约个约定俗称的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    _waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._waterAmount = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">waterAmount</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._waterAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">power</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加水</span></span><br><span class="line">coffeeMachine.waterAmount = -<span class="number">10</span>; <span class="comment">// _waterAmount 将变为 0，而不是 -10</span></span><br></pre></td></tr></table></figure>
<p>现在访问已受到控制，因此将水量的值设置为小于零的数变得不可能。</p>
<p>设置只读属性，将咖啡机的 power属性设置为在开始创建之后就不可更改。我们值需要设施getter属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">power</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">power</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">`Power is: <span class="subst">$&#123;coffeeMachine.power&#125;</span>W`</span>); <span class="comment">// 功率是：100W</span></span><br><span class="line"></span><br><span class="line">coffeeMachine.power = <span class="number">25</span>; <span class="comment">// Error（没有 setter）</span></span><br></pre></td></tr></table></figure>
<p>在上述的代码中我们使用了 getter和setter语法，但是我们大多数使用get…/set… 这中函数：因为函数更灵活。它们可以接受多个参数，但是并没有严格约定使用那种方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    _waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setWaterAmount</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>._waterAmount = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getWaterAmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._waterAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CoffeeMachine().setWaterAmount(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>受保护的字段是可以被继承的</strong></p>
<p>如果我们继承 <code>class MegaMachine extends CoffeeMachine</code>，那么什么都无法阻止我们从新的类中的方法访问 <code>this._waterAmount</code> 或 <code>this._power</code>。</p>
<p>所以受保护的字段是自然可被继承的。</p>
</blockquote>
<h2 id="3-私有的属性"><a href="#3-私有的属性" class="headerlink" title="3 私有的属性"></a>3 私有的属性</h2><p><strong>私有属性和方法应该以 <code>#</code> 开头。它们只在类的内部可被访问。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    #waterLimit = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    #<span class="function"><span class="title">fixWaterAmount</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="built_in">this</span>.#waterLimit) <span class="keyword">return</span> <span class="built_in">this</span>.#waterLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setWaterAmount</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.#waterLimit = <span class="built_in">this</span>.#fixWaterAmount(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.#waterLimit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能从类的外部访问类的私有属性和方法</span></span><br><span class="line"><span class="comment">// Private field &#x27;#fixWaterAmount&#x27; must be declared in an enclosing class</span></span><br><span class="line">coffeeMachine.#fixWaterAmount(<span class="number">123</span>); <span class="comment">// Error</span></span><br><span class="line">coffeeMachine.#waterLimit = <span class="number">1000</span>; <span class="comment">// Error</span></span><br><span class="line">coffeeMachine.print()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在语言级别，<code>#</code> 是该字段为私有的特殊标志。我们无法从外部或从继承的类中访问它。</p>
<p>私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 <code>#waterAmount</code> 和公共的 <code>waterAmount</code> 字段。例如 让waterAmount成为#waterAmount 的访问器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    #waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">waterAmount</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.#waterAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.#waterAmount = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> machine = <span class="keyword">new</span> CoffeeMachine();</span><br><span class="line"></span><br><span class="line">machine.waterAmount = <span class="number">100</span>;</span><br><span class="line">alert(machine.#waterAmount); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>与受保护的字段不同，私有字段由语言本身强制执行。当我们需要继承CoffeeMachine时， 私有字段不会被继承，需要依赖属性访问器<code>waterAmount</code> getter/setter。</p>
<p>许多种情况下，我们经常会扩展某个有私有属性的类，这种私有属性太限制，所以我们还是常常使用受保护的属性，即使它们不受语言语法的支持。</p>
<blockquote>
<p><strong>私有字段不能通过 this[name] 访问</strong></p>
<p>私有字段很特别。</p>
<p>正如我们所知道的，通常我们可以使用 <code>this[name]</code> 访问字段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fieldName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>[fieldName]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于私有字段来说，这是不可能的：<code>this[&#39;#name&#39;]</code> 不起作用。这是确保私有性的语法限制。</p>
</blockquote>
<h2 id="4-扩展内建类"><a href="#4-扩展内建类" class="headerlink" title="4 扩展内建类"></a>4 扩展内建类</h2><p>内建的 Array, Map 对象也是可以扩展的。例如我们扩展了一个内建的Array 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> PowerArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.isEmpty()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(filteredArr); <span class="comment">// 10, 50</span></span><br><span class="line"><span class="built_in">console</span>.log(filteredArr.isEmpty()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<p>在上述代码中， 我们发现 PowerArray 的 arr 实例，具有Array的方法 filter, 由filter 得到的新数组具有PowerArray 的 isEmpty 方法。所以我们得知 arr.filter它内部使用的是arr.constructor， 来创建新的数组，因此我们才可以在结果数组上继续使用isEmpty方法。</p>
<p>我们可以给这个类添加一个特殊的静态访问器方法，Symbol.species，如果存在，则返回JS 在内部用来在 <code>map</code> 和 <code>filter</code> 等方法中创建新实体的 <code>constructor</code>。如果我们希望像 <code>map</code> 或 <code>filter</code> 这样的内建方法返回常规数组，我们可以在 <code>Symbol.species</code> 中返回 <code>Array</code>，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内建方法将使用这个作为 constructor</span></span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> PowerArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.isEmpty()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter 使用 arr.constructor[Symbol.species] 作为 constructor 创建新数组</span></span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// filteredArr 不是 PowerArray，而是 Array</span></span><br><span class="line"><span class="built_in">console</span>.log(filteredArr.isEmpty()); <span class="comment">// Error: filteredArr.isEmpty is not a function</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>其他集合，例如 <code>Map</code> 和 <code>Set</code> 的工作方式类似。它们也使用 <code>Symbol.species</code>。</p>
</blockquote>
<h2 id="5-内建类没有静态方法继承"><a href="#5-内建类没有静态方法继承" class="headerlink" title="5 内建类没有静态方法继承"></a>5 内建类没有静态方法继承</h2><p>内建对象有它们自己的静态方法，例如 <code>Object.keys</code>，<code>Array.isArray</code> 等。</p>
<p>如我们所知道的，原生的类互相扩展。例如，<code>Array</code> 扩展自 <code>Object</code>。</p>
<p>通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承。这已经在 <a href="https://zh.javascript.info/static-properties-methods#statics-and-inheritance">静态属性和静态方法</a> 中详细地解释过了。</p>
<p>但内建类却是一个例外。它们相互间不继承静态方法。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>就面向对象编程（OOP）而言，内部接口与外部接口的划分被称为 <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">封装</a>。</p>
<p>它具有以下优点：</p>
<ul>
<li><p>保护用户，使他们不会误伤自己</p>
<p>想象一下，有一群开发人员在使用一个咖啡机。这个咖啡机是由“最好的咖啡机”公司制造的，工作正常，但是保护罩被拿掉了。因此内部接口暴露了出来。所有的开发人员都是文明的 —— 他们按照预期使用咖啡机。但其中的一个人，约翰，他认为自己是最聪明的人，并对咖啡机的内部做了一些调整。然而，咖啡机两天后就坏了。这肯定不是约翰的错，而是那个取下保护罩并让约翰进行操作的人的错。编程也一样。如果一个 class 的使用者想要改变那些本不打算被从外部更改的东西 —— 后果是不可预测的。</p>
</li>
<li><p>可支持性</p>
<p>编程的情况比现实生活中的咖啡机要复杂得多，因为我们不只是购买一次。我们还需要不断开发和改进代码。<strong>如果我们严格界定内部接口，那么这个 class 的开发人员可以自由地更改其内部属性和方法，甚至无需通知用户。</strong>如果你是这样的 class 的开发者，那么你会很高兴知道可以安全地重命名私有变量，可以更改甚至删除其参数，因为没有外部代码依赖于它们。对于用户来说，当新版本问世时，应用的内部可能被进行了全面检修，但如果外部接口相同，则仍然很容易升级。</p>
</li>
<li><p>隐藏复杂性</p>
<p>人们喜欢使用简单的东西。至少从外部来看是这样。内部的东西则是另外一回事了。程序员也不例外。<strong>当实施细节被隐藏，并提供了简单且有据可查的外部接口时，总是很方便的。</strong></p>
</li>
</ul>
<p>为了隐藏内部接口，我们使用受保护的或私有的属性：</p>
<ul>
<li>受保护的字段以 <code>_</code> 开头。这是一个众所周知的约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以 <code>_</code> 开头的字段。</li>
<li>私有字段以 <code>#</code> 开头。JavaScript 确保我们只能从类的内部访问它们。</li>
</ul>
<p>目前，各个浏览器对私有字段的支持不是很好，但可以用 polyfill 解决。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(五)</title>
    <url>/2023/03/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%BA%94)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-五"><a href="#JS笔记之JS类-五" class="headerlink" title="JS笔记之JS类(五)"></a>JS笔记之JS类(五)</h1><h2 id="1-类检查-instanceof"><a href="#1-类检查-instanceof" class="headerlink" title="1 类检查 instanceof"></a>1 类检查 instanceof</h2><p>instanceof 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承。</p>
<p>在许多情况下，可能都需要进行此类检查。例如，它可以被用来构建一个 <strong>多态性（polymorphic）</strong> 的函数，该函数根据参数的类型对参数进行不同的处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> Class</span><br><span class="line"><span class="comment">//如果 obj 隶属于 Class 类（或 Class 类的衍生类），则返回 true。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// rabbit 是 Rabbit class 的对象吗？</span></span><br><span class="line"><span class="built_in">console</span>.log( rabbit <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>还可以与构造函数一起使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是构造函数，而不是 class</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> Rabbit() <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>与内建的类一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">alert( arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> ); <span class="comment">// true</span></span><br><span class="line">alert( arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常，<code>instanceof</code> 在检查中会将原型链考虑在内。此外，我们还可以在静态方法 <code>Symbol.hasInstance</code> 中设置自定义逻辑。</p>
</blockquote>
<h2 id="2-obj-instanceof-Class-的-算法逻辑如下："><a href="#2-obj-instanceof-Class-的-算法逻辑如下：" class="headerlink" title="2 obj instanceof Class 的 算法逻辑如下："></a>2 obj instanceof Class 的 算法逻辑如下：</h2><ol>
<li><p>如果Class 有静态方法：Symbol.hasInstance，那么就直接调用这个方法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 instanceOf 检查</span></span><br><span class="line"><span class="comment">// 并假设具有 canEat 属性的都是 animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.canEat) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">canEat</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Animal); <span class="comment">// true：Animal[Symbol.hasInstance](obj) 被调用</span></span><br></pre></td></tr></table></figure></li>
<li><p>大多数 class 没有 Symbol.hasInstance。在这种情况下，标准的逻辑是：使用 obj instanceOf Class 检查 Class.prototype 是否等于 obj 的原型链中的原型之一。也就是在Class 的原型链上一步一步的比较。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.__proto__ === Class.prototype?</span><br><span class="line">obj.__proto__.__proto__ === Class.prototype?</span><br><span class="line">obj.__proto__.__proto__.__proto__ === Class.prototype?</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果任意一个的答案为 true，则返回 true</span></span><br><span class="line"><span class="comment">// 否则，如果我们已经检查到了原型链的尾端，则返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承中的比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"><span class="built_in">console</span>.log(rabbit <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rabbit.__proto__ === Animal.prototype（无匹配）</span></span><br><span class="line"><span class="comment">// rabbit.__proto__.__proto__ === Animal.prototype（匹配！）</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
<p>这里还要提到一个方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf">objA.isPrototypeOf(objB)</a>，如果 <code>objA</code> 处在 <code>objB</code> 的原型链中，则返回 <code>true</code>。所以，可以将 <code>obj instanceof Class</code> 检查改为 <code>Class.prototype.isPrototypeOf(obj)</code>。</p>
<p>这很有趣，但是 <code>Class</code> 的 constructor 自身是不参与检查的！检查过程只和原型链以及 <code>Class.prototype</code> 有关。</p>
<p>创建对象后如果更改对象的 prototype 属性，那么示例就不再是类的示例了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改了 prototype</span></span><br><span class="line">Rabbit.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...再也不是 rabbit 了！</span></span><br><span class="line"><span class="built_in">console</span>.log(rabbit <span class="keyword">instanceof</span> Rabbit); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h2 id="3-使用-Object-prototype-toString-方法来揭示类型"><a href="#3-使用-Object-prototype-toString-方法来揭示类型" class="headerlink" title="3 使用 Object.prototype.toString 方法来揭示类型"></a>3 使用 Object.prototype.toString 方法来揭示类型</h2><p>一个普通的对象被转化为字符串时得到的结果是：[Object Object]，这是通过toString方法实现的，但是此处有一个隐藏功能，可以使toString变得更加强大，可以将其作为 typeof 的增强版或者 instanceof 的替代方法来使用。</p>
<p>按照 规范 所讲，内建的 toString 方法可以被从对象中提取出来，并在任何其他值的上下文中执行。其结果取决于该值。</p>
<ul>
<li>对于 number 类型，结果是 <code>[object Number]</code></li>
<li>对于 boolean 类型，结果是 <code>[object Boolean]</code></li>
<li>对于 <code>null</code>：<code>[object Null]</code></li>
<li>对于 <code>undefined</code>：<code>[object Undefined]</code></li>
<li>对于数组：<code>[object Array]</code></li>
<li>……等（可自定义）</li>
</ul>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方便起见，将 toString 方法复制到一个变量中</span></span><br><span class="line"><span class="keyword">let</span> objectToString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它是什么类型的？</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内部，toString 的算法会检查 this，并返回相应的结果</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(arr) ); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(<span class="number">123</span>) ); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(<span class="literal">null</span>) ); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(<span class="built_in">console</span>.log) ); <span class="comment">// [object Function]</span></span><br></pre></td></tr></table></figure>


<p>可以使用特殊的对象属性，Symbol.toStringTag 自定义对象的 toString 方法的行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;User&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.toString.call(user)); <span class="comment">// [object User]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特定于环境的对象和类的 toStringTag：</span></span><br><span class="line">alert( <span class="built_in">window</span>[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// Window</span></span><br><span class="line">alert( XMLHttpRequest.prototype[<span class="built_in">Symbol</span>.toStringTag] ); <span class="comment">// XMLHttpRequest</span></span><br><span class="line"></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="built_in">window</span>) ); <span class="comment">// [object Window]</span></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="keyword">new</span> XMLHttpRequest()) ); <span class="comment">// [object XMLHttpRequest]</span></span><br></pre></td></tr></table></figure>
<p>正如我们所看到的，输出结果恰好是 <code>Symbol.toStringTag</code>（如果存在），只不过被包裹进了 <code>[object ...]</code> 里。所以，如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 <code>&#123;&#125;.toString.call</code> 替代 <code>instanceof</code>。</p>
<p>类型检查方法：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">用于</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>typeof</code></td>
<td align="left">原始数据类型</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left"><code>&#123;&#125;.toString</code></td>
<td align="left">原始数据类型，内建对象，包含 <code>Symbol.toStringTag</code> 属性的对象</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left"><code>instanceof</code></td>
<td align="left">对象</td>
<td align="left">true/false</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(三)</title>
    <url>/2023/03/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%B8%89)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-三"><a href="#JS笔记之JS类-三" class="headerlink" title="JS笔记之JS类(三)"></a>JS笔记之JS类(三)</h1><h2 id="1-静态属性和方法"><a href="#1-静态属性和方法" class="headerlink" title="1 静态属性和方法"></a>1 静态属性和方法</h2><p>使用字面量创建一个 静态方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === User);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是我直接给类的属性复制一个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">User.staticMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === User);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常，静态方法用于实现属于 整个类，但不属于该类任何特定对象的函数。</p>
<p>例如，我们创建一个article类，然后我们创建一个方法来比较这个article，通常的方案就是添加一个静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">title, date</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">compare</span>(<span class="params">articleA, articleB</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> articleA.date - articleB.date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法：</span></span><br></pre></td></tr></table></figure>
<p>或者使用静态类创建一个工厂方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">title, date</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">createTodays</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 记住 this = Article</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>(<span class="string">&quot;Today&#x27;s digest&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> article = Article.createTodays();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(article.title); <span class="comment">// Today&#x27;s digest</span></span><br></pre></td></tr></table></figure>
<p>静态方法也被用于与数据库相关的公共类，可以用于搜索/保存/删除数据库中的条目， 就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定 Article 是一个用来管理文章的特殊类</span></span><br><span class="line"><span class="comment">// 通过 id 来移除文章的静态方法：</span></span><br><span class="line">Article.remove(&#123;<span class="attr">id</span>: <span class="number">12345</span>&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态方法不是类的对象的方法，二是类本身的方法。</p>
<p>他可以再类上调用， 但是不能在对象上调用。</p>
</blockquote>
<h2 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h2><p>JS比较新的特性。他看起来就像常规的类的属性，但是前面回家一个 static ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> publisher = <span class="string">&quot;Levi Ding&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( Article.publisher ); <span class="comment">// Levi Ding</span></span><br></pre></td></tr></table></figure>
<p>这种定义的方式， 等同于直接给Article赋值。<code>Article.publisher = &quot;Levi Ding&quot;;</code></p>
<p>继承静态属性和方法</p>
<p>类的静态属性和方法同样可以继承，也是通过原型链进行查找。extends 让 Rabbit 的 [[Prototype]] 指向了 Animal。</p>
<p><img src="https://tc.chaizz.com/tc/image-20230313151407307.png" alt="image-20230313151407307"></p>
<p>所以，<code>Rabbit extends Animal</code> 创建了两个 <code>[[Prototype]]</code> 引用：</p>
<ol>
<li><code>Rabbit</code> 函数原型继承自 <code>Animal</code> 函数。</li>
<li><code>Rabbit.prototype</code> 原型继承自 <code>Animal.prototype</code></li>
</ol>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>原型的静态方法被应用于整个类的功能， 和具体的实例没有关系，在类声明中，它们都被用关键字 static 进行了标记。</p>
<p>静态属性被用于当我们想要存储类级别的数据时，而不是绑定到实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> property = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从技术上讲，静态声明与直接给类相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyClass.property = ...</span><br><span class="line">MyClass.method = ...</span><br></pre></td></tr></table></figure>
<p>静态属性和方法是可被继承的。</p>
<p>对于 <code>class B extends A</code>，类 <code>B</code> 的 prototype 指向了 <code>A</code>：<code>B.[[Prototype]] = A</code>。因此，如果一个字段在 <code>B</code> 中没有找到，会继续在 <code>A</code> 中查找。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(二)</title>
    <url>/2023/03/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-二"><a href="#JS笔记之JS类-二" class="headerlink" title="JS笔记之JS类(二)"></a>JS笔记之JS类(二)</h1><h2 id="1-类的继承-使用“extends”-关键字"><a href="#1-类的继承-使用“extends”-关键字" class="headerlink" title="1 类的继承, 使用“extends” 关键字"></a>1 类的继承, 使用“extends” 关键字</h2><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">someMethods</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;继承&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建一个动物类，有动物的一些方法属性，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params">speed</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = speed;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="built_in">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> stands still.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">&quot;My animal&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.run(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.hide(); <span class="comment">// White Rabbit hides!</span></span><br></pre></td></tr></table></figure>


<p>在内部，关键字 extends 使用了原型的机制工作，他将<code>Rabbit.prototype.[[prototype]]</code>设置为了<code>Animal.prototype</code>，所以在Rabbit中找不到的方法，会自动去他的原型链上去寻找。</p>
<p>extends 后面可以根任意的表达式，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; alert(phrase); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User extends f(&quot;Hello&quot;) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>根据许多条件使用函数生成类，并继承它们时来说可能很有用。</p>
<h2 id="2-重写类的方法"><a href="#2-重写类的方法" class="headerlink" title="2 重写类的方法"></a>2 重写类的方法</h2><p>完全重新类的方法， 直接在子类中定义名称相同的方法名即可，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ……现在这个将会被用作 rabbit.stop()</span></span><br><span class="line">        <span class="comment">// 而不是来自于 class Animal 的 stop()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们通常都只是想扩展一下， 父类的方法。JS提供了 super 关键字。使用 super.method() 来调用一个父类。使用 super()一个父类的constructor。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.stop(); <span class="comment">// 调用父类的 stop</span></span><br><span class="line">        <span class="built_in">this</span>.hide(); <span class="comment">// 然后 hide</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.run(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.stop(); <span class="comment">// White Rabbit stands still. White Rabbit hides!</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>箭头函数没有super，如果被访问他从外部获取，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">super</span>.stop(), <span class="number">1000</span>); <span class="comment">// 1 秒后调用父类的 stop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-重写-constructor"><a href="#3-重写-constructor" class="headerlink" title="3 重写 constructor"></a>3 重写 constructor</h2><p>如果一个类继承了一个父类，但是没有重写constructor，那么他的constructor，默认是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为没有自己的 constructor 的扩展类生成的</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们设置自己子类的constructor，但是有一定的要求：</p>
<ul>
<li>继承类的constructor， 必须调用 super()。</li>
<li>并且一定要在this 之前调用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, earLength</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.earLength = earLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-重写类字段"><a href="#4-重写类字段" class="headerlink" title="4 重写类字段"></a>4 重写类字段</h2><p>一般错误的实现方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;rabbit&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(); <span class="comment">// animal</span></span><br><span class="line"><span class="keyword">new</span> Rabbit(); <span class="comment">// animal</span></span><br></pre></td></tr></table></figure>
<p><strong>是因为，父类构造器总是会使用它自己字段的值，而不是被重写的那一个。</strong></p>
<p>实际上，原因在于字段初始化的顺序。类字段是这样初始化的：</p>
<ul>
<li>对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</li>
<li>对于子类，在 super() 后立刻初始化</li>
</ul>
<p>在上面的例子中，Rabbit是子类, 他没有实现constructor，所以是一个空的 super(…args)的构造器。</p>
<p>所以，new Rabbit() 调用了 super()，因此它执行了父类构造器，并且只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候，Rabbit 还没有自己的类字段，这就是为什么 Animal 类字段被使用了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>想要扩展一个类：<code>class Child extends Parent</code>。</p>
<p>这意味着 <code>Child.prototype.__proto__</code> 将是 <code>Parent.prototype</code>，所以方法会被继承。</p>
<p>重写一个 constructor：在使用 <code>this</code> 之前，我们必须在 <code>Child</code> 的 constructor 中将父 constructor 调用为 <code>super()</code>。</p>
<p>重写一个方法：我们可以在一个 <code>Child</code> 方法中使用 <code>super.method()</code> 来调用 <code>Parent</code> 方法。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(一)</title>
    <url>/2023/03/08/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%B8%80)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-一"><a href="#JS笔记之JS类-一" class="headerlink" title="JS笔记之JS类(一)"></a>JS笔记之JS类(一)</h1><p>在日常的开发中，京城需要构建许多类型相同的对象，例如 Users, Goods ，我们可以使用构造器来完成这样的操作，但是在现代JS中可以是使用类这种方式来创建相同类型的对象。</p>
<h2 id="1-类基本语法"><a href="#1-类基本语法" class="headerlink" title="1 类基本语法"></a>1 类基本语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class 方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="title">method1</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="title">method2</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="title">method3</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User()</span><br></pre></td></tr></table></figure>
<p>new 会自动调用<code>constructor</code>方法，因此可以在<code>constructor</code>方法中初始化对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure>
<p>在python中创建类的方式也大同小异。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&quot;我的名字是：<span class="subst">&#123;self.name&#125;</span>，Hi~&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    user = User(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">    user.say_hi()</span><br></pre></td></tr></table></figure>
<p>在JS中当 new User(“john”)被调用时，代表一个新的对象被创建，constructor 使用给定的参数运行，并且将其赋值给this.name。</p>
<blockquote>
<p>Tips：</p>
<p>类的方法之间没有逗号。</p>
</blockquote>
<h2 id="2-所以class到底是什么？"><a href="#2-所以class到底是什么？" class="headerlink" title="2 所以class到底是什么？"></a>2 所以class到底是什么？</h2><p>在JS中类是一种函数，class User(…) 实际上做了如下的事情：</p>
<ol>
<li>创建一个名为User的函数，该函数称为类声明的结果，该函数的代码来自于constructor方法（如果不编写这个方法，那么就为空）。</li>
<li>存储类中的方法，例如 User.prototype.sayHi</li>
</ol>
<h2 id="3-class-不仅仅是语法糖"><a href="#3-class-不仅仅是语法糖" class="headerlink" title="3 class 不仅仅是语法糖"></a>3 class 不仅仅是语法糖</h2><p>声明上述的User对象不使用类也可以声明一个同样的对象：`</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用纯函数重写 class User</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建构造器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数的原型（prototype）默认具有 &quot;constructor&quot; 属性，</span></span><br><span class="line"><span class="comment">// 所以，我们不需要创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将方法添加到原型</span></span><br><span class="line">User.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure>
<p>虽然得到的结果基本相同，但是他们之间仍然存着巨大的差异。</p>
<ol>
<li><p>通过class创建的函数具有特殊的内部属性标记。[[IsClassConstructor]]:true。</p>
<p>必须使用 new 来创建它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> User); <span class="comment">// function</span></span><br><span class="line">User();  <span class="comment">// Class constructor User cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>类方法不可枚举，类定义将 prototype 中的所有的方法的描述符enumerable设置为fasle。</p>
</li>
<li><p>类总是使用 user strict , 在类构造中的代码都自动进入严格模式。</p>
</li>
</ol>
<h2 id="4-类表达式"><a href="#4-类表达式" class="headerlink" title="4 类表达式"></a>4 类表达式</h2><p>类会像函数一样可以在另外一个表达式中被定义，被传递，返回，赋值等。如果类表达式有名字，那么该名字仅在类内部可见。且可以动态的创建类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> User = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// “命名类表达式（Named Class Expression）”</span></span><br><span class="line"><span class="comment">// (规范中没有这样的术语，但是它和命名函数表达式类似)</span></span><br><span class="line"><span class="keyword">let</span> User = <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(MyClass); <span class="comment">// MyClass 这个名字仅在类内部可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// 正常运行，显示 MyClass 中定义的内容</span></span><br><span class="line"></span><br><span class="line">alert(MyClass); <span class="comment">// error，MyClass 在外部不可见</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态的创建类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClass</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个类并返回它</span></span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            alert(phrase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的类</span></span><br><span class="line"><span class="keyword">let</span> User = makeClass(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="5-getters-setters"><a href="#5-getters-setters" class="headerlink" title="5 getters/setters"></a>5 getters/setters</h2><p>类同样可能包括getters/setters，以及计算属性 （computed properties）等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 setter</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;Name is too short.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> User(<span class="string">&quot;&quot;</span>); <span class="comment">// Name is too short.</span></span><br></pre></td></tr></table></figure>


<h2 id="6-计算属性"><a href="#6-计算属性" class="headerlink" title="6 计算属性"></a>6 计算属性</h2><p>计算属性的方法名称使用中括号声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="string">&#x27;say&#x27;</span> + <span class="string">&#x27;Hi&#x27;</span>]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi();</span><br></pre></td></tr></table></figure>


<h2 id="7-类字段"><a href="#7-类字段" class="headerlink" title="7 类字段"></a>7 类字段</h2><p>类字段是一种允许添加任何属性的语法，类字段的重要的不同之处在于他们会在每个对立对象中被设置好，而不是在User.prototype：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// John</span></span><br><span class="line"><span class="built_in">console</span>.log(User.prototype.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>


<h2 id="8-使用类字段实现绑定方法"><a href="#8-使用类字段实现绑定方法" class="headerlink" title="8 使用类字段实现绑定方法"></a>8 使用类字段实现绑定方法</h2><p>在JS中具有动态的this，它取决于调用上下文，如果一个对象方法被传递到某处，或者在另一个上下文中被调用，则this不在是起对象的引用。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> Button(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(button.click, <span class="number">1000</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>


<p>在函数进阶中的函数绑定中说明过这个情况，解决的方法有两种，一是使用包装器，二是将方法绑定到对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 他是基于每一个对象创建的，在这里每一个button都有一个独立的方法，内部都有一个指向此对象的this,可以把button.click()传递到任何都一个对象。</span></span><br><span class="line">    click = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> Button(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(button.click, <span class="number">1000</span>); <span class="comment">// hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在浏览器环境中，它对于进行事件监听尤为有用。</p>
</blockquote>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>类的基本语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    prop = value; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...</span>)</span> &#123; <span class="comment">// 构造器</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">method</span>(<span class="params">...</span>)</span> &#123; &#125; <span class="comment">// method</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">something</span>(<span class="params">...</span>) &#123; &#125; <span class="comment">// getter 方法</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title">something</span>(<span class="params">...</span>) &#123; &#125; <span class="comment">// setter 方法</span></span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; &#125; <span class="comment">// 有计算名称（computed name）的方法（此处为 symbol）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>技术上来说，<code>MyClass</code> 是一个函数（我们提供作为 <code>constructor</code> 的那个），而 methods、getters 和 setters 都被写入了 <code>MyClass.prototype</code>。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(六)</title>
    <url>/2023/03/02/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E5%85%AD)%20/</url>
    <content><![CDATA[<p>​        </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-六"><a href="#JS笔记之JS函数进阶-六" class="headerlink" title="JS笔记之JS函数进阶(六)"></a>JS笔记之JS函数进阶(六)</h1><h2 id="1-函数绑定"><a href="#1-函数绑定" class="headerlink" title="1 函数绑定"></a>1 函数绑定</h2><p>将对象方法作为回调进行绑定，例如传递给<code>setTimeout</code>会存在丢失this的问题。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(user.sayHi, <span class="number">1000</span>); <span class="comment">// Hello, undefined!</span></span><br></pre></td></tr></table></figure>
<p>这是因为<code>setTimeout</code> 获取到的函数 <code>user.sayHi</code> 和对象 <code>user</code> 分离了，无法在获取<code>user</code> 对象的上下文。</p>
<p>这是一种比较典型的问题：我们想将一个对象的方法，传递到别的地方调用，如何确保对象中的方法的上下文呢？</p>
<h2 id="2-解决方案一：包装器"><a href="#2-解决方案一：包装器" class="headerlink" title="2 解决方案一：包装器"></a>2 解决方案一：包装器</h2><p>通过包装器从外部的此法环境，能够获取user，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    user.sayHi(); <span class="comment">// Hello, John!</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用箭头函数函数m 更简洁的语法</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> user.sayHi(), timeout);</span><br></pre></td></tr></table></figure>


<p>上述的方法有一个问题就是函数执行有一秒的延迟，但是在这一秒之内，原来的对象被修改了，name将会执行被修改后的对象的方法，或者直接抛出异常。</p>
<h2 id="3-解决方案二：bind"><a href="#3-解决方案二：bind" class="headerlink" title="3 解决方案二：bind"></a>3 解决方案二：bind</h2><p>函数提供了一个内建方法，他可以绑定this，基本的语法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.bind(context);</span><br></pre></td></tr></table></figure>
<p>简单来说就是把<code>this</code>，提供给<code>func</code>，和之前的<code>func.call(contenxt, arg1,...)</code>和<code>func.apply(contenxt, ...args)</code>类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.firstName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> funcUser = func.bind(user);</span><br><span class="line">funcUser(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>


<p>现在来尝试解决解决方案一出现的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params">phrase</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;phrase&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = user.sayHi.bind(user); <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在没有对象（译注：与对象分离）的情况下运行它</span></span><br><span class="line">sayHi(<span class="string">&quot;李四&quot;</span>); <span class="comment">// 李四, John!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 张三, John!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使 user 的值在不到 1 秒内发生了改变</span></span><br><span class="line"><span class="comment">// sayHi 还是会使用预先绑定（pre-bound）的值，该值是对旧的 user 对象的引用</span></span><br></pre></td></tr></table></figure>


<p>现在使用<code>bind</code>来操作函数，并且函数能够保持在对象改变的情况下，保持对原来对象的引用。同样可以正常运行。<code>let sayHi = user.sayHi.bind(user);</code> 我们将<code>user</code>对象的方法绑定给<code>sayHi</code>，他可以被单独调用，也可以传递到<code>setTimeout</code>中。</p>
<p>如果一个对象有很多方法， 可以在循环中进行绑定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> user[key] == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        user[key] = user[key].bind(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-部分应用函数-（Partial-functions）"><a href="#4-部分应用函数-（Partial-functions）" class="headerlink" title="4 部分应用函数 （Partial functions）"></a>4 部分应用函数 （Partial functions）</h2><p>JS中不仅可以绑定函数，还可以绑定参数，在python中也有同样的概念，Python中partial的基本使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">sum_1 = partial(<span class="built_in">sum</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(sum_1(<span class="number">2</span>)) </span><br></pre></td></tr></table></figure>


<p>JS partial的基本语法：<code>let bound = func.bind(context, [arg1], [arg2], ...);</code>他可以将上下文绑定为<code>this</code>，且绑定部分参数。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> double = mul.bind(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">3</span>)); <span class="comment">// = mul(2, 3) = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">4</span>)); <span class="comment">// = mul(2, 4) = 8</span></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">5</span>)); <span class="comment">// = mul(2, 5) = 10</span></span><br></pre></td></tr></table></figure>


<p>值得一提的是，当没有上下文<code>this</code>需要绑定的时候， 要显示的将上下文设置为<code>null</code>。或者可以理解为将<code>null</code>绑定为了上下文。但是不能省略。</p>
<p>可用的场景大概是：①：我们再原来的函数的基础上创建一个可独享较高的独立函数，且不必每次都提供一个参数，因为参数是被绑定了的。②：或者是当我们有一个很灵活的函数，希望有一个不那么领灵活的变形时，可以使用这个方法。</p>
<h2 id="5-没有上下文的部分应用函数-（Partial-functions）"><a href="#5-没有上下文的部分应用函数-（Partial-functions）" class="headerlink" title="5 没有上下文的部分应用函数 （Partial functions）"></a>5 没有上下文的部分应用函数 （Partial functions）</h2><p>当我们只想为一些函数绑定参数，但是没有上下文，原生的<code>bind</code>不支持这样。这是我们可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">func, ...argsBound</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(<span class="built_in">this</span>, ...argsBound, ...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>function partial(func, ...argsBound)</code>调用的结果是一个包装器，这个包装器调用<code>func</code>，并且与他获得的函数具有相同的<code>this</code>，<code>...argsBound</code>是<code>function partial(func, ...argsBound)</code>的参数，<code>...args</code>是给包装器的参数。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params">time, phrase</span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`[<span class="subst">$&#123;time&#125;</span>] <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>: <span class="subst">$&#123;phrase&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个带有绑定时间的 partial 方法</span></span><br><span class="line"><span class="comment">// new Date().getHours() + &#x27;:&#x27; + new Date().getMinutes() 是包装器的参数，就是...argsBound</span></span><br><span class="line">user.sayNow = partial(user.say, <span class="keyword">new</span> <span class="built_in">Date</span>().getHours() + <span class="string">&#x27;:&#x27;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getMinutes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello 是包装器的参数。</span></span><br><span class="line">user.sayNow(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的结果： [22:41] John: Hello!</span></span><br></pre></td></tr></table></figure>


<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><ul>
<li>方法<code>func.bind(context, ...args)</code>返回函数<code>func</code>的“绑定变体”，它绑定了上下文 this 和第一个参数（如果给定了）。我们一般使用<code>bind</code>绑定<code>this</code>传递到其他地方用，例如传递给<code>setTimeout</code>。</li>
<li>当绑定现有函数的一些参数后，绑定的函数被称为 partially  applied或者偏函数（自创）。</li>
<li>bind 绑定的结果是一个新的对象，他没有原来函数的属性。</li>
<li>一个函数不能被重绑定（re-bound）。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS弹性盒模型Flex知识巩固</title>
    <url>/2023/02/27/CSS%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8BFlex%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<p>​               </p>
<a id="more"></a>          



<p>所谓弹性盒模型就是首先要有一个盒子，即弹性盒，在盒子中的所有的元素都是弹性元素，我们可以控制里面的元素的排列组合。</p>
<p>例如盒子中有两个元素水平排列时，他们自动等宽排列。我们同样可以使其（弹性元素）竖直排列。</p>
<p><img src="https://tc.chaizz.com/tc/image-20230227202922436.png" alt="image-20230227202922436"></p>
<p>当增加了一个盒子，会自动变为三个元素水平等宽排列。</p>
<p><img src="https://tc.chaizz.com/tc/image-20230227203140920.png" alt="image-20230227203140920"></p>
<h2 id="1-声明弹性盒子"><a href="#1-声明弹性盒子" class="headerlink" title="1 声明弹性盒子"></a>1 声明弹性盒子</h2><p>例如当前我们有这样一个结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> * &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://tc.chaizz.com/tc/image-20230227204707086.png" alt="image-20230227204707086"></p>
<h2 id="2-弹性元素排列"><a href="#2-弹性元素排列" class="headerlink" title="2 弹性元素排列"></a>2 弹性元素排列</h2><p>默认的HTML的文档流排列方法为从上到下， 1,2,3 三个<code>div</code>以此排列。</p>
<p>当我们在<code>article</code>上添加 <code>display:flex</code> 时，此时三个<code>div</code>将编程如下的排列方式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="comment">/* 将article转化为弹性盒 */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://tc.chaizz.com/tc/image-20230227205029209.png" alt="image-20230227205029209"></p>
<p>弹性盒中的弹性元素默认为水平排列，当元素的个数发生变化，元素宽度会自适应伸缩。我们仍然可以使用<code>flex-direction</code>来改变弹性元素的排列方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-direction：控制弹性元素的排列方式。</span></span><br><span class="line"><span class="comment">        row：默认的排列方式。水平排列</span></span><br><span class="line"><span class="comment">        row-reverse：水平排列，但是弹性元素进行翻转</span></span><br><span class="line"><span class="comment">        column：竖向方向排列</span></span><br><span class="line"><span class="comment">        column-reverse：竖向排列，但是弹性元素进行翻转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-direction</span>: row;  </span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-弹性元素换行"><a href="#3-弹性元素换行" class="headerlink" title="3 弹性元素换行"></a>3 弹性元素换行</h2><p>在上文中， 弹性元素都没有弹性盒子的宽度宽，有时候我们会有很多的弹性元素，默认是自适应伸缩的，但是我们想让他们超过弹性盒子宽度时进行换行要怎么实现呢？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    flex-wrap：控制元素在溢出的时候是否换行 </span></span><br><span class="line"><span class="comment">        npwrap：不换行</span></span><br><span class="line"><span class="comment">        wrap：换行</span></span><br><span class="line"><span class="comment">        wrap-reverse：反向换行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>根据<code>flex-wrap</code>的属性和<code>flex-direction</code>的属性，我们可以控制元素的水平、列排布以及在元素溢出的时候的换行排布。css针对上述属性提供了一个快捷的属性<code>flex-flow</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    flex-flow 可以同时设置排列和换行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-flow</span>: column wrap;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-弹性盒排列的方式"><a href="#4-弹性盒排列的方式" class="headerlink" title="4 弹性盒排列的方式"></a>4 弹性盒排列的方式</h2><p>在弹性元素水平竖直排列时候，会有一个轴的概念。弹性盒主要根据轴来区分弹性元素排列的方向。弹性盒内部会有一个主轴副轴之分，如果是默认排列方式：<code>flex-flow:row nowarp</code> 此时水平方向的轴为弹性盒的主轴。当元素换行的时候元素就会根据副轴（即竖直方向的轴）进行排列。</p>
<p><img src="https://tc.chaizz.com/tc/image-20230227212850381.png" alt="image-20230227212850381"></p>
<p>如果是排列方式为：<code>flex-flow:column nowarp</code> 此时竖直方向的轴为弹性盒的主轴。当元素换行的时候元素就会根据副轴（即水平方向的轴）进行排列。</p>
<p><img src="https://tc.chaizz.com/tc/image-20230227213340600.png" alt="image-20230227213340600"></p>
<p>所以根据上面的图例，可以说明在弹性盒模型中，主轴并不一定是水平方向或者是垂直方向，是要根据弹性盒模型的<code>flex-direction</code>属性决定的。</p>
<h2 id="5-主轴的排列方式（单行）"><a href="#5-主轴的排列方式（单行）" class="headerlink" title="5 主轴的排列方式（单行）"></a>5 主轴的排列方式（单行）</h2><p>使用<code>justify-content</code>来控制主轴的排列方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">article &#123;</span><br><span class="line">	display: flex;</span><br><span class="line">	flex-flow: row wrap;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">    justify-content：控制弹性元素在主轴的对齐方式</span></span><br><span class="line"><span class="comment">        1、当 flex-direction 为 row 时，主轴为水平方向。</span></span><br><span class="line"><span class="comment">            flex-start：从主轴开始对齐， 默认。从左到右。</span></span><br><span class="line"><span class="comment">            flex-end：从主轴结束对齐，从右到左。</span></span><br><span class="line"><span class="comment">            如果 flex-direction 进行翻转：row-reverse，以上两种对齐方式则也会翻转</span></span><br><span class="line"><span class="comment">        2、当 flex-direction 为 column 时，主轴为竖直方向。</span></span><br><span class="line"><span class="comment">            flex-start：从主轴开始对齐， 默认。从上到下。</span></span><br><span class="line"><span class="comment">            flex-end：从主轴结束对齐，从下到上。</span></span><br><span class="line"><span class="comment">            如果 flex-direction 进行翻转：column-reverse，以上两种对齐方式则也会翻转</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、根据主轴居中</span></span><br><span class="line"><span class="comment">            center：所有元素在主轴之间进行居中显示</span></span><br><span class="line"><span class="comment">        4、平均分布</span></span><br><span class="line"><span class="comment">            4.1  space-evenly：完全的平局分布</span></span><br><span class="line"><span class="comment">            4.2  space-around：元素左右两侧会有相等的间距。</span></span><br><span class="line"><span class="comment">            4.3  space-between：左右两边的元素完全靠边，中间的元素平均分布</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	justify-content: space-around;</span><br><span class="line">	border: 2px solid rgb(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	width: 600px;</span><br><span class="line">	height: 600px;</span><br><span class="line">	margin: 50px auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://tc.chaizz.com/tc/image-20230227221805554.png" alt="image-20230227221805554"></p>
<p>当主轴为竖直方向也是相同的排列规则。</p>
<h2 id="6-副轴（交叉轴）的排列方式（单行）"><a href="#6-副轴（交叉轴）的排列方式（单行）" class="headerlink" title="6 副轴（交叉轴）的排列方式（单行）"></a>6 副轴（交叉轴）的排列方式（单行）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">	<span class="attribute">justify-content</span>: space-around;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    align-items 控制弹性元素在副轴（交叉轴）的对齐方式</span></span><br><span class="line"><span class="comment">        1、当主轴为水平方向时：</span></span><br><span class="line"><span class="comment">            flex-start：从副轴开始对齐，从上到下。</span></span><br><span class="line"><span class="comment">            flex-end：从副轴开始对齐，从下到上。</span></span><br><span class="line"><span class="comment">        2、center</span></span><br><span class="line"><span class="comment">            交叉轴的中心对齐。</span></span><br><span class="line"><span class="comment">        3、stretch</span></span><br><span class="line"><span class="comment">            元素拉伸，前提是元素没有高度，否则会进行覆盖。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        当主轴为垂直方向时 与水平方向原理一致。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">align-items</span>: stretch;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> * &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="comment">/* height: 100px; */</span></span><br><span class="line">	<span class="attribute">background-color</span>: red;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>案例：单行元素在弹性盒模型中水平垂直居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="comment">/* 1、将盒子设置为弹性盒模型。 */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* 2、设置主轴方向上的居中。 */</span></span><br><span class="line">	<span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="comment">/* 3、设置副轴（交叉轴）方向上的居中。 */</span></span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> * &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: red;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>步骤：</p>
<ol>
<li>将盒子设置为弹性盒模型。</li>
<li>设置主轴方向上的居中：<code>justify-content: center</code>。</li>
<li>设置副轴（交叉轴）方向上的居中：<code> align-items: center</code>。</li>
</ol>
<h2 id="7-多行元素在交叉轴的排列"><a href="#7-多行元素在交叉轴的排列" class="headerlink" title="7 多行元素在交叉轴的排列"></a>7 多行元素在交叉轴的排列</h2><p>如果交叉轴的元素有<code>margin</code>属性是<code>auto</code>，则会忽略<code>align-self</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">        对单个元素的交叉轴进行控制</span></span><br><span class="line"><span class="comment">        flex-end：反向排列</span></span><br><span class="line"><span class="comment">        flex-start：默认排列</span></span><br><span class="line"><span class="comment">        center：居中对齐排列</span></span><br><span class="line"><span class="comment">        stretch：将元素拉伸 （没有高度或者自动的高度）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="attribute">align-self</span>: baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="8-弹性元素在弹性盒可用空间的分配"><a href="#8-弹性元素在弹性盒可用空间的分配" class="headerlink" title="8 弹性元素在弹性盒可用空间的分配"></a>8 弹性元素在弹性盒可用空间的分配</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    lex-grow：按比例在弹性盒中分配，</span></span><br><span class="line"><span class="comment">        当只为一个元素设置lex-grow 属性时，他的值可以是任意值，其他的元素没有设置，代表其余的模型宽度不变。</span></span><br><span class="line"><span class="comment">        当前设置的元素占据剩下盒子宽度的所有。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    lex-grow 当其他的元素也设置 lex-grow 属性时， 就会按照弹性盒的宽度记性等分。</span></span><br><span class="line"><span class="comment">    例如第二个元素设置了1， 第一个元素也设置了1，那么弹性盒除去未设置的元素的大小 100px,</span></span><br><span class="line"><span class="comment">    剩下的500px 将 元素1 和 元素2 等分，都是250px，因为他们的flex-grow 都是1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果第二个元素设置为2，那么弹性盒除去未设置的元素的大小100px,剩下的500px 设置为三等分，第二个元素占用</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="9-关于第八点的案例"><a href="#9-关于第八点的案例" class="headerlink" title="9 关于第八点的案例"></a>9 关于第八点的案例</h2><p>在手机应用中，常常会有顶部导航栏，底部菜单栏，中间全部时内容区域。切会根据不同的手机分辨率，自适用伸缩。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置 高度和视口高度一致 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="comment">/* 设置body为弹性盒模型 */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* 设置为列对齐， 主轴为竖直方向 */</span></span><br><span class="line">	<span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="comment">/* 设置上下元素贴边，中间居中 */</span></span><br><span class="line">	<span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置该弹性盒模型的元素占用剩余弹性盒的所有区域 */</span></span><br><span class="line">	<span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: blueviolet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: forestgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="10-元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）"><a href="#10-元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）" class="headerlink" title="10 元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）"></a>10 元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）</h2><p><code>flex-shrink</code>：控制元素在弹性盒空间不足以容纳弹性元素且不换行时的弹性元素的伸缩比例。</p>
<p>当<code>flex-shirk</code>为0时，弹性元素不进行缩放，如果设置某个元素的缩放比例。</p>
<p>元素缩小比例的计算规则：(可以缩小的总宽度/((A元素<em>flex-shrink的值) + (B元素</em>flex-shrink的值) + …) * 对应flex-shrink的值) * 元素的本身的宽度。这个属性用的比较少。。。。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="comment">/* 控制某个弹性元素的缩放比例 */</span></span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="11-主轴的基准尺寸"><a href="#11-主轴的基准尺寸" class="headerlink" title="11 主轴的基准尺寸"></a>11 主轴的基准尺寸</h2><p><code>flex-basis</code> 的主轴的基准尺寸，来设置元素的宽度或者高度，当主轴为水平轴时，基准尺寸为元素的宽度，如果是竖直排列，基准尺寸为元素的高度。</p>
<p>基准尺寸会覆盖元素的宽度。但是当元素有<code>max-width</code>或者<code>min-width</code>时，他的优先级要比基准尺寸要高。所以优先级为：<code>max/min-width</code>&gt;<code>flex-basis</code>&gt;<code>width</code>。</p>
<h2 id="12-结合弹性元素的放大、缩放、主轴组合定义"><a href="#12-结合弹性元素的放大、缩放、主轴组合定义" class="headerlink" title="12 结合弹性元素的放大、缩放、主轴组合定义"></a>12 结合弹性元素的放大、缩放、主轴组合定义</h2><p><code>flex: 放大 缩放 主轴基准</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">artile</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="comment">/* 以上的三种属性可以直接在flex上直接定义，依次是 flex-grow flex-shrink flex-basis */</span></span><br><span class="line">    <span class="comment">/* 更推荐这种写法 */</span></span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-控制弹性盒模型的弹性元素顺序"><a href="#13-控制弹性盒模型的弹性元素顺序" class="headerlink" title="13 控制弹性盒模型的弹性元素顺序"></a>13 控制弹性盒模型的弹性元素顺序</h2><p><code>order</code>属性的值为整数，代表按照顺序排列元素， 按照该整数（最低的值）首先按照视觉顺序放置项目。如果多个项目具有相同的整数值，则在该组中按照源顺序对项目进行布局。</p>
<p>值越低顺序越在前，越高越往后。</p>
<h2 id="14-弹性盒模型中的文本"><a href="#14-弹性盒模型中的文本" class="headerlink" title="14 弹性盒模型中的文本"></a>14 弹性盒模型中的文本</h2><p>文本同样适用于弹性盒模型。</p>
<h2 id="15-定位元素在弹性布局中的效果"><a href="#15-定位元素在弹性布局中的效果" class="headerlink" title="15 定位元素在弹性布局中的效果"></a>15 定位元素在弹性布局中的效果</h2><ol>
<li>绝对定位<ol>
<li>和普通的绝对定位一致，直接浮动于其他的元素之上，其他的元素无法感知到他的位置。可以使用top left 等进行控制。</li>
</ol>
</li>
<li>相对定位<ol>
<li>相对定位，原来的空间位是保存的，其他的元素能够感知到他，不会占据他的空间，也可以top left 等进行控制。</li>
</ol>
</li>
</ol>
<h2 id="16-案例-一"><a href="#16-案例-一" class="headerlink" title="16 案例(一)"></a>16 案例(一)</h2><p>移动端的弹出菜单栏</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">			* &#123;</span><br><span class="line">				margin: 0;</span><br><span class="line">				padding: 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			body &#123;</span><br><span class="line">				height: 100vh;</span><br><span class="line">				display: flex;</span><br><span class="line">				flex-direction: column;</span><br><span class="line">                font-size: 30px;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			main &#123;</span><br><span class="line">				flex: 1;</span><br><span class="line"><span class="css">				<span class="selector-tag">background-color</span>: <span class="selector-id">#f3f3f3</span>;</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			footer &#123;</span><br><span class="line">				height: 100px;</span><br><span class="line">				display: flex;</span><br><span class="line"><span class="css">				<span class="selector-tag">border-top</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">				justify-content: space-between;</span><br><span class="line">				background-color: rgb(145, 145, 149);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			footer section &#123;</span><br><span class="line">				flex: 1;</span><br><span class="line">				background-color: rgb(174, 171, 171);</span><br><span class="line">				border-right: 1px solid seagreen;</span><br><span class="line"></span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column-reverse;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            footer section  h4 &#123;</span><br><span class="line">                flex: 0 0 100px;</span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column;</span><br><span class="line">                justify-content: center;</span><br><span class="line">                text-align: center;</span><br><span class="line">                font-size: 2rem;</span><br><span class="line">                cursor: pointer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            footer section  ul &#123;</span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">                text-align: center;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            footer section  ul  li &#123;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">                flex:  1 0 70px;</span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column;</span><br><span class="line">                justify-content: center;</span><br><span class="line">                cursor: pointer;</span><br><span class="line">            &#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>后端<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Django<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Flask<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>AI<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Pytorch<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>TensorFlow<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>大前端<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>React<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>效果：</p>
<p><img src="https://tc.chaizz.com/tc/image-20230228235044543.png" alt="image-20230228235044543"></p>
<h2 id="17-案例-二"><a href="#17-案例-二" class="headerlink" title="17 案例(二)"></a>17 案例(二)</h2><p>导航栏的左右靠边</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">			* &#123;</span><br><span class="line">				margin: 0;</span><br><span class="line">				padding: 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			nav &#123;</span><br><span class="line">				width: 1200px;</span><br><span class="line">				height: 60px;</span><br><span class="line"><span class="css">				<span class="selector-tag">background-color</span>: <span class="selector-id">#f3f3f3</span>;</span></span><br><span class="line">				margin: 0 auto;</span><br><span class="line">				display: flex;</span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line">			ul &#123;</span><br><span class="line">				list-style: none;</span><br><span class="line">				display: flex;</span><br><span class="line"><span class="css">				<span class="comment">/* 交叉轴居中 */</span></span></span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">			<span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">				/*</span><br><span class="line">            使用flex：1 代表让第一个ul占满弹性盒， </span><br><span class="line">            剩下的元素按照他自身的宽度占据弹性盒的宽度</span><br><span class="line"><span class="css">            <span class="selector-tag">margin-right</span>：<span class="selector-tag">auto</span>也可以达到 <span class="selector-tag">flex</span><span class="selector-pseudo">:1</span> 同样的效果</span></span><br><span class="line">            */</span><br><span class="line">				flex: 1;</span><br><span class="line"><span class="css">				<span class="comment">/* margin-right: auto; */</span></span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">			<span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">				margin: 0 20px;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">			<span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(2)</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">				width: 50px;</span><br><span class="line">				height: 50px;</span><br><span class="line">				margin-right: 20px;</span><br><span class="line">				background: chartreuse;</span><br><span class="line">				border-radius: 100% 100%;</span><br><span class="line">				justify-content: center;</span><br><span class="line">				display: flex;</span><br><span class="line">				justify-content: center;</span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Go<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>JavScript<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>JS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>效果：</p>
<p><img src="https://tc.chaizz.com/tc/image-20230302214940526.png" alt="image-20230302214940526"></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(三)</title>
    <url>/2023/02/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%B8%89)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-三"><a href="#JS笔记之JS函数进阶-三" class="headerlink" title="JS笔记之JS函数进阶(三)"></a>JS笔记之JS函数进阶(三)</h1><p>在JS中 函数也是一种值，函数的类型就是Object，函数本身也包含自己的属性。</p>
<h2 id="1-name-属性"><a href="#1-name-属性" class="headerlink" title="1 name 属性"></a>1 name 属性</h2><p>在创建一个函数时，我们可以根据函数名获取对应函数的name属性，直接创建一个具名函数或者使用命名表达式，来创建函数，函数名和命名表达式的变量名就是函数的name属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayHi.name); <span class="comment">// sayHi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sayHi.name); <span class="comment">// sayHi（有名字！）</span></span><br></pre></td></tr></table></figure>
<p>在对象中的函数同样也是具有该属性，当无法获取该属性时， name的值为空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数是在数组中创建的</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log( arr[<span class="number">0</span>].name ); <span class="comment">// &lt;空字符串&gt;</span></span><br><span class="line"><span class="comment">// 引擎无法设置正确的名字，所以没有值</span></span><br></pre></td></tr></table></figure>


<h2 id="2-length-属性"><a href="#2-length-属性" class="headerlink" title="2 length 属性"></a>2 length 属性</h2><p>该属性返回的是函数入参的个数，但是不包含…rest的参数，属性 length 有时在操作其它函数的函数中用于做 内省/运行时检查（introspection）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">many</span>(<span class="params">a, b, ...more</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">alert(f1.length); <span class="comment">// 1</span></span><br><span class="line">alert(f2.length); <span class="comment">// 2</span></span><br><span class="line">alert(many.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>


<h2 id="3-自定义属性"><a href="#3-自定义属性" class="headerlink" title="3 自定义属性"></a>3 自定义属性</h2><p>在函数内部还可以直接自定义属性，直接使用函数名.属性名， 这里的属性名和函数内部的变量名，是两个概念，他们之间没有关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算调用次数</span></span><br><span class="line">    sayHi.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi.counter = <span class="number">0</span>; <span class="comment">// 初始值</span></span><br><span class="line">  </span><br><span class="line">  sayHi(); <span class="comment">// Hi</span></span><br><span class="line">  sayHi(); <span class="comment">// Hi</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">`Called <span class="subst">$&#123;sayHi.counter&#125;</span> times`</span> ); <span class="comment">// Called 2 times</span></span><br></pre></td></tr></table></figure>


<p>函数的属性有时候会代替闭包，因为函数属性，可以在函数作用域内，保存局部的变量信息。</p>
<h2 id="4-函数命名表达式"><a href="#4-函数命名表达式" class="headerlink" title="4 函数命名表达式"></a>4 函数命名表达式</h2><p>带有函数 (NFE，Named Function Expression) 指带有名字的表达式的术语。</p>
<p>一个普通的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funcName = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给这个函数加一个名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funcName = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时加名字和不加名字的区别就是：</p>
<ul>
<li>加名字可以在函数的内部调用，</li>
<li>在函数的外部是不可见的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">et sayHi = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func(<span class="string">&quot;Guest&quot;</span>); <span class="comment">// 使用 func 再次调用函数自身</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// Hello, Guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但这不工作：</span></span><br><span class="line">func(); <span class="comment">// Error, func is not defined（在函数外不可见）</span></span><br></pre></td></tr></table></figure>


<h2 id="5-使用-new-Function-来创建函数"><a href="#5-使用-new-Function-来创建函数" class="headerlink" title="5 使用 new Function 来创建函数"></a>5 使用 new Function 来创建函数</h2><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数是通过给定的 arg1 arg2 参数 和 functionBody 创建的</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span> ([arg1, arg2, ...argN], functionBody);</span><br></pre></td></tr></table></figure>
<p>实际的例字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含参数和函数体</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;return a + b&#x27;</span>);</span><br><span class="line">alert( sum(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 只有函数体</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;alert(&quot;Hello&quot;)&#x27;</span>);</span><br><span class="line">sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>使用的场景：比如我们需要动态的从服务器获取一段代码来运行。</p>
<h2 id="6-闭包"><a href="#6-闭包" class="headerlink" title="6 闭包"></a>6 闭包</h2><p>闭包是指使用一个特殊的属性，来记录函数自身得创建时的环境的函数，他具体执行了函数创建时的此法环境，但是我们使用 new Function 创建的函数，他并不指向当前的词法环境，而是全局环境。</p>
<p>new Function 这种特性在实际中非常使用，想象一下我们必须通过一个字符串来创建一个函数。在编写脚本时我们不会知道该函数的代码（这也就是为什么我们不用常规方法创建函数），但在执行过程中会知道了。我们可能会从服务器或其他来源获取它。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><ul>
<li><p>new Function 语法：<code>let func = new Function ([arg1, arg2, ...argN], functionBody);</code></p>
</li>
<li><p>使用 new Function 创建的函数，的词法环境执行全局的环境。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(四)</title>
    <url>/2023/02/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-四"><a href="#JS笔记之JS函数进阶-四" class="headerlink" title="JS笔记之JS函数进阶(四)"></a>JS笔记之JS函数进阶(四)</h1><h2 id="1-setTimeout-和-setInterval"><a href="#1-setTimeout-和-setInterval" class="headerlink" title="1 setTimeout 和 setInterval"></a>1 setTimeout 和 setInterval</h2><p>语法格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout 第一个参数：一个函数或者是字符串代码(这个不常用)，第二个参数：时间间隔，代表多少秒后直行，剩下的参数：代表函数的参数。</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;&#125;, timeout [, arg1, arg2]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和setTimeout 参数一致，只不过代表的含义为重复执行该函数，interval 是重复的间隔。</span></span><br><span class="line"><span class="keyword">let</span> timer2 = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;&#125;, interval [, arg1, arg2]);</span><br></pre></td></tr></table></figure>
<p>停止计时器使用clearTimeout(timer) 和 clearInterval(timer2)。</p>
<p>使用 clearInterval 函数的调用间隔实际会代码设置的调用间隔要短，因为是在函数开始时就开始计算时间，这个间隔时间包括函数执行的时间，如果函数执行的比较慢，name就会等待函数执行完成，如果函数的执行时间小于执行间隔，那么实际的执行间隔就是：函数的执行时间+剩余的时间= Interval。</p>
<p>使用clearTimeout 则不会出现这个问题，他是等待函数执行完毕，在进行下一次的函数调用。</p>
<blockquote>
<p>当一个函数传入 setInterval/setTimeout 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。</p>
</blockquote>
<h2 id="2-嵌套setTimeout"><a href="#2-嵌套setTimeout" class="headerlink" title="2 嵌套setTimeout"></a>2 嵌套setTimeout</h2><p>使用clearInterval 调用函数每次间隔都是一致的，如果想要更加的灵活的设置函数执行之间的间隔，可以将clearInterval 进行嵌套调用。一个常用的场景就是，我们调用接口获取失败后重试，可以设置不同的访问间隔，避免造成服务器压力过大。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delay = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;发送请求！&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果请求失败，下一次执行的间隔是当前的 2 倍</span></span><br><span class="line">        delay *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(request, delay);</span><br><span class="line">&#125;, delay);</span><br></pre></td></tr></table></figure>


<h2 id="3-零延时的setTimeout"><a href="#3-零延时的setTimeout" class="headerlink" title="3 零延时的setTimeout"></a>3 零延时的setTimeout</h2><p>setTimeout(func, 0) 或者是 setTimeout(func)，这种特性，叫做零延时调度，但是他需要在哦脚本执行完毕后执行。例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> alert(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">alert(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上的代码显示输出 Hello， 在输出 World。 </p>
<blockquote>
<p>但是在浏览器环境中，零延时并不为零，嵌套定时器的运行频率是受限制的。根据 HTML5 标准 所讲：“经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒”。</p>
</blockquote>
<p><strong>任何 setTimeout 都只会在当前代码执行完毕之后才会执行。</strong></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><ul>
<li>setTimeout(func, delay, …args) 和 setInterval(func, delay, …args) 方法允许我们在 delay 毫秒之后运行 func 一次或以 delay 毫秒为时间间隔周期性运行 func。要取消函数的执行，我们应该调用 clearInterval/clearTimeout，并将 setInterval/setTimeout 返回的值作为入参传入。</li>
<li>嵌套的 setTimeout 比 setInterval 用起来更加灵活，允许我们更精确地设置两次执行之间的时间。<br>零延时调度 setTimeout(func, 0)（与 setTimeout(func) 相同）用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。</li>
<li>浏览器会将 setTimeout 或 setInterval 的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。</li>
<li>请注意，所有的调度方法都不能 保证 确切的延时<ul>
<li>例如，浏览器内的计时器可能由于许多原因而变慢：</li>
<li>CPU 过载。</li>
<li>浏览器页签处于后台模式。</li>
<li>笔记本电脑用的是省电模式。</li>
<li>所有这些因素，可能会将定时器的最小计时器分辨率（最小延迟）增加到 300ms 甚至 1000ms，具体以浏览器及其设置为准。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(五)</title>
    <url>/2023/02/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%BA%94)/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-五"><a href="#JS笔记之JS函数进阶-五" class="headerlink" title="JS笔记之JS函数进阶(五)"></a>JS笔记之JS函数进阶(五)</h1><h2 id="1-JS函数应用缓存之透明缓存"><a href="#1-JS函数应用缓存之透明缓存" class="headerlink" title="1 JS函数应用缓存之透明缓存"></a>1 JS函数应用缓存之透明缓存</h2><p>当我们有一个函数运行非常慢且每次结果都一致的时候，可以用到包装器函数，用来保存他的运行结果。我们可以使用一个Map 对象，来保存函数第一次运行的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可能会有重负载的 CPU 密集型工作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Called with <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.has(x)) &#123;    <span class="comment">// 如果缓存中有对应的结果</span></span><br><span class="line">            <span class="keyword">return</span> cache.get(x); <span class="comment">// 从缓存中读取结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result = func(x);  <span class="comment">// 否则就调用 func</span></span><br><span class="line"></span><br><span class="line">        cache.set(x, result);  <span class="comment">// 然后将结果缓存（记住）下来</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slow = cachingDecorator(slow);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(slow(<span class="number">1</span>)); <span class="comment">// slow(1) 被缓存下来了，并返回结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Again: &quot;</span> + slow(<span class="number">1</span>)); <span class="comment">// 返回缓存中的 slow(1) 的结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(slow(<span class="number">2</span>)); <span class="comment">// slow(2) 被缓存下来了，并返回结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Again: &quot;</span> + slow(<span class="number">2</span>)); <span class="comment">// 返回缓存中的 slow(2) 的结果</span></span><br></pre></td></tr></table></figure>
<p>上述代码段中：<code>cachingDecorator</code>方法中定义了一个map对象，然后返回了一个方法。Map对象的作用就是判断耗时的函数是否已经被调用过。返回的函数接受一个参数值，该值就是耗时函数的值，在函数中首先判断Map中是否有当前参数的一个对象，如果有则直接返回Map对象的值，如果没有则继续执行耗时函数，并把结果添加到Map对象中。</p>
<p>我们可以将<code>cachingDecorator</code>称为装饰器，装饰器是一个特殊的函数，他接收一个函数，并返回一个函数。</p>
<p>装饰器有几个好处：</p>
<ul>
<li>装饰器<code>cachingDecorator</code>是可重用的，我们可以将它应用于另外一个函数。</li>
<li>缓存的逻辑是独立的，我们并没有修改耗时函数的复杂性。</li>
<li>装饰器可以进行多个组合。</li>
</ul>
<p>在使用上面的装饰器时，有时我们可能会遇到一个问题，当这个耗时方法在对象中是，且在函数中使用<code>this</code>调用了对像中的其他的属性，例如一个方法 <code>someMethod</code>，我们要对这个对象的方法属性应用装饰器，那么就会出现如下的问题：</p>
<p><code>TypeError: this.someMethod is not a function</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">    <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">slow</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 可怕的 CPU 过载任务</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Called with &quot;</span> + x);</span><br><span class="line">        <span class="keyword">return</span> x * <span class="built_in">this</span>.someMethod(); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和之前例子中的代码相同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.has(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> result = func(x); <span class="comment">// (**)</span></span><br><span class="line">        cache.set(x, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">1</span>)); <span class="comment">// 原始方法有效</span></span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow); <span class="comment">// 现在对其进行缓存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">2</span>)); <span class="comment">// TypeError: this.someMethod is not a function</span></span><br></pre></td></tr></table></figure>
<p>出现上面的问题，是因为此时好使函数中的<code>this</code>已经不再是原来的<code>worker</code>对象了，他指向了<code>global</code>，在全局对象中，自然没有<code>someMethod </code>这个方法。</p>
<p>当我们将<code>worker.slow</code>赋值给一个变量时，也会出现上面的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = worker.slow;</span><br><span class="line">func(<span class="number">2</span>); <span class="comment">// TypeError: this.someMethod is not a function</span></span><br></pre></td></tr></table></figure>


<h2 id="2-使用-“func-call”-设定上下文"><a href="#2-使用-“func-call”-设定上下文" class="headerlink" title="2 使用 “func.call” 设定上下文"></a>2 使用 “func.call” 设定上下文</h2><p>他允许调用一个显示设置this的函数，运行func，提供第一参数作为该函数的this对象，后端面的作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line">  <span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 call 将不同的对象传递为 &quot;this&quot;</span></span><br><span class="line">  sayHi.call( user ); <span class="comment">// John</span></span><br><span class="line">  sayHi.call( admin ); <span class="comment">// Admin</span></span><br></pre></td></tr></table></figure>
<p>在上述的包装器中使用<code>func.call()</code> 来解决<code>TypeError: this.someMethod is not a function</code> 的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">    <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">slow</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Called with &quot;</span> + x);</span><br><span class="line">        <span class="keyword">return</span> x * <span class="built_in">this</span>.someMethod(); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.has(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> result = func.call(<span class="built_in">this</span>, x); <span class="comment">// 现在 &quot;this&quot; 被正确地传递了</span></span><br><span class="line">        cache.set(x, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow); <span class="comment">// 现在对其进行缓存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">2</span>)); <span class="comment">// 工作正常</span></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">2</span>)); <span class="comment">// 工作正常，没有调用原始函数（使用的缓存）</span></span><br></pre></td></tr></table></figure>
<p>上述<code>func.call()</code>的调佣详细过程：</p>
<ol>
<li><code>cachingDecorator</code> 装饰器函数接受的方法是 <code>worker.slow</code>。</li>
<li>此时， 装饰器中的 <code>function(x)</code> 就是<code>worker.slow</code>。</li>
<li>当执行<code>worker.slow(2)</code>，<code>this</code> 就是的方法前的对象，也就是<code>.</code>之前的对象<code>worker</code>。</li>
</ol>
<h2 id="3-传递多个参数"><a href="#3-传递多个参数" class="headerlink" title="3 传递多个参数"></a>3 传递多个参数</h2><p>上述中的装饰器只接受一个参数，我们使用一个参数作为Map对象的key，但是当有多个参数时如何存储缓存呢？</p>
<ol>
<li>自定义一个可以使用多个参数作为key的Map对象。</li>
<li>使用嵌套Map，即一个 cache.get(x) 是另一个Map的key cache.get(x).get(b)。</li>
<li>将两个值合并为一个，并将其hash。</li>
</ol>
<p>第三种实现方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">    <span class="function"><span class="title">slow</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Called with <span class="subst">$&#123;min&#125;</span>,<span class="subst">$&#123;max&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> min + max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func, hash</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> key = hash(<span class="built_in">arguments</span>); <span class="comment">// (*)</span></span><br><span class="line">        <span class="keyword">if</span> (cache.has(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result = func.call(<span class="built_in">this</span>, ...arguments); <span class="comment">// (**)</span></span><br><span class="line"></span><br><span class="line">        cache.set(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>] + <span class="string">&#x27;,&#x27;</span> + args[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow, hash);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// works</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Again &quot;</span> + worker.slow(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// same (cached)</span></span><br></pre></td></tr></table></figure>


<h2 id="4-func-apply"><a href="#4-func-apply" class="headerlink" title="4 func.apply"></a>4 func.apply</h2><p>使用<code>func.apply()</code> 同样可以实现<code>func.call()</code>的方法，使用的方法为：<code>func.apply(this, arguments)</code> 代替 <code>func.call(this, ...arguments</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(context, ...args);</span><br><span class="line">func.apply(context, args);</span><br></pre></td></tr></table></figure>
<p><code>apply </code>和 <code>call</code> 只有一个关于 <code>args</code> 的细微的差别：</p>
<ul>
<li>Spread 语法 <code>...</code> 允许将 <strong>可迭代对象</strong> <code>args</code> 作为列表传递给 <code>call</code>。</li>
<li><code>apply</code> 只接受 <strong>类数组</strong> <code>args</code>。</li>
</ul>
<p>对于一个即可迭代又是类数组的对象，例如一个真正的数组，我是用apply可能会更快，因为大多数JS引擎内部对其进行了优化。</p>
<h2 id="5-呼叫转移"><a href="#5-呼叫转移" class="headerlink" title="5 呼叫转移"></a>5 呼叫转移</h2><p>将所有的参数连同上下文一起传递给另一个函数被称为”呼叫转移（call fowarding）”</p>
<p>最简单的语法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="6-借用一种方法"><a href="#6-借用一种方法" class="headerlink" title="6 借用一种方法"></a>6 借用一种方法</h2><p>针对上文中的<code>hash</code>函数做一个改进，他只接受两个参数，如果是任意数量的参数如何处理呢？</p>
<p>一般数组对象转化为字符串时可以使用<code>arr.join()</code>方法，但是在这合理无法使用，因为参数<code>args</code>并不是一个真正的数组。但是我们可以一个技巧来借用数组的<code>join()</code>方法：<code>[].join().call(args)</code>，这种方法叫做方法借用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].join.call(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个技巧主要是从数组<code>[].join</code>借取<code>join</code>方法，并使用 <code>[].join.call</code> 在 <code>args</code> 的上下文中运行它。</p>
<h2 id="7-装饰器和函数属性"><a href="#7-装饰器和函数属性" class="headerlink" title="7 装饰器和函数属性"></a>7 装饰器和函数属性</h2><p>在使用装饰器的时候，注意一点如果原始函数有属性，则装饰后的函数不在提供这些属性。如果需要保留原始函数的属性等信息，需要使用特殊的<code>Proxy</code>对象来包装函数。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>装饰器是一个围绕改变函数行为的包装器，主要工作还是由函数来完成。</p>
<p><code>func.call(context, arg1, arg2)</code> 用给定的上下文和参数调用函数。</p>
<p><code>func.apply(context, arg1, arg2)</code> 调用 <code>func</code> 将 <code>context</code> 作为 <code>this</code> 和类数组的 <code>args</code> 传递给参数列表。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(一)</title>
    <url>/2023/02/15/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​             </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-一"><a href="#JS笔记之JS函数进阶-一" class="headerlink" title="JS笔记之JS函数进阶(一)"></a>JS笔记之JS函数进阶(一)</h1><h2 id="1-let-和-var-的区别"><a href="#1-let-和-var-的区别" class="headerlink" title="1 let 和 var 的区别"></a>1 let 和 var 的区别</h2><p>let 属于现代JS的声明变量的方式，而var则是老旧的方式。所以现在尽可能使用let。</p>
<p>一般情况下可以使用 let 代替var，或者使用var 代替 let，但是在某些方面存在着巨大的差异。</p>
<h3 id="1-1-var没有块级作用域"><a href="#1-1-var没有块级作用域" class="headerlink" title="1.1 var没有块级作用域"></a>1.1 var没有块级作用域</h3><p>例如：在 if 或者 while 中使用 var 声明的变量，可以在其他的地方获取到。是因为早期的JS中，块没有词法环境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;var&quot; 而不是 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// true，变量在 if 结束后仍存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// ReferenceError: test is not defined</span></span><br></pre></td></tr></table></figure>


<h3 id="1-2-var-允许重新声明"><a href="#1-2-var-允许重新声明" class="headerlink" title="1.2 var 允许重新声明"></a>1.2 var 允许重新声明</h3><p>使用var可以多次声明同一个变量，最新声明的变量就会无效，因为上面已经声明过了。</p>
<p>使用let在同一个作用域下声明两次会提示已经被声明的错误，var 则不会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user;</span><br><span class="line"><span class="keyword">let</span> user; <span class="comment">// SyntaxError: &#x27;user&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;Pete&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;John&quot;</span>; <span class="comment">// 这个 &quot;var&quot; 无效（因为变量已经声明过了）</span></span><br><span class="line"><span class="comment">// ……不会触发错误</span></span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-var-声明的变量-可以再声明之前使用。"><a href="#1-3-var-声明的变量-可以再声明之前使用。" class="headerlink" title="1.3 var 声明的变量 可以再声明之前使用。"></a>1.3 var 声明的变量 可以再声明之前使用。</h3><p>这种情况叫做提升，相当于使用var声明的变量 会被提升到一个函数或者脚本的最上面。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(phrase);</span><br><span class="line">    <span class="keyword">var</span> phrase = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的函数就相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> phrase</span><br><span class="line">    <span class="built_in">console</span>.log(phrase);</span><br><span class="line">    phrase = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但是有一点值的注意，虽然声明会提升到函数的开始，但是赋值并不会被提升，所以输出的结果就是一个未被赋值的变量，即：undefined。</p>
<h3 id="1-4-IIFE"><a href="#1-4-IIFE" class="headerlink" title="1.4 IIFE"></a>1.4 IIFE</h3><p>在很久以前，JS中只有var这一种声明变量的方式，且没有快捷作用域，所以程序员就发明了一种模仿块级作用域的方法，这种方法叫做立即调用函数表达式（immediately-invoked function expressions，IIFE）例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;立即调用函数表达式&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在我们已经没有理由需要这样的方法了。</p>
</blockquote>
<h3 id="1-5-全局对象"><a href="#1-5-全局对象" class="headerlink" title="1.5 全局对象"></a>1.5 全局对象</h3><p>全局对象提供可在任何地方调用的变量和函数。在浏览器中他的名字叫做 window 在nodejs中他的名字叫做global。不同的环境可能会有不同的名字， 所以JS 提出了一个标准名称叫做 globalThis。</p>
<p>使用var 定义的变量，会成为全局对象的属性，函数声明也是同样的，但是不建议直接使用<code>window.xx</code> 调用。</p>
<blockquote>
<p>一般不建议使用全局变量，全局变量应该尽可能的少的使用。</p>
</blockquote>
<h3 id="1-6-使用-polyfills"><a href="#1-6-使用-polyfills" class="headerlink" title="1.6 使用 polyfills"></a>1.6 使用 polyfills</h3><p>有时候我们可以使用全局对象来做兼容性的工作，例如查看全局对象中是否含有 Promise对象，如果没有的话我们可以创建 polyfills，来添加环境中不支持但在现代浏览器标准中存在的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.Promise) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;当前正使用旧的浏览器!&quot;</span>);</span><br><span class="line">    <span class="comment">// 定制实现现代语言功能</span></span><br><span class="line">    <span class="built_in">window</span>.Promise = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h2><p>var 和 let 的主要的两个区别：</p>
<ul>
<li>var 生明没有块级作用域，仅在当前函数内部可见，或者全局可见。</li>
<li>var 变量的声明在函数开头就会被处理。</li>
</ul>
<p>在现代JS中尽可能的使用 const 或者 let。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(一)</title>
    <url>/2023/02/15/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%B8%80)/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-一"><a href="#JS笔记之JS函数进阶-一" class="headerlink" title="JS笔记之JS函数进阶(一)"></a>JS笔记之JS函数进阶(一)</h1><h2 id="1-函数rest参数"><a href="#1-函数rest参数" class="headerlink" title="1 函数rest参数"></a>1 函数rest参数</h2><p>在JS中很多内建的参数都支持传入无限个数的参数。</p>
<p>当我们自己定义一个函数时， 也可以转入无限个数的参数，但是只能根据形参的个数来获取真正的参数，如何实现接收无限个参数或者接收数组形式的参数？</p>
<p>可以在函数定义时声明一个数组来收集参数，语法格式为：<code>...变量名</code>， 这会声明一个数组，并指定一个名称为变量名，其中存有剩余的参数。三个点的含义就是将剩余的参数存储到指定的数组中。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">...args</span>) </span>&#123; <span class="comment">// 数组名为 args</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> args) sum += arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>...args</code> 称为Rest 参数，他可以和其他的正常的函数同时使用，因为<code>...args</code> 会收集所有剩余的参数，因此，这种语法格式只能放在函数的末尾。</p>
<p>在Python函数支持位置参数和关键字参数，同样可以使用<code>*args</code> 来接收不限个数的位置参数或者是使用<code>**kwargs</code>来接收不限制个数的关键字参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_all</span>(<span class="params">*args: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">sum</span> += x</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(sum_all(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p>在JS中还有一个特殊的参数对象areguments，可以在函数中被访问，该对象以参数在参数列中的索引作为键，存储所有的参数。areguments是一个类数组，也是一个可迭代对象，他不支持数组方法，而且他始终包含所有的参数，无法向数组那样直接对参数截取。因此当接受很多参数时最好使用Rest参数。</p>
<blockquote>
<p>另外箭头函数是没有areguments的。如果在剪头函数中访问 areguments 得到的是箭头函数的外部的普通函数的areguments。</p>
<p>即箭头函数没有本身的this以及 areguments。</p>
</blockquote>
<h2 id="2-函数Spread语法"><a href="#2-函数Spread语法" class="headerlink" title="2 函数Spread语法"></a>2 函数Spread语法</h2><p>在上文中Rest参数是从多个参数中得到一个类数组对象，而Spread则与之相反，当我们有一个数组，如何将它作为多个参数的函数中去？</p>
<p>Spread的语法和Rest参数语法很像，也是使用<code>...</code>，但是用途确实相反，当在函数中调用<code>...arr</code>时，他会把可迭代对象展开到参数列表中去，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...arr) ); <span class="comment">// 5（spread 语法把数组转换为参数列表）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样可以传入多个可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>, <span class="number">3</span>, -<span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...arr1, ...arr2) ); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与常规的参数使用</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>, <span class="number">3</span>, -<span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(<span class="number">1</span>, ...arr1, <span class="number">2</span>, ...arr2, <span class="number">25</span>) ); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>Spread 可以迭代任意的可迭代对象，例如字符串，Spread内部使用迭代器来收集元素，和for…of 的方式相同，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( [...str1] ); <span class="comment">// H,e,l,l,o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 将可迭代对象转换为数组</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.from(str2) ); <span class="comment">// H,e,l,l,o</span></span><br></pre></td></tr></table></figure>
<p>上述的例字中Array.from 和[…str] 得到的结果一致，但是他们之间还有一个细微的差别：</p>
<ul>
<li>Array.from(str) 适用于类数组对象也适用于可迭代对象。</li>
<li>Spread 语法只适用于可迭代对象。</li>
</ul>
<p>使用Spread也可以进行浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrCopy = [...arr]; <span class="comment">// 将数组 spread 到参数列表中，然后将结果放到一个新数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(arr) === <span class="built_in">JSON</span>.stringify(arrCopy)); <span class="comment">// 结果是一致的</span></span><br><span class="line"><span class="built_in">console</span>.log(arr === arrCopy);  <span class="comment">// 引用是不一致的</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy);</span><br></pre></td></tr></table></figure>
<p>使用同样的方式也可以复制一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objCopy = &#123; ...obj &#125;; <span class="comment">// 将对象 spread 到参数列表中</span></span><br><span class="line">                          <span class="comment">// 然后将结果返回到一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个对象中的内容相同吗？</span></span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(obj) === <span class="built_in">JSON</span>.stringify(objCopy)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个对象相等吗？</span></span><br><span class="line">alert(obj === objCopy); <span class="comment">// false (not same reference)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改我们初始的对象不会修改副本：</span></span><br><span class="line">obj.d = <span class="number">4</span>;</span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4&#125;</span></span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(objCopy)); <span class="comment">// &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种方式比使用 let arrCopy = Object.assign([], arr) 复制数组，或使用 let objCopy = Object.assign({}, obj) 复制对象来说更为简便。因此，只要情况允许，我们倾向于使用它</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>Rest 参数语法和Spread 语法的一个区别就是若<code>...</code>出现在函数参数列表的最后，那么他就是Rest参数，如果出现在函数调用或者类似的表达式中，那么就是Spread语法。</p>
<p>可以使用这两种语法轻松的转换参数列表和参数数组。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(七)</title>
    <url>/2023/02/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%83)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-七"><a href="#JS笔记之JS数据类型-七" class="headerlink" title="JS笔记之JS数据类型(七)"></a>JS笔记之JS数据类型(七)</h1><h2 id="1-日期和时间"><a href="#1-日期和时间" class="headerlink" title="1 日期和时间"></a>1 日期和时间</h2><h3 id="1-1-创建日期"><a href="#1-1-创建日期" class="headerlink" title="1.1 创建日期"></a>1.1 创建日期</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Date-接收参数类型"><a href="#1-2-Date-接收参数类型" class="headerlink" title="1.2 Date() 接收参数类型"></a>1.2 Date() 接收参数类型</h3><ul>
<li><p>int类型：代表距离 1970 年 1 月 1 日 UTC+0 之后经过的毫秒数，可以为负数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 表示 01.01.1970 UTC+0</span></span><br><span class="line"><span class="keyword">let</span> Jan01_1970 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">alert( Jan01_1970 );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在增加 24 小时，得到 02.01.1970 UTC+0</span></span><br><span class="line"><span class="keyword">let</span> Jan02_1970 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">alert( Jan02_1970 );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 31 Dec 1969</span></span><br><span class="line"><span class="keyword">let</span> Dec31_1969 = <span class="keyword">new</span> <span class="built_in">Date</span>(-<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">alert( Dec31_1969 );</span><br></pre></td></tr></table></figure></li>
<li><p>str类型：将会自动解析为 时间字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-01-26&quot;</span>);</span><br><span class="line">alert(date);</span><br><span class="line"><span class="comment">// 未指定具体时间，所以假定时间为格林尼治标准时间（GMT）的午夜零点</span></span><br><span class="line"><span class="comment">// 并根据运行代码时的用户的时区进行调整</span></span><br><span class="line"><span class="comment">// 因此，结果可能是</span></span><br><span class="line"><span class="comment">// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="comment">// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)</span></span><br></pre></td></tr></table></figure></li>
<li><p>year, month, date, hours, minutes, seconds, ms：使用当前时区的给定组件创建日期，只有前两个参数是必须的，</p>
<ul>
<li>year 应该是四位数，为了兼容也接受两位数，例如：98 应该等于1998，强烈建议使用四位数。</li>
<li>month 计数从 0（一月）开始，到 11（十二月）结束。</li>
<li>date 是当月的具体某一天，如果缺失，默认为1。</li>
<li>hours, minutes, seconds, ms 如果缺失默认为0.</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 1 Jan 2011, 00:00:00</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 同样，时分秒等均为默认值 0</span></span><br><span class="line"><span class="comment">// 时间度量精确到1毫秒</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">567</span>);</span><br><span class="line">alert( date ); <span class="comment">// 1.01.2011, 02:03:04.567</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1-3-获取日期组件"><a href="#1-3-获取日期组件" class="headerlink" title="1.3 获取日期组件"></a>1.3 获取日期组件</h3><ul>
<li>getFullYear：从Date对象中获取年（四位数）。</li>
<li>getMonth()：获取月份，从0 到11。</li>
<li>getDate() 获取具体的日期。1 到 31。</li>
<li>getHouers() 获取当天的小时。</li>
<li>getMinutes() 获取分钟。</li>
<li>getSeconds() 获取秒</li>
<li>getMilliseconds() 获取毫秒。</li>
<li>getDay() 获取一周中的第几天， 星期几，从0 到 6， 星期天是0。</li>
<li>getTime() 返回自1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。</li>
<li>getTimezoneOffset() 返回UTC时间与本地时间的误差，以分钟为单位。</li>
</ul>
<h3 id="1-4-设置日期组件"><a href="#1-4-设置日期组件" class="headerlink" title="1.4 设置日期组件"></a>1.4 设置日期组件</h3><ul>
<li>setFullYear(year, [month], [date])</li>
<li>setMonth(month, [date])</li>
<li>setDate(date)</li>
<li>setHours(hour, [min], [sec], [ms])</li>
<li>setMinutes(min, [sec], [ms])</li>
<li>setSeconds(sec, [ms])</li>
<li>setMilliseconds(ms)</li>
<li>setTime(milliseconds)（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）</li>
</ul>
<p>以上方法除了 setTime() 方法，都有UTC变体，例如：setUTCHours()。</p>
<p>其中有的方法接受多个参数，不过不填的话，默认按照当前的时间。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">today.setHours(<span class="number">0</span>);</span><br><span class="line">alert(today); <span class="comment">// 日期依然是今天，但是小时数被改为了 0  2023-02-09T16:53:33.757Z</span></span><br><span class="line"></span><br><span class="line">today.setHours(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">alert(today); <span class="comment">// 日期依然是今天，时间为 00:00:00。 2023-02-09T16:00:00.000Z</span></span><br></pre></td></tr></table></figure>


<h3 id="1-5-自动校准"><a href="#1-5-自动校准" class="headerlink" title="1.5 自动校准"></a>1.5 自动校准</h3><p>Date 的参数超过范围，它本身会自动校准。</p>
<p>假设我们要在日期 “28 Feb 2016” 上加 2 天。结果可能是 “2 Mar” 或 “1 Mar”，因为存在闰年。但是我们不需要考虑这些，只需要直接加 2 天，剩下的 Date 对象会帮我们处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">28</span>);</span><br><span class="line">date.setDate(date.getDate() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">alert( date ); <span class="comment">// 1 Mar 2016</span></span><br></pre></td></tr></table></figure>
<p>这个特性经常获取给定时间段后的时间。</p>
<h3 id="1-6-日期转化为数字，日期差值。"><a href="#1-6-日期转化为数字，日期差值。" class="headerlink" title="1.6 日期转化为数字，日期差值。"></a>1.6 日期转化为数字，日期差值。</h3><p>当Date被转化为数字时， 获取的是时间戳，与getTime()相同，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 使用一元运算符 将Date对象转化为数字 </span></span><br><span class="line">alert(+date);</span><br></pre></td></tr></table></figure>


<p>日期可以相减，结果是以毫秒为单位的时间差，可以用作测试代码的执行速度。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 开始测量时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do the job</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> doSomething = i * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 结束测量时间</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">`The loop took <span class="subst">$&#123;end - start&#125;</span> ms`</span> );</span><br></pre></td></tr></table></figure>


<h3 id="1-7-Date-new"><a href="#1-7-Date-new" class="headerlink" title="1.7 Date.new()"></a>1.7 Date.new()</h3><p>在上文中，创建了两个Date对象，用来计算时间间隔，在JS中还有一个方法Date.new()，他会返回当前时间戳，相等于 new Date().getTime() 但是不会创建中间的Date对象，因此更快，不会对垃圾回收造成额外的压力，所以在使用JS编写游戏或者其他有性能要求的场景会使用到。</p>
<p>因此上文中的 计算代码执行速度这种方式最好：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now(); <span class="comment">// 从 1 Jan 1970 至今的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do the job</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> doSomething = i * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="built_in">Date</span>.now(); <span class="comment">// 完成</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">`The loop took <span class="subst">$&#123;end - start&#125;</span> ms`</span> ); <span class="comment">// 相减的是时间戳，而不是日期</span></span><br></pre></td></tr></table></figure>


<h3 id="1-8-对字符串调用Date-parse"><a href="#1-8-对字符串调用Date-parse" class="headerlink" title="1.8 对字符串调用Date.parse"></a>1.8 对字符串调用Date.parse</h3><p>根据时间字符串获取对应的时间戳，字符串的格式为：YYYY-MM-DDTHH:mm:ss.sssZ，其中：T 是分隔符，Z 为 +- hh:mm 格式的时区，单个字符代表 UTC+0 时区，简短的形式也可以：YYYY，或者是 YYYY-MM-DD 或者YYYY-MM。</p>
<p>Date.parse 返回的结果是时间戳，从 1970-01-01 00:00:00 起所经过的毫秒数，如果给点的字符串不正确，则返回NaN。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(八)</title>
    <url>/2023/02/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AB)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-八"><a href="#JS笔记之JS数据类型-八" class="headerlink" title="JS笔记之JS数据类型(八)"></a>JS笔记之JS数据类型(八)</h1><h2 id="1-JSON-stringify-obj"><a href="#1-JSON-stringify-obj" class="headerlink" title="1 JSON.stringify(obj)"></a>1 JSON.stringify(obj)</h2><p>JSON编码的对象与JS对象的字面量有一些区别：</p>
<ul>
<li>字符串使用双引号，没有单引号或者反引号。</li>
<li>对象的属性名称也是双引号的，是强制性的。</li>
</ul>
<p>JSON支持以下的数据类型：</p>
<ul>
<li>Objects {…}</li>
<li>Arrays […]</li>
<li>Strings ‘ ‘</li>
<li>numbers 1</li>
<li>boolean  true false</li>
<li>null</li>
</ul>
<p>JSON是语言无关的数据规范，所以一些属于JS的对象属性将会被忽略掉，例如：</p>
<ul>
<li>函数</li>
<li>Symbol</li>
<li>undefined</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 被忽略</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>)]: <span class="number">123</span>, <span class="comment">// 被忽略</span></span><br><span class="line">    something: <span class="literal">undefined</span> <span class="comment">// 被忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(user) ); <span class="comment">// &#123;&#125;（空对象）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips：在使用JSON.stringify(obj) 时（仅包含单个参数），对象中不能有循环引用。</strong></p>
</blockquote>
<h2 id="2-排除和转换-replacer"><a href="#2-排除和转换-replacer" class="headerlink" title="2 排除和转换 replacer"></a>2 排除和转换 replacer</h2><p>JSON.stringify 的完整语法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="built_in">JSON</span>.stringify(value[, replacer, space])</span><br><span class="line"></span><br><span class="line"><span class="comment">// value：要编码的值</span></span><br><span class="line"><span class="comment">// reolacer：要编码的属性数组，或者映射函数。 function(key, value)</span></span><br><span class="line"><span class="comment">// sapce：要格式化的空格数量</span></span><br></pre></td></tr></table></figure>
<p>如果要过滤掉循环引用， 可以使用JSON.stringify的第二个参数：replacer，如果我们传递一个属性数组给他，name只有这些属性会被编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">    place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup, [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;participants&#x27;</span>]) );</span><br><span class="line"><span class="comment">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上文的例字中，因为只设置了 participants和title， 所以输出内容中的 participants的下一级为空。</p>
<p>可以使用一个函数来保证转换的数据不包括循环引用的所有属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">    place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="string">&#x27;occupiedBy&#x27;</span>) ? <span class="literal">undefined</span> : value;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// : [object Object]</span></span><br><span class="line"><span class="comment">// title: Conference                                                                       </span></span><br><span class="line"><span class="comment">// participants: [object Object],[object Object]                                           </span></span><br><span class="line"><span class="comment">// 0: [object Object]                                                                     </span></span><br><span class="line"><span class="comment">// name: John                                                                             </span></span><br><span class="line"><span class="comment">// 1: [object Object]                                                                    </span></span><br><span class="line"><span class="comment">// name: Alice                                                                             </span></span><br><span class="line"><span class="comment">// place: [object Object]                                                                 </span></span><br><span class="line"><span class="comment">// number: 23                                                                             </span></span><br><span class="line"><span class="comment">// occupiedBy: [object Object]                                                             </span></span><br><span class="line"><span class="comment">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],&quot;place&quot;:&#123;&quot;number&quot;:23&#125;&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="3-格式化-space"><a href="#3-格式化-space" class="headerlink" title="3 格式化 space"></a>3 格式化 space</h2><p>JSON.stringif 的第三个参数是优化格式的空格数量。也可以是字符串，字符串用于缩进而不是空格的数量。spaces 参数仅用于日志记录和美化输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">    place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(meetup, <span class="literal">null</span>, <span class="string">&quot;====&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// ====&quot;title&quot;: &quot;Conference&quot;,</span></span><br><span class="line"><span class="comment">// ====&quot;participants&quot;: [</span></span><br><span class="line"><span class="comment">// ========&#123;</span></span><br><span class="line"><span class="comment">// ============&quot;name&quot;: &quot;John&quot;</span></span><br><span class="line"><span class="comment">// ========&#125;,</span></span><br><span class="line"><span class="comment">// ========&#123;</span></span><br><span class="line"><span class="comment">// ============&quot;name&quot;: &quot;Alice&quot;</span></span><br><span class="line"><span class="comment">//     ========&#125;</span></span><br><span class="line"><span class="comment">// ====],</span></span><br><span class="line"><span class="comment">// ====&quot;place&quot;: &#123;</span></span><br><span class="line"><span class="comment">// ========&quot;number&quot;: 23</span></span><br><span class="line"><span class="comment">// ====&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="4-自定义-toJson"><a href="#4-自定义-toJson" class="headerlink" title="4 自定义 toJson"></a>4 自定义 toJson</h2><p>toString 可以进行字符串转化， 对象也可以自定义toJson来进行JSON转换，如果可用，JSON.stringify 则会自动调用它。 在Python 输出类的字符串形式， 使用魔术方法<code>__str__</code>和<code>__repr__</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span>,</span><br><span class="line">    <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    room</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(room) ); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup) );</span><br></pre></td></tr></table></figure>
<p>toJson 既可以用于直接调用JSON.stringify， 也可以在嵌套在另一个对象时，被调用。</p>
<h2 id="5-JSON-parse"><a href="#5-JSON-parse" class="headerlink" title="5 JSON.parse"></a>5 JSON.parse</h2><p>将JSON字符串要解码JS对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="built_in">JSON</span>.parse(str, [reviver]);</span><br><span class="line"><span class="comment">// str：要解析的字符串</span></span><br><span class="line"><span class="comment">// reviver：可选的函数参数，函数将每个（key, value）对调用，并可以对值进行转换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userData = <span class="string">&#x27;&#123; &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] &#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(userData);</span><br><span class="line"><span class="built_in">console</span>.log( user.friends[<span class="number">1</span>] ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>


<p>当要解析的字符串包括日期字符串时，JSON.parse 就无法解析，这是我们可以通过第二个参数，定义一个函数来判断key。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> schedule = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">  &quot;meetups&quot;: [</span></span><br><span class="line"><span class="string">    &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&quot;title&quot;:&quot;Birthday&quot;,&quot;date&quot;:&quot;2017-04-18T12:00:00.000Z&quot;&#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line">schedule = <span class="built_in">JSON</span>.parse(schedule, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">&#x27;date&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( schedule.meetups[<span class="number">1</span>].date.getDate() ); <span class="comment">// 正常运行了！</span></span><br></pre></td></tr></table></figure>
<p>函数在嵌套中同样适用。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><ul>
<li>JSON 支持 object，array，string，number，boolean 和 null。</li>
<li>如果独享具有toJson方法，那么会被 JSON.stringify 调用。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(四)</title>
    <url>/2023/02/06/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>



<h1 id="JS笔记之JS数据类型-四"><a href="#JS笔记之JS数据类型-四" class="headerlink" title="JS笔记之JS数据类型(四)"></a>JS笔记之JS数据类型(四)</h1><h2 id="1-可迭代对象定义"><a href="#1-可迭代对象定义" class="headerlink" title="1 可迭代对象定义"></a>1 可迭代对象定义</h2><p>可迭代对象是数组的泛化，任何对象都可以被定制为在 for…of循环使用的对象。</p>
<p>在JS中可迭代的内建对象有很多，例如数组，字符串等。</p>
<h3 id="1-1-创建可迭代对象"><a href="#1-1-创建可迭代对象" class="headerlink" title="1.1 创建可迭代对象"></a>1.1 创建可迭代对象</h3><p>例如我们要让下面的对象，能够使用for…of循环得到下面的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">    to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望得到的结果</span></span><br><span class="line"><span class="comment">// for (let num of range) ... num = 1，2, 3,4，5</span></span><br></pre></td></tr></table></figure>


<p>使用内建方法：Symbol.iterator （一个专门使对象可迭代的内建Symbol） </p>
<ol>
<li>给range对象添加一个属性， 即这个方法Symbol.iterator ，这个方法返回一个迭代器：一个有next方法的对象。</li>
<li>for…of 适用于这个被返回的对象。</li>
<li>当for…of循环，希望取得下一个值的时候，就会调用这个和next方法。</li>
<li>next方法返回的结构必须是{done:Boolean, value:any} 当done为true时，循环结束， 否则value是下一个值。</li>
</ol>
<h3 id="1-2-具体的实现方法："><a href="#1-2-具体的实现方法：" class="headerlink" title="1.2 具体的实现方法："></a>1.2 具体的实现方法：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. for..of 调用首先会调用这个：</span></span><br><span class="line">range[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……它返回迭代器对象（iterator object）：</span></span><br><span class="line">  <span class="comment">// 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    current: <span class="built_in">this</span>.from,</span><br><span class="line">    last: <span class="built_in">this</span>.to,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. next() 在 for..of 的每一轮循环迭代中被调用</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 4. 它将会返回 &#123;done:.., value :...&#125; 格式的对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在它可以运行了！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>range 本身没有next方法。而是通过symbol.iterator 创建了另一个对象，即迭代器对象，并且他的next会为迭代生成值。</p>
</blockquote>
<p><strong>迭代器和要进行迭代的对象是分开的，技术上也可以进行合并。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">this</span>.from;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.to) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 range的Symbol.iterator 属性，返回的是自身，即range有一个next方法属性。</p>
<h3 id="1-3-字符串也是可迭代的"><a href="#1-3-字符串也是可迭代的" class="headerlink" title="1.3 字符串也是可迭代的"></a>1.3 字符串也是可迭代的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&quot;test&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 触发 4 次，每个字符一次</span></span><br><span class="line">  alert( char ); <span class="comment">// t, then e, then s, then t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-显示的调用迭代器"><a href="#1-4-显示的调用迭代器" class="headerlink" title="1.4 显示的调用迭代器"></a>1.4 显示的调用迭代器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 for..of 做相同的事</span></span><br><span class="line"><span class="comment">// for (let char of str) alert(char);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = str[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = iterator.next();</span><br><span class="line">  <span class="keyword">if</span> (result.done) <span class="keyword">break</span>;</span><br><span class="line">  alert(result.value); <span class="comment">// 一个接一个地输出字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中很少这样做，但是这样做自由度更高，我们可以在任意迭代的过程中，暂停，并做一些其他的处理。</p>
<h3 id="1-5-可迭代和类数组-（array-like）"><a href="#1-5-可迭代和类数组-（array-like）" class="headerlink" title="1.5 可迭代和类数组 （array-like）"></a>1.5 可迭代和类数组 （array-like）</h3><p>可迭代：实现了上述 symbol.iterator 方法的对象。</p>
<p>array-like：是有索引和length属性的对象，所以他们看起来像数组。</p>
<p>可迭代对象通常都不是数组，他们没有push和pop方法，如果要将一个可迭代对象转化为数组，要怎么实现？</p>
<h3 id="1-6-array-from"><a href="#1-6-array-from" class="headerlink" title="1.6 array.from"></a>1.6 array.from</h3><p>array.from 接收一个可迭代和类数组的值，并从中获取一个真正的数组，然后对齐调用数组的方法。</p>
<p>array.from 也接收一个可选的函数作为参数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 range 来自上文例子中</span></span><br><span class="line"><span class="comment">// 求每个数的平方</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line">alert(arr); <span class="comment">// 1,4,9,16,25</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 str 拆分为字符数组</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> chars = <span class="built_in">Array</span>.from(str);</span><br><span class="line">alert(chars[<span class="number">0</span>]); <span class="comment">// 𝒳</span></span><br><span class="line">alert(chars[<span class="number">1</span>]); <span class="comment">// 😂</span></span><br><span class="line">alert(chars.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>array.from 相对于str.split() 要精简许多。</p>
<h2 id="2-总结："><a href="#2-总结：" class="headerlink" title="2 总结："></a>2 总结：</h2><p>可迭代对象必须实现symbol.iterator方法。他的结果是一个对象，被称为迭代器，由这个对象的next属性进一步处理迭代过程。</p>
<p>symbol.iterator 由for…of自动调用，但是我们也可以手动调用。</p>
<p>有索引和length属性的兑现我们称之为类数组对象，这种对象可能有其他的方法，但是没有数组的内建方法。</p>
<p>array.from(obj[,mapFn, thisAsg]) 将可迭代对象或者类数组对象转化为真正的数组, 然后我们就可以使用对应的数组方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(五)</title>
    <url>/2023/02/06/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%94)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-五"><a href="#JS笔记之JS数据类型-五" class="headerlink" title="JS笔记之JS数据类型(五)"></a>JS笔记之JS数据类型(五)</h1><h2 id="1-Map"><a href="#1-Map" class="headerlink" title="1 Map"></a>1 Map</h2><p>map 是一个带键的数据项的集合，他和object很像， 但是map允许任意类型的键，而对象的键只能是 字符串和symbol，不管用什么当做对象的key（除了symbol），都会被js转化为字符串。</p>
<h3 id="1-1-方法"><a href="#1-1-方法" class="headerlink" title="1.1 方法"></a>1.1 方法</h3><ul>
<li>new Map() ：创建一个map。</li>
<li>map.set(key, value)：根据键设置值。map在创建时保留了值插入的顺序。</li>
<li>map.get(key)：根据键来返回值，如果不存在key，则返回undefined。</li>
<li>map.has(key)：如果key存在返回true，不存在返回false。</li>
<li>map.delete(key)：删除指定的key。</li>
<li>map.clear()：清空map。</li>
<li>map.size：返回当前元素的个数。</li>
</ul>
<p>在使用map获取key的值或者设置值时 应该使用 map.get() 或者 map.set() 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;str1&#x27;</span>);   <span class="comment">// 字符串键</span></span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">&#x27;num1&#x27;</span>);     <span class="comment">// 数字键</span></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>); <span class="comment">// 布尔值键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 则会保留键的类型，所以下面这两个结果不同：</span></span><br><span class="line">alert( map.get(<span class="number">1</span>)   ); <span class="comment">// &#x27;num1&#x27;</span></span><br><span class="line">alert( map.get(<span class="string">&#x27;1&#x27;</span>) ); <span class="comment">// &#x27;str1&#x27;</span></span><br><span class="line"></span><br><span class="line">alert( map.size ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map 使用对象作为key</span></span><br><span class="line"><span class="keyword">let</span> username = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;john&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> visitsCountMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">visitsCountMap.set(<span class="string">&#x27;john&#x27;</span>, <span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>map比较键的方法：使用sameValueZero算法来比较键是否相等，他和严格等于 === 差不多，但区别是 NaN是等于NaN的，所以NaN也可以被用作键。</p>
<p>map 在设置key的时候返回的是他自身，所以可以被链式调用，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapObj = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">mapObj.set(<span class="string">&#x27;name&#x27;</span>, ‘张三).set(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>).set(<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Map-迭代"><a href="#1-2-Map-迭代" class="headerlink" title="1.2 Map 迭代"></a>1.2 Map 迭代</h3><p>在map里面循环可以使用下面的三个方法：</p>
<ul>
<li><p>map.keys() 遍历并返回一个包含所有键的可迭代对象。</p>
</li>
<li><p>map.values() 遍历并返回一个包含所有值的可迭代对象。</p>
</li>
<li><p>map.entries() 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for…of 在默认情况下才 就是使用的此方法。</p>
</li>
<li><p>map.forEach()  和数组一样，对每个键值对执行一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对每个键值对 (key, value) 运行 forEach 函数</span></span><br><span class="line">recipeMap.forEach( <span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// cucumber: 500 etc</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1-3-将对象转化为Map-gt-Object-entries"><a href="#1-3-将对象转化为Map-gt-Object-entries" class="headerlink" title="1.3 将对象转化为Map -&gt; Object.entries"></a>1.3 将对象转化为Map -&gt; Object.entries</h3><p>当new 一个Map() 对象时，我们可以使用一个带键值对的数组（或者其他的可迭代对象）进行初始化，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键值对 [key, value] 数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>,  <span class="string">&#x27;str1&#x27;</span>],</span><br><span class="line">  [<span class="number">1</span>,    <span class="string">&#x27;num1&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">alert( map.get(<span class="string">&#x27;1&#x27;</span>) ); <span class="comment">// str1</span></span><br></pre></td></tr></table></figure>
<p>如果使用普通的对象来创建map，我们可以使用内建方法 Object.entries(obj)，该方法返回对象的键值对数组。</p>
<h3 id="1-4-将Map转化为建对象-Object-fromEntries-obj"><a href="#1-4-将Map转化为建对象-Object-fromEntries-obj" class="headerlink" title="1.4 将Map转化为建对象 Object.fromEntries(obj)"></a>1.4 将Map转化为建对象 Object.fromEntries(obj)</h3><p>它与 Object.entries(obj)是相反的，给定一个具有[key, value] 的数组，他会根据数组创建一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> prices = <span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 prices = &#123; banana: 1, orange: 2, meat: 4 &#125;</span></span><br><span class="line">alert(prices.orange); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>例如 将一个map的数组转化为一个普通对象传输给第三方的接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map)</span><br></pre></td></tr></table></figure>
<h2 id="2-set"><a href="#2-set" class="headerlink" title="2 set"></a>2 set</h2><p>set 是一个特殊的类型集合 – 值的集合，他没有键，而且他的值只能出现一次。</p>
<h3 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h3><ul>
<li>new Set(iterable)：  创建一个set，如果提供了一个可迭代对象（通常是数组），将会从数组里面复制到set中。有重复的值，自动删除。</li>
<li>set.add(value)：添加一个值返回set 本身，可以像map那样链式调用。</li>
<li>set.delete(value)： 删除值，存在返回true，不存在返回false。</li>
<li>set.has(value)：如果value在set中，返回true，不在返回false。</li>
<li>set.clear()：清空set。</li>
<li>set.size：返回当前元素的个数。</li>
</ul>
<h3 id="2-2-set-迭代"><a href="#2-2-set-迭代" class="headerlink" title="2.2 set 迭代"></a>2.2 set 迭代</h3><p>可以使用for…of 或者 forEach 来迭代set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;oranges&quot;</span>, <span class="string">&quot;apples&quot;</span>, <span class="string">&quot;bananas&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set) alert(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 forEach 相同：</span></span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, valueAgain, set</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在forEach的回调函数中有三个参数， 一个是value，另一个也是 value，最后是目标对象。</p>
<p><strong>在map中的迭代方法在set中同样适用。</strong></p>
<h2 id="3-WeakMap"><a href="#3-WeakMap" class="headerlink" title="3 WeakMap"></a>3 WeakMap</h2><p>在JS中 数组或者对象中的key 或者value，他们都是认为是可达的，如果一个对象被传入数组中，那么我们认为如果这个数组存在，那么这个对象也一定是可达的。在 map 中的 key或者是value 也是同样的道理。</p>
<p>JS垃圾回收中JS引擎在值可达和被可能引用的时候，会将值保存在内存中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象能被访问，john 是它的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖引用</span></span><br><span class="line">john = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象将会被从内存中清除</span></span><br></pre></td></tr></table></figure>
<p>当某个对象作为map的键的时候， 我们也认为改对象是可达的，他会占用内存，且不会被垃圾回收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(john, <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>; <span class="comment">// 覆盖引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// john 被存储在了 map 中，</span></span><br><span class="line"><span class="comment">// 我们可以使用 map.keys() 来获取它，所以他不会被垃圾回收</span></span><br></pre></td></tr></table></figure>
<p>WeakMap 和 Map 的区别</p>
<ul>
<li>在键上的区别<ul>
<li>WeakMap  的键必须是对象，不能是原始值。</li>
</ul>
</li>
<li>方法上的区别<ul>
<li>只支持 has()  get () set() delete() 方法， 不支持 keys() values() entries()</li>
<li>不能迭代。</li>
</ul>
</li>
</ul>
<p>WeakMap  的使用场景主要的使用场景：</p>
<p><strong>额外数据的存储</strong>。</p>
<blockquote>
<p>假如要处理另一些代码的数据，或者是第三方库的数据并且要存储一些相关的数据，那么这时候这些数据就应该和这个对象共存亡。将这些数据存储到WeakMap 中，并使用该对象作为这些数据的键，当改对象对垃圾回收后，这些数据也会被回收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">// 如果 john</span></span><br><span class="line">weakMap.set(john, <span class="string">&#x27;some data&#x27;</span>);</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>做数据缓存</strong></p>
<blockquote>
<p> 可以缓存函数返回的结果，一遍多次电泳不需要重新计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并记结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="comment">/* calculate the result for */</span> obj;</span><br><span class="line">    cache.set(obj, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache.get(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 📁 main.js</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="comment">/* some object */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = process(obj);</span><br><span class="line"><span class="keyword">let</span> result2 = process(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……稍后，我们不再需要这个对象时：</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法获取 cache.size，因为它是一个 WeakMap，</span></span><br><span class="line"><span class="comment">// 要么是 0，或即将变为 0</span></span><br><span class="line"><span class="comment">// 当 obj 被垃圾回收，缓存的数据也会被清除</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="4-WeakSet"><a href="#4-WeakSet" class="headerlink" title="4 WeakSet"></a>4 WeakSet</h2><p>WeakSet 和 Set 的区别</p>
<ul>
<li>WeakSet 的元素只能是对象。</li>
<li>对象只有在其他某个地方能被访问的时候，再能六在 WeakSet中。</li>
<li>只支持add() has() delete() 不支持size和 keys() ，并且不可迭代。</li>
</ul>
<p>weakSet也可以作为额外的空间，但是只能是针对<strong>是/否</strong>的事实。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> visitedSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">visitedSet.add(john); <span class="comment">// John 访问了我们</span></span><br><span class="line">visitedSet.add(pete); <span class="comment">// 然后是 Pete</span></span><br><span class="line">visitedSet.add(john); <span class="comment">// John 再次访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 现在有两个用户了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 John 是否来访过？</span></span><br><span class="line">alert(visitedSet.has(john)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Mary 是否来访过？</span></span><br><span class="line">alert(visitedSet.has(mary)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 将被自动清理(即自动清除其中已失效的值 john)</span></span><br></pre></td></tr></table></figure>


<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><ul>
<li><p>map 是一个带有键的数据的集合。与普通的对象不同的是，他的键可以是任意数据类型。有不同结构的方法，例如：map.size</p>
</li>
<li><p>set 是一组唯一值的集合。</p>
</li>
<li><p>在map和set 迭代总是按照插入的顺序，所以不能说他们的元素是无序的，但也不能对元素重新排序，也不能按照编号来取数据。</p>
</li>
<li><p>WeakMap 类似于Map ，但是只能设置键为对象，并且这些对象一旦在其他地方无法访问，则这个对象就会被垃圾回收，且WeakMap 对应的值也会被删除回收。</p>
</li>
<li><p>WeakSet 类似于Set，但是只能存储对象，并且这些对象一旦在其他地方无法访问，那么也会在WeakSet中删除回收。</p>
</li>
<li><p>WeakMap WeakSet 被用作主要对象存储之外的辅助数据结构。例如缓存的使用场景。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(六)</title>
    <url>/2023/02/06/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AD)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-六"><a href="#JS笔记之JS数据类型-六" class="headerlink" title="JS笔记之JS数据类型(六)"></a>JS笔记之JS数据类型(六)</h1><p>解构赋值是一种特殊的语法，他使可迭代对象拆包值一系列变量中，而只需要其中的一部分（与python的拆包类似）。</p>
<h2 id="1-在数组中的解构"><a href="#1-在数组中的解构" class="headerlink" title="1 在数组中的解构"></a>1 在数组中的解构</h2><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [var1, var2] = arr;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们有一个存放了名字和姓氏的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Smith&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="comment">// 设置 firstName = arr[0]</span></span><br><span class="line"><span class="comment">// 以及 surname = arr[1]</span></span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = arr;</span><br><span class="line"></span><br><span class="line">alert(firstName); <span class="comment">// John</span></span><br><span class="line">alert(surname);  <span class="comment">// Smith</span></span><br></pre></td></tr></table></figure>
<p>当结构语法配合spilt更加优雅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, surname] = <span class="string">&quot;John Smith&quot;</span>.split(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>结构并不意味着破坏，原有的数据对象自身没有被修改。</strong></p>
<h3 id="1-2-忽略使用逗号的元素"><a href="#1-2-忽略使用逗号的元素" class="headerlink" title="1.2 忽略使用逗号的元素"></a>1.2 忽略使用逗号的元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要第二个元素， 剩下的元素也被跳过了。</span></span><br><span class="line"><span class="keyword">let</span> [firstName, , title] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br></pre></td></tr></table></figure>


<h3 id="1-3-解构的元素可以赋值给任何对象"><a href="#1-3-解构的元素可以赋值给任何对象" class="headerlink" title="1.3 解构的元素可以赋值给任何对象"></a>1.3 解构的元素可以赋值给任何对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line">[user.name, user.surname] = <span class="string">&quot;John Smith&quot;</span>.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br><span class="line">alert(user.surname); <span class="comment">// Smith</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：使用解构交换两个变量的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> guest = <span class="string">&quot;Jane&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> admin = <span class="string">&quot;Pete&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让我们来交换变量的值：使得 guest = Pete，admin = Jane</span></span><br><span class="line">[guest, admin] = [admin, guest];</span><br><span class="line"></span><br><span class="line">alert(<span class="string">`<span class="subst">$&#123;guest&#125;</span> <span class="subst">$&#123;admin&#125;</span>`</span>); <span class="comment">// Pete Jane（成功交换！）</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-4-使用-…-解构"><a href="#1-4-使用-…-解构" class="headerlink" title="1.4 使用 … 解构"></a>1.4 使用 … 解构</h3><p>在解构时遇到很多元素，当左边没有右边长时，部分元素作为一个整体进行结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [name1, name2, ...rest] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 是包含从第三项开始的其余数组项的数组</span></span><br><span class="line">alert(rest[<span class="number">0</span>]); <span class="comment">// Consul</span></span><br><span class="line">alert(rest[<span class="number">1</span>]); <span class="comment">// of the Roman Republic</span></span><br><span class="line">alert(rest.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在Python中 是使用<code>*</code>代替<code>...</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name1, name2, *rest = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line">// rest 是包含从第三项开始的其余数组项的数组</span><br><span class="line">print(rest[<span class="number">0</span>]); // Consul</span><br><span class="line">print(rest[<span class="number">1</span>]); // of the Roman Republic</span><br><span class="line">print(<span class="built_in">len</span>(rest)); // <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>当左边比右边长时， 多出的变量名默认为：undefined，也可以手动指定变量的默认值， 默认值可以是更复杂的表达式，或者是一个函数。这些表达式或者函数只有在变量未被赋值的时候在会执行计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, surname] = [];</span><br><span class="line">alert(firstName); <span class="comment">// undefined</span></span><br><span class="line">alert(surname); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定默认值</span></span><br><span class="line"><span class="keyword">let</span> [name = <span class="string">&quot;Guest&quot;</span>, surname = <span class="string">&quot;Anonymous&quot;</span>] = [<span class="string">&quot;Julius&quot;</span>];</span><br><span class="line">alert(name);    <span class="comment">// Julius（来自数组的值）</span></span><br><span class="line">alert(surname); <span class="comment">// Anonymous（默认值被使用了</span></span><br></pre></td></tr></table></figure>


<h2 id="2-在对象中的解构"><a href="#2-在对象中的解构" class="headerlink" title="2 在对象中的解构"></a>2 在对象中的解构</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;var1, var2&#125; = &#123;<span class="attr">var1</span>:…, <span class="attr">var2</span>:…&#125;</span><br><span class="line"><span class="comment">// 在等号右侧是一个已经存在的对象。</span></span><br><span class="line"><span class="comment">// 等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 &#123;...&#125; 中的变量名列表。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;title, width, height&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(width);  <span class="comment">// 100</span></span><br><span class="line">alert(height); <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的属性值 options.title options.width  options.theightitle  被赋值给 title width height</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-在等号左侧的-pattern-可以更加的复杂：指定属性和变量间的关系。"><a href="#2-2-在等号左侧的-pattern-可以更加的复杂：指定属性和变量间的关系。" class="headerlink" title="2.2 在等号左侧的 pattern 可以更加的复杂：指定属性和变量间的关系。"></a>2.2 在等号左侧的 pattern 可以更加的复杂：指定属性和变量间的关系。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果我们想把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么我们可以使用冒号来设置变量名称：</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; sourceProperty: targetVariable &#125;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">widthk</span>: w = <span class="string">&#x27;222&#x27;</span>, <span class="attr">height</span>: h, title&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// width -&gt; w</span></span><br><span class="line"><span class="comment">// height -&gt; h</span></span><br><span class="line"><span class="comment">// title -&gt; title</span></span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(w);      <span class="comment">// 100</span></span><br><span class="line">alert(h);      <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<p>其中冒号的语法是：<code>对象中的某个属性名：具体的变量名</code>，如果<code>对象中的某个属性名</code> 不在要解构的对象中，赋值得到的结果是：undefined。 同样也可以设置默认值，默认值是任意表达式或者函数。</p>
<h3 id="2-3-对象结构对于多余的属性同样可以使用：…"><a href="#2-3-对象结构对于多余的属性同样可以使用：…" class="headerlink" title="2.3 对象结构对于多余的属性同样可以使用：…"></a>2.3 对象结构对于多余的属性同样可以使用：…</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  height: <span class="number">200</span>,</span><br><span class="line">  width: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// title = 名为 title 的属性</span></span><br><span class="line"><span class="comment">// rest = 存有剩余属性的对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;title, ...rest&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 title=&quot;Menu&quot;, rest=&#123;height: 200, width: 100&#125;</span></span><br><span class="line">alert(rest.height);  <span class="comment">// 200</span></span><br><span class="line">alert(rest.width);   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


<p>在解构中如果预先定义了变量， 可能会遇到一些错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一行发生了错误</span></span><br><span class="line">&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>主要的问题是 JS 把主代码流，中的 {…} 当做一个代码块，为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 <code>(...)</code> 包起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在就可以了</span></span><br><span class="line">(&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br><span class="line"></span><br><span class="line">alert( title ); <span class="comment">// Menu</span></span><br></pre></td></tr></table></figure>


<h2 id="3-嵌套解构"><a href="#3-嵌套解构" class="headerlink" title="3 嵌套解构"></a>3 嵌套解构</h2><p>如果一个独享或者数组中包括其他的对象或者数组，可以使用更负责的嵌套解构进行赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  size: &#123;</span><br><span class="line">    width: <span class="number">100</span>,</span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  items: [<span class="string">&quot;Cake&quot;</span>, <span class="string">&quot;Donut&quot;</span>],</span><br><span class="line">  extra: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了清晰起见，解构赋值语句被写成多行的形式</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  size: &#123; <span class="comment">// 把 size 赋值到这里</span></span><br><span class="line">    width,</span><br><span class="line">    height</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [item1, item2], <span class="comment">// 把 items 赋值到这里</span></span><br><span class="line">  title = <span class="string">&quot;Menu&quot;</span> <span class="comment">// 在对象中不存在（使用默认值）</span></span><br><span class="line">&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(width);  <span class="comment">// 100</span></span><br><span class="line">alert(height); <span class="comment">// 200</span></span><br><span class="line">alert(item1);  <span class="comment">// Cake</span></span><br><span class="line">alert(item2);  <span class="comment">// Donu</span></span><br></pre></td></tr></table></figure>


<h2 id="4-智能参数函数"><a href="#4-智能参数函数" class="headerlink" title="4 智能参数函数"></a>4 智能参数函数</h2><p>有时候一个函数有很多的参数，大部分是可选的，我们可以使用一个对象来传递所有的参数，而函数负责把这个对象进行解构为对应的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;My menu&quot;</span>,</span><br><span class="line">  items: [<span class="string">&quot;Item1&quot;</span>, <span class="string">&quot;Item2&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMenu</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  title = <span class="string">&quot;Untitled&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  width: w = <span class="number">100</span>,  <span class="regexp">//</span> width goes to w</span></span></span><br><span class="line"><span class="function"><span class="params">  height: h = <span class="number">200</span>, <span class="regexp">//</span> height goes to h</span></span></span><br><span class="line"><span class="function"><span class="params">  items: [item1, item2] <span class="regexp">//</span> items first element goes to item1, second to item2</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;w&#125;</span> <span class="subst">$&#123;h&#125;</span>`</span> ); <span class="comment">// My Menu 100 200</span></span><br><span class="line">  alert( item1 ); <span class="comment">// Item1</span></span><br><span class="line">  alert( item2 ); <span class="comment">// Item2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMenu(options);</span><br></pre></td></tr></table></figure>
<p>上面输入的参数对象是确定了存在参数，如果想让所有的参数都是用默认值，那么在函数中直接传递一个空对象即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showMenu(&#123;&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMenu</span>(<span class="params">&#123; title = <span class="string">&quot;Menu&quot;</span>, width = <span class="number">100</span>, height = <span class="number">200</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;width&#125;</span> <span class="subst">$&#123;height&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMenu(); <span class="comment">// Menu 100 200</span></span><br></pre></td></tr></table></figure>


<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>解构可以将一个对象或者数组（只要是可迭代对象）拆开赋值到多个变量上。</p>
<p>解构对象的完成语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span> : varName = <span class="keyword">default</span>, ...rest&#125; = object</span><br><span class="line"><span class="comment">// prop：代表对象的key</span></span><br><span class="line"><span class="comment">// varName：要复制的变量名</span></span><br><span class="line"><span class="comment">// default：变量的默认值</span></span><br><span class="line"><span class="comment">// ...rest：其余的属性组成的对象</span></span><br></pre></td></tr></table></figure>
<p>解构数组的完整语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [item1 = <span class="keyword">default</span>, item2, ...rest] = array</span><br><span class="line"></span><br><span class="line"><span class="comment">// item1：数组的第一个元素</span></span><br><span class="line"><span class="comment">// default：默认值</span></span><br><span class="line"><span class="comment">// item2：数组的第二个元素</span></span><br><span class="line"><span class="comment">// ...rest：其余的元素组成的数组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(三)</title>
    <url>/2023/01/31/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%89)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-三"><a href="#JS笔记之JS数据类型-三" class="headerlink" title="JS笔记之JS数据类型(三)"></a>JS笔记之JS数据类型(三)</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h2><p>在JS中数组被定义为：[], 可以存放任意数据类型的元素。</p>
<h3 id="1-1-at"><a href="#1-1-at" class="headerlink" title="1.1 at"></a>1.1 at</h3><p>获取数组最后一个元素，在Python语言中可以使用 list1[-1]，但是JS不可以这样使用，他提供了一个专门的方法：at， 这个方法在旧的浏览器上存在兼容问题。</p>
<p>如果 <code>i &gt;= 0</code> 那么 <code>arr[i]</code> 和 <code>arr.at(i) </code>结果一致。 如果i为负数，<code>arr.at(i)</code> 则从后往前数。</p>
<h3 id="1-2-pop-push-shift-unshift-方法"><a href="#1-2-pop-push-shift-unshift-方法" class="headerlink" title="1.2 pop/push, shift/unshift 方法"></a>1.2 pop/push, shift/unshift 方法</h3><h4 id="1-2-1-作用于数组末端的方法："><a href="#1-2-1-作用于数组末端的方法：" class="headerlink" title="1.2.1 作用于数组末端的方法："></a>1.2.1 作用于数组末端的方法：</h4><p>pop：取出并返回数组的最后一个元素， 和上面的 array.at(-1) 结果一致， 但是，pop()会把最后一个元素删除，原数组被修改。空数组返回undefined。</p>
<p>push：在数组的末端添加元素，与 array[array.length] = “” 结果一致</p>
<h4 id="1-2-2-作用于数组首端的方法："><a href="#1-2-2-作用于数组首端的方法：" class="headerlink" title="1.2.2 作用于数组首端的方法："></a>1.2.2 作用于数组首端的方法：</h4><p>shift：取出数组的第一个元素并返回它。</p>
<p>unshift：在数组的首端添加元素。</p>
<p>unshift 和 push 都可以添加多个元素： <code>unshift(&#39;a&#39;,&#39;b&#39;)</code>、<code>push(&#39;a&#39;,&#39;b&#39;)</code>。</p>
<p>数组的访问方式：array[0], 实际上是来自于对象的语法，它扩展了对象，并提供了特殊的方法，来处理有序结合以及length属性，但是本质上讲数组仍然是一个对象。</p>
<p>例如数组的复制，是通过引用来实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Banana&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = fruits; <span class="comment">// 通过引用复制 (两个变量引用的是相同的数组)</span></span><br><span class="line"></span><br><span class="line">alert( arr === fruits ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="string">&quot;Pear&quot;</span>); <span class="comment">// 通过引用修改数组</span></span><br><span class="line"></span><br><span class="line">alert( fruits ); <span class="comment">// Banana, Pear — 现在有 2 项了</span></span><br></pre></td></tr></table></figure>


<p>但是数组的内部实现是将数组的元素一个一个的存储在连续的内存区域，且针对其优化，使其效率更高。</p>
<p>但是我们在使用数组想使用对象那样的话，数组的优化就不存在了。如下==错误==的使用方法：</p>
<ul>
<li>添加一个非数字的属性：array.test = 3。</li>
<li>制造空洞，比如添加array[0], 然后在添加array[9999]。</li>
<li>以倒叙填充数组 比如：arr[1000], arr[999]。</li>
</ul>
<p>所以在使用数组的时候，将数组作用于有序数组的特殊结构，JS引擎内部经过特殊优化过，如果需要任意值，可能普通对象更合适。</p>
<h3 id="1-3-性能"><a href="#1-3-性能" class="headerlink" title="1.3 性能"></a>1.3 性能</h3><p>pop和push 方法运行的比较快，而shift unshift 运行的比较慢。首先查看四个方法在执行期间都执行了什么？</p>
<p>shift</p>
<ol>
<li><p>第一步从首端取出第一个元素，所以移除了array[0]的元素，</p>
</li>
<li><p>还需要将后面的所有的元素的索引进行重新编号。1 改成0 2 改成 1。</p>
</li>
<li><p>更新数组的属性：length</p>
</li>
</ol>
<p>unshift 也和shift 一样 在array[0] 新增一个元素，修改所有元素的索引值，修改length属性。元素越多，性能越慢。</p>
<p>pop:</p>
<ol>
<li>删除最后一个元素。</li>
</ol>
<p>pop 和 push 一样，不需要移动元素，</p>
<h3 id="1-4-循环"><a href="#1-4-循环" class="headerlink" title="1.4 循环"></a>1.4 循环</h3><p>普通的计数循环可以使用 <code>for (let i=0; i&lt;array.length; i++) &#123;...&#125;</code>，在数组中可以使用<code>for (let x of array) &#123;...&#125;</code>。使用 for…of 不能获取元素得索引 只能获取元素。</p>
<p>还有一种方法：<code>for(let key in array)&#123;...&#125;</code> 虽有效果也是一样的，但是会存在问题：</p>
<ol>
<li>循环会遍历所有属性，不仅仅是数字属性。在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</li>
<li><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。</li>
</ol>
<p><strong>索引遍历数组不推荐使用for…in。</strong></p>
<h3 id="1-5-数组的length"><a href="#1-5-数组的length" class="headerlink" title="1.5 数组的length"></a>1.5 数组的length</h3><p>准确地说数组的length，并不是数组元素得个数，二是数组最大索引加一。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [];</span><br><span class="line">fruits[<span class="number">123</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( fruits.length ); <span class="comment">// 124 输出的结果就输索引值 + 1</span></span><br></pre></td></tr></table></figure>
<p>length的又一特性为 length <strong>是可写的</strong>，但是修改了length以后的数组是不可逆的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">2</span>; <span class="comment">// 截断到只剩 2 个元素</span></span><br><span class="line">alert( arr ); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">5</span>; <span class="comment">// 又把 length 加回来</span></span><br><span class="line">alert( arr[<span class="number">3</span>] ); <span class="comment">// undefined：被截断的那些数值并没有回来</span></span><br></pre></td></tr></table></figure>


<h3 id="1-6-多维数组"><a href="#1-6-多维数组" class="headerlink" title="1.6 多维数组"></a>1.6 多维数组</h3><p>数组里面的项也可以是数组，我们称之为多维数组，可以用来存储矩阵。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> matrix = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>


<h3 id="1-7-toString"><a href="#1-7-toString" class="headerlink" title="1.7 toString"></a>1.7 toString</h3><p>数组的toString会返回以逗号隔开的元素列表。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( [] + <span class="number">1</span> ); <span class="comment">// &quot;1&quot;</span></span><br><span class="line">alert( [<span class="number">1</span>] + <span class="number">1</span> ); <span class="comment">// &quot;11&quot;</span></span><br><span class="line">alert( [<span class="number">1</span>,<span class="number">2</span>] + <span class="number">1</span> ); <span class="comment">// &quot;1,21&quot;</span></span><br><span class="line"><span class="comment">// 这里 [] 就变成了一个空字符串，[1] 变成了 &quot;1&quot;，[1,2] 变成了 &quot;1,2&quot;。</span></span><br></pre></td></tr></table></figure>


<h3 id="1-8-不要使用-比较数组"><a href="#1-8-不要使用-比较数组" class="headerlink" title="1.8 不要使用 == 比较数组"></a>1.8 不要使用 == 比较数组</h3><p>如果我们使用 <code>==</code> 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。</p>
<h2 id="2-数组方法"><a href="#2-数组方法" class="headerlink" title="2 数组方法"></a>2 数组方法</h2><p>前面介绍了 shift/unshift/pop/push等在数组开头结尾添加删除数组方法，还有一些其他的方法</p>
<h3 id="2-1-splice-拼接"><a href="#2-1-splice-拼接" class="headerlink" title="2.1 splice [拼接]"></a>2.1 splice [拼接]</h3><p>splice 可以添加、删除、插入元素</p>
<p>使用 <code>del array[1]</code>的问题是：虽然数组的元素被删除掉了，但是根据array.length 获取数组的长度， 还是原来的长度，使用splice不出出现这个问题。</p>
<p>splice的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// start：从数组的索引 start 开始，删除 deleteCount 个元素，并在当前位置插入 elem1, ..., elemN 最后返回被删除的元素组成的数组。</span></span><br><span class="line">array.splice(start [, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从索引 1 开始删除 1 个元素</span></span><br><span class="line">alert( arr ); <span class="comment">// [&quot;I&quot;, &quot;JavaScript&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;now&quot;</span>];</span><br><span class="line"><span class="comment">// 删除数组的前三项，并使用其他内容代替它们</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Let&#x27;s&quot;</span>, <span class="string">&quot;dance&quot;</span>);</span><br><span class="line">alert( arr ) <span class="comment">// 现在 [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"><span class="comment">// 从索引 2 开始</span></span><br><span class="line"><span class="comment">// 删除 0 个元素</span></span><br><span class="line"><span class="comment">// 然后插入 &quot;complex&quot; 和 &quot;language&quot;</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;complex&quot;</span>, <span class="string">&quot;language&quot;</span>);</span><br><span class="line">alert( arr ); <span class="comment">// &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许负向索引</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 从索引 -1（尾端前一位）</span></span><br><span class="line"><span class="comment">// 删除 0 个元素，</span></span><br><span class="line"><span class="comment">// 然后插入 3 和 4</span></span><br><span class="line">arr.splice(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">alert( arr ); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-slice-切片"><a href="#2-2-slice-切片" class="headerlink" title="2.2 slice [切片]"></a>2.2 slice [切片]</h3><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它返回一个新数组，从索引 start 开始到 end [取头不取尾]  start 和 end 都可以是负数， 和字符串的slice方法一致。</span></span><br><span class="line">arr.slice([start], [end])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>];</span><br><span class="line">alert( arr.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// e,s（复制从位置 1 到位置 3 的元素）</span></span><br><span class="line">alert( arr.slice(-<span class="number">2</span>) ); <span class="comment">// s,t（复制从位置 -2 到尾端的元素）</span></span><br><span class="line"></span><br><span class="line">arr.slice()  <span class="comment">// 创建一个arr副本，以进行不影响原始数组的进一步转换。</span></span><br></pre></td></tr></table></figure>


<h3 id="2-3-concat"><a href="#2-3-concat" class="headerlink" title="2.3 concat"></a>2.3 concat</h3><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收任意数量的参数， 数组或者是值都可以，结果是包含arr和添加的值的数组，如果argN 是数组，那么会复制argN。</span></span><br><span class="line">arr.concat(arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 arr 和 [3,4] 创建一个新数组</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>]) ); <span class="comment">// 1,2,3,4</span></span><br><span class="line"><span class="comment">// 从 arr、[3,4] 和 [5,6] 创建一个新数组</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]) ); <span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line"><span class="comment">// 从 arr、[3,4]、5 和 6 创建一个新数组</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>) ); <span class="comment">// 1,2,3,4,5,6</span></span><br></pre></td></tr></table></figure>


<p>如果某个对象，具有Symbol.isConcatSpreadable属性， 那么concat会把这个对象当做数组一样来处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;else&quot;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat(arrayLike) ); <span class="comment">// 1,2,something,else</span></span><br></pre></td></tr></table></figure>


<h3 id="2-4-forEach-遍历"><a href="#2-4-forEach-遍历" class="headerlink" title="2.4 forEach 遍历"></a>2.4 forEach 遍历</h3><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许数组的每个元素，都运行一个函数, 有结果的话会被忽略。</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do something with item</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对每个元素调用 alert</span></span><br><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].forEach(alert);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 介绍了它们在目标数组中的位置：</span></span><br><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;item&#125;</span> is at index <span class="subst">$&#123;index&#125;</span> in <span class="subst">$&#123;array&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h3 id="2-5-indexOf-lastIndexOf-includes"><a href="#2-5-indexOf-lastIndexOf-includes" class="headerlink" title="2.5 indexOf/lastIndexOf/includes"></a>2.5 indexOf/lastIndexOf/includes</h3><p>在数组中进行搜索</p>
<p>arr.indexOf(item, from)：从索引from开始搜索item, 找到返回索引，找不到返回-1。</p>
<p>arr.includes(item, from)：从索引from开始搜索item, 找到返回true，找不到返回false。</p>
<p>arr.lastIndexOf(item, from)与 indexOf 一样， 但是是从右到左查找。</p>
<p>一般只会传入item, 从头搜索。在搜索进行比较的时候使用的是 严格比较’===’。</p>
<p><strong>indexOf 和 includes 在查找 NaN 的时候 是有区别的，indexOf无法找到NaN，而includes 可以找到。</strong></p>
<p>在数组中查找具有特定条件的对象</p>
<h3 id="2-6-find-findIndex-findLastIndex"><a href="#2-6-find-findIndex-findLastIndex" class="headerlink" title="2.6 find/findIndex/findLastIndex"></a>2.6 find/findIndex/findLastIndex</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// item 是数组中的元素，index 是元素得索引， array 是数组本身</span></span><br><span class="line"><span class="keyword">let</span> ret = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果返回 true，则返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（falsy）的情况，则返回 undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如，我们有一个存储用户的数组，每个用户都有 id 和 name 字段。让我们找到 id == 1 的那个用户：</span></span><br><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>findIndex 和find 有相同的的语法，只不过当找到时，返回的元素的索引。如果没找到返回-1。</p>
<p>findLastIndex 方法类似于 findIndex，但从右向左搜索，类似于 lastIndexOf。</p>
<h3 id="2-7-filter"><a href="#2-7-filter" class="headerlink" title="2.7 filter"></a>2.7 filter</h3><p>find 是查找数组中的符合条件返回true的第一个元素，如果需要匹配的有很多，使用fileter。</p>
<p>语法与find相同，但是filter返回的是匹配元素组成的数组，没找到返回空数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前两个用户的数组</span></span><br><span class="line"><span class="keyword">let</span> someUsers = users.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">alert(someUsers.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>


<h3 id="2-8-map-有用且经常使用"><a href="#2-8-map-有用且经常使用" class="headerlink" title="2.8 map (有用且经常使用)"></a>2.8 map (有用且经常使用)</h3><p>map 他对每个数组都调用函数，并返回结果数组。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lengths = [<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].map(<span class="function"><span class="params">item</span> =&gt;</span> item.length);</span><br><span class="line"><span class="built_in">console</span>.log(lengths); <span class="comment">// 5,7,6</span></span><br></pre></td></tr></table></figure>


<h3 id="2-9-sort-fn"><a href="#2-9-sort-fn" class="headerlink" title="2.9 sort(fn)"></a>2.9 sort(fn)</h3><p>对数组进行原位排序， 在数组内部，而不是生成一个新的数组， 返回排序后的数组。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"><span class="comment">// 该方法重新排列 arr 的内容</span></span><br><span class="line">arr.sort();</span><br><span class="line">alert( arr );  <span class="comment">// 1, 15, 2</span></span><br></pre></td></tr></table></figure>
<p><strong>上面的排序结果是默认进行字符串进行排序的。</strong></p>
<p>比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于数字的比较</span></span><br><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line">arr.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于字符串的比较</span></span><br><span class="line"><span class="keyword">let</span> countries = [<span class="string">&#x27;Österreich&#x27;</span>, <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Vietnam&#x27;</span>];</span><br><span class="line">countries.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b) ) </span><br></pre></td></tr></table></figure>


<h3 id="2-10-reverse"><a href="#2-10-reverse" class="headerlink" title="2.10 reverse"></a>2.10 reverse</h3><p>颠倒数组的元素， 返回颠倒后的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line">alert( arr ); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>


<h3 id="2-11-split和join"><a href="#2-11-split和join" class="headerlink" title="2.11 split和join"></a>2.11 split和join</h3><p>split：将字符串根据特定的字符串分割，并返回组成的数组，split方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拆分字母</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">alert( str.split(<span class="string">&#x27;&#x27;</span>) ); <span class="comment">// t,e,s,t</span></span><br></pre></td></tr></table></figure>
<p>join：与split相反，根据特定的字符将数组的元素组成一个字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Bilbo&#x27;</span>, <span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;Nazgul&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.join(<span class="string">&#x27;;&#x27;</span>); <span class="comment">// 使用分号 ; 将数组粘合成字符串</span></span><br><span class="line">alert( str ); <span class="comment">// Bilbo;Gandalf;Nazgul</span></span><br></pre></td></tr></table></figure>


<h3 id="2-12-reduce-reduceRight"><a href="#2-12-reduce-reduceRight" class="headerlink" title="2.12 reduce/reduceRight"></a>2.12 reduce/reduceRight</h3><p>当我们需要遍历一个数组时，我们可以使用 for/forof/forEach，需要遍历并返回每个元素的数据时，可以使用map， arr.reduce和arr.reduceRught更复杂，用于根据数组计算单个值。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。</span></span><br><span class="line"><span class="comment">// item —— 当前的数组元素。</span></span><br><span class="line"><span class="comment">// index —— 当前索引。</span></span><br><span class="line"><span class="comment">// arr —— 数组本身。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, [initial]);</span><br></pre></td></tr></table></figure>
<p>应用函数时，上一个函数的调用结果，将作为参数传递给下一个函数。如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。<strong>建议始终指定初始值。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line">alert(result); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、在第一次运行时，sum 的值为初始值 initial（reduce 的最后一个参数），等于 0，current 是第一个数组元素，等于 1。所以函数运行的结果是 1。</span></span><br><span class="line"><span class="comment">// 2、在第二次运行时，sum = 1，我们将第二个数组元素（2）与其相加并返回。</span></span><br><span class="line"><span class="comment">// 3、在第三次运行中，sum = 3，我们继续把下一个元素与其相加，以此类推……</span></span><br></pre></td></tr></table></figure>
<p>reduceRight 和 reduce 一样，只是总右到左。</p>
<h3 id="2-13-Array-isArray"><a href="#2-13-Array-isArray" class="headerlink" title="2.13 Array.isArray"></a>2.13 Array.isArray</h3><p>数组是基于对象的，所以不能使用 typeOf 准确地判断类型。因此有一种特殊的方法，用来判断数组是一个数组：Array.isArray(value)。如果value是数组则返回true，否则返回false。</p>
<h3 id="2-14-thisArg"><a href="#2-14-thisArg" class="headerlink" title="2.14 thisArg"></a>2.14 thisArg</h3><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.find(func, thisArg);</span><br><span class="line">arr.filter(func, thisArg);</span><br><span class="line">arr.map(func, thisArg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// thisArg 是可选的最后一个参数</span></span><br></pre></td></tr></table></figure>


<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><h3 id="3-1-添加删除元素"><a href="#3-1-添加删除元素" class="headerlink" title="3.1 添加删除元素"></a>3.1 添加删除元素</h3><p>push(…items)  向尾端添加 items </p>
<p>pop()   从尾端删除元素</p>
<p>shift()   在首部删除元素</p>
<p>unshift(…items)  在首部添加 items</p>
<p>splice(pos, deleteCount, …items) 从pos删除deleteCount并插入items</p>
<p>slice(start, end)  返回一个新数组，返回从start开始到end结束的数组，但不包括end。</p>
<p>concat(…items) 返回一个新数组，参数如果是数组，则将数组拷贝过来，如果不是数组，直接添加。</p>
<h3 id="3-2-搜索元素"><a href="#3-2-搜索元素" class="headerlink" title="3.2 搜索元素"></a>3.2 搜索元素</h3><p>indexOf/lastIndoxOf(items, pos)  从pos索引位置开始判断数组中是否含有items, 有返回items索引，没有返回-1。</p>
<p>includes(value) 如果数组有value，则返回true，否则返回 false。</p>
<p>find/fliter(func) 通过方法过滤元素。返回使 func 返回 true 的第一个值/所有值。。</p>
<p>findIndex 返回索引值。</p>
<h3 id="3-3-遍历元素"><a href="#3-3-遍历元素" class="headerlink" title="3.3 遍历元素"></a>3.3 遍历元素</h3><p>forEach(func)  对每个元素都调用func。</p>
<h3 id="3-4-转换数组"><a href="#3-4-转换数组" class="headerlink" title="3.4 转换数组"></a>3.4 转换数组</h3><p>map(func)  根据每个元素调用func的返回的结果创建一个新数组。</p>
<p>sort(func) 对数组进行原位排序， 然后返回他。</p>
<p>reverse() 原位（in-place）反转数组，然后返回它。</p>
<p>split/join  将字符串转换为数组并返回/ 将数组转化为字符串并返回。</p>
<p>reduce/reduceRight(func, initial)   对每个元素执行方法，并将前一个元素作为函数的参数。</p>
<h3 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h3><p>Array.isArray(value) 判断value是否为数组， 是返回true不是返回false</p>
<p>sort、reverse、splice 都是对数组本身操作，不会产生新的数组。</p>
<p>some(func)/every(func) 对数组的每个元素调用func,如果为任何/所有结果true，返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较数组是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraysEqual</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.length === arr2.length &amp;&amp; arr1.every(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value === arr2[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( arraysEqual([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>fill(value， start, end)  从索引start到end用重复的value 填充数组。</p>
<p>copyWithin(target, start, end) 将从位置 start 到 end 的所有元素复制到 自身 的 target 位置（覆盖现有元素）。</p>
<p>arr.flat(depth)/arr.flatMap(fn) 从多维数组创建一个新的扁平数组。</p>
<p>of(element0[,element1[,elementN]]) 基于可变数量的参数创建一个新的 Array 实例，而不需要考虑参数的数量或类型。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python第三方包Dynaconf</title>
    <url>/2023/01/30/Python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85Dynaconf/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="Python第三方包Dynaconf的使用"><a href="#Python第三方包Dynaconf的使用" class="headerlink" title="Python第三方包Dynaconf的使用"></a>Python第三方包Dynaconf的使用</h1><p>不管开发什么项目，我们总会遇到不同的环境下有着不同的配置信息，对于这些配置有应用相关的信息，同时也会有一些比较隐私的配置，比如MySQL或者Redis的账号密码等等。</p>
<h2 id="1-项目中常用的配置方式"><a href="#1-项目中常用的配置方式" class="headerlink" title="1 项目中常用的配置方式"></a>1 项目中常用的配置方式</h2><ul>
<li><p>类似flask中的app.config可以加载类的模式读取配置信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">    LOG_LEVEL = logging.DEBUG</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProdConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    LOG_LEVEL = logging.INFO</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>或者使用python-dotenv， 从.env 中加载配置信息，且是遵循了<a href="https://12factor.net/config">12-factor application</a>原则。具体配置不在赘述。</p>
</li>
<li><p>使用Dynaconf， Dynaconf同样是受到了<a href="https://12factor.net/config">12-factor application</a>的启发，但是相对于dotenv 提供了多种不同的配置方式。并且可以兼容python-dotenv。</p>
</li>
</ul>
<h2 id="2-Dynaconf的基础用法"><a href="#2-Dynaconf的基础用法" class="headerlink" title="2 Dynaconf的基础用法"></a>2 Dynaconf的基础用法</h2><p><a href="https://www.dynaconf.com/">Dynaconf</a>的Slogan就是**<em>Configuration Management for Python.**</em></p>
<h3 id="2-1-Dynaconf的基本特征-内容来自官网-："><a href="#2-1-Dynaconf的基本特征-内容来自官网-：" class="headerlink" title="2.1 Dynaconf的基本特征(内容来自官网)："></a>2.1 Dynaconf的基本特征(内容来自官网)：</h3><ul>
<li>受到了<a href="https://12factor.net/config">12-factor application</a>的启发。</li>
<li>设置管理（默认值、验证、解析、模板）。</li>
<li>多种文件格式（toml、yaml、json、ini、py）。</li>
<li>支持环境变量覆盖，支持dotenv。</li>
<li>可以用于多环境。（default, development, testing, production）。</li>
<li>内置支持 Hashicorp Vault 和 Redis 作为设置和秘密存储。</li>
<li><strong>Django</strong>和<strong>Flask</strong>网络框架的内置扩展。</li>
<li>常见操作的 CLI，例如<code>init, list, write, validate, export</code>。</li>
</ul>
<h3 id="2-2-Dynaconf安装"><a href="#2-2-Dynaconf安装" class="headerlink" title="2.2 Dynaconf安装"></a>2.2 Dynaconf安装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install dynaconf</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Dynaconf初始化"><a href="#2-3-Dynaconf初始化" class="headerlink" title="2.3 Dynaconf初始化"></a>2.3 Dynaconf初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移动到项目根目录下</span></span><br><span class="line">cd your/project/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化dynaconf相关配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dynaconf 支持多种文件，默认使用toml格式，也可以指定其他的格式（在Django）项目中建议使用yaml格式。</span></span><br><span class="line">dynaconf init -f toml</span><br></pre></td></tr></table></figure>
<p>正常输出如下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">⚙️  Configuring your Dynaconf environment</span><br><span class="line">------------------------------------------</span><br><span class="line">🐍 The file `config.py` was generated.</span><br><span class="line">  on your code now use `from config import settings`.</span><br><span class="line">  (you must have `config` importable in your PYTHONPATH).</span><br><span class="line"></span><br><span class="line">🎛️  settings.toml created to hold your settings.</span><br><span class="line"></span><br><span class="line">🔑 .secrets.toml created to hold your secrets.</span><br><span class="line"></span><br><span class="line">🙈 the .secrets.toml is also included in `.gitignore`</span><br><span class="line">  beware to not push your secrets to a public repo</span><br><span class="line">  or use dynaconf builtin support for Vault Servers.</span><br><span class="line"></span><br><span class="line">🎉 Dynaconf is configured! read more on https://dynaconf.com</span><br><span class="line">   Use `dynaconf -i config.settings list` to see your settings</span><br></pre></td></tr></table></figure>
<p>在项目文件夹中生成了如下四个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    目录: D:\Chaizz\Project\Python\dyna</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/1/30     15:12                __pycache__</span><br><span class="line">-a----         2023/1/30     15:12             46 .gitignore</span><br><span class="line">-a----         2023/1/30     15:12              0 .secrets.toml</span><br><span class="line">-a----         2023/1/30     15:12            270 config.py</span><br><span class="line">-a----         2023/1/30     15:12              0 settings.toml</span><br></pre></td></tr></table></figure>
<p>.gitignore      ：上传到代码仓库标记需要忽略的文件</p>
<p>.secrets.toml   ：存放隐私配置</p>
<p>config.py       ：实例化Dynaconf 对象</p>
<p>settings.toml   ：项目的常规配置</p>
<h3 id="2-4-在python中使用示例"><a href="#2-4-在python中使用示例" class="headerlink" title="2.4 在python中使用示例"></a>2.4 在python中使用示例</h3><p>config.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> Dynaconf, Validator</span><br><span class="line"></span><br><span class="line">settings = Dynaconf(</span><br><span class="line">    <span class="comment"># 取消 Dynaconf 的前缀</span></span><br><span class="line">    envvar_prefix=<span class="literal">False</span>,</span><br><span class="line">    <span class="comment"># 指定包含配置的文件</span></span><br><span class="line">    settings_files=[<span class="string">&#x27;settings.toml&#x27;</span>, <span class="string">&#x27;.secrets.toml&#x27;</span>],</span><br><span class="line">    <span class="comment"># 启用分层环境，即下文中的 dev、test、prod</span></span><br><span class="line">    environments=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># 自定义验证器</span></span><br><span class="line">    validators=[</span><br><span class="line">        <span class="comment"># 确保某些参数存在（必需）</span></span><br><span class="line">        Validator(<span class="string">&#x27;VERSION&#x27;</span>, must_exist=<span class="literal">True</span>),</span><br><span class="line">        <span class="comment"># 确保变量的类型， 为特定的类型</span></span><br><span class="line">        Validator(<span class="string">&#x27;MYSQL_PORT&#x27;</span>, is_type_of=<span class="built_in">int</span>),</span><br><span class="line">        <span class="comment"># 确保某些参数不存在</span></span><br><span class="line">        Validator(<span class="string">&#x27;PASSWORD&#x27;</span>, must_exist=<span class="literal">False</span>),</span><br><span class="line">        <span class="comment"># 保证参数满足一些条件</span></span><br><span class="line">        <span class="comment"># conditions: (eq, ne, lt, gt, lte, gte, identity, is_type_of, is_in, is_not_in)</span></span><br><span class="line">        Validator(<span class="string">&#x27;AGE&#x27;</span>, lte=<span class="number">30</span>, gte=<span class="number">10</span>),</span><br><span class="line">        <span class="comment"># 在某个环境中确保一些参数等于某个值</span></span><br><span class="line">        Validator(<span class="string">&#x27;PROJECT&#x27;</span>, eq=<span class="string">&#x27;hello_world&#x27;</span>, env=<span class="string">&#x27;prod&#x27;</span>),</span><br><span class="line">        <span class="comment"># 保证参数（字符串）满足一些条件</span></span><br><span class="line">        <span class="comment"># conditions: (len_eq, len_ne, len_min, len_max, cont)</span></span><br><span class="line">        <span class="comment"># 确定值的最小最大长度</span></span><br><span class="line">        Validator(<span class="string">&quot;NAME&quot;</span>, len_min=<span class="number">3</span>, len_max=<span class="number">125</span>),</span><br><span class="line">        <span class="comment"># 确保，字符串在集合中存在</span></span><br><span class="line">        Validator(<span class="string">&quot;DEV_SERVERS&quot;</span>, cont=<span class="string">&#x27;localhost&#x27;</span>),</span><br><span class="line">        <span class="comment"># 确保参数的长度和定义的长度相等</span></span><br><span class="line">        Validator(<span class="string">&quot;PORT&quot;</span>, len_eq=<span class="number">4</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>settings.toml</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="comment"># 当 Dynaconf的属性：environments 为True，default 为默认属性。</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">15</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[dev]</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">190</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[test]</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">150</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[prod]</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">PROJECT</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br></pre></td></tr></table></figure>
<p>.secrets.toml</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="comment"># 当 Dynaconf的属性：environments 为True，default 为默认属性。</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[dev]</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;1.1.1.1&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;PASSWORD&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;database&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[test]</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;22222222&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;database&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[prod]</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;333333333333&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;prod&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;database&quot;</span></span><br></pre></td></tr></table></figure>


<p>在上面的toml文件中：dev、test、prod 代表不同的开发环境下的不同的配置信息，需要在系统环境变量中设置 <code>export ENV_FOR_DYNACONF = dev|test|prod</code> 。</p>
<p>default是当Dynaconf的属性environments为True时, 设置的默认值。</p>
<p><strong>在不同的开发环境之间切换只需要在环境变量中设置<code>ENV_FOR_DYNACONF</code>的值即可。</strong></p>
<h2 id="3-Dynaconf的高级用法"><a href="#3-Dynaconf的高级用法" class="headerlink" title="3 Dynaconf的高级用法"></a>3 Dynaconf的高级用法</h2><h3 id="3-1-hooks：需要根据先前加载的设置，有条件地加载数据。"><a href="#3-1-hooks：需要根据先前加载的设置，有条件地加载数据。" class="headerlink" title="3.1 hooks：需要根据先前加载的设置，有条件地加载数据。"></a>3.1 hooks：需要根据先前加载的设置，有条件地加载数据。</h3><h3 id="3-2-PrefixFilter：根据前缀过滤"><a href="#3-2-PrefixFilter：根据前缀过滤" class="headerlink" title="3.2 PrefixFilter：根据前缀过滤"></a>3.2 PrefixFilter：根据前缀过滤</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> Dynaconf</span><br><span class="line"><span class="keyword">from</span> dynaconf.strategies.filtering <span class="keyword">import</span> PrefixFilter</span><br><span class="line"></span><br><span class="line">settings = Dynaconf(</span><br><span class="line">    settings_file=<span class="string">&quot;settings.toml&quot;</span>,</span><br><span class="line">    environments=<span class="literal">False</span></span><br><span class="line">    <span class="comment"># 初始化Dynaconf时，添加过滤条件，仅加载前缀为prefix_开头的配置。</span></span><br><span class="line">    filter_strategy=PrefixFilter(<span class="string">&quot;prefix&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="3-3-切换工作环境"><a href="#3-3-切换工作环境" class="headerlink" title="3.3 切换工作环境"></a>3.3 切换工作环境</h3><h4 id="3-3-1-from-env：返回指定环境的配置"><a href="#3-3-1-from-env：返回指定环境的配置" class="headerlink" title="3.3.1 from_env：返回指定环境的配置"></a>3.3.1 from_env：返回指定环境的配置</h4><p>在配置文件 srttings.toml 中有如下配置。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[development]</span></span><br><span class="line"><span class="attr">message</span> = <span class="string">&#x27;This is in dev&#x27;</span></span><br><span class="line"><span class="attr">foo</span> = <span class="number">1</span></span><br><span class="line"><span class="section">[other]</span></span><br><span class="line"><span class="attr">message</span> = <span class="string">&#x27;this is in other env&#x27;</span></span><br><span class="line"><span class="attr">bar</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在正常使用时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.MESSAGE)</span><br><span class="line"><span class="string">&#x27;This is in dev&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.FOO)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.BAR)</span><br><span class="line">AttributeError: settings <span class="built_in">object</span> has no attribute <span class="string">&#x27;BAR&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后你可以使用<code>from_env</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.from_env(<span class="string">&#x27;other&#x27;</span>).MESSAGE)</span><br><span class="line"><span class="string">&#x27;This is in other env&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.from_env(<span class="string">&#x27;other&#x27;</span>).BAR)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.from_env(<span class="string">&#x27;other&#x27;</span>).FOO)</span><br><span class="line">AttributeError: settings <span class="built_in">object</span> has no attribute <span class="string">&#x27;FOO&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也可以分别获取不同的环境下配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">development_settings = settings.from_env(<span class="string">&#x27;development&#x27;</span>)</span><br><span class="line">other_settings = settings.from_env(<span class="string">&#x27;other&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="3-3-2-setenv：在原地更改配置。"><a href="#3-3-2-setenv：在原地更改配置。" class="headerlink" title="3.3.2 setenv：在原地更改配置。"></a>3.3.2 setenv：在原地更改配置。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">settings.setenv(<span class="string">&#x27;other&#x27;</span>)</span><br><span class="line"><span class="comment"># 将当前的环境更改为 other 环境</span></span><br><span class="line"><span class="keyword">assert</span> settings.MESSAGE == <span class="string">&#x27;This is in other env&#x27;</span></span><br><span class="line"></span><br><span class="line">settings.setenv()</span><br><span class="line"><span class="comment"># 将当前环境返回到先前的环境</span></span><br></pre></td></tr></table></figure>


<h4 id="3-3-3-using-env：使用上下文管理器切换环境"><a href="#3-3-3-using-env：使用上下文管理器切换环境" class="headerlink" title="3.3.3 using_env：使用上下文管理器切换环境"></a>3.3.3 using_env：使用上下文管理器切换环境</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> settings.using_env(<span class="string">&#x27;other&#x27;</span>):</span><br><span class="line">    <span class="comment"># 在上下文管理器之内，切换为选择的环境</span></span><br><span class="line">    <span class="keyword">assert</span> settings.MESSAGE == <span class="string">&#x27;This is in other env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在上下文管理器之外，还是默认的环境</span></span><br><span class="line"><span class="keyword">assert</span> settings.MESSAGE == <span class="string">&#x27;This is in dev&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="3-4-导出配置信息"><a href="#3-4-导出配置信息" class="headerlink" title="3.4 导出配置信息"></a>3.4 导出配置信息</h3><ol>
<li><p>使用命令导出 <code>dynaconf list -o /path/to/file.yaml|toml|ini|json|py</code></p>
</li>
<li><p>使用代码导出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> loaders</span><br><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> dynaconf.utils.boxing <span class="keyword">import</span> DynaBox</span><br><span class="line"></span><br><span class="line"><span class="comment"># generates a dict with all the keys for `development` env</span></span><br><span class="line">data = settings.as_dict(env=<span class="string">&#x27;development&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># writes to a file, the format is inferred by extension</span></span><br><span class="line"><span class="comment"># can be .yaml, .toml, .ini, .json, .py</span></span><br><span class="line">loaders.write(<span class="string">&#x27;../file.json&#x27;</span>, DynaBox(data).to_dict(), env=<span class="string">&#x27;development&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-Dynaconf的详细配置"><a href="#4-Dynaconf的详细配置" class="headerlink" title="4 Dynaconf的详细配置"></a>4 Dynaconf的详细配置</h2></li>
</ol>
<p><a href="https://www.dynaconf.com/configuration/">Dynaconfg详细配置</a></p>
]]></content>
      <categories>
        <category>Dynaconf</category>
      </categories>
      <tags>
        <tag>Dynaconf</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(二)</title>
    <url>/2023/01/29/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>



<p>JS笔记之JS数据类型(二)</p>
<p>字符串</p>
<p>在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。 字符串是不可变的。</p>
<p>字符串的内部格式始终是 <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>，它不依赖于页面编码。</p>
<p>引号</p>
<p>在字符串中有三种引号，单引号和双引号基本相同。但是，反引号允许我们通过 <code>$&#123;…&#125;</code> 将任何表达式嵌入到字符串中。 使用反引号允许字符串跨行。</p>
<p>反引号还允许我们在第一个反引号之前指定一个“模版函数”。语法是：<code>func</code>string``。函数 <code>func</code> 被自动调用，接收字符串和嵌入式表达式，并处理它们。你可以在 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals">docs</a> 中阅读更多关于它们的信息。这叫做 “tagged templates”。此功能可以更轻松地将字符串包装到自定义模版或其他函数中，但这很少使用。</p>
<p>特殊字符</p>
<p>在上述的反引号能够换行，特殊字符也可以达到目的。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\n</code></td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">在 Windows 文本文件中，两个字符 <code>\r\n</code> 的组合代表一个换行。而在非 Windows 操作系统上，它就是 <code>\n</code>。这是历史原因造成的，大多数的 Windows 软件也理解 <code>\n</code>。</td>
</tr>
<tr>
<td align="left"><code>\&#39;</code>, <code>\&quot;</code></td>
<td align="left">引号</td>
</tr>
<tr>
<td align="left"><code>\\</code></td>
<td align="left">反斜线</td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left"><code>\b</code>, <code>\f</code>, <code>\v</code></td>
<td align="left">退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。</td>
</tr>
<tr>
<td align="left"><code>\xXX</code></td>
<td align="left">具有给定十六进制 Unicode <code>XX</code> 的 Unicode 字符，例如：<code>&#39;\x7A&#39;</code> 和 <code>&#39;z&#39;</code> 相同。</td>
</tr>
<tr>
<td align="left"><code>\uXXXX</code></td>
<td align="left">以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 Unicode 字符，例如 <code>\u00A9</code> —— 是版权符号 <code>©</code> 的 Unicode。它必须正好是 4 个十六进制数字。</td>
</tr>
<tr>
<td align="left"><code>\u&#123;X…XXXXXX&#125;</code>（1 到 6 个十六进制字符）</td>
<td align="left">具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&quot;\u00A9&quot;</span> ); <span class="comment">// ©</span></span><br><span class="line">alert( <span class="string">&quot;\u&#123;20331&#125;&quot;</span> ); <span class="comment">// 佫，罕见的中国象形文字（长 Unicode）</span></span><br><span class="line">alert( <span class="string">&quot;\u&#123;1F60D&#125;&quot;</span> ); <span class="comment">// 😍，笑脸符号（另一个长 Unicode）</span></span><br></pre></td></tr></table></figure>
<p>反斜杠 <code>\</code> 在 JavaScript 中用于正确读取字符串，然后消失。内存中的字符串没有 <code>\</code>。</p>
<p>length 字符串长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="string">`My\n`</span>.length ); <span class="comment">// 3  \n 是一个单独的“特殊”字符，所以长度确实是 3。</span></span><br></pre></td></tr></table></figure>
<p>length 是一个属性。</p>
<p>访问字符</p>
<p>要获取在pos位置的一个字符，可以使用<code>[]</code> 或者调用<code>str.charAt(pos)</code>，第一个字符串位置从0开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Hello`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个字符</span></span><br><span class="line">alert( str[<span class="number">0</span>] ); <span class="comment">// H</span></span><br><span class="line">alert( str.charAt(<span class="number">0</span>) ); <span class="comment">// H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个字符</span></span><br><span class="line">alert( str[str.length - <span class="number">1</span>] ); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>方括号是获取字符的一种现代化方法，而 <code>charAt</code> 是历史原因才存在的。</p>
<p>它们之间的唯一区别是，如果没有找到字符，<code>[]</code>返回 <code>undefined</code>，而 <code>charAt</code> 返回一个空字符串 ‘’</p>
<p>也可以使用for..of 遍历字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">  alert(char); <span class="comment">// H,e,l,l,o（char 变为 &quot;H&quot;，然后是 &quot;e&quot;，然后是 &quot;l&quot; 等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>字符串常用方法：</p>
<ul>
<li><p><strong>改变大小写</strong>：<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase">toLowerCase()</a> 和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">toUpperCase()</a>。</p>
</li>
<li><p><strong>查找子字符串</strong>：<a href="https://zh.javascript.info/string#strindexof">str.indexOf(substr, pos)</a>，它从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code>，如果没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。 pos 允许我们从指定位置查找。**str.lastIndexOf(substr, pos)**：它从字符串的末尾开始搜索到开头，它会以相反的顺序列出这些事件。</p>
<p>在if 中使用 indexOf ， 应该判断是否不等于 -1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Widget with id&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str.indexOf(<span class="string">&quot;Widget&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">    alert(<span class="string">&quot;We found it&quot;</span>); <span class="comment">// 现在工作了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><a href="https://zh.javascript.info/string#an-wei-bitwisenot-ji-qiao">按位（bitwise）NOT 技巧</a></p>
<p>这里使用的一个老技巧是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">bitwise NOT</a> <code>~</code> 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。</p>
<p>实际上，这意味着一件很简单的事儿：对于 32-bit 整数，<code>~n</code> 等于 <code>-(n+1)</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( ~<span class="number">2</span> ); <span class="comment">// -3，和 -(2+1) 相同</span></span><br><span class="line">alert( ~<span class="number">1</span> ); <span class="comment">// -2，和 -(1+1) 相同</span></span><br><span class="line">alert( ~<span class="number">0</span> ); <span class="comment">// -1，和 -(0+1) 相同</span></span><br><span class="line">alert( ~-<span class="number">1</span> ); <span class="comment">// 0，和 -(-1+1) 相同</span></span><br></pre></td></tr></table></figure>
<p>正如我们看到这样，只有当 <code>n == -1</code> 时，<code>~n</code> 才为零（适用于任何 32-bit 带符号的整数 <code>n</code>）。</p>
<p>因此，仅当 <code>indexOf</code> 的结果不是 <code>-1</code> 时，检查 <code>if ( ~str.indexOf(&quot;...&quot;) )</code> 才为真。换句话说，当有匹配时。</p>
<p>人们用它来简写 <code>indexOf</code> 检查：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Widget&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">&quot;Widget&quot;</span>)) &#123;</span><br><span class="line">  alert( <span class="string">&#x27;Found it!&#x27;</span> ); <span class="comment">// 正常运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要记住：<code>if (~str.indexOf(...))</code> 读作 “if found”。</p>
<p>确切地说，由于 <code>~</code> 运算符将大数字截断为 32 位，因此存在给出 <code>0</code> 的其他数字，最小的数字是 <code>~4294967295=0</code>。这使得这种检查只有在字符串没有那么长的情况下才是正确的。</p>
<p>现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 <code>.includes</code> 方法（见下文）。</p>
<p>includes，startsWith，endsWith</p>
<p>str.includes(substr, pos) 根据str 中是否包含 substr 来返回true或者false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测匹配，但不需要它的位置</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Widget with id&quot;</span>.includes(<span class="string">&quot;Widget&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Hello&quot;</span>.includes(<span class="string">&quot;Bye&quot;</span>) ); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 第二个参数也是查询的起始位置</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Widget&quot;</span>.includes(<span class="string">&quot;id&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Widget&quot;</span>.includes(<span class="string">&quot;id&quot;</span>, <span class="number">3</span>) ); <span class="comment">// false, 从位置 3 开始没有 &quot;id&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&quot;Widget&quot;</span>.startsWith(<span class="string">&quot;Wid&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span></span><br><span class="line">alert( <span class="string">&quot;Widget&quot;</span>.endsWith(<span class="string">&quot;get&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span></span><br></pre></td></tr></table></figure>


<p>获取子字符串</p>
<p>JS中有三种获取子字符串的方法， substring、substr、slice</p>
<p>str.slice(start [, end])：返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。如果没有第二个参数，<code>slice</code> 会一直运行到字符串末尾。<code>start/end</code> 也有可能是负值。它们的意思是起始位置从字符串结尾计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右边的第四个位置开始，在右边的第一个位置结束</span></span><br><span class="line">alert( str.slice(-<span class="number">4</span>, -<span class="number">1</span>) ); <span class="comment">// &#x27;gif&#x27;</span></span><br></pre></td></tr></table></figure>
<p>str.substring(start [, end])：返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。这与 <code>slice</code> 几乎相同，但它允许 <code>start</code> 大于 <code>end</code>。不支持负参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些对于 substring 是相同的</span></span><br><span class="line">alert( str.substring(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……但对 slice 是不同的：</span></span><br><span class="line">alert( str.slice(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;（一样）</span></span><br><span class="line">alert( str.slice(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;&quot;（空字符串）</span></span><br></pre></td></tr></table></figure>
<p>str.substr(start [, length])：返回字符串从 <code>start</code> 开始的给定 <code>length</code> 的部分。</p>
<p>与以前的方法相比，这个允许我们指定 <code>length</code> 而不是**==结束位置==**：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.substr(<span class="number">2</span>, <span class="number">4</span>) ); <span class="comment">// &#x27;ring&#x27;，从位置 2 开始，获取 4 个字符</span></span><br></pre></td></tr></table></figure>
<p>具体使用哪一个？ </p>
<blockquote>
<p>   它们都可用于获取子字符串。正式一点来讲，<code>substr</code> 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中。附录 B 的内容主要是描述因历史原因而遗留下来的仅浏览器特性。因此，理论上非浏览器环境可能无法支持 <code>substr</code>，但实际上它在别的地方也都能用。</p>
<p>相较于其他两个变体，<code>slice</code> 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 <code>slice</code> 就足够了。</p>
</blockquote>
<p>比较字符串</p>
<p>字符串的比较按照字母的顺序逐字比较，但是有特殊情况：</p>
<ol>
<li><p>小写字母总是大于大写字母。<code>console.log( &#39;a&#39; &gt; &#39;Z&#39; ); // true</code></p>
</li>
<li><p>带变音符号的字母存在“乱序”的情况。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&#x27;Österreich&#x27;</span> &gt; <span class="string">&#x27;Zealand&#x27;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>为什么会出现乱序？</p>
<p>在JS中所有的字符串都使用 <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。str.codePointAt(pos) 返回在 <code>pos</code> 位置的字符代码 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同的字母有不同的代码</span></span><br><span class="line">alert( <span class="string">&quot;z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 122</span></span><br><span class="line">alert( <span class="string">&quot;Z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 90</span></span><br></pre></td></tr></table></figure>








































]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(一)</title>
    <url>/2023/01/19/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%80)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-一"><a href="#JS笔记之JS数据类型-一" class="headerlink" title="JS笔记之JS数据类型(一)"></a>JS笔记之JS数据类型(一)</h1><p>原始类型的方法</p>
<p>在JS中允许我们像使用对象一样使用原始类型（数字。字符串等）。</p>
<h2 id="1-字符串与对象的基本区别"><a href="#1-字符串与对象的基本区别" class="headerlink" title="1 字符串与对象的基本区别"></a>1 字符串与对象的基本区别</h2><p>一个原始值：</p>
<ul>
<li>是原始类型中的一种值。</li>
<li>在 JavaScript 中有 7 种原始类型：<code>string</code>，<code>number</code>，<code>bigint</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 和 <code>undefined</code>。</li>
</ul>
<p>一个对象：</p>
<ul>
<li>能够存储多个值作为属性。</li>
<li>可以使用大括号 <code>&#123;&#125;</code> 创建对象，例如：<code>&#123;name: &quot;John&quot;, age: 30&#125;</code>。JavaScript 中还有其他种类的对象，例如函数就是对象</li>
</ul>
<h3 id="1-1-如何解决使原始类型拥有和对象类似的方法？"><a href="#1-1-如何解决使原始类型拥有和对象类似的方法？" class="headerlink" title="1.1 如何解决使原始类型拥有和对象类似的方法？"></a>1.1 如何解决使原始类型拥有和对象类似的方法？</h3><ol>
<li>原始类型仍然是原始的。与预期相同，提供单个值。</li>
<li>JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。</li>
<li>为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。</li>
</ol>
<p>所以原始类型可以提供方法，但它们依然是轻量级的。</p>
<p>JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。</p>
<blockquote>
<p><strong>null/undefined 没有任何方法</strong></p>
<p>特殊的原始类型 <code>null</code> 和 <code>undefined</code> 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。</p>
<p>尝试访问这种值的属性会导致错误：<code>alert(null.test); // error</code></p>
</blockquote>
<h2 id="2-数字类型"><a href="#2-数字类型" class="headerlink" title="2 数字类型"></a>2 数字类型</h2><p>在现代的JS中数字有两种类型：</p>
<ul>
<li>JS中常规的数字以64为的格式存储，也称为双精度浮点数，是我们大多数使用时数字。但是不能安全地超过 <code>(253-1)</code> 或小于 <code>-(253-1)</code>。</li>
<li>BigInt 表示任意长度的整数，仅在少数特殊领域才会用到 BigInt。</li>
</ul>
<h3 id="2-1-编写数字的方式"><a href="#2-1-编写数字的方式" class="headerlink" title="2.1 编写数字的方式"></a>2.1 编写数字的方式</h3><p>你如要写一个10亿的数字：<code>let billion = 1000000000</code> 也可以使用下划线作为分隔符 <code>let billiion = 1_000_000_000</code>。</p>
<p>这里的下划线 <code>_</code> 扮演了“<a href="https://en.wikipedia.org/wiki/Syntactic_sugar">语法糖</a>”的角色，使得数字具有更强的可读性。JS引擎会直接忽略数字之间的 <code>_</code>，所以 上面两个例子其实是一样的。</p>
<p>在 JS 中，我们可以通过在数字后面附加字母 <code>&quot;e&quot;</code> 并指定零的个数来缩短数字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1e9</span>;  <span class="comment">// 10 亿，字面意思：数字 1 后面跟 9 个 0</span></span><br><span class="line"></span><br><span class="line">alert( <span class="number">7.3e9</span> );  <span class="comment">// 73 亿（与 7300000000 和 7_300_000_000 相同）</span></span><br></pre></td></tr></table></figure>
<p>换句话说，<code>e</code> 把数字乘以 <code>1</code> 后面跟着给定数量的 0 的数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1e3</span> === <span class="number">1</span> * <span class="number">1000</span>; <span class="comment">// e3 表示 *1000</span></span><br><span class="line"><span class="number">1.23e6</span> === <span class="number">1.23</span> * <span class="number">1000000</span>; <span class="comment">// e6 表示 *1000000</span></span><br></pre></td></tr></table></figure>
<p>现在让我们写一些非常小的数字。例如，1 微秒（百万分之一秒）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mcs = <span class="number">0.000001</span>;</span><br></pre></td></tr></table></figure>
<p>就像以前一样，可以使用 <code>&quot;e&quot;</code> 来完成。如果我们想避免显式地写零，我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mcs = <span class="number">1e-6</span>; <span class="comment">// 1 的左边有 6 个 0</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-十六进制、八进制和二进制数字"><a href="#2-2-十六进制、八进制和二进制数字" class="headerlink" title="2.2 十六进制、八进制和二进制数字"></a>2.2 十六进制、八进制和二进制数字</h3><p>十六进制 在JS中总是表示颜色，使用<code>0x</code> 表示，二进制使用<code>0b</code>表示，八进制使用<code>0o</code>表示。只有这三种进制支持这种写法，其他的进制使用 parseInt 表示。</p>
<h3 id="2-3-toString-base"><a href="#2-3-toString-base" class="headerlink" title="2.3 toString(base)"></a>2.3 toString(base)</h3><p>方法toString(base)方法，返回在给定base进制数字系统（base的范围可以从2到36。默认情况下是10）中num的字符串表示形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num= <span class="number">255</span>;</span><br><span class="line"><span class="built_in">console</span>.log&#123;num.toString(<span class="number">16</span>)&#125; <span class="comment">// ff</span></span><br><span class="line"><span class="built_in">console</span>.log&#123;num.tostring(<span class="number">2</span>)&#125; <span class="comment">// 11111111</span></span><br></pre></td></tr></table></figure>
<p>常用的进制范例：</p>
<ol>
<li>base=16 用户十六进制颜色，字符编码等，数字可以是0..9 或者是A..F。</li>
<li>base=2 主要用于调试按位操作。数字是0和1。</li>
<li>base=36 是最大进制，数字可以是0..9或者A..Z，所有的字母都被用于表示数字，对于36进制来说、一个；例字设计：将一个较长的数字标识符转化较短的时候，比如短连接，可以使用基数为36的数字系统表示。<code>console.log( 123456..toString(36) ); // 2n9c</code></li>
</ol>
<blockquote>
<p>在范例第三点中 <code>123456..toString(36)</code> 两个点不是错误。如果想直接在一个数字上，调用一个方法，比如上面的例字中的toString，那么需要在数字后面加上两个点 .. 。</p>
<p>如果放置一个点，<code>123456.toString(36)</code>那么就会出现一个error，因为JS语法隐含了第一个点后面的部分是小数部分，如果再放一个点，那么JS就知道小数部分为空。</p>
<p>也可以写成<code>(123346).toString(36)</code></p>
</blockquote>
<h3 id="2-4-舍入"><a href="#2-4-舍入" class="headerlink" title="2.4 舍入"></a>2.4 舍入</h3><p>舍入是对数字比较常用的操作之一。一下是几个对数字进行舍入操作的内建函数。</p>
<p>Math.floor：向下舍入， 3.1 变成 3，-1.1 变成 -2。</p>
<p>Math.ceil：向下舍入，3.1 变成 4，-1.1 变成 -1。</p>
<p>Math.round：像最近的整数舍入。3.1 变成 3，3.6 变成 4，3.5 变成 4。</p>
<p>Math.trunc：（IE浏览器不支持）移除小数点后的内容而不舍入。3.1 变成 3，-1.1 变成 -1。</p>
<h3 id="2-5-保留小数位数"><a href="#2-5-保留小数位数" class="headerlink" title="2.5 保留小数位数"></a>2.5 保留小数位数</h3><p>toFixed(n) 将数字输入到下小数的后n位，以字符串的形式返回结果。会向上或者向下的舍入到近似的值，类似Math.round()。如果小数部分比需要的短，则在末尾加0。 可以使用一元符号或者Number()将其转化为数字。例如：<code>+num.toFixed(5)</code></p>
<h3 id="2-6-不精确的计算"><a href="#2-6-不精确的计算" class="headerlink" title="2.6 不精确的计算"></a>2.6 不精确的计算</h3><p>数字内部是以64为存储数字的，所以：其中52位被用于存储这些数字，11为被存储与小数点的位置，一位用于符号，如果一个数字很大，可能会溢出64位存储，变成一个特殊的值：infinty。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1e500</span>);</span><br></pre></td></tr></table></figure>
<p>在大多数语言中都会有精度的问题，<code>console.log( 0.1 + 0.2 ); // 0.30000000000000004</code>,</p>
<p>出现的原因：数字是以二进制存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 <code>0.1</code>，<code>0.2</code> 这样的小数，实际上在二进制形式中是无限循环小数。</p>
<p>其中的解决办法有：</p>
<ul>
<li><p>通过将数字舍入到最接近的可能数字来解决此问题，使用toFixed <code>+(0.1 + 0.2 ).toFixed(2)</code></p>
</li>
<li><p>使用乘法或者除法来减少误差。但是乘法除法只能减少误差，不能消除误差。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( (<span class="number">0.1</span> * <span class="number">10</span> + <span class="number">0.2</span> * <span class="number">10</span>) / <span class="number">10</span> ); <span class="comment">// 0.3</span></span><br><span class="line">alert( (<span class="number">0.28</span> * <span class="number">100</span> + <span class="number">0.14</span> * <span class="number">100</span>) / <span class="number">100</span>); <span class="comment">// 0.4200000000000001</span></span><br></pre></td></tr></table></figure>
<p>实际上完全处理小数是不可能的，但是我们可以在满足条件的情况下，减掉尾巴，来进行四舍五入即可。</p>
</li>
</ul>
<h3 id="2-7-isFinite和isNaN"><a href="#2-7-isFinite和isNaN" class="headerlink" title="2.7 isFinite和isNaN"></a>2.7 isFinite和isNaN</h3><p>infinity和-infinity以及NaN 都属于Number类型，但不是普通的数字。</p>
<ul>
<li><p>isNaN() 将参数转化为数字，并判断其是否为NaN。</p>
<p>为什么不用 <code>xx === NaN</code>？因为在JS中，NaN是独一无二的，即使是<code>NaN === NaN</code> 进行比较也是false。</p>
</li>
<li><p>isFinity() 将参数转为数字， 判断是否为常规数字。如果是常规数字而不是NaN、infinity,-infinity 返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">isFinite</span>(<span class="string">&quot;15&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">isFinite</span>(<span class="string">&quot;str&quot;</span>) ); <span class="comment">// false，因为是一个特殊的值：Na</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) ); <span class="comment">// false，因为是一个特殊的值：Infinity</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>与Object.is 进行比较。它类似于 === 一样对值进行比较，但是他对于两种边缘庆魁昂更可靠。</p>
<p>1.它适用于NaN：<code>Object.is(NaN, NaN) === true</code>。</p>
<p>2.值0和-0是不同的，<code>Object.is(0, -0) === False</code>，从技术上讲是对的，因为在内部数字的符号位可能会不同，即使其他的均为0。</p>
<p>在所有情况下， <code>Objet.is(a, b) 与 a === b</code> 相同。</p>
</blockquote>
<h3 id="2-8-parseInt-和-parsrFloat"><a href="#2-8-parseInt-和-parsrFloat" class="headerlink" title="2.8 parseInt 和 parsrFloat"></a>2.8 parseInt 和 parsrFloat</h3><p>使用一元运算符将字符串转化为数字时，是严格的，当转化的字符串不是一个数字时就会失败。(除了字符开头结尾的空格)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;sss&quot;</span>)  <span class="comment">// NaN	</span></span><br></pre></td></tr></table></figure>
<p>在现实中我们会经常遇到带有单位的字符串， 100px, 100pt，19€（欧元）。</p>
<p>parseInt 和 parsrFloat 他们可以从字符串中提取数字，，直到无法读取为止，如果发生error则返回收集到的数字，函数parseInt 返回一个整数，parseFloat 返回一个浮点数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseInt</span>(<span class="string">&#x27;100px&#x27;</span>) ); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseFloat</span>(<span class="string">&#x27;12.5em&#x27;</span>) ); <span class="comment">// 12.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseInt</span>(<span class="string">&#x27;12.3&#x27;</span>) ); <span class="comment">// 12，只有整数部分被返回了</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseFloat</span>(<span class="string">&#x27;12.3.4&#x27;</span>) ); <span class="comment">// 12.3，在第二个点出停止了读取</span></span><br></pre></td></tr></table></figure>
<p>parseInt 和 parsrFloat 的局限性：只能是数字开头的字符串，如果第一个字符就不是数字则无法读取，返回NaN。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;xxx111&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>parseInt(str，radix) radix:技术的意思， 第二个参数制定了数字系统的基数，因此parseInt 还可以解析十六进制，八进制，二进制等字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>) ); <span class="comment">// 255</span></span><br><span class="line">alert( <span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>) ); <span class="comment">// 255，没有 0x 仍然有效</span></span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">parseInt</span>(<span class="string">&#x27;2n9c&#x27;</span>, <span class="number">36</span>) ); <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure>


<h3 id="2-9-其他的数学函数"><a href="#2-9-其他的数学函数" class="headerlink" title="2.9 其他的数学函数"></a>2.9 其他的数学函数</h3><p>Math 对象包含了一个小型的数学函数和常量库。</p>
<ul>
<li>Math.random() 返回一个从 0 到 1 的随机数（不包括 1）。</li>
<li>Math.max(a, b, c…) 和 Math.min(a, b, c…) 从任意数量的参数中返回最大值和最小值。</li>
<li>Math.pow(n, power) 返回 <code>n</code> 的给定（power）次幂。</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>要写很多0的数字</p>
<ul>
<li>有很多0的整数，将e和0的个数写到数字的后面。 <code>123e5 === 12300000</code>。</li>
<li>有很多0的小数，将e和0的个数写到数字的后面，0的个数前加上负号-，<code>1.33e-5 === 0.0000133</code> </li>
</ul>
<h3 id="3-2-不同的数字系统"><a href="#3-2-不同的数字系统" class="headerlink" title="3.2 不同的数字系统"></a>3.2 不同的数字系统</h3><ul>
<li>可以在十六进制，八进制，二进制 数字系统中写入数字。</li>
<li>parseInt(str, base) 将字符串 str 解析为在给定的 <code>base</code> 数字系统中的整数，<code>2 ≤ base ≤ 36</code>。</li>
<li>num.toString(base) 将数字转化为给定的base数字系统中的字符串。</li>
</ul>
<h3 id="3-3-对于常规的数字检测"><a href="#3-3-对于常规的数字检测" class="headerlink" title="3.3 对于常规的数字检测"></a>3.3 对于常规的数字检测</h3><ul>
<li>isNaN(value) 将参数转为为数字，并判断是否为NaN。</li>
<li>isFinite(value) 将其参数转换为数字，如果它是常规数字，则返回 true，而不是 `NaN/Infinity/-Infinity</li>
</ul>
<h3 id="3-4-将字符串转为数字"><a href="#3-4-将字符串转为数字" class="headerlink" title="3.4 将字符串转为数字"></a>3.4 将字符串转为数字</h3><ul>
<li>使用一元符号，但是是严格模式。</li>
<li>使用parseInt/parseFloat进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。</li>
</ul>
<h3 id="3-5-小数"><a href="#3-5-小数" class="headerlink" title="3.5 小数"></a>3.5 小数</h3><ul>
<li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入。</li>
<li>使用小数时损失精度。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(八)</title>
    <url>/2023/01/19/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AB)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-八"><a href="#JS笔记之JS对象基础知识-八" class="headerlink" title="JS笔记之JS对象基础知识(八)"></a>JS笔记之JS对象基础知识(八)</h1><h2 id="1-对象原始值的转换"><a href="#1-对象原始值的转换" class="headerlink" title="1 对象原始值的转换"></a>1 对象原始值的转换</h2><p>当对象相加或者相减时，使用 alert(obj) 打印会输出什么？</p>
<p>JS不允许自定义运算符对对象的处理方式，我们无法实现特殊的对象处理方法来处理加法或者是其他的运算。</p>
<p>在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值，这是一个重要的限制：因为 <code>obj1 + obj2</code>（或者其他数学运算）的结果不能是另一个对象！</p>
<p>例如我们无法使用对象来表示向量或者是矩阵，或者是成就或者其他。</p>
<p>因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。</p>
<p>对象如何转换为原始值，以及如何对其进行自定义。</p>
<h3 id="1-1-转换规则"><a href="#1-1-转换规则" class="headerlink" title="1.1 转换规则"></a>1.1 转换规则</h3><ul>
<li>没有转换为布尔值，所有的对象在布尔值上下文中均为<code>true</code>，只有字符串和数字转换。</li>
<li>数字转换发生在对象相减或应用数学函数时，例如Date对象可以相减，date1-date2 的结果是两个日期之间的差值。</li>
<li>对于字符串转换，通常发生在我们像alert(obj)这样输出一个对象和类似的上下文中。</li>
</ul>
<p>我们可以使用特殊的对象方法，实现字符串和数字的转换。</p>
<h3 id="1-2-hint定义"><a href="#1-2-hint定义" class="headerlink" title="1.2 hint定义"></a>1.2 hint定义</h3><p>类型转换在各种情况下有三种变体，他们被称为hint.</p>
<h4 id="1-2-1-String"><a href="#1-2-1-String" class="headerlink" title="1.2.1 String"></a>1.2.1 String</h4><p>对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 “alert”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">alert(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象作为属性键</span></span><br><span class="line">anotherObj[obj] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


<h4 id="1-2-2-Number"><a href="#1-2-2-Number" class="headerlink" title="1.2.2 Number"></a>1.2.2 Number</h4><p>对象到数字的转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式转换</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Number</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学运算（除了二元加法）</span></span><br><span class="line"><span class="keyword">let</span> n = +obj; <span class="comment">// 一元加法</span></span><br><span class="line"><span class="keyword">let</span> delta = date1 - date2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于/大于的比较</span></span><br><span class="line"><span class="keyword">let</span> greater = user1 &gt; user2;</span><br></pre></td></tr></table></figure>
<p>大多数内建的数学函数也包括这种转换。</p>
<h4 id="1-2-3-default"><a href="#1-2-3-default" class="headerlink" title="1.2.3 default"></a>1.2.3 default</h4><p>当运算符 “不确定” 期望值的类型时。在极少数情况下发生。</p>
<p>例如二元加法 <code>+</code> 可用于字符串的拼接，也可用于数字的相加，因此当二元加法得到对象类型的参数时，他将依据 <code>default</code> hint 来对其进行转换。</p>
<p>此外如果对象被用于与字符串、数字、或者symbol进行<code>==</code>比较，这时候他进行那种类型转换也不熟很明确，因此使用 <code>default</code> hint。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二元加法使用默认 hint</span></span><br><span class="line"><span class="keyword">let</span> total = obj1 + obj2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj == number 使用默认 hint</span></span><br><span class="line"><span class="keyword">if</span> (user == <span class="number">1</span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-转换方法"><a href="#1-3-转换方法" class="headerlink" title="1.3 转换方法"></a>1.3 转换方法</h3><p><strong>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</strong></p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> —— 带有 symbol 键 <code>Symbol.toPrimitive</code>（系统 symbol）的方法，如果这个方法存在的话，</li>
<li>否则，如果 hint 是 <code>&quot;string&quot;</code> —— 尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li>
<li>否则，如果 hint 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> —— 尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li>
</ol>
<h4 id="1-3-1-Symbol-toPrimitive"><a href="#1-3-1-Symbol-toPrimitive" class="headerlink" title="1.3.1 Symbol.toPrimitive"></a>1.3.1 Symbol.toPrimitive</h4><p>他是被用来给转换方法命名。如果它存在则他会被用于所有的hint。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是将此对象转换为原始值的代码</span></span><br><span class="line">  <span class="comment">// 它必须返回一个原始值</span></span><br><span class="line">  <span class="comment">// hint = &quot;string&quot;、&quot;number&quot; 或 &quot;default&quot; 中的一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-3-2-toString-valueOf"><a href="#1-3-2-toString-valueOf" class="headerlink" title="1.3.2 toString/valueOf"></a>1.3.2 toString/valueOf</h4><p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试寻找 <code>toString</code> 和 <code>valueOf</code> 方法：</p>
<ul>
<li>对于 <code>&quot;string&quot;</code> hint：调用 <code>toString</code> 方法，如果它不存在，则调用 <code>valueOf</code> 方法（因此，对于字符串转换，优先调用 <code>toString</code>）。</li>
<li>对于其他 hint：调用 <code>valueOf</code> 方法，如果它不存在，则调用 <code>toString</code> 方法（因此，对于数学运算，优先调用 <code>valueOf</code> 方法）。</li>
</ul>
<p>这些方法必须返回一个原始值。如果 <code>toString</code> 或 <code>valueOf</code> 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p>
<p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p>
<ul>
<li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li>
<li><code>valueOf</code> 方法返回对象自身。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">// [object Object]</span></span><br><span class="line">alert(user.valueOf() === user); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<p>所以如果我们将一个对象当做字符串来使用，例如 alerty(obj) 将会得到<code>[object Object]</code>。</p>
<h3 id="1-4-自定义转化方法"><a href="#1-4-自定义转化方法" class="headerlink" title="1.4 自定义转化方法"></a>1.4 自定义转化方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line">alert(+user); <span class="comment">// valueOf -&gt; 1000</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// valueOf -&gt; 1500</span></span><br></pre></td></tr></table></figure>


<p>通常我们希望一个全能的地方来处理所有的原始转换。可以只实现toString 来实现。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">// toString -&gt; John</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// toString -&gt; John500</span></span><br></pre></td></tr></table></figure>
<p>如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换。</p>
<h3 id="1-5-转换可以返回任何原始类型"><a href="#1-5-转换可以返回任何原始类型" class="headerlink" title="1.5 转换可以返回任何原始类型"></a>1.5 转换可以返回任何原始类型</h3><p>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p>
<p>没有限制 <code>toString()</code> 是否返回字符串，或 <code>Symbol.toPrimitive</code> 方法是否为 <code>&quot;number&quot;</code> hint 返回数字。</p>
<p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p>
<blockquote>
<p>Tips：由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p>
<p>相反，<code>Symbol.toPrimitive</code> 更严格，它 <strong>必须</strong> 返回一个原始值，否则就会出现 error。</p>
</blockquote>
<h3 id="1-6-进一步的转换"><a href="#1-6-进一步的转换" class="headerlink" title="1.6 进一步的转换"></a>1.6 进一步的转换</h3><p>许多运算符和函数执行类型转换， 例如乘法，将操作数转化为数字。</p>
<p>如果我们将对象作为参数传递，则会出现两个运算阶段：</p>
<ol>
<li>对象被转化为原始值。根据上面转化的规则。</li>
<li>如果还需进一步计算。则生成的原始值会进一步的转换。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// toString 在没有其他方法的情况下处理所有转换</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj * <span class="number">2</span>); <span class="comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。</span></span><br></pre></td></tr></table></figure>
<p>比如上面的例字：</p>
<ol>
<li>乘法 <code>obj * 2</code> 首先将对象转换为原始值（字符串 “2”）。</li>
<li>之后 <code>&quot;2&quot; * 2</code> 变为 <code>2 * 2</code>（字符串被转换为数字）。</li>
</ol>
<h3 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h3><p>对象到原始值的转换，是自动触发的。</p>
<p>有三种类型的hint：</p>
<ul>
<li>“string” 对于 alert 和其他需要字符串的操作。</li>
<li>“number” 对于数学运算。</li>
<li>“default” 少数运算符，通常对象已和 “number” 相同的方式实现 default 转换。</li>
</ul>
<p>规范明确描述了哪个运算符使用哪个 hint。</p>
<p>转换算法是：</p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</li>
<li>否则，如果 hint 是 “string”<ul>
<li>尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li>
</ul>
</li>
<li>否则，如果 hint 是 “number” 或者 “default”<ul>
<li>尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li>
</ul>
</li>
</ol>
<p>所有这些方法都必须返回一个原始值才能工作（如果已定义）。</p>
<p><strong>在实际使用中，通常只实现 <code>obj.toString()</code> 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</strong></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(七)</title>
    <url>/2023/01/18/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%83)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-七"><a href="#JS笔记之JS对象基础知识-七" class="headerlink" title="JS笔记之JS对象基础知识(七)"></a>JS笔记之JS对象基础知识(七)</h1><h2 id="1-symbol类型"><a href="#1-symbol类型" class="headerlink" title="1 symbol类型"></a>1 symbol类型</h2><p>根据规范，对象的关键字数据类型只有两种，字符串和symbol类型，如果使用数字或者 true会自动转化为字符串类型。</p>
<h3 id="1-1-symbol定义"><a href="#1-1-symbol定义" class="headerlink" title="1.1 symbol定义"></a>1.1 symbol定义</h3><p>symbol表示唯一的标识符，可以使用Symbol()来创建这种类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure>
<p>创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id 是描述为 &quot;id&quot; 的 symbol</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-使用Symbol"><a href="#1-2-使用Symbol" class="headerlink" title="1.2 使用Symbol"></a>1.2 使用Symbol</h3><p>在JS中大多数数值都支持字符串的隐士转换，但Symbol不会被自动转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-显示Symbol"><a href="#1-3-显示Symbol" class="headerlink" title="1.3 显示Symbol"></a>1.3 显示Symbol</h3><p>如果要显示一个Symbol，需要使用toString()，或者获取<code>symbol.description</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">alert(id.toString()); <span class="comment">// Symbol(id)，现在它有效了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">alert(id.description); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>


<h3 id="1-4-隐藏属性"><a href="#1-4-隐藏属性" class="headerlink" title="1.4 隐藏属性"></a>1.4 隐藏属性</h3><p>Symbol 允许我们创建对象的隐藏属性，代码的任何其他的部分都不能访问后者重写这些属性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="comment">// 属于另一个代码</span></span><br><span class="line">  name: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">user[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">alert( user[id] ); <span class="comment">// 我们可以使用 symbol 作为键来访问数据</span></span><br></pre></td></tr></table></figure>
<p>这样写的好处就是：因为<code>user</code> 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 <code>user</code> 对象是安全的。</p>
<h3 id="1-5-对象字面量中的-symbol"><a href="#1-5-对象字面量中的-symbol" class="headerlink" title="1.5 对象字面量中的 symbol"></a>1.5 对象字面量中的 symbol</h3><p>在通过字面量创建对象时，需要使用方括号把它括起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  [id]: <span class="number">123</span> <span class="comment">// 而不是 &quot;id&quot;：123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：Symbol 属性会在for..in 中被跳过。</p>
<p>Object.keys(user) 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p>
<p>但是 <strong>Object.assign</strong> 会同时复制字符串和Symbol属性。</p>
</blockquote>
<h3 id="1-6-全局Symbol"><a href="#1-6-全局Symbol" class="headerlink" title="1.6 全局Symbol"></a>1.6 全局Symbol</h3><p>通常所有的Symbol都是不同的对象，即使他们有相同的名字。但是有时候我们想要相同名字的symbol具有相同的实体，例如应用程序的不同部分想要访问的symbol 指的是完全相同的属性。</p>
<p>在JS中有一个全局的Symbol注册表，可以创建并在全局访问他们，可以确保每次访问相同名字的symbol返回的都是相同的Symbol。</p>
<h3 id="1-7-Symbol-for-key"><a href="#1-7-Symbol-for-key" class="headerlink" title="1.7 Symbol.for(key)"></a>1.7 Symbol.for(key)</h3><p>key 为Symbol的描述。从注册表读取并创建symbol， 读取时如果不存在自动创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从全局注册表中读取</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>); <span class="comment">// 如果该 symbol 不存在，则创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同的 symbol</span></span><br><span class="line">alert( id === idAgain ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注册表内的Symbol被称为全局Symbol，如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 ——这就是它们的用途。</p>
<h3 id="1-8-Symbol-keyFor-key"><a href="#1-8-Symbol-keyFor-key" class="headerlink" title="1.8 Symbol.keyFor(key)"></a>1.8 Symbol.keyFor(key)</h3><p>可以根据Symbol的变量名返回Symbol的描述。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 name 获取 symbol</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>.for(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 symbol 获取 name</span></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(sym) ); <span class="comment">// name</span></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(sym2) ); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>
<p>Symbol.keyFor使用全局注册表来查找symbol的键，所以它不适用于非全局的Symbol，如果Symbol不是全局的他将无法找回并返回Undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(globalSymbol) ); <span class="comment">// name，全局 symbol</span></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(localSymbol) ); <span class="comment">// undefined，非全局</span></span><br><span class="line"></span><br><span class="line">alert( localSymbol.description ); <span class="comment">// name</span></span><br></pre></td></tr></table></figure>
<h3 id="1-9-系统Symbol"><a href="#1-9-系统Symbol" class="headerlink" title="1.9 系统Symbol"></a>1.9 系统Symbol</h3><p>JS内部有许多的系统Symbol，我们可以用他们来微调对象的各个方面。在<a href="https://tc39.es/ecma262/#sec-well-known-symbols">symbol列表</a>中找到。</p>
<h3 id="1-10-总结"><a href="#1-10-总结" class="headerlink" title="1.10 总结"></a>1.10 总结</h3><ul>
<li><p><code>symbol</code> 是唯一标识符的基本类型</p>
</li>
<li><p>symbol 是使用带有可选描述（name）的 <code>Symbol()</code> 调用创建的。</p>
</li>
<li><p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回（如果需要的话则创建）一个以 <code>key</code> 作为名字的全局 symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 symbol 时，返回的就是同一个 symbol。</p>
</li>
</ul>
<p>symbol 有两个主要的使用场景：</p>
<ol>
<li><p>“隐藏” 对象属性。</p>
<p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
<p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
</li>
<li><p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内建行为。例如：使用 <code>Symbol.iterator</code> 来进行 <a href="https://zh.javascript.info/iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a href="https://zh.javascript.info/object-toprimitive">对象原始值的转换</a> 等等。</p>
</li>
</ol>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(六)</title>
    <url>/2023/01/18/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AD)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-六"><a href="#JS笔记之JS对象基础知识-六" class="headerlink" title="JS笔记之JS对象基础知识(六)"></a>JS笔记之JS对象基础知识(六)</h1><h2 id="1-可选链-“-”"><a href="#1-可选链-“-”" class="headerlink" title="1 可选链 “?.”"></a>1 可选链 “?.”</h2><p>可选链<code>?.</code>是一种访问嵌套对象属性的安全的方式，即使中间的属性不存在，也不会出现错误。</p>
<h3 id="1-1-“不存在的属性”的问题"><a href="#1-1-“不存在的属性”的问题" class="headerlink" title="1.1 “不存在的属性”的问题"></a>1.1 “不存在的属性”的问题</h3><p>例如在一个嵌套的对象中，我们获取user对象的address对象的street属性，但是实际上user是一个空对象，此时JS会返回错误，这是正常的返回，但是有时候我们需要的不抛出异常，而是返回<code>undefined</code>，表示user对象的address对象没有该属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span></span><br><span class="line"></span><br><span class="line">alert(user.address.street); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>
<p>又或者是我们获取htmlDOM元素得时候，获取某个元素的 innerHTML 属性，如果获取不到该元素，也会抛出一个异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 如果 <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.elem&#x27;</span>) 的结果为 <span class="literal">null</span>，则这里不存在这个元素</span><br><span class="line"><span class="keyword">let</span> html = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.elem&#x27;</span>).innerHTML; <span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-如何去避免这一问题呢？"><a href="#1-2-如何去避免这一问题呢？" class="headerlink" title="1.2 如何去避免这一问题呢？"></a>1.2 如何去避免这一问题呢？</h3><p>可能比较容易想到的方法就是获取到该对象以后，使用三元运算符进行比较：<code>user.address ? user.address.street : undefined</code>，但是<code>user.address</code>重复出现，如果对象之间如果嵌套的更深，代码则会有大量重复。</p>
<p>还有一个方法是使用<code>&amp;&amp;</code>运算符，但是任然会有 大量的代码重复。使用可选链就可以解决该问题。</p>
<h3 id="1-3-可选链语法"><a href="#1-3-可选链语法" class="headerlink" title="1.3 可选链语法"></a>1.3 可选链语法</h3><p>如果可选链<code>?.</code>前面的值为<code>undefined</code>和<code>null</code> 它会停止运算，并且返回<code>ubdefined</code>。</p>
<p>例如<code>value?.pop</code>:</p>
<ul>
<li>如果value存在，则结果与value.pop 属性值相同。</li>
<li>如果当value的是undefined和null时，则返回undefined。</li>
</ul>
<p>比如使用这种方式访问上面的 <code>user.address.street</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( user?.address?.street ); <span class="comment">// undefined（不报错）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：<code>?.</code>使其前面（左边）的值成为可选值，但不会对后面的值起作用。</p>
</blockquote>
<blockquote>
<p><strong>不要过度使用可选链</strong></p>
<p>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</p>
<p>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</p>
<p>那么，如果 <code>user</code> 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</p>
</blockquote>
<blockquote>
<p><strong><code>?.</code> 前的变量必须已声明</strong></p>
<p>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误。可选链仅适用于已声明的变量。</p>
</blockquote>
<h3 id="1-4-可选链的短路效应"><a href="#1-4-可选链的短路效应" class="headerlink" title="1.4 可选链的短路效应"></a>1.4 可选链的短路效应</h3><p>即可选链的左边不存在，就会立刻停止运行（短路效应）。因此如果在<code>?.</code>的右侧有任何下一步的操作都不会执行。</p>
<h3 id="1-5-可选链的变体："><a href="#1-5-可选链的变体：" class="headerlink" title="1.5 可选链的变体：?.[] ?.()"></a>1.5 可选链的变体：?.[] ?.()</h3><p>可选链不是一个运算符，而是一中特殊的语法结构，他还可以与函数以及方括号一起使用。</p>
<p>例如<code>?.()</code>调用一个可能不存在的函数。在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userAdmin = &#123;</span><br><span class="line">  <span class="function"><span class="title">admin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;I am admin&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userGuest = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">userAdmin.admin?.(); <span class="comment">// I am admin</span></span><br><span class="line"></span><br><span class="line">userGuest.admin?.(); <span class="comment">// 啥都没发生（没有这样的方法）</span></span><br></pre></td></tr></table></figure>
<p>使用方括号获取属性的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;firstName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">alert( user1?.[key] ); <span class="comment">// John</span></span><br><span class="line">alert( user2?.[key] ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>此外还可以将<code>?.</code>和 <code>delete</code>一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> user?.name; <span class="comment">// 如果 user 存在，则删除 user.name</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：需要注意的是可选链可以进行安全的读取和删除，但是不能进行写入。可选链不能用在赋值语句的左边。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">user?.name = <span class="string">&quot;John&quot;</span>; <span class="comment">// Error，不起作用</span></span><br><span class="line"><span class="comment">// 因为它在计算的是：undefined = &quot;John&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p>可选链的语法格式有大概几种：</p>
<ul>
<li>obj?.prop    —&gt; 如果obj存在则返回<code>obj.prop</code>如果不存在则返回<code>undefined</code>。</li>
<li>obj?.[prop]  —&gt; 如果obj存在则返回<code>obj.prop</code>如果不存在则返回<code>undefined</code>。、</li>
<li>obj.method?.()  —&gt; 如果<code>obj.method</code>存在则调用<code>obj.method()</code>，否则返回 <code>undefined</code>。</li>
</ul>
<p>我们应该谨慎的使用<code>?.</code>，根据我们的代码逻辑，仅在当做部分不存在的可接受的条件下使用最好。且该语法格式是JS新出的特性，可能会存在兼容问题，旧式浏览器可能需要 polyfills。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(五)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%94)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-五"><a href="#JS笔记之JS对象基础知识-五" class="headerlink" title="JS笔记之JS对象基础知识(五)"></a>JS笔记之JS对象基础知识(五)</h1><h2 id="1-构造器和操作符new"><a href="#1-构造器和操作符new" class="headerlink" title="1 构造器和操作符new"></a>1 构造器和操作符new</h2><p>创建对象可以使用字面量的方式：{} 也可以使用new操作符，相较于字面量创建对象的方式，new操作符能够方面的创建许多类似的对象，例如多个用户和菜单对象。</p>
<h3 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h3><p>构造函数在技术上是常规函数，只是有两个约定：</p>
<ul>
<li>他的命名都是一大写字母开头。</li>
<li>只能有<code>new</code>操作符来执行。</li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// Jack</span></span><br><span class="line">alert(user.isAdmin); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-构造器的执行步骤："><a href="#1-2-构造器的执行步骤：" class="headerlink" title="1.2 构造器的执行步骤："></a>1.2 构造器的执行步骤：</h3><ol>
<li>一个新的空对象被创建并分配给this。</li>
<li>函数体执行，通常他会修改<code>this</code>,并为其添加新的属性。</li>
<li>返回<code>this</code>的值。</li>
</ol>
<p>总的来说 new User(…) 做的就是如下的事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123;</span><br><span class="line">    name:<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    isAdmin:<span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以 user1 和 user2 的结果是相通的对象。</span></span><br></pre></td></tr></table></figure>
<p>所以接下来我们创建新的对象，就可以使用 <code>new User(&#39;Alice&#39;)</code> <code>new User(&#39;Ann&#39;)</code>等， 要比每次都是用字面量要更与阅读。</p>
<p><strong>这就是构造起的主要目的：实可重用的对象创建代码。</strong></p>
<p>从技术上将，除了箭头函数以外，任何函数都可以用作构造器，即可以通过<code>new</code>来运行，他会执行上面的构造器的执行步骤。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>
<p>封装构建单个对象的代码的技巧：</p>
<p>如果有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数并立即使用 new 调用它</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……用于用户创建的其他代码</span></span><br><span class="line">  <span class="comment">// 也许是复杂的逻辑和语句</span></span><br><span class="line">  <span class="comment">// 局部变量等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个构造函数不能被再次调用，因为他不保存在任何地方，只是被创建和调用。</p>
<h3 id="1-3-构造器模式测试：new-target"><a href="#1-3-构造器模式测试：new-target" class="headerlink" title="1.3 构造器模式测试：new.target"></a>1.3 构造器模式测试：new.target</h3><p>在一个函数内部我们是可以使用new.target 属性来检查他是否被使用new调用了。对于常规调用，它是 undefined, 但是对于new的调用，则等于该函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带 &quot;new&quot;：</span></span><br><span class="line">User(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 &quot;new&quot;：</span></span><br><span class="line"><span class="keyword">new</span> User(); <span class="comment">// function User &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>
<p>主要的使用方式：被使用在函数的内部，来判断该函数是被通过new调用的构造器模式，还是常规模式；也可以让new调用和常规调用最相同的工作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123; <span class="comment">// 如果你没有通过 new 运行我</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(name); <span class="comment">// ……我会给你添加 new</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = User(<span class="string">&quot;John&quot;</span>); <span class="comment">// 将调用重定向到新用户</span></span><br><span class="line">alert(john.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>


<h3 id="1-4-构造起的return"><a href="#1-4-构造起的return" class="headerlink" title="1.4 构造起的return"></a>1.4 构造起的return</h3><p>通常构造器没有return，他们的任务是将所有必须要写入的东西写入到this，并自动转化为结果，但是如果有return语句就会有不同的规则：</p>
<ul>
<li>如果返回的是一个对象，怎返回这个对象，不返回this。</li>
<li>如果返回的是一个原始类型，则忽略。</li>
</ul>
<p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BigUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;Godzilla&quot;</span> &#125;;  <span class="comment">// &lt;-- 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> BigUser().name );  <span class="comment">// Godzilla，得到了那个对象</span></span><br></pre></td></tr></table></figure>
<p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmallUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// &lt;-- 返回 this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> SmallUser().name );  <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>Tips：构造函数没有参数，可以在被new调用的时候可以省略参数。（这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User; <span class="comment">// &lt;-- 没有参数</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>
<p>使用构造函数来创建对象会带来很大的灵活性。构造函数可以传入一些参数，又或者是一些方法。使创建的对象更加灵活。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><ul>
<li>构造函数或者简称构造器，就是常规函数，只不过对他有着共同的约定，就是首字母大写。</li>
<li>构造函数只能使用<code>new</code>来调用，这样就意味着在创建了一个空的对象<code>this</code>, 并且最后返回了这个<code>this</code>。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(四)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-四"><a href="#JS笔记之JS对象基础知识-四" class="headerlink" title="JS笔记之JS对象基础知识(四)"></a>JS笔记之JS对象基础知识(四)</h1><h2 id="1-对象方法，this"><a href="#1-对象方法，this" class="headerlink" title="1 对象方法，this"></a>1 对象方法，this</h2><p>通常创建对象来表示显示世界中的实体，比如用户或者订单。在现实世界中用户可以进行操作，比如登录注销，往购物车中添加商品。</p>
<p>在JS中 行为（action）由属性中的函数表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi(); <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们给<code>user</code>对象的<code>sayHi</code>属性赋值了一个函数，这种对象的属性的函数被称为对象的方法。</p>
<p><strong>通常，全局中定义的函数称之为函数，对象中的属性是函数的话称之为方法。</strong></p>
<p><strong>我们在代码中使用对象表示实体时，这就是所谓的面向对象编程，简称OOP。</strong></p>
<h3 id="1-1-方法简写"><a href="#1-1-方法简写" class="headerlink" title="1.1 方法简写"></a>1.1 方法简写</h3><p>方法还有一个简写的方式 （可能会在继承层面会有些微的差别）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些对象作用一样</span></span><br><span class="line"></span><br><span class="line">user = &#123;</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;		</span><br><span class="line">    alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写看起来更好，对吧？</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span></span><br><span class="line">    alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="1-2-方法中的this"><a href="#1-2-方法中的this" class="headerlink" title="1.2 方法中的this"></a>1.2 方法中的this</h3><p>通常对象的方法可能需要访问对象的其他的属性，为了访问改对象，在方法中可以使用<code>this</code>这个关键字。<code>this</code>的值就是在点之前（<strong>object</strong>.attr）的这个对象，即调用该方法的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;this&quot; 指的是“当前的对象”</span></span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>同样也可以使用这种方式访问到user的name属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert( user.name ); <span class="comment">// 导致错误</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是上述例子有一个明显的问题：如果给user重新赋值，那将访问到错误的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line">user = <span class="literal">null</span>; <span class="comment">// 重写让其更明显</span></span><br><span class="line"></span><br><span class="line">admin.sayHi(); <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of null</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-this-不受限制"><a href="#1-3-this-不受限制" class="headerlink" title="1.3 this 不受限制"></a>1.3 this 不受限制</h3><p>在JS中，<code>this</code>关键字可以用于任何函数，即使他不是对象的方法。 下面这样写也不会错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="built_in">this</span>.name );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以不回错误，是因为<code>this</code>的值是计算出来的，它取决于代码的上下文。例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="built_in">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在两个对象中使用相同的函数</span></span><br><span class="line">user.f = sayHi;</span><br><span class="line">admin.f = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个调用有不同的 this 值</span></span><br><span class="line"><span class="comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span></span><br><span class="line">user.f(); <span class="comment">// John（this == user）</span></span><br><span class="line">admin.f(); <span class="comment">// Admin（this == admin）</span></span><br><span class="line"></span><br><span class="line">admin[<span class="string">&#x27;f&#x27;</span>](); <span class="comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure>
<p>严格模式下，在没有对象的情况下调用：<code>this === undefined</code>，在非严格模式下，<code>this</code>是 全局对象，（浏览器中的Window）。通常这种调用是程序出错了。如果在一个函数内部有 <code>this</code>，那么通常意味着它是在对象上下文环境中被调用的</p>
<p><strong>在JS中<code>this</code>是自由的，他的值是实时计算出来的，他的值并不取决于方法声明的位置，而是取决于在“点符号之前”的是什么对象。</strong></p>
<p><strong>在运行时对<code>this</code>求值的这个概念优优点也有缺点，一方面函数可以被重用于不同的对象，另一方面更大的灵活性造成了更大的出错的可能性。</strong></p>
<p>箭头函数没有自己的this</p>
<p>箭头函数有些特别：它们没有自己的 <code>this</code>。这是箭头函数的一个特性，当我们并不想要一个独立的 <code>this</code>，反而想从外部上下文中获取时，它很有用。</p>
<h3 id="1-4-总结："><a href="#1-4-总结：" class="headerlink" title="1.4 总结："></a>1.4 总结：</h3><ul>
<li>存储在对象属性中的函数被称为方法。</li>
<li>方法允许对对像进行类似 obj.dosomething() 这样的操作。</li>
<li>方法可以将对象引用为<code>this</code>。</li>
<li><code>this</code>的值是在程序运行时得到的。</li>
<li>一个函数在运行时可能就定义了<code>this</code>，但是这个<code>this</code>只有在函数被调用时才会有值。</li>
<li>可以在对象之间复制函数。（不太懂）</li>
<li>以方法的语法调用函数时，<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li>
<li>箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(三)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%89)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-三"><a href="#JS笔记之JS对象基础知识-三" class="headerlink" title="JS笔记之JS对象基础知识(三)"></a>JS笔记之JS对象基础知识(三)</h1><h2 id="1-垃圾回收"><a href="#1-垃圾回收" class="headerlink" title="1 垃圾回收"></a>1 垃圾回收</h2><p>对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。</p>
<h3 id="1-1-什么是垃圾？"><a href="#1-1-什么是垃圾？" class="headerlink" title="1.1 什么是垃圾？"></a>1.1 什么是垃圾？</h3><p>在JS引擎运行时，我们创建的一些原始值、对象，经过使用之后就没有就再也没有使用过，这些个原始值，或者对象都是垃圾。</p>
<h3 id="1-2-有哪些垃圾？"><a href="#1-2-有哪些垃圾？" class="headerlink" title="1.2 有哪些垃圾？"></a>1.2 有哪些垃圾？</h3><p>任何变量或者对象在未来的程序运行中总不会被访问的b变量和对象都是垃圾。</p>
<h3 id="1-3-什么是垃圾回收？"><a href="#1-3-什么是垃圾回收？" class="headerlink" title="1.3 什么是垃圾回收？"></a>1.3 什么是垃圾回收？</h3><p>JS对内存管理的一种手段。</p>
<h3 id="1-4-为什么垃圾回收？"><a href="#1-4-为什么垃圾回收？" class="headerlink" title="1.4 为什么垃圾回收？"></a>1.4 为什么垃圾回收？</h3><p>释放内存，节约资源。</p>
<h3 id="1-5-如何垃圾回收？"><a href="#1-5-如何垃圾回收？" class="headerlink" title="1.5 如何垃圾回收？"></a>1.5 如何垃圾回收？</h3><p>JS中的内存管理概念<strong>可达性</strong>，就是能够通过某种凡是访问到的值，他们一定是存在于内存中的。</p>
<p>比如一些明显的可达的值：</p>
<ul>
<li>当前执行的函数，他的局部变量和参数。</li>
<li>当前嵌套调用链上的其他的函数，他们的局部变量和函数。</li>
<li>全局变量</li>
<li>一些内部的对象</li>
</ul>
<p>一个值可以通过引用链从根访问任何其他值，则认为该值也是可达的。</p>
<p>一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user 具有对这个对象的引用</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/tc/image-20230117154427386.png" alt="image-20230117154427386"></p>
<p>user 指的的时这个 Object的对象的引用，全局变量 <code>&quot;user&quot;</code> 引用了对象 <code>&#123;name：&quot;John&quot;&#125;</code>。</p>
<p>如果 user 被重写，赋予了其他的值，那么这个引用就没了，</p>
<p><img src="https://tc.chaizz.com/tc/image-20230117155148312.png" alt="image-20230117155148312"></p>
<p>现在这个 Object 变成不可达的了，垃圾收集器就会将它视为垃圾，然后进行回收。</p>
<p>垃圾回收的内部算法：</p>
<ol>
<li>垃圾收集器找到所有的根并标记它们。</li>
<li>然后它遍历并标记来自它的引用。</li>
<li>然后他遍历标记的对象并标记它们额的引用，所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>循环操作直到所有可达的对象都被访问到并标记。</li>
<li>没有被标记的测会被删除。</li>
</ol>
<p>JS 引擎对垃圾回收做了优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。</p>
<h3 id="1-6-一些优化建议："><a href="#1-6-一些优化建议：" class="headerlink" title="1.6 一些优化建议："></a>1.6 一些优化建议：</h3><ul>
<li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</li>
<li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</li>
<li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(二)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-二"><a href="#JS笔记之JS对象基础知识-二" class="headerlink" title="JS笔记之JS对象基础知识(二)"></a>JS笔记之JS对象基础知识(二)</h1><h2 id="1-对象的引用和复制"><a href="#1-对象的引用和复制" class="headerlink" title="1 对象的引用和复制"></a>1 对象的引用和复制</h2><p>对象和原始类型（数字字符串布尔类型等）的区别就是对象是<strong>通过引用</strong> 存储和复制的，而原始类型总是作为一个整体复制。</p>
<h3 id="1-1-JS赋值时会发生什么？"><a href="#1-1-JS赋值时会发生什么？" class="headerlink" title="1.1 JS赋值时会发生什么？"></a>1.1 JS赋值时会发生什么？</h3><p>首先原始类型进行赋值时，message 和 phrase 是两个独立的变量。之间没有什么直接的关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> phrase = message;</span><br></pre></td></tr></table></figure>
<p>而对象不是这样的，一个对象被赋值给某个变量，这个变量存储的并不是对象的本身，而是这个对象的内存的地址。</p>
<p>就像一把钥匙对应一个柜子，这把钥匙可以对该柜子打开并添加、取走里面的内容，此时又根据这把钥匙重新配了一个一个钥匙，而新配的这把钥匙也能够打开这个柜子。 这两把钥匙都可以对这个柜子修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line"></span><br><span class="line">admin.name = <span class="string">&#x27;Pete&#x27;</span>; <span class="comment">// 通过 &quot;admin&quot; 引用来修改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到	</span></span><br></pre></td></tr></table></figure>
<p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p>
<h3 id="1-2-通过引用来比较"><a href="#1-2-通过引用来比较" class="headerlink" title="1.2 通过引用来比较"></a>1.2 通过引用来比较</h3><p>仅当两个对象为同一个对象时，两者才相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 复制引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a == b ); <span class="comment">// true，都引用同一对象</span></span><br><span class="line"><span class="built_in">console</span>.log( a === b ); <span class="comment">// true	</span></span><br></pre></td></tr></table></figure>
<p>而这里我们创建了两个空对象，看起来都是空的对象，但他们并不相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;; <span class="comment">// 两个独立的对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a == b ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-克隆与合并"><a href="#1-3-克隆与合并" class="headerlink" title="1.3 克隆与合并"></a>1.3 克隆与合并</h3><p>如果想要复制一个全新对象，可以循环遍历原有的对象，然后建立新的对象并进行创建。</p>
<p>还可以使用 <code>Object.assign(dest, [src1, src2, src3...])</code> 来创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> permissions1 = &#123; <span class="attr">canView</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123; <span class="attr">canEdit</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span></span><br><span class="line"><span class="built_in">Object</span>.assign(user, permissions1, permissions2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果被拷贝的属性已经存在，怎会覆盖掉原有的属性。</p>
<p>以上的情况都是建立在对象的属性都是原始类型的情况下，但是有些对象可能包含其他的对象，如果使用<code>Object.assign()</code> 不会对深层的对象进行拷贝，而是引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  sizes: &#123;</span><br><span class="line">    height: <span class="number">182</span>,</span><br><span class="line">    width: <span class="number">50</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="built_in">Object</span>.assign(&#123;&#125;, user);</span><br><span class="line"></span><br><span class="line">alert( user.sizes === clone.sizes ); <span class="comment">// true，同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user 和 clone 分享同一个 sizes</span></span><br><span class="line">user.sizes.width++;       <span class="comment">// 通过其中一个改变属性值</span></span><br><span class="line">alert(clone.sizes.width); <span class="comment">// 51，能从另外一个获取到变更后的结果</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，并让 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。可以使用递归实现， 或者也可以使用现成的轮子， lodash 库的 <a href="https://lodash.com/docs/4.17.15#cloneDeep">_.cloneDeep(obj)</a>。</p>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p>
<p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。</p>
<p>为了创建“真正的拷贝”（一个克隆），我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(一)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%80)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-一"><a href="#JS笔记之JS对象基础知识-一" class="headerlink" title="JS笔记之JS对象基础知识(一)"></a>JS笔记之JS对象基础知识(一)</h1><p>js 对象是用来存储键值对或者更复杂的实体信息。</p>
<h2 id="1-创建空对象的两种方法"><a href="#1-创建空对象的两种方法" class="headerlink" title="1 创建空对象的两种方法"></a>1 创建空对象的两种方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// “构造函数” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;  <span class="comment">// “字面量” 的语法</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-创建对象"><a href="#1-1-创建对象" class="headerlink" title="1.1 创建对象"></a>1.1 创建对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;     <span class="comment">// 一个对象</span></span><br><span class="line">  name: <span class="string">&#x27;John&#x27;</span>,  <span class="comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span></span><br><span class="line">  age: <span class="number">30</span>,        <span class="comment">// 键 &quot;age&quot;，值 30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象属性的操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(user.age); <span class="comment">// 获取对象</span></span><br><span class="line">user.age = <span class="number">100</span>  <span class="comment">// 修改属性值</span></span><br><span class="line"><span class="keyword">delete</span> user.age <span class="comment">// 使用delete 删除对象的属性</span></span><br><span class="line">user.sex = <span class="string">&#x27;man&#x27;</span> <span class="comment">// 新增属性值</span></span><br></pre></td></tr></table></figure>
<p>创建对象也可以使用对个词语作为属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  <span class="string">&#x27;likes birds&#x27;</span>: <span class="literal">true</span>,  <span class="comment">// 多词属性名必须加引号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的最后一个属性应以逗号结尾，这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。</p>
<p>如果在对象中使用多词语属性，那么就不能使用【对象.属性】来获取对象的属性值， 必须使用方括号。</p>
<p>因为点符号要求是有效的变量标识符，所以不能包含空格、不以数字开头、也不包含特殊符号（除了<code>_</code>和<code>$</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(user[<span class="string">&quot;likes birds&quot;</span>]);</span><br></pre></td></tr></table></figure>


<h3 id="1-2-计算属性"><a href="#1-2-计算属性" class="headerlink" title="1.2 计算属性"></a>1.2 计算属性</h3><p>可以通获取变量来动态的创建对象属性，这叫做计算属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = prompt(<span class="string">&quot;Which fruit to buy?&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( bag.apple ); <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-属性值简写"><a href="#1-3-属性值简写" class="headerlink" title="1.3 属性值简写"></a>1.3 属性值简写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeUser</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    <span class="comment">// ……其他的属性</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = makeUser(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>在上述的例子中属性名和属性值一样，可以使用简写的形式，类似下面这种， 也可以进行混用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeUser</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name, <span class="comment">// 与 name: name 相同</span></span><br><span class="line">    age,  <span class="comment">// 与 age: age 相同</span></span><br><span class="line">    sex:<span class="string">&#x27;man&#x27;</span>, <span class="comment">// 简写与不简写混用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user = makeUser(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-属性名称限制"><a href="#1-4-属性名称限制" class="headerlink" title="1.4 属性名称限制"></a>1.4 属性名称限制</h3><p>在定义变量的时候， 我们不能使用js的一些和关键字保留字，但是在定义对象的属性时， 是可以使用的。所以对象的属性名是没有限制的，属性名可以是任意的字符串或者是symbol。例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;test&quot;</span> <span class="comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会输出相同的属性（数字 0 被转为字符串 &quot;0&quot;）</span></span><br><span class="line">alert( obj[<span class="string">&quot;0&quot;</span>] ); <span class="comment">// test</span></span><br><span class="line">alert( obj[<span class="number">0</span>] ); <span class="comment">// test (相同的属性)</span></span><br></pre></td></tr></table></figure>


<h3 id="1-5-属性存在性测试，-‘in’-操作符"><a href="#1-5-属性存在性测试，-‘in’-操作符" class="headerlink" title="1.5 属性存在性测试， ‘in’ 操作符"></a>1.5 属性存在性测试， ‘in’ 操作符</h3><p>在Python中获取一个对象的不存在的属性时会直接抛出异常，而js则不会，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_ex = &#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ex</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(dict_ex[<span class="string">&#x27;c&#x27;</span>])   <span class="comment"># 会直接提示  KeyError: &#x27;c&#x27;</span></span><br><span class="line">    Ex().c    <span class="comment"># 会直接提示  AttributeError: &#x27;Ex&#x27; object has no attribute &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">alert( user.noSuchProperty === <span class="literal">undefined</span> ); <span class="comment">// true 意思是没有这个属性</span></span><br></pre></td></tr></table></figure>
<p>检查属性是否存在的操作符 <code>&quot;in&quot;</code>，语法格式：<code>&#39;key&#39; in object</code> 例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;age&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// true，user.age 存在</span></span><br><span class="line">alert( <span class="string">&quot;blabla&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// false，user.blabla 不存在。</span></span><br></pre></td></tr></table></figure>
<p>使用<code>in</code> 和使用<code>===undefined</code> 判断属性是否存在的区别，那就是当一个对象的属性存在，但是他的值恰好就是<code>undefined</code>， 此时使用 <code>===undefined</code> 就无法准确地判断对象属性是否存在（这种情况也少之又少）。</p>
<h3 id="1-6-for…in-循环"><a href="#1-6-for…in-循环" class="headerlink" title="1.6 for…in 循环"></a>1.6 for…in 循环</h3><p>主要用来遍历对象的所有的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="comment">// 对此对象属性中的每个键执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-7-对象有顺序吗？"><a href="#1-7-对象有顺序吗？" class="headerlink" title="1.7 对象有顺序吗？"></a>1.7 对象有顺序吗？</h3><p>有但不多，对像中的<strong>整数的属性</strong>会被排序，以升序排列，其他的属性会按照创建的顺序显示。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;49&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">  <span class="string">&quot;41&quot;</span>: <span class="string">&quot;Switzerland&quot;</span>,</span><br><span class="line">  <span class="string">&quot;44&quot;</span>: <span class="string">&quot;Great Britain&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;1&quot;</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(code); <span class="comment">// 1, 41, 44, 49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数属性的解释：这里的“整数属性”指的是一个可以在<strong>不做任何更改</strong>的情况下与一个整数进行相互转换的字符串，像是 “+49” 或者是 “1.3342” 就不行了。</p>
<p>所以为了解决以上的例子，能够按属性的定义顺序输出可以在属性名前加一个<code>+</code>号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;+49&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+41&quot;</span>: <span class="string">&quot;Switzerland&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+44&quot;</span>: <span class="string">&quot;Great Britain&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;+1&quot;</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( +code ); <span class="comment">// 49, 41, 44, 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
































































]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>VitePress搭建文档网站</title>
    <url>/2022/11/30/VitePress%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>​            </p>
<a id="more"></a>

<h1 id="VitePress搭建文档"><a href="#VitePress搭建文档" class="headerlink" title="VitePress搭建文档"></a>VitePress搭建文档</h1><blockquote>
<p>在VitePress官方文档中指明它是基于Vite构建的一个VuePress的小兄弟，同时也对VuePress存在的几个问题进行一些改进：</p>
<ul>
<li> 更快</li>
<li> 使用Vue3</li>
<li> 更加轻巧</li>
</ul>
</blockquote>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p><a href="https://vitejs.cn/vitepress/guide/getting-started.html">以下步骤来自官网</a></p>
<p><strong>步骤 1:</strong> 创建并进入一个目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkdir vitepress-starter &amp;&amp; <span class="built_in">cd</span> vitepress-starter</span><br></pre></td></tr></table></figure>
<p><strong>步骤 2:</strong> 初始化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn init</span><br></pre></td></tr></table></figure>
<p><strong>步骤 3:</strong> 本地安装 VitePress</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn add --dev vitepress</span><br></pre></td></tr></table></figure>
<p><strong>步骤 4:</strong> 创建你第一篇文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkdir docs &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;# Hello VitePress&#x27;</span> &gt; docs/index.md</span><br></pre></td></tr></table></figure>
<p><strong>步骤 5:</strong> 在 <code>package.json</code>.添加一些<code>script</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;docs:dev&quot;</span>: <span class="string">&quot;vitepress dev docs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;docs:build&quot;</span>: <span class="string">&quot;vitepress build docs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;docs:serve&quot;</span>: <span class="string">&quot;vitepress serve docs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤 6:</strong> 在本地服务器上启动文档站点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn docs:dev</span><br></pre></td></tr></table></figure>
<p>VitePress 会在 <code>http://localhost:5173 </code>启动一个热重载的开发服务器。</p>
<h2 id="二、设置基本信息"><a href="#二、设置基本信息" class="headerlink" title="二、设置基本信息"></a>二、设置基本信息</h2><p>进入项目根目录，在根目录中有一个 <code>docs</code> 文件夹，进入并创建 <code>.vitepress</code> 文件夹。在 <code>.vitepress</code> 文件夹中创建VitePress的配置文件 <code>config.js</code>。</p>
<p>目录结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>


<p>在配置文件中为网站设置相关信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;网站标题&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;网站介绍&#x27;</span>,</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        logo: <span class="string">&quot;/logo.svg&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>themeConfig.logo </code>配置可以配置网站首页的图标, 需要指定图标文件在公共文件夹下。即在 <code>docs</code> 文件夹下新建 <code>public</code> 文件，然后将 <code>logo.svg</code> 存放在此文件夹下。一些公共图片等也都可以放在此文件夹下。</p>
<p><img src="https://tc.chaizz.com/d963f51c709711edb4470242ac190002.png"></p>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>


<h2 id="三、设置导航栏"><a href="#三、设置导航栏" class="headerlink" title="三、设置导航栏"></a>三、设置导航栏</h2><p>在 <code>config.js</code> 中配置 <code>themeConfig.nav</code> 设置导航栏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;网站标题&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;网站介绍&#x27;</span>,</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        logo: <span class="string">&quot;/logo.svg&quot;</span>,</span><br><span class="line">        nav: [</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&quot;Guide&quot;</span>,</span><br><span class="line">                items: [</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 1&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-1&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 2&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-2&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 3&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-3&#x27;</span>&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>nav</code> 是一个数组，每个元素代表一个导航栏标签，标签有两个属性 <code>text</code> 和 <code>link</code> 。</p>
<p><code>text</code> ：标签名<code>link</code> ：跳转的url。也可以使用下拉导航栏，例如上面中的示例。此时 <code>link</code> 元素改为 <code>items</code>，在 <code>items</code> 中是每个标签的属性。导航栏相对应的跳转url, 是在 <code>docs</code> 文件夹下创建同名的文件夹。</p>
<p><strong>非下拉导航栏</strong>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nav: [</span><br><span class="line">    &#123;</span><br><span class="line">        text: &quot;Guide&quot;,</span><br><span class="line">        link: &quot;&#x2F;guide&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--guide</span><br><span class="line">|	|	|--index.md</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>
<p><strong>下拉导航栏</strong>格式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nav: [</span><br><span class="line">    &#123;</span><br><span class="line">        text: <span class="string">&quot;Guide&quot;</span>,</span><br><span class="line">        items: [</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 1&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 2&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-2&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 3&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-3&#x27;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--guide</span><br><span class="line">|	|	|--guide-<span class="number">1.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">2.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">3.</span>md</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>


<h2 id="四、设置侧边栏"><a href="#四、设置侧边栏" class="headerlink" title="四、设置侧边栏"></a>四、设置侧边栏</h2><p>在 <code>config.js</code> 中配置 <code>themeConfig.sidebar</code> 设置侧边栏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;网站标题&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;网站介绍&#x27;</span>,</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        logo: <span class="string">&quot;/logo.svg&quot;</span>,</span><br><span class="line">        nav: [</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&quot;Guide&quot;</span>,</span><br><span class="line">                items: [</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 1&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-1&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 2&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-2&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 3&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-3&#x27;</span>&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        sidebar: [</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&quot;web&quot;</span>,</span><br><span class="line">                items: [</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&quot;js&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/js/&quot;</span>,&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&quot;css&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/css/&quot;</span>&#125;,</span><br><span class="line">                ],</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>sidebar</code> 和 <code>nav</code> 设置方式一致，二级菜单使用 <code>items</code> 设置。</p>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--guide</span><br><span class="line">|	|	|--guide-<span class="number">1.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">2.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">3.</span>md</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--css</span><br><span class="line">|	|	|--index.md</span><br><span class="line">|	|--js</span><br><span class="line">|	|	|--index.md</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>VitePress</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Js事件</title>
    <url>/2022/10/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="事件冒泡及捕获"><a href="#事件冒泡及捕获" class="headerlink" title="事件冒泡及捕获"></a>事件冒泡及捕获</h1><p>js的事件冒泡和捕获是两种机制，主要描述一个元素上有两个相同类型的事件处理器被激活会发生什么。</p>
<p>例如该例子：<a href="https://github.com/mdn/learning-area/blob/main/javascript/building-blocks/events/show-video-box.html">源码</a></p>
<p>他显示和隐藏一个包含 <video> 元素的 <div> 元素。</div></video></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Display video<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.mp4&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.webm&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn&#x27;t support HTML video. Here is a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>link to the video<span class="tag">&lt;/<span class="name">a</span>&gt;</span> instead.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>当<code>button</code>元素按钮被单击时，他将显示视频，其实改变<code>div</code>的<code>class</code>属性值从<code>hidden</code>变<code>showing</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> videoBox = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayVideo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (videoBox.getAttribute(<span class="string">&#x27;class&#x27;</span>) === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">        videoBox.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;showing&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, displayVideo);</span><br></pre></td></tr></table></figure>
<p>当我们再添加几个<code>click</code>事件处理器，第一个添加在<code>&lt;div&gt;</code>元素上，第二个添加在<code>&lt;video&gt;</code>元素上。这个想法是当视频 (<code>&lt;video&gt;</code>）外 <code>&lt;div&gt;</code>元素内这块区域被单击时，这个视频盒子应该再次隐藏；当单击视频 (<code>&lt;video&gt;</code>）本身，这个视频将开始播放。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">videoBox.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> videoBox.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;hidden&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line"></span><br><span class="line">video.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> video.play());</span><br></pre></td></tr></table></figure>


<h2 id="1-问题就出现了"><a href="#1-问题就出现了" class="headerlink" title="1 问题就出现了"></a>1 问题就出现了</h2><p>当点击<code>video</code>开始播放视频时，<code>div</code>被隐藏， 这是因为<code>video</code>在<code>div</code>之内，所以点击<code>video</code>实际上也同时运行了<code>div</code>上的事件处理程序。</p>
<p>综合以上示例：</p>
<p>当一个事件发生在具有父元素的元素上（本例子的video元素）时，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。</p>
<p>在捕获阶段：</p>
<ul>
<li>浏览器检查元素的最外层祖先<code>html</code>，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。</li>
<li>然后，他移动到<code>html</code>中点击元素的下一个祖先元素，并执行相同的操作，接下来是点击元素再下一个祖先元素，以此类推，直到到达实际点击的元素。</li>
</ul>
<p>在冒泡阶段恰恰相反：</p>
<ul>
<li>浏览器检查实际点击的元素是否在冒泡阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它。</li>
<li>然后他移动到下一个直接的祖先元素，并做同样的事情，再到下一个祖先元素，直到他到达<code>html</code>元素。</li>
</ul>
<p><strong>在现代浏览器中，默认情况下，所有的时间处理程序，都是在冒泡阶段进行注册。</strong> 因此上述例子当我们点击视频时，这个单击事件从<code>video</code>元素向外冒泡直到<code>html</code>元素，沿着这个事件冒泡线路：</p>
<ul>
<li>首先发现了<code>video.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>第一次开始播放。</li>
<li>接着还发现了<code>videoBox.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>也隐藏起来了。</li>
</ul>
<h2 id="2-解决方法："><a href="#2-解决方法：" class="headerlink" title="2 解决方法："></a>2 解决方法：</h2><p>标准事件对象具有可用的名为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>stopPropagation()</code></a>的函数，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在<strong>冒泡</strong>链上进一步扩大，因此将不会有更多事件处理器被运行 (不会向上冒泡)。所以，我们可以通过改变前面代码块中的第二个处理函数来解决当前的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line">video.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> video.play());</span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">video.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    video.play();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>注：</strong>如上所述，默认情况下，所有事件处理程序都是在冒泡阶段注册的，这在大多数情况下更有意义。如果您真的想在捕获阶段注册一个事件，那么可以通过使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>注册您的处理程序，并将可选的第三个属性设置为 true。</p>
<h2 id="3-延伸"><a href="#3-延伸" class="headerlink" title="3 延伸"></a>3 延伸</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>正式因为冒泡的机制， 所以我们可以利用该机制，实现下面这样的行为：如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。这种行为称之为事件委托。这个概念的更多的例子-<a href="https://davidwalsh.name/event-delegate">How JavaScript Event Delegation Works</a>。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS异步编程之Promise</title>
    <url>/2022/10/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8BPromise/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><blockquote>
<p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p>
</blockquote>
<p>浏览器在执行js代码时，是按照书写的顺序一行一行的执行，会等待代码的解析和工作，在上一行执行完毕后才会执行下一行。执行同步函数时也是如此。</p>
<p>单当遇到一个耗时的同步函数时，操作会非常消耗时间且我们无法做其他事情。</p>
<p>我们希望我们的程序可以：</p>
<ul>
<li>通过调用一个函数来启动一个长期运行的操作。</li>
<li>然函数开始 操作时立即返回，这样我们的程序就可以保持对其他事件做出反应能力。</li>
<li>单操作完成时通知我们操作的结果。</li>
</ul>
<p>以上的功能是异步寒函数为我们提供的能力。</p>
<p>我们常见的事件处理程序就是异步编程的一种形式。即提供的函数，将在事件发生时被调用（而不是立即被用用），如果事件操作已经完成，那么就可以看到事件是如何被用来通知调用者异步函数调用的结果的。</p>
<p>例如一些早期的API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>,可以通过给 <code>XMLHttpRequest</code> 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。</p>
<p>事件处理程序是一种特殊的回调函数，而回调函数则是一个被传递到另一个函数中的会在合适的时候被调用的函数。回调函数曾经是 JavaScript 中实现异步函数的主要方式。</p>
<p>然而回调函数本身也接受被回调，基于回调的代码则会非常难理解。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep1</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = init + <span class="number">1</span>;</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep2</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = init + <span class="number">2</span>;</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep3</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = init + <span class="number">3</span>;</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doOperation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doStep1(<span class="number">0</span>, <span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        doStep2(result1, <span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">            doStep3(result2, <span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`结果：<span class="subst">$&#123;result3&#125;</span>`</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doOperation();</span><br></pre></td></tr></table></figure>
<p>由于以上原因大多数现代的异步API都不使用回调，事实上JS中的异步编程的基础是 Promise 。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 是现代js中异步编程的基础，是一个由异步函数返回的 可以向我们指示当前操作所处的 对象的状态。在 Promise 返回给调用者的时候，操作往往还没有完成，但是 Promise 对象可以让我们操作最终完成时对其处理（无论成功还是失败）。</p>
<p>在基于 Promise 的API中，异步函数会启动操作并返回 Promise 对象，然后，你可以将处理函数附加到 Promise 对象上，当操作完成时（成功或者失败），这些处理函数将会执行。</p>
<p>示例：使用fetch()API 来解释promise。</p>
<p>打开网站：<a href="https://example.org/">https://example.org</a> 在控制台中输入以下的代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 fetch() API，并将返回值赋给 fetchPromise 变量。</span></span><br><span class="line">const fetchPromise = fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧接着，输出 fetchPromise 变量，输出结果应该像这样：Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;。这告诉我们有一个 Promise 对象，它有一个 state属性，值是 &quot;pending&quot;。&quot;pending&quot; 状态意味着操作仍在进行中。</span></span><br><span class="line">console.log(fetchPromise);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个处理函数传递给 Promise 的 then() 方法。当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 Response 对象。</span></span><br><span class="line">fetchPromise.then( response =&gt; &#123;</span><br><span class="line">  console.log(`已收到响应：$&#123;response.status&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出一条信息，说明我们已经发送了这个请求。</span></span><br><span class="line">console.log(&quot;已发送请求……&quot;);</span><br></pre></td></tr></table></figure>
<p>控制台的响应结果应该是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123; &lt;state&gt;: <span class="string">&quot;pending&quot;</span> &#125;</span><br><span class="line">已发送请求……</span><br><span class="line">已收到响应：<span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到已发送请求在响应之前输出了，如果是同步函数，则会在最后返回【已发送请求……】。</p>
<p>当通过 fetch()API得到一个Response对象时，需要调用另一个函数来接受这个响应，这次我们想要得到json格式的数据，可以调用Response.json()方法。 json()也是也是一个异步函数，因此我们连续调用两个异步函数。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const fetchPromise = fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line">fetchPromise.then( response =&gt; &#123;</span><br><span class="line">  const jsonPromise = response.json();</span><br><span class="line">  jsonPromise.then( json =&gt; &#123;</span><br><span class="line">    console.log(json);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>在这个示例中fetch()返回的 Promise 对象的then()方法，调用了response.json()方法，json()同样返回了一个 Promise 对象。 jsonPromise的then()方法输出了json的内容。</p>
<p>以上的代码看起来和之前的多层级回调差不多，确实是这样。但是 Promise 的优雅之处在于then()也是返回一个 Promise 对象，这个 Promise 将指示 <code>then()</code> 中调用的异步函数的完成状态。这意味着我们可以（当然也应该）把上面的代码改写成这样：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const fetchPromise = fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        return response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(json =&gt; &#123;</span><br><span class="line">        console.log(json[0].name);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<p>我们不必在第一个then()方法里面写另外一个then()方法，我们可以直接返回json()返回的 Promise ,并且在改返回值上调用第二个then()，这种调用方式叫做<strong>Promise链</strong>。意味着当我们连续调用异步函数的时候就可以避免嵌套带来的代码不美观易懂。</p>
<h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><p>上述的一个response请求示例是一个理想的代码，因为没有添加异常的处理。Promise 对象中提供了一个catch()方法来处理错误，她很像then()，可以调用它并传入一个处理函数。然后，当异步操作<em>成功</em>时，传递给then()的处理函数被调用，而当异步操作<em>失败</em>时，传递给catch()的处理函数被调用。</p>
<p>如果将catch()添加到 Promise 链的末尾，它就可以在任何异步函数失败时被调用。于是，我们就可以将一个操作实现为几个连续的异步函数调用，并在一个地方处理所有错误。</p>
<p>例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const fetchPromise = fetch(&#x27;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        if (!response.ok) &#123;</span><br><span class="line">            throw new Error(`HTTP 请求错误：$&#123;response.status&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">        return response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(json =&gt; &#123;</span><br><span class="line">        console.log(json[0].name);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">        console.error(`无法获取产品列表：$&#123;error&#125;`);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<h2 id="Promise-术语"><a href="#Promise-术语" class="headerlink" title="Promise 术语"></a>Promise 术语</h2><p>首先 Promise 有三种状态：</p>
<ul>
<li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。这是调用fetch()返回 Promise 时的状态，此时请求还在进行中。</li>
<li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。当 Promise 完成时，它的then()处理函数被调用。</li>
<li><strong>已拒绝（rejected）</strong>：意味着操作失败。当一个 Promise 失败时，它的catch()处理函数被调用。</li>
</ul>
<p>有时我们用 <strong>已敲定（settled）</strong> 这个词来同时表示 <strong>已兑现（fulfilled）</strong> 和 <strong>已拒绝（rejected）</strong> 两种情况。</p>
<p>如果一个 Promise 处于已决议（resolved）状态，或者它被“锁定”以跟随另一个 Promise 的状态，那么它就是 <strong>已兑现（fulfilled）</strong>。</p>
<p>文章 <a href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/">Let’s talk about how to talk about promises</a> 对这些术语的细节做了很好的解释。</p>
<blockquote>
<p>注：这里的成功或者失败取决于使用的API。例如：fetch()认为服务器返回一个错误（如<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404">404 Not Found</a>）时请求成功，但如果网络错误阻止请求被发送，则认为请求失败。</p>
</blockquote>
<p>文章 <a href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/">Let’s talk about how to talk about promises</a> 对这些术语的细节做了很好的解释。</p>
<h2 id="合并使用多个-Promise"><a href="#合并使用多个-Promise" class="headerlink" title="合并使用多个 Promise"></a>合并使用多个 Promise</h2><p>当操作有几个异步函数组成时，而且需要在下一个函数开始之前完成每一个函数，需要的就是 Promise 链。但是在其他的一些情况下，可能需要合并多个异步函数的调用。</p>
<p>有时你需要所有的 Promise 都得到实现，但它们并不相互依赖。在这种情况下，==将它们一起启动然后在它们全部被兑现后得到通知会更有效率==。这里需要 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> 方法。它接收一个 Promise 数组，并返回一个单一的 Promise。</p>
<p>由 Promise.all() 返回的 Promise 有以下的特性：</p>
<p>1、当且仅当数组中所有的 Promise都被兑现时，才会通知then()函数，并提供一个包含所有响应的数组，数组中响应的顺序与被传入all()的 Promise 相等。</p>
<p>2、会被拒绝–如果数组中任何一个 Promise 被拒绝，此时 catch()处理函数被调用，并提供被拒绝的 Promise 所抛出的错误。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise1 = fetch(<span class="string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fetchPromise2 = fetch(<span class="string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fetchPromise3 = fetch(<span class="string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([fetchPromise1, fetchPromise2, fetchPromise3])</span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> response <span class="keyword">of</span> responses) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`获取失败：<span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>有时，可能需要等待一组 Promise 中的某一个 Promise 的执行，而不关心是哪一个。在这种情况下，你需要 Promise.any()这就像Promise.all()，不过在 Promise 数组中的任何一个被兑现时它就会被兑现，如果所有的 Promise 都被拒绝，它也会被拒绝。</p>
<blockquote>
<p>注：在这种情况下，我们无法预测哪个获取请求会先被兑现。</p>
</blockquote>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 关键字提供了一种更简单的方法来处理基于异步 Promise 的代码，在一个函数的开头添加 async 可以使其成为一个异步函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在异步函数中，可以在调用一个返回 Promise 的函数之前使用 <code>await</code> 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProducts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span></span><br><span class="line">        <span class="comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`HTTP 请求错误：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span></span><br><span class="line">        <span class="comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span></span><br><span class="line">        <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">        <span class="built_in">console</span>.log(json[<span class="number">0</span>].name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`无法获取产品列表：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchProducts();</span><br></pre></td></tr></table></figure>
<p>上面的代码使用await关键字 让异步函数想同步函数一样去执行，但是，即使像同步函数那样也无法使用下面那样的代码进行操作：(因为异步函数总是返回一个 Promise)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">async function fetchProducts() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const response = await fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line">        if (!response.ok) &#123;</span><br><span class="line">            throw new Error(`HTTP 请求错误：$&#123;response.status&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">        const json = await response.json();</span><br><span class="line">        return json;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.error(`无法获取产品列表：$&#123;error&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const json = fetchProducts();</span><br><span class="line">console.log(json[0].name);   // json 是一个 Promise 对象，因此这句代码无法正常工作</span><br></pre></td></tr></table></figure>


<p>但是我们可以这样做：(因为异步函数返回一个 Promise 可以调用.then()方法)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">async function fetchProducts() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const response = await fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line">        if (!response.ok) &#123;</span><br><span class="line">            throw new Error(`HTTP 请求错误：$&#123;response.status&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">        const json = await response.json();</span><br><span class="line">        return json;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.error(`无法获取产品列表：$&#123;error&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const jsonPromise = fetchProducts();</span><br><span class="line">jsonPromise.then((json) =&gt; console.log(json[0].name));</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在实际开发过程中可能会在 Promise 链的地方使用async函数， await将会强制异步操作以串联的形式工作。如果下一个操作的结果取决于上一个操作的结果，这是非常必要的，反之 Promise.all() 这样的操作会有更好的性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Promise 是现代JavaScript异步编程的基础，他避免的深度嵌套，是表达和理解异步操作变的更加容易，并且还支持一种类似于同步编程中 <code>try...catch</code> 语句的错误处理方式。</p>
<p><code>async</code> 和 <code>await</code> 关键字使得从一系列连续的异步函数调用中建立一个操作变得更加容易，避免了创建显式 Promise 链，并允许你像编写异步代码那样编写同步代码。</p>
<p>Promise 在所有现代浏览器的最新版本中都可以使用；唯一会出现支持问题的地方是 Opera Mini 和 IE11 及更早的版本。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Js代码调用策略</title>
    <url>/2022/10/12/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="Js代码调用策略"><a href="#Js代码调用策略" class="headerlink" title="Js代码调用策略"></a>Js代码调用策略</h1><p>javascript代码位置和css一样，可以设置为内部样式、内联样式、外部样式。HTML代码渲染是由上而下加载，js代码的位置可能会导致js获取DOM元素时，无法获取未渲染的HTML标签，从而引发错误。</p>
<p>想要脚本调用的时候符合预期，需要解决一系列问题。</p>
<p>例如当js代码处于文档头处，解析HTML文档体之前。这样做是有隐患的，需要使用一些结构来避免错误发生。</p>
<h2 id="1-使用-DOMContentLoaded-解决"><a href="#1-使用-DOMContentLoaded-解决" class="headerlink" title="1 使用 DOMContentLoaded 解决"></a>1 使用 DOMContentLoaded 解决</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是一个事件监听器，他监听浏览器的<strong>DOMContentLoaded</strong>事件，即HTML加载、解释完毕事件。事件将触发 … 的代码，从而避免了错误发生。</p>
<h2 id="2-使用-async-解决"><a href="#2-使用-async-解决" class="headerlink" title="2 使用 async 解决"></a>2 使用 async 解决</h2><p>在调用外部js代码时可以使用js的一项现代技术（async）来解决这一问题，他告知浏览器在遇到<javascript> 元素时不用中断后续HTML内容的加载。</javascript></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> 外部脚本 async 属性可以解决调用顺序问题，但是async只适用于外部脚本。</p>
<p>一般解决此问题的旧方法是：把脚本元素放在底部，这样脚本就可以再HTML内容解析之后加载了。这种方案和上面 DOMContentLoaded 的问题是：==只有在所有 HTML DOM 加载完成后才开始脚本的加载/解析过程。对于有大量 JavaScript 代码的大型网站，可能会带来显著的性能损耗。这也是 async 属性诞生的初衷。==</p>
<h2 id="3-async-和-defer"><a href="#3-async-和-defer" class="headerlink" title="3 async 和 defer"></a>3 async 和 defer</h2><p>上述的脚本阻塞问题实际有两种解决方案 —— <code>async</code> 和 <code>defer</code>。</p>
<p>浏览器遇到acync脚本时不会阻塞渲染HTML，而是直接下载然后运行，这样脚本的执行顺序就无法把控，仅仅是脚本不会阻止剩余页面的渲染。当页面和脚本之间独立，且不依赖于本页面的其它任何脚本时，<code>async</code> 是最理想的选择。</p>
<p>比如页面有多个脚本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;js/script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;js/script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>三者的调用顺序是不一定的，<code>jquery</code> 可能在 <code>script2</code> 和 <code>script3</code> 之后调用，如果这样的话，后两个脚本中依赖 <code>jquery</code> 的函数将产生错误，因为脚本运行时 <code>jquery</code> 尚未加载。</p>
<p>解决这一问题可使用 <code>defer</code> 属性，脚本将按照在页面中出现的顺序加载和运行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code> 必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code> 之前。</p>
<p>总结：</p>
<ul>
<li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li>
<li>如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 4 安装注册</title>
    <url>/2022/10/11/Sublime%20Text4%20%E5%AE%89%E8%A3%85%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p>​                     </p>
<a id="more"></a>

<h1 id="sublime-text-4-注册方法"><a href="#sublime-text-4-注册方法" class="headerlink" title="sublime text 4 注册方法"></a>sublime text 4 注册方法</h1><blockquote>
<p>Sublime Text 是一个文本<a href="https://baike.baidu.com/item/%E7%BC%96%E8%BE%91%E5%99%A8/9067697?fromModule=lemma_inlink">编辑器</a>（收费<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053?fromModule=lemma_inlink">软件</a>，可以无限期试用），同时也是一个先进的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048?fromModule=lemma_inlink">代码</a>编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的<a href="https://baike.baidu.com/item/Vim?fromModule=lemma_inlink">Vim</a>。</p>
</blockquote>
<h2 id="1-sublime-text-4-最新激活方法-版本4143"><a href="#1-sublime-text-4-最新激活方法-版本4143" class="headerlink" title="1 sublime text 4 最新激活方法 (版本4143)"></a>1 sublime text 4 最新激活方法 (版本4143)</h2><ol>
<li>打开网站 <a href="https://hexed.it/">hexed.it</a>。在网站上面导航栏左上角点击打开文件，选择sublime text 安装文件夹下的 <code>sublime_text.exe</code>。</li>
<li>按下 ctrl+f 搜索，在网站右侧边栏搜索输入框输入： <code>80 78 05 00 0f 94 c1</code> 。</li>
<li>在网站右侧边栏，搜索方案中选择启动替换，在替换输入框中输入 <code>c6 40 05 01 48 85 c9</code>，只需替换一次。</li>
<li>点击网站上面导航栏中的另存为，直接替换原有的<code>sublime_text.exe</code>文件。</li>
<li>再次打开 sublime text 4 即可查看已注册成功。</li>
</ol>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2023-02-07_09-37-52.png"></p>
<h2 id="2-sublime-text-4-激活方法-版本4126-（已失效）"><a href="#2-sublime-text-4-激活方法-版本4126-（已失效）" class="headerlink" title="2 sublime text 4 激活方法(版本4126) （已失效）"></a>2 sublime text 4 激活方法(版本4126) （已失效）</h2><p>注册码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">—– BEGIN LICENSE —–</span><br><span class="line"></span><br><span class="line">Mifeng User</span><br><span class="line"></span><br><span class="line">Single User License</span><br><span class="line"></span><br><span class="line">EA7E-1184812</span><br><span class="line"></span><br><span class="line">C0DAA9CD 6BE825B5 FF935692 1750523A</span><br><span class="line"></span><br><span class="line">EDF59D3F A3BD6C96 F8D33866 3F1CCCEA</span><br><span class="line"></span><br><span class="line">1C25BE4D 25B1C4CC 5110C20E 5246CC42</span><br><span class="line"></span><br><span class="line">D232C83B C99CCC42 0E32890C B6CBF018</span><br><span class="line"></span><br><span class="line">B1D4C178 2F9DDB16 ABAA74E5 95304BEF</span><br><span class="line"></span><br><span class="line">9D0CCFA9 8AF8F8E2 1E0A955E 4771A576</span><br><span class="line"></span><br><span class="line">50737C65 325B6C32 817DCB83 A7394DFA</span><br><span class="line"></span><br><span class="line">27B7E747 736A1198 B3865734 0B434AA5</span><br><span class="line"></span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>flask常用扩展</title>
    <url>/2022/08/30/Flask%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>​                  </p>
<a id="more"></a>

<h1 id="Flask-常用扩展"><a href="#Flask-常用扩展" class="headerlink" title="Flask 常用扩展"></a>Flask 常用扩展</h1><h2 id="1-Flask-Cors"><a href="#1-Flask-Cors" class="headerlink" title="1 Flask-Cors"></a>1 Flask-Cors</h2><p>用于处理跨域资源共享的扩展。 <a href="https://flask-cors.corydolphin.com/en/latest/api.html">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -U flask-cors</span><br></pre></td></tr></table></figure>


<h2 id="2-Flask-Limiter-Memcached"><a href="#2-Flask-Limiter-Memcached" class="headerlink" title="2 Flask-Limiter Memcached"></a>2 Flask-Limiter Memcached</h2><p>给接口提供速率限制，可以设置各种后端配置来提供限制功能，如：Redis、MongoDB、Memcached、In-Memory（在内存中限制）。<a href="https://flask-limiter.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-Limiter</span><br></pre></td></tr></table></figure>


<h2 id="3-Flask-JWT-Extended"><a href="#3-Flask-JWT-Extended" class="headerlink" title="3 Flask-JWT-Extended"></a>3 Flask-JWT-Extended</h2><p>添加了flask的JWT支持，且增加了其他的功能：自动加载用户、自定义声明验证Token等。<a href="https://flask-jwt-extended.readthedocs.io/en/stable/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-JWT-Extended</span><br></pre></td></tr></table></figure>


<h2 id="4-flask-marshmallow"><a href="#4-flask-marshmallow" class="headerlink" title="4 flask-marshmallow"></a>4 flask-marshmallow</h2><p>用户python对象的一个序列化反序列换的库。在flask中可与 Flask-SQLAlchemy集成。<a href="https://flask-marshmallow.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install flask-marshmallow</span><br></pre></td></tr></table></figure>


<h2 id="5-Flask-SQLAlchemy"><a href="#5-Flask-SQLAlchemy" class="headerlink" title="5 Flask-SQLAlchemy"></a>5 Flask-SQLAlchemy</h2><p>flask的一个orm扩展。<a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure>


<h2 id="6-marshmallow-sqlalchemy"><a href="#6-marshmallow-sqlalchemy" class="headerlink" title="6 marshmallow-sqlalchemy"></a>6 marshmallow-sqlalchemy</h2><p>sqlalchemy与marshmallow的集成，用于对orm对象的序列化与反序列化。<a href="https://marshmallow-sqlalchemy.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install marshmallow-sqlalchemy</span><br></pre></td></tr></table></figure>


<h2 id="7-Fask-Migrate"><a href="#7-Fask-Migrate" class="headerlink" title="7 Fask-Migrate"></a>7 Fask-Migrate</h2><p>使用 Alembic 为 Flask 应用程序处理 SQLAlchemy 数据库迁移。<a href="https://flask-migrate.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-Migrate</span><br></pre></td></tr></table></figure>


<h2 id="8-Flask-Admin"><a href="#8-Flask-Admin" class="headerlink" title="8 Flask-Admin"></a>8 Flask-Admin</h2><p>类似Django-admin的一个后台管理页面。<a href="https://flask-admin.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-Admin</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS转换过渡和动画</title>
    <url>/2022/08/24/CSS%E8%BD%AC%E6%8D%A2%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>​                 </p>
<a id="more"></a>

<h1 id="CSS转换过渡和动画"><a href="#CSS转换过渡和动画" class="headerlink" title="CSS转换过渡和动画"></a>CSS转换过渡和动画</h1><p>转换可以对元素进行移动、缩放、转动、拉伸。转换的效果是让某个元素改变形状，大小和位置。可以使用2D和3D来转换元素，</p>
<h2 id="1-2D转换"><a href="#1-2D转换" class="headerlink" title="1 2D转换"></a>1 2D转换</h2><h3 id="1-1-平移-translate"><a href="#1-1-平移-translate" class="headerlink" title="1.1 平移 translate"></a>1.1 平移 translate</h3><p>根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：是从左边元素移动50个像素，并从顶部移动100像素。</p>
<h3 id="1-2-旋转-rotate"><a href="#1-2-旋转-rotate" class="headerlink" title="1.2 旋转 rotate"></a>1.2 旋转 rotate</h3><p>顺时针旋转的角度。负值是逆时针旋转。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：将元素顺时针旋转30度。</p>
<h3 id="1-3-缩放-scale"><a href="#1-3-缩放-scale" class="headerlink" title="1.3 缩放 scale"></a>1.3 缩放 scale</h3><p>增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">/* 标准语法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：将元素转变宽度为原来的大小的2倍，和其原始大小3倍的高度。</p>
<h3 id="1-4-倾斜-skew"><a href="#1-4-倾斜-skew" class="headerlink" title="1.4 倾斜 skew"></a>1.4 倾斜 skew</h3><p>包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：将元素在X轴和Y轴上倾斜20度30度。</p>
<h3 id="1-5-以上方法的缩写-matrix"><a href="#1-5-以上方法的缩写-matrix" class="headerlink" title="1.5 以上方法的缩写 matrix"></a>1.5 以上方法的缩写 matrix</h3><p>matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。</p>
<p>表示以下函数：matrix( scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY() )</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-CSS-过渡"><a href="#2-CSS-过渡" class="headerlink" title="2 CSS 过渡"></a>2 CSS 过渡</h2><h3 id="2-1-transition-使某种想过转变到另一种效果。"><a href="#2-1-transition-使某种想过转变到另一种效果。" class="headerlink" title="2.1 transition 使某种想过转变到另一种效果。"></a>2.1 transition 使某种想过转变到另一种效果。</h3><ul>
<li>transition-property 应用过渡的CSS属性。</li>
<li>transition-duration 过渡的CSS时间，默认是0。</li>
<li>transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。</li>
<li>transition-delay    规定过渡效果何时开始。默认是 0 （立即开始）。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transition-property</span>: width;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br><span class="line">    <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">-webkit-transition-property</span>:width;</span><br><span class="line">    <span class="attribute">-webkit-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition-timing-function</span>:linear;</span><br><span class="line">    <span class="attribute">-webkit-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-transition-以上属性简写"><a href="#2-2-transition-以上属性简写" class="headerlink" title="2.2 transition 以上属性简写"></a>2.2 transition 以上属性简写</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">    <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">-webkit-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-CSS-动画"><a href="#3-CSS-动画" class="headerlink" title="3 CSS 动画"></a>3 CSS 动画</h2><p>动画是使元素从一种样式逐渐变化为另一种样式的效果，可以改变任意多的样式任意多的次数。</p>
<p>使用百分比来规定变化发生的时间，或者使用关键字<code>from</code>和<code>to</code>等同于0%和100%。为了有更好的体验，应该使用定义0%和100%。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span>; <span class="comment">/* Safari 与 Chrome */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> myfirst &#123;</span><br><span class="line">    0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">    25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">    50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">    100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> myfirst /* Safari 与 Chrome */ &#123;</span><br><span class="line">    0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">    25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">    50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">    100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-animation-相关属性"><a href="#3-1-animation-相关属性" class="headerlink" title="3.1 animation 相关属性"></a>3.1 animation 相关属性</h3><ul>
<li>@keyframes    规定动画规则。</li>
<li>animation-name    规定 @keyframes 动画的名称。    </li>
<li>animation-duration    规定动画完成一个周期所花费的秒或毫秒。默认是 0。    </li>
<li>animation-timing-function    规定动画的速度曲线。默认是 “ease”。    </li>
<li>animation-fill-mode    规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。    </li>
<li>animation-delay    规定动画何时开始。默认是 0。    </li>
<li>animation-iteration-count    规定动画被播放的次数。默认是 1。    </li>
<li>animation-direction    规定动画是否在下一周期逆向地播放。默认是 “normal”。    </li>
<li>animation-play-state    规定动画是否正在运行或暂停。默认是 “running”</li>
</ul>
<h3 id="3-2-设置所有属性示例"><a href="#3-2-设置所有属性示例" class="headerlink" title="3.2 设置所有属性示例"></a>3.2 设置所有属性示例</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: myfirst;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">    <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">    <span class="comment">/* Safari 与 Chrome: */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: myfirst;</span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">-webkit-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: infinite;</span><br><span class="line">    <span class="attribute">-webkit-animation-direction</span>: alternate;</span><br><span class="line">    <span class="attribute">-webkit-animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简写示例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">    <span class="comment">/* Safari 与 Chrome: */</span></span><br><span class="line">    <span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


























































]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS媒体查询</title>
    <url>/2022/08/22/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>



<h1 id="CSS媒体查询"><a href="#CSS媒体查询" class="headerlink" title="CSS媒体查询"></a>CSS媒体查询</h1><p>CSS 媒体查询为你提供了一种应用 CSS 的方法，仅在浏览器和设备的环境与你指定的规则相匹配的时候 CSS 才会真的被应用</p>
<p>媒体查询是响应式 Web 设计的关键部分，因为它允许你按照视口的尺寸创建不同的布局，不过它也可以用来探测和你的站点运行的环境相关联的其它条件，比如用户是在使用触摸屏还是鼠标。</p>
<h2 id="1-媒体查询基础"><a href="#1-媒体查询基础" class="headerlink" title="1 媒体查询基础"></a>1 媒体查询基础</h2><p>最简单的媒体查询语法看起来是像这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> media-type <span class="keyword">and</span> (media-feature-rule) &#123;</span><br><span class="line">  <span class="comment">/* CSS rules go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它由以下部分组成：</p>
<ul>
<li>一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；</li>
<li>一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试；</li>
<li>一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。</li>
</ul>
<h2 id="2-媒体类型"><a href="#2-媒体类型" class="headerlink" title="2 媒体类型"></a>2 媒体类型</h2><ul>
<li>all：适用于所有设备。</li>
<li>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档。</li>
<li>screen：主要用于屏幕。</li>
<li>speech：主要用于语音合成器</li>
</ul>
<h2 id="3-媒体特征规则"><a href="#3-媒体特征规则" class="headerlink" title="3 媒体特征规则"></a>3 媒体特征规则</h2><h3 id="3-1宽和高-width-height"><a href="#3-1宽和高-width-height" class="headerlink" title="3.1宽和高 width height"></a>3.1宽和高 width height</h3><p>为了建立响应式设计（已经广受浏览器支持），我们一般最常探测的特征是视口宽度，而且我们可以使用min-width、max-width和width媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用 CSS。</p>
<p>在实践中一般比较常用的是 min- 和 max- </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-朝向-orientation"><a href="#3-2-朝向-orientation" class="headerlink" title="3.2 朝向 orientation"></a>3.2 朝向 orientation</h3><p>可以用它测得竖放（portrait）模式 和横放（landscape）模式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准的桌面视图是横放朝向的，在这种朝向上能够表现良好的设计，在处于竖放模式的手机或平板电脑上可能不会表现得这么好。对朝向的测试可以帮你建立一个为竖放设备优化的布局。</p>
<h3 id="3-3-使用可指点设备（可悬浮在元素上）"><a href="#3-3-使用可指点设备（可悬浮在元素上）" class="headerlink" title="3.3 使用可指点设备（可悬浮在元素上）"></a>3.3 使用可指点设备（可悬浮在元素上）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">hover:</span> hover) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-复杂的媒体查询"><a href="#4-复杂的媒体查询" class="headerlink" title="4 复杂的媒体查询"></a>4 复杂的媒体查询</h2><p>使用与、或、非组合上面的媒体查询逻辑。</p>
<p>规则：body 的文字只会在viewport至少为 400 像素宽，且设备横放时应用变为蓝色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。</p>
<p>规则：body会在viewport至少为 400 像素宽的时候<strong>或者</strong>设备处于横放状态的时候应用变为蓝色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用not`操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局-弹性盒子与网格布局</title>
    <url>/2022/08/22/CSS%E5%B8%83%E5%B1%80-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E4%B8%8E%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS布局-弹性盒子与网格布局"><a href="#CSS布局-弹性盒子与网格布局" class="headerlink" title="CSS布局-弹性盒子与网格布局"></a>CSS布局-弹性盒子与网格布局</h1><p>css的布局技术可以让我们控制他们的相对正常布局流、周边元素、父容器或者主视口/窗口的位置。常见的布局形式有：正常布局流、display属性布局、弹性盒子布局、网格布局、浮动布局、定位布局、表格布局、多列布局。</p>
<p>每种技术都有他们的用途，通过理解各个布局的相关理念，构建理想的布局方案。</p>
<p>一些布局技术会覆盖默认的布局技术；</p>
<p>display：默认的一些属性<code>inline</code>、<code>block</code>、<code>inline-block</code>在正常布局流中的表现形式为对应的盒模型的属性。</p>
<p>在CSS中实现页面的布局的主要方法是设定<code>display</code>的值，正常的布局流中所有的属性都有一个<code>display</code>的值，例如在段落下面显示另外一个段落，是因为他的<code>display</code>的值是<code>block</code>吗，如果在段落中添加了一个连接，这个段落并不会换行，是应为连接<code>a</code>的<code>display</code>的属性值是<code>inline</code>。</p>
<p>在讨论布局时，最重要的两个值是<code>display</code>:<code>flex</code>和<code>display</code>:<code>grid</code>。</p>
<h2 id="1-弹性布局：flex"><a href="#1-弹性布局：flex" class="headerlink" title="1 弹性布局：flex"></a>1 弹性布局：flex</h2><p>主要解决问题：</p>
<ul>
<li><p>在父内容里面垂直居中一个块内容。</p>
</li>
<li><p>使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度/高度可用。</p>
</li>
<li><p>使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。</p>
</li>
</ul>
<p>使用方法：在想要进行 flex 布局的父元素上应用<code>display:flex</code>，所有的子元素都会按照flex进行布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了可以设置父容器的属性以外，还有很多属性可以设置到flex items上，这些属性可以改变flex items在flex布局中占用宽/高的方式，允许它们通过伸缩来适应可用空间。</p>
<p>例如在所有的flex items上设置<code>flex:1</code>可以设置所有的flex items都伸展并填充容器。</p>
<h3 id="1-1-flex模型说明"><a href="#1-1-flex模型说明" class="headerlink" title="1.1 flex模型说明"></a>1.1 flex模型说明</h3><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p>
<p><img src="https://tc.chaizz.com/tc/flex_terms.png" alt="flex_terms.png"></p>
<ul>
<li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li>
<li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li>
<li>设置了 <code>display: flex</code> 的父元素，被称之为 <strong>flex 容器（flex container）。</strong></li>
<li>在 flex 容器中表现为柔性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）。</li>
</ul>
<p>在flex布局中提供了==行列==布局的选项，通过<code>flex-direction</code>设置，他可以指定主轴的方向，默认行布局值为<code>row</code>，按照语言的默认方向排成一排。使用<code>column</code> 值将改为列布局，还有<code>row-reverse</code> 和 <code>column-reverse</code> 值反向排列 flex items。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;</span><br></pre></td></tr></table></figure>
<p>在布局中使用固定宽度或者固定高度，flex items可能会溢出弹性盒子，可以使用<code>flx-wrap:wrap</code>来避免这种情况。同时也可以设置每个flex items的最小宽度<code>flex:200px</code>，使用了以上属性，溢出的flex items将会移动到下一行。</p>
<p>可以将<code>flex-direction</code>和<code>flex-wrap</code>缩写为 <code>flex-flow</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;</span><br><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 缩写为 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">row</span> <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure>


<p>上文中通过<code>flex:200px</code> 来控制flex items的宽度，如何动态的设置flex items 占用空间的比例呢？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 1;</span><br></pre></td></tr></table></figure>
<p>这是一个没有单位的比例值，表示每个 flex 项沿主轴的可用空间大小。例如设置为1代表每个flex items占用的空间是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为这是一个比例值，所以数字的大小所产生的效果是一样的。</p>
<p>也可以指定flex的最小值<code>flex: 1 2-00px;</code>， 表示每个flex items先给出200px，然后剩余的空间按照分配的比例共享。</p>
<h3 id="1-2-flex的缩写与全写"><a href="#1-2-flex的缩写与全写" class="headerlink" title="1.2 flex的缩写与全写"></a>1.2 flex的缩写与全写</h3><p>可以指定最多三个值的缩写属性：(不建议使用全写)</p>
<ul>
<li>第一个即上文中的无比例单位，也可以单独指定全写<code>flex-grow: 1;</code>。</li>
<li>第二个无单位比例是<code>flex-shrink</code>，一般用于溢出容器的flex items，他指定了从每个flex items取出多少溢出量，以阻止它们溢出它们的容器。（高级）</li>
<li>第三个是最小值，可以单独指定全写<code>flex-basis</code>。</li>
</ul>
<h3 id="1-3-弹性布局水平和垂直对齐"><a href="#1-3-弹性布局水平和垂直对齐" class="headerlink" title="1.3 弹性布局水平和垂直对齐"></a>1.3 弹性布局水平和垂直对齐</h3><p>通过<code>align-items</code>控制flex items在交叉轴上的位置</p>
<ul>
<li>默认的值是 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。</li>
<li><code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。</li>
<li> <code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。</li>
</ul>
<p>可以在每个单独的flex items设置特殊的布局<code>align-self: flex-end;</code>。</p>
<p>通过<code>justify-content</code>控制flex items在主轴上的位置。</p>
<ul>
<li>默认值是 <code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。</li>
<li>使用 <code>flex-end</code> 来让 flex 项到结尾处，与上面的值相反。</li>
<li>使用<code>center</code> 让 flex 项在主轴居中，但是每个元素之间不会有间隔。</li>
<li>使用 <code>space-around</code> 让flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li>
<li>使用 <code>space-between</code>，它和 <code>space-around</code> 非常相似，只是它不会在两端留下任何空间。</li>
</ul>
<h3 id="1-4-flex-items-排序"><a href="#1-4-flex-items-排序" class="headerlink" title="1.4 flex items 排序"></a>1.4 flex items 排序</h3><p>弹性盒子可以改变flex items的布局的位置，而不会影响到dom元素的顺序。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>所有 flex items 的默认 <code>order</code> 的值是0。</li>
<li>order 值大的 flex items 比 order 值小的在显示顺序中更靠后。</li>
<li>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。</li>
<li>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。</li>
</ul>
<p>也可以给 order 设置负值使它们比值为 0 的元素排得更前面。</p>
<h2 id="2-网格布局：grid"><a href="#2-网格布局：grid" class="headerlink" title="2 网格布局：grid"></a>2 网格布局：grid</h2><p>网格是由一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。</p>
<p>一个网格通常还有许多的列与行，以及行与行、列与列之间的间隙，间隙一般称为沟槽。</p>
<p><img src="https://tc.chaizz.com/tc/grid.png" alt="img"></p>
<p>与弹性盒子的区别：在定义网格后，网页并不会马上发生变化。因为<code>display: grid</code>的声明只创建了一个只有一列的网格，所以你的子项还是会像正常布局流那样从上而下一个接一个的排布</p>
<h3 id="2-1-给网格设置列"><a href="#2-1-给网格设置列" class="headerlink" title="2.1 给网格设置列"></a>2.1 给网格设置列</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置列的单位可以是具体的px，或者百分比也可以是fr，他比px和百分比更加的灵活，这个单位表示了一个可用空间的一个比例。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fe</span>;</span><br></pre></td></tr></table></figure>
<p>设置了fr，每一列的宽度们可以随着空间的变小而变小。</p>
<blockquote>
<p><strong><code>fr</code>单位分配的是<em>可用</em>空间而非<em>所有</em>空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。</strong></p>
</blockquote>
<h3 id="2-2-网格间隙"><a href="#2-2-网格间隙" class="headerlink" title="2.2 网格间隙"></a>2.2 网格间隙</h3><p>使用 <code>grid-column-gap</code>属性来定义列间隙；使用 <code>grid-row-gap</code>来定义行间隙；使用 <code>grid-gap</code> 可以同时设定两者。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>间隙距离可以用任何长度单位包括百分比来表示，但不能使用<code>fr</code>单位。</p>
<h3 id="2-3-重复构建行-列"><a href="#2-3-重复构建行-列" class="headerlink" title="2.3 重复构建行/列"></a>2.3 重复构建行/列</h3><p>可以使用<code>repeat</code>来重复构建具有某些宽度配置的某些列。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-4-显式网格和隐式网格"><a href="#2-4-显式网格和隐式网格" class="headerlink" title="2.4 显式网格和隐式网格"></a>2.4 显式网格和隐式网格</h3><p>显式网格是我们用<code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。</p>
<p>隐式网格的行列大小默认是auto，大小会根据放入的内容自动调整。也可以使用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>手动设置隐式网格的大小。</p>
<p>简单来说，隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显式网格自动生成的网格部分。</p>
<h3 id="2-4-minmax函数"><a href="#2-4-minmax函数" class="headerlink" title="2.4 minmax函数"></a>2.4 minmax函数</h3><p>函数为一个行/列的尺寸设置了取值范围。比如设定为 <code>minmax(100px, auto)</code>，那么尺寸就至少为 100 像素，并且如果内容尺寸大于 100 像素则会根据内容自动调整。</p>
<p>浮动布局：例如<code>float:left</code>值可以让块级元素相互排成一行。</p>
<p>position：允许精准设置盒子中的盒子的位置，正常布局流中的默认值为<code>static</code>，他的值会引起不同元素的布局方式，例如将元素固定到浏览器左上角的。</p>
<p>表格布局：表格的布局方式，可以用在非表格内容上，可以使用<code>display:table</code>和相关属性在非表格元素上使用。</p>
<p>多列布局：<code>multi-column-layout</code>属性可以让快按照列布局，类似报纸的形式。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局-浮动与定位与多列布局</title>
    <url>/2022/08/22/CSS%E5%B8%83%E5%B1%80-%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS布局-浮动与定位与多列布局"><a href="#CSS布局-浮动与定位与多列布局" class="headerlink" title="CSS布局-浮动与定位与多列布局"></a>CSS布局-浮动与定位与多列布局</h1><h2 id="1-浮动-float"><a href="#1-浮动-float" class="headerlink" title="1 浮动 float"></a>1 浮动 float</h2><p>浮动属性最初只用在成块的文本内的图像上，使用浮动来布局页面被看做传统的布局方法。</p>
<h3 id="1-1-添加浮动"><a href="#1-1-添加浮动" class="headerlink" title="1.1 添加浮动"></a>1.1 添加浮动</h3><p>浮动元素会脱离正常的文档布局流，并吸附到其父容器的左/右边元素）。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右/左侧的空间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;  <span class="comment">/*  left和right */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-清除浮动"><a href="#1-2-清除浮动" class="headerlink" title="1.2 清除浮动"></a>1.2 清除浮动</h3><p>一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也受到浮动元素的影响，我们需要 <em>停止</em> 它；这是通过添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 属性实现的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cleared</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear 属性接受下列值：</p>
<ul>
<li><code>left</code>：停止任何活动的左浮动</li>
<li><code>right</code>：停止任何活动的右浮动</li>
<li><code>both</code>：停止任何活动的左右浮动</li>
</ul>
<h3 id="1-3-清除浮动元素周围的盒子"><a href="#1-3-清除浮动元素周围的盒子" class="headerlink" title="1.3 清除浮动元素周围的盒子"></a>1.3 清除浮动元素周围的盒子</h3><p>第一种方式，其过程为：先向包含浮动内容及其本身的盒子后方插入一些生成的内容，并将生成的内容清除浮动。（比较传统的形式）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式和在盒子后面手动添加类似div的块元素 ，并设置样式为<code>clear:both</code>的效果是一样的。</p>
<p>第二种方式 使用 <code>overflow</code>(以上方案的替代方法)。</p>
<p>将包裹元素的 <code>overflow</code>属性设置为<code>visible</code>外其他的值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto; <span class="comment">/* 设置为auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分情况下这种小技巧都可以奏效，但是可能会出现莫名其妙的滚动条或裁剪阴影，这是使用 overflow 带来的一些副作用。</p>
<p>第三种形式， 比较现代的形式。</p>
<p>使用<code>display:flow-root</code>可以无需小技巧来创建块格式化上下文（BFC），在使用上没有副作用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-定位-position"><a href="#2-定位-position" class="headerlink" title="2 定位 position"></a>2 定位 position</h2><p>理解定位首先熟悉文档流。</p>
<blockquote>
<p>文档流</p>
<p>围绕元素内容添加任何内边距，边界和外边距来布置单个元素盒子，这就是盒模型。默认请况下，块级元素的宽度是父级元素宽度的100%，高度是内容的高度，内联元素的宽高和内容一样宽高一样，不能对内联元素设置宽–他们只是位于块级元素的内容中，如果要控制内联元素的大小需要将其设置为<code>display:block</code>。</p>
<p>正常的布局流是将元素放置在浏览器视口内的系统，块级元素在视口中垂直布局——每个都将显示在上一个元素下面的新行上，并且它们的外边距将分隔开它们；</p>
<p>内联元素表现不一样——它们不会出现在新行上；相反，它们互相之间以及任何相邻（或被包裹）的文本内容位于同一行上，只要在父块级元素的宽度内有空间可以这样做。如果没有空间，那么溢流的文本或元素将向下移动到新行。</p>
<p>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫外边距折叠。</p>
</blockquote>
<p>定位是允许我们覆盖上面描述的基本文档流行为。</p>
<h3 id="2-1-静态定位-static"><a href="#2-1-静态定位-static" class="headerlink" title="2.1 静态定位 static"></a>2.1 静态定位 static</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态定位是每个元素获取的默认值–它只是意味着“将元素放入它在文档布局流中的正常位置。</p>
<h3 id="2-2-相对定位-relative"><a href="#2-2-相对定位-relative" class="headerlink" title="2.2 相对定位 relative"></a>2.2 相对定位 relative</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他与静态定位非常相似。占据在正常文档流中，可以通过 top、bottom、left、right改变元素的位置。</p>
<p>以上四个值是用来精确指定元素的位置，</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">.positioned &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: <span class="number">30</span>px;</span><br><span class="line">    left: <span class="number">30</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-3-绝对定位-absolute"><a href="#2-3-绝对定位-absolute" class="headerlink" title="2.3 绝对定位 absolute"></a>2.3 绝对定位 absolute</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。这意味着我们可以创建不干扰页面上其他元素的位置的隔离的 UI 功能。例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的 UI 功能……</p>
<p>==绝对定位是根据他的父元素的position 属性来进行绝对定位==，如果所有的父元素都没有显式地定义 position 属性，那么所有的父元素默认情况下 position 属性都是 static。绝对定位元素会被放在<html>元素的外面，并且根据浏览器视口来定位。</html></p>
<h3 id="2-4-z-index"><a href="#2-4-z-index" class="headerlink" title="2.4 z-index"></a>2.4 z-index</h3><p>当元素开始重叠的时候，是什么决定了那些元素应该出现在顶层，哪些在底层？</p>
<p>在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。</p>
<p>网页也有一个 z 轴：一条从屏幕到面前的线，z-index 值影响定位元素位于该轴上的位置；正值将它们移动到顶层即向屏幕外垂直延伸到面前，负值将它们向下移动到底层向屏幕里垂直延伸。默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。</p>
<p>z-index 只接受无单位索引值。</p>
<h3 id="2-5-固定定位-fixed"><a href="#2-5-固定定位-fixed" class="headerlink" title="2.5 固定定位 fixed"></a>2.5 固定定位 fixed</h3><p>这种定位方式与绝对定位的方式完全相同，只有一个区别：绝对定位将元素固定在相对于其位置最近的祖先。（（如果没有，则为初始包含它的块）而固定定位固定元素则是相对于浏览器视口本身</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>相对位置和固定位置的混合体 sticky</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个值比其他的值要新，他是相对位置个绝对位置的混合体，表现行为和相对定位一样，直到它滚动到某个阈值点为止，他就变得固定了。</p>
<p>sticky 一种常用的用法，是创建一个滚动索引页面。在此页面上，不同的标题会停留在页面顶部。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-多列布局"><a href="#3-多列布局" class="headerlink" title="3 多列布局"></a>3 多列布局</h2><h3 id="3-1-设置列数-column-count"><a href="#3-1-设置列数-column-count" class="headerlink" title="3.1 设置列数 column-count"></a>3.1 设置列数 column-count</h3><p>创建的这些列具有弹性的宽度 — 由浏览器计算出每一列分配多少空间。</p>
<h3 id="3-2-设置列宽-column-width"><a href="#3-2-设置列宽-column-width" class="headerlink" title="3.2 设置列宽 column-width"></a>3.2 设置列宽 column-width</h3><p>浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。 这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p>
<h3 id="3-3-给多列增加样式"><a href="#3-3-给多列增加样式" class="headerlink" title="3.3 给多列增加样式"></a>3.3 给多列增加样式</h3><p>Multicol 创建的列无法单独的设定样式。不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。</p>
<ul>
<li><code>column-gap</code> 改变列间间隙。</li>
<li><code>column-rule</code> 在列间加入分割线。</li>
</ul>
<p><code>column-rule</code>。和 <code>border</code>属性类似， <code>column-rule</code> 是 <code>column-rule-color</code>和 <code>column-rule-style</code>的缩写，接受同 <code>border</code> 一样的单位。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">4px</span> dotted <span class="built_in">rgb</span>(<span class="number">79</span>, <span class="number">185</span>, <span class="number">227</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-4-列与内容折断"><a href="#3-4-列与内容折断" class="headerlink" title="3.4 列与内容折断"></a>3.4 列与内容折断</h3><p>使用对列布局时把内容放入多列布局容器内，内容被拆成碎块放进列中，从而影响阅读体验。可以在列上使用这一属性避免<code>break-inside:avoid</code>。 现阶段旧属性 <code>page-break-inside: avoid</code> 能够获得更好的浏览器支持。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式化文本</title>
    <url>/2022/08/19/CSS%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h2 id="1-CSS文本样式"><a href="#1-CSS文本样式" class="headerlink" title="1 CSS文本样式"></a>1 CSS文本样式</h2><h3 id="1-1-字体栈"><a href="#1-1-字体栈" class="headerlink" title="1.1 字体栈"></a>1.1 字体栈</h3><p>因为无法抱枕没字网页的上使用的字体的可用性，所以可以提供一个字体栈，这样浏览器就可以有多种选择。只需要使用<code>font-famioly</code>属性，其值用几个逗号分离的字体名称组成。使用方式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Trebuchet MS&quot;</span>, Verdana, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，浏览器会检查第一个字体，在征集其中是否可用，如果不可用则会顺延到下一个字体，在进行检查以此类推，都不可用则会使用默认的字体。</p>
<blockquote>
<p><strong>备注：</strong> 有一些字体名称不止一个单词，比如<code>Trebuchet MS</code> ，那么就需要用引号包裹。</p>
</blockquote>
<h3 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h3><p>主要注意字体的单位</p>
<ul>
<li>px：将像素的值赋予文本，他是一个绝对的单位，任何情况下页面上的文本大小都是固定的。</li>
<li>em：1em等于当前元素的父元素上设置的字体的大小，如果设置了大量的不同字体大小的嵌套元素， 可能会导致字体大小非常混乱。</li>
<li>rem：1rem等于html中根元素的字体的大小（<html>），而不是父元素的字体大小，但是不支持IE8及以下版本。</html></li>
</ul>
<p>标签的<code>font-size</code>属性是从根元素（<html>）继承的m，所以一切都是从根元素的开始，==浏览器的默认<code>font-size</code> 标准设置的值为 16px==。在根元素中的任何段落中的没有设置字体大小的元素都有一个默认值：16px，其他的元素有默认的代大小，比如<code>h1</code>的默认大小为2em，转化为像素为32px。</html></p>
<h3 id="1-3-字体样式"><a href="#1-3-字体样式" class="headerlink" title="1.3 字体样式"></a>1.3 字体样式</h3><p><code>font-style</code>: 用来打开和关闭文本 italic (斜体)。可能的值如下 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态)：</p>
<ul>
<li><code>normal</code>: 将文本设置为普通字体 (将存在的斜体关闭)</li>
<li><code>italic</code>: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。</li>
<li><code>oblique</code>: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。</li>
</ul>
<p><code>font-weight</code>: 设置文字的粗体大小。这里有很多值可选 (比如-light,-normal,-bold,-extrabold,-black, 等等), 不过事实上你很少会用到<code>normal</code>和<code>bold</code>以外的值：</p>
<ul>
<li><code>normal</code>, <code>bold</code>: 普通或者<strong>加粗</strong>的字体粗细</li>
<li><code>lighter</code>, <code>bolder</code>: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。<code>100</code>–<code>900</code>: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。</li>
</ul>
<p><code>text-transform</code>: 允许你设置要转换的字体。值包括：</p>
<ul>
<li><code>none</code>: 防止任何转型。</li>
<li><code>uppercase</code>: 将所有文本转为大写。</li>
<li><code>lowercase</code>: 将所有文本转为小写。</li>
<li><code>capitalize</code>: 转换所有单词让其首字母大写。</li>
<li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。</li>
</ul>
<p><code>text-decoration</code>: 设置/取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为：</p>
<ul>
<li><code>none</code>: 取消已经存在的任何文本装饰。</li>
<li><code>underline</code>: 文本下划线。</li>
<li><code>overline</code>: 文本上划线</li>
<li><code>line-through</code>: 穿过文本的线。</li>
</ul>
<p><code>text-decoration</code>可以一次接受多个值 比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-decoration</span>: <span class="selector-tag">underline</span> <span class="selector-tag">overline</span></span><br></pre></td></tr></table></figure>
<p><code>text-decoration</code>是一个缩写形式，它由<code>text-decoration-line</code>,<code>text-decoration-style</code>和<code>text-decoration-color</code>构成。你可以使用这些属性值的组合来创建有趣的效果，比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-decoration</span>: <span class="selector-tag">line-through</span> <span class="selector-tag">red</span> <span class="selector-tag">wavy</span></span><br></pre></td></tr></table></figure>
<p>文字样式示例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.4rem</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">font-weight</span>: lighter;</span><br><span class="line">    <span class="attribute">font-family</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through underline overline wheat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-4-文字阴影"><a href="#1-4-文字阴影" class="headerlink" title="1.4 文字阴影"></a>1.4 文字阴影</h3><p>使用<code>text-shadow</code>设置文字阴影。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: 4<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">red</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>, 但是 px 是比较合适的。这个值必须指定。</li>
<li>阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。</li>
<li>模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为 0，这意味着没有模糊。可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</li>
<li>阴影的基础颜色，可以使用大多数的 CSS 颜色单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#colors">CSS color unit</a>. 如果没有指定，默认为 <code>black</code>.</li>
</ol>
<blockquote>
<p><strong>备注：</strong> 正偏移值可以向右移动阴影，但也可以使用负偏移值来左右移动阴影，例如 <code>-1px -1px</code>。</p>
</blockquote>
<p>字体还可以指定多个阴影：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: <span class="selector-tag">-1px</span> <span class="selector-tag">-1px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#aaa</span>,</span><br><span class="line">             0<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,0.5),</span><br><span class="line">             4<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,0.7),</span><br><span class="line">             0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 7<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,0.4);</span><br></pre></td></tr></table></figure>
<h3 id="1-5-文本布局"><a href="#1-5-文本布局" class="headerlink" title="1.5 文本布局"></a>1.5 文本布局</h3><p><code>text-align</code></p>
<p>该属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同：</p>
<ul>
<li><code>left</code>: 左对齐文本。</li>
<li><code>right</code>: 右对齐文本。</li>
<li><code>center</code>: 居中文字</li>
<li><code>justify</code>: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>，打破一些更长的词语。</li>
</ul>
<p><code>line-height</code> </p>
<p>该属性设置文本每行之间的高，可以接受大多数单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 来获得 <code>line-height</code>。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。==推荐的行高大约是 1.5–2 (双倍间距)==。 所以要把我们的文本行高设置为字体高度的 1.5 倍，你可以使用这个：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">line-height</span>: 1.5;</span><br></pre></td></tr></table></figure>


<p><code>letter-spacing</code> 和 <code>word-spacing</code></p>
<p>以上两个值可以设置字母与字母之间的间距、或是单词与单词之间的间距。</p>
<h2 id="2-css列表样式"><a href="#2-css列表样式" class="headerlink" title="2 css列表样式"></a>2 css列表样式</h2><h3 id="2-1-列表特定样式"><a href="#2-1-列表特定样式" class="headerlink" title="2.1 列表特定样式"></a>2.1 列表特定样式</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。（这个属性在控制项目符号的位置，大小等方面是有限的，最好使用<code>background</code>）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: square;</span><br><span class="line">  <span class="attribute">list-style-image</span>: <span class="built_in">url</span>(example.png);</span><br><span class="line">  <span class="attribute">list-style-position</span>: inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的三种属性，可以使用一个单独的属性<code>list-style</code>来设置，属性值可以任意顺序排列，可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside），如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: square <span class="built_in">url</span>(example.png) inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-管理列表计数"><a href="#2-2-管理列表计数" class="headerlink" title="2.2 管理列表计数"></a>2.2 管理列表计数</h3><p>在列表上进行不同的计数方式，例如设置<code>ol</code>标签的序号，正序倒序，指定数值。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-start"><code>start</code></a> 属性允许你从 1 以外的数字开始计数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Wash and chop the salad.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2022-08-19_14-52-03.png"></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-reversed"><code>reversed</code></a> 属性将启动列表倒计数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">&quot;4&quot;</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Wash and chop the salad.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2022-08-19_14-53-32.png"></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-value"><code>value</code></a> 属性允许设置列表项指定数值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;6&quot;</span>&gt;</span>Wash and chop the salad.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;8&quot;</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2022-08-19_14-54-25.png"></p>
<h2 id="3-CSS连接样式"><a href="#3-CSS连接样式" class="headerlink" title="3 CSS连接样式"></a>3 CSS连接样式</h2><p>善于利用伪类有效地建立链接状态是很重要的，以及如何为链接添加样式来实现常用的功能，比如说导航栏、选项卡。</p>
<h3 id="3-1-连接状态"><a href="#3-1-连接状态" class="headerlink" title="3.1 连接状态"></a>3.1 连接状态</h3><p>连接处于不同的状态，都处于一个状态都可以利用对应的伪类来应用样式。</p>
<p>没有访问过的状态，连接的默认状态，可以使用<code>:link</code>来应用样式。</p>
<p>被访问过的状态（存在与浏览器的历史状态），可以使用<code>:visited</code>来应用样式。</p>
<p>鼠标悬停在连接上的状态，可以使用<code>:hover</code>伪类来应用样式。</p>
<p>被选中的时状态 (比如通过键盘的 Tab 移动到这个链接的时候，或者使用编程的方法来选中这个链接 <code>HTMLElement.focus()</code>) 可以使用<code> :focus</code>伪类来应用样式。</p>
<p>一个链接当它被激活的状态 (比如被点击的时候)，它可以使用<code>:active</code>伪类来应用样式。</p>
<p>连接的一些默认状态</p>
<ul>
<li>链接具有下划线。</li>
<li>未访问过的 (Unvisited) 的链接是蓝色的。</li>
<li>访问过的 (Visited) 的链接是紫色的。</li>
<li>悬停 (Hover) 在一个链接的时候鼠标的光标会变成一个小手的图标。</li>
<li>选中 (Focus) 链接的时候，链接周围会有一个轮廓。</li>
<li>激活 (Active) 链接（点击链接时）的时候会变成红色 。</li>
</ul>
<h3 id="3-2-连接中包含图标"><a href="#3-2-连接中包含图标" class="headerlink" title="3.2 连接中包含图标"></a>3.2 连接中包含图标</h3><p>常见的做法是在链接中包含图标，使链接提供更多关于链接指向的内容的信息。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;http&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;icons8-external-link-26.png&#x27;</span>) no-repeat <span class="number">100%</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">16px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">19px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-web字体"><a href="#4-web字体" class="headerlink" title="4 web字体"></a>4 web字体</h2><p>在浏览器中使用指定字体。</p>
<p>首先，在 CSS 的开始处有一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>块，它指定要下载的字体文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;myFont&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;myFont.ttf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后应用到文档中去：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;myFont&quot;</span>, <span class="string">&quot;Bitstream Vera Serif&quot;</span>, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















































]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS背景和边框</title>
    <url>/2022/08/18/CSS%E8%83%8C%E6%99%AF%E5%92%8C%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS背景和边框"><a href="#CSS背景和边框" class="headerlink" title="CSS背景和边框"></a>CSS背景和边框</h1><p>设计CSS的背景和边框，可以是CSS的样式更具有多样性。CSS背景可以做哪些不同的事情？</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><h3 id="1-1-颜色背景：background-color"><a href="#1-1-颜色背景：background-color" class="headerlink" title="1.1 颜色背景：background-color"></a>1.1 颜色背景：<code>background-color</code></h3><p>定义了CSS中任何元素的背景颜色，属性接受的是有效的color值，==背景会扩展到元素的内容和内边距的下面==。</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2022-08-18_09-57-45.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#567895</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Background Colors<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Try changing the background <span class="tag">&lt;<span class="name">span</span>&gt;</span>colors<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-图片背景：background-image"><a href="#1-2-图片背景：background-image" class="headerlink" title="1.2 图片背景：background-image"></a>1.2 图片背景：<code>background-image</code></h3><p>该属性允许在元素的背景中显示图像，但是要注意的是：大图不会缩小以适应标签方框，而小图则是平铺</p>
<p>填充方框。<strong>如果除了背景图像外，还指定了背景颜色，则图像将颜色覆盖。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span>, <span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: black solid <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;9.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;400.jpeg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2022-08-18_10-14-47.png"></p>
<h4 id="1-2-1-控制背景的平铺行为：background-repeat"><a href="#1-2-1-控制背景的平铺行为：background-repeat" class="headerlink" title="1.2.1 控制背景的平铺行为：background-repeat"></a>1.2.1 控制背景的平铺行为：<code>background-repeat</code></h4><ul>
<li><code>no-repeat</code> 不重复。</li>
<li><code>repeat-x</code> 水平重复。</li>
<li><code>repeat-y</code> 垂直重复。</li>
<li><code>repeat</code> 在两个方向重复。</li>
</ul>
<h4 id="1-2-2-调整背景图像的大小：-background-size"><a href="#1-2-2-调整背景图像的大小：-background-size" class="headerlink" title="1.2.2 调整背景图像的大小： background-size"></a>1.2.2 调整背景图像的大小： <code>background-size</code></h4><p>可以设置长度（100px 200px），百分比。</p>
<ul>
<li><p><code>cover</code>：浏览器将图像等比例放大，和元素盒子一样大，但是当图片尺寸和盒子尺寸不一致是往往会跳出盒子。</p>
</li>
<li><p><code>contain</code>：浏览器使图像的大小适应盒子内，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</p>
</li>
</ul>
<h4 id="1-2-3-背景图像定位：background-position"><a href="#1-2-3-背景图像定位：background-position" class="headerlink" title="1.2.3 背景图像定位：background-position"></a>1.2.3 背景图像定位：<code>background-position</code></h4><p>设置背景图像显示在其应用到的盒子中的位置，在盒子中坐标系（0，0）位于盒子的左上角。默认额的背景图像位置为（0,0）。</p>
<ul>
<li> <code>background-position</code> 是 <code>background-position-x</code> 和 <code>background-position-y</code>的简写，它们允许您分别设置不同的坐标轴的值。</li>
</ul>
<h4 id="1-2-4-背景附加：background-attachment"><a href="#1-2-4-背景附加：background-attachment" class="headerlink" title="1.2.4 背景附加：background-attachment"></a>1.2.4 背景附加：<code>background-attachment</code></h4><p>==此属性只有在有内容要滚动时才会有效果==。</p>
<p>它可以接受以下值：<a href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html">示例</a></p>
<ul>
<li><code>scroll</code>: 只有在页面滚动时背景图像在会滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li>
<li><code>fixed</code>: 使元素的背景固定在页面的某个位置上，这样当页面或元素内容滚动时，它都不会滚动。它将始终保持在屏幕上相同的位置。</li>
<li><code>local</code>: 使用该值元素滚动和页面滚动都会导致背景图像滚动。</li>
</ul>
<h3 id="1-3-渐变背景"><a href="#1-3-渐变背景" class="headerlink" title="1.3 渐变背景"></a>1.3 渐变背景</h3><p>当渐变用于背景时，也可以使用像图像一样的 <code>background-image</code>属性设置。</p>
<p><img src="/2022/08/18/CSS%E8%83%8C%E6%99%AF%E5%92%8C%E8%BE%B9%E6%A1%86/Users\LHKJ0\Pictures\WEB\CSS\Snipaste_2022-08-18_10-56-41.png">s</p>
<p>使用<code>background</code>可以设置全部的属性，但是在设置属性时有一些<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background">规则</a>：</p>
<ul>
<li><code>background-color</code> 只能在逗号之后指定。</li>
<li><code>background-size</code> 值只能包含在背景位置之后，用’/‘字符分隔，例如：<code>center/80%</code>。</li>
</ul>
<p>例如指定多个 <code>background-image</code> 的值时，用逗号分隔每个值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">image1</span><span class="selector-class">.png</span>), <span class="selector-tag">url</span>(<span class="selector-tag">image2</span><span class="selector-class">.png</span>), <span class="selector-tag">url</span>(<span class="selector-tag">image3</span><span class="selector-class">.png</span>), <span class="selector-tag">url</span>(<span class="selector-tag">image4</span><span class="selector-class">.png</span>);</span><br><span class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>, <span class="selector-tag">repeat-x</span>, <span class="selector-tag">repeat</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: 10<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>,  <span class="selector-tag">top</span> <span class="selector-tag">right</span>;</span><br></pre></td></tr></table></figure>
<p>不同的属性值， 与其他属性中相同位置的值匹配。</p>
<h2 id="2-边框"><a href="#2-边框" class="headerlink" title="2 边框"></a>2 边框</h2><p>使用 border属性设置 CSS 中盒子设置边框的颜色、宽度和样式。 </p>
<h3 id="2-1-边框样式：border-style"><a href="#2-1-边框样式：border-style" class="headerlink" title="2.1 边框样式：border-style"></a>2.1 边框样式：<code>border-style</code></h3><p>关键字用于描述边框样式。它可以有以下取值：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style">示例</a></p>
<table>
<thead>
<tr>
<th align="left"><code>none</code></th>
<th align="left">和关键字 <code>hidden</code> 类似，不显示边框。在这种情况下，如果没有设定背景图片，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 计算后的值将是 <code>0</code>，即使先前已经指定过它的值。在单元格边框重叠情况下，<code>none</code> 值优先级最低，意味着如果存在其他的重叠边框，则会显示为那个边框。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>hidden</code></td>
<td align="left">和关键字 <code>none</code> 类似，不显示边框。在这种情况下，如果没有设定背景图片，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 计算后的值将是 <code>0</code>，即使先前已经指定过它的值。在单元格边框重叠情况下，<code>hidden</code> 值优先级最高，意味着如果存在其他的重叠边框，边框不会显示。</td>
</tr>
<tr>
<td align="left"><code>dotted</code></td>
<td align="left">显示为一系列圆点。标准中没有定义两点之间的间隔大小，视不同实现而定。圆点半径是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 计算值的一半。</td>
</tr>
<tr>
<td align="left"><code>dashed</code></td>
<td align="left">显示为一系列短的方形虚线。标准中没有定义线段的长度和大小，视不同实现而定。</td>
</tr>
<tr>
<td align="left"><code>solid</code></td>
<td align="left">显示为一条实线。</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left">显示为一条双实线，宽度是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 。</td>
</tr>
<tr>
<td align="left"><code>groove</code></td>
<td align="left">显示为有雕刻效果的边框，样式与 <code>ridge</code> 相反。</td>
</tr>
<tr>
<td align="left"><code>ridge</code></td>
<td align="left">显示为有浮雕效果的边框，样式与 <code>groove</code> 相反。</td>
</tr>
<tr>
<td align="left"><code>inset</code></td>
<td align="left">显示为有陷入效果的边框，样式与 <code>outset</code> 相反。当它指定到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a> 为 <code>collapsed</code> 的单元格时，会显示为 <code>groove</code> 的样式。</td>
</tr>
<tr>
<td align="left"><code>outset</code></td>
<td align="left">显示为有突出效果的边框，样式与 <code>inset</code> 相反。当它指定到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a> 为 <code>collapsed</code> 的单元格时，会显示为 <code>ridge</code> 的样式。</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端包管理器之pnpm</title>
    <url>/2022/08/18/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8Bpnpm/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="前端包管理器之pnpm"><a href="#前端包管理器之pnpm" class="headerlink" title="前端包管理器之pnpm"></a>前端包管理器之pnpm</h1><p><a href="https://pnpm.io/zh/motivation">pnpm</a> 正如他官网的口号一样：速度快、节省磁盘空间的软件包管理器。</p>
<p>主要解决了npm的一些痛点：</p>
<ul>
<li>如果有多个项目，那么使用npm的情况下每个项目就会有各自的依赖，可能会造成依赖的重复，浪费磁盘空间。</li>
<li>不同版本的依赖，存储在同一位置，且不会因为版本的不同而修改保存依赖包的所有文件。</li>
</ul>
<p>最终的体现结果就是依赖的存储空间变少了，速速也会变快，官方声称构建速度是同类构建工具的将近2倍。</p>
<h2 id="1-安装pnpm"><a href="#1-安装pnpm" class="headerlink" title="1 安装pnpm"></a>1 安装pnpm</h2><p>建议写卸载现有的npm,node和nvm等其他的包管理器，和node版本管理器。</p>
<p>没有安装nodejs的情况下安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iwr</span> https://get.pnpm.io/install.ps1 <span class="literal">-useb</span> | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure>
<p>已经安装了npm的情况下安装, 直接全局安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> pnpm</span><br></pre></td></tr></table></figure>
<p>安装后修改如果嫌pnpm的命令长，可以改为短命令：pn</p>
<p>在windows中只需要两步：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、使用管理员打开终端</span></span><br><span class="line">notepad <span class="variable">$profile</span>.AllUsersAllHosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、在 profile.ps1 文件里加入：</span></span><br><span class="line"><span class="built_in">set-alias</span> <span class="literal">-name</span> pn <span class="literal">-value</span> pnpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存后，打开新的窗口直接使用 pn -v</span></span><br></pre></td></tr></table></figure>


<h2 id="2-pnpm的常用命令"><a href="#2-pnpm的常用命令" class="headerlink" title="2 pnpm的常用命令"></a>2 pnpm的常用命令</h2><p>大部分都和npm一致, 少数会有区别</p>
<h3 id="2-1-node环境管理"><a href="#2-1-node环境管理" class="headerlink" title="2.1 node环境管理"></a>2.1 node环境管理</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看有哪些可安装的node版本</span></span><br><span class="line">pn env list -<span class="literal">-remote</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地已经安装的node版本 或者是  pn env ls</span></span><br><span class="line">pn env list </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装/切换具体的node lts 版本, 或者指定版本号， 或者是 latest最新稳定版本   --global 可以简写为-g 和npm使用 别名差不多。 </span></span><br><span class="line">pn env use -<span class="literal">-global</span> lts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定版本的node</span></span><br><span class="line">pn env remove -<span class="literal">-global</span> <span class="number">14.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-设置-pnpm-配置"><a href="#2-2-设置-pnpm-配置" class="headerlink" title="2.2  设置 pnpm 配置"></a>2.2  设置 pnpm 配置</h3><p>Windows路径为：<strong>C:\Users&lt;UserName&gt;.npmrc</strong>，可以手动打开进行配置</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前配置   -g 列出全局配置</span></span><br><span class="line">pn config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 pnpm 的源</span></span><br><span class="line"><span class="comment"># 淘宝</span></span><br><span class="line">pn config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 腾讯</span></span><br><span class="line">pn config <span class="built_in">set</span> registry http://mirrors.cloud.tencent.com/npm/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 华为</span></span><br><span class="line">pn config <span class="built_in">set</span> registry https://repo.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure>
<h3 id="2-3-安装-更新-卸载包和相关依赖"><a href="#2-3-安装-更新-卸载包和相关依赖" class="headerlink" title="2.3 安装/更新/卸载包和相关依赖"></a>2.3 安装/更新/卸载包和相关依赖</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -g 全局安装  -D 保存到 devDependencies</span></span><br><span class="line">pn add <span class="literal">-g</span> pkg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line"><span class="comment"># 在不带参数的情况下使用时，将更新所有依赖关系</span></span><br><span class="line">pn update pkg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载 -g 全局卸载</span></span><br><span class="line">pn remove <span class="literal">-g</span> pkg</span><br><span class="line"><span class="comment"># 别名：rm, uninstall, un</span></span><br></pre></td></tr></table></figure>






]]></content>
      <tags>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>前端包管理器之npm</title>
    <url>/2022/08/18/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8Bnpm/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="前端包管理器之npm"><a href="#前端包管理器之npm" class="headerlink" title="前端包管理器之npm"></a>前端包管理器之npm</h1><p>npm是一个软件注册中心，有大量的开发者和组织将软件上传到npm。npm是由三部分构成， website、cli、register。 我们最常用的就是npm cli。</p>
<h2 id="1-安装npm"><a href="#1-安装npm" class="headerlink" title="1 安装npm"></a>1 安装npm</h2><p>要使用npm, 需要安装node.js和npm软件，node.js 是一个异步事件驱动的 JavaScript 运行时。</p>
<p>node.js 就像其他的语言一样，有很多的版本， npm官网推荐使用<code>nvm</code>–一个node版本管理器，为了解决nodejs各种版本不兼容的问题，类似Python的conda。</p>
<p>nvm: 一个node版本管理器， 提供不同版本的node和npm安装。</p>
<p>node.js: 一个JavaScript运行时。</p>
<p>npm: 一个前端包管理器。</p>
<h2 id="2-安装nvm"><a href="#2-安装nvm" class="headerlink" title="2 安装nvm"></a>2 安装nvm</h2><p>在windwos上安装 nvm <a href="https://github.com/coreybutler/nvm-windows">Github地址</a>，<a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a>。 直接下载 .exe 可执行文件进行安装。</p>
<p>常用命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nvm version <span class="comment"># 显示nvm的版本</span></span><br><span class="line"></span><br><span class="line">nvm list <span class="comment"># 列出当前系统安装的node.js 版本列表，使用【*】开头的代表，正在使用的版本。</span></span><br><span class="line"></span><br><span class="line">nvm list available <span class="comment"># 列出可供下载的nodejs版本</span></span><br><span class="line"></span><br><span class="line">nvm url </span><br><span class="line"></span><br><span class="line">nvm install &lt;版本号&gt;  [--<span class="type">insecure</span>]   <span class="comment"># 安装指定版本的nodejs， 加上--insecure绕过远程验证。</span></span><br><span class="line"></span><br><span class="line">nvm root &lt;path&gt;: <span class="comment"># 设置nvm存放不同版本node.js的目录。如果&lt;path&gt;未设置，将显示当前根目录。</span></span><br><span class="line"></span><br><span class="line">nvm node_mirror &lt;node_mirror_url&gt; <span class="comment"># 设置node国内镜像：https://npmmirror.com/mirrors/node/</span></span><br><span class="line"></span><br><span class="line">nvm npm_mirror &lt;npm_mirror_url&gt; <span class="comment"># 设置npm国内镜像：https://npmmirror.com/mirrors/npm/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上三个配置也可以到nvm的安装路径下的settings.txt设置</span></span><br></pre></td></tr></table></figure>
<p>使用nvm install nodejs版本号。 即可安装和nodejs匹配的npm。</p>
<h2 id="3-npm的常用命令"><a href="#3-npm的常用命令" class="headerlink" title="3 npm的常用命令"></a>3 npm的常用命令</h2><h3 id="3-1-查询npm的版本"><a href="#3-1-查询npm的版本" class="headerlink" title="3.1 查询npm的版本"></a>3.1 查询npm的版本</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="literal">-v</span> </span><br></pre></td></tr></table></figure>
<h3 id="3-2-初始化或更新一个包"><a href="#3-2-初始化或更新一个包" class="headerlink" title="3.2 初始化或更新一个包"></a>3.2 初始化或更新一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成它而不让它问任何问题</span></span><br><span class="line">npm init <span class="literal">-y</span> </span><br></pre></td></tr></table></figure>
<h3 id="3-3-安装一个包"><a href="#3-3-安装一个包" class="headerlink" title="3.3 安装一个包"></a>3.3 安装一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm installl package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名 i，add, in, ins, inst, insta, instal, isnt, isnta, isntal, isntall</span></span><br><span class="line"><span class="comment"># npm install package -g   全局安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># npm i package@latest 指定最新版本， 或者版本号</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-全新安装项目-（安装一个干净的项目）"><a href="#3-4-全新安装项目-（安装一个干净的项目）" class="headerlink" title="3.4 全新安装项目 （安装一个干净的项目）"></a>3.4 全新安装项目 （安装一个干净的项目）</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm ci</span><br><span class="line"><span class="comment"># 别名: clean-install, ic, install-clean, isntall-clean</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令与 npm install 类似，不同之处在于它旨在用于自动化环境，例如测试平台、持续集成和部署——或任何您希望确保对依赖项进行全新安装的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 npm install 和 npm ci 的主要区别是：</span></span><br><span class="line"><span class="comment"># 1.该项目必须具有现有的 package-lock.json 或 npm-shrinkwrap.json。</span></span><br><span class="line"><span class="comment"># 2. 如果包锁中的依赖项与 package.json 中的依赖项不匹配，npm ci 将退出并出错，而不是更新包锁。</span></span><br><span class="line"><span class="comment"># 3. npm ci 一次只能安装整个项目： 不能使用此命令添加单个依赖项。</span></span><br><span class="line"><span class="comment"># 4. 如果 node_modules 已经存在，它将在 npm ci 开始安装之前自动删除。</span></span><br><span class="line"><span class="comment"># 5. 它永远不会写入 package.json 或任何包锁： 安装基本上被冻结了。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-管理-npm-配置文件"><a href="#3-5-管理-npm-配置文件" class="headerlink" title="3.5 管理 npm 配置文件"></a>3.5 管理 npm 配置文件</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> &lt;key&gt;=&lt;value&gt; [&lt;<span class="type">key</span>&gt;=&lt;<span class="type">value</span>&gt; <span class="type">...</span>]</span><br><span class="line">npm config get [&lt;<span class="type">key</span>&gt; [&lt;<span class="type">key</span>&gt; <span class="type">...</span>]]</span><br><span class="line">npm config delete &lt;key&gt; [&lt;<span class="type">key</span>&gt; <span class="type">...</span>]</span><br><span class="line">npm config list [--<span class="type">json</span>]</span><br><span class="line">npm config edit</span><br><span class="line">npm config fix</span><br><span class="line"><span class="comment"># 别名: c</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-列出安装的包"><a href="#3-6-列出安装的包" class="headerlink" title="3.6 列出安装的包"></a>3.6 列出安装的包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">ls</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># npm ls --all 列出所有包的依赖</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-启动一个包"><a href="#3-7-启动一个包" class="headerlink" title="3.7 启动一个包"></a>3.7 启动一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">start</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将运行在包的 &quot;scripts&quot; 对象的 &quot;start&quot; 属性中指定的预定义命令。如果 &quot;scripts&quot; 对象没有定义 &quot;start&quot; 属性，npm 将运行 node server.js。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-8-停止一个包"><a href="#3-8-停止一个包" class="headerlink" title="3.8 停止一个包"></a>3.8 停止一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm stop </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将运行在包的 &quot;scripts&quot; 对象的 &quot;stop&quot; 属性中指定的预定义命令。与 npm start 不同，如果未定义 &quot;stop&quot; 属性，则不会运行默认脚本。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-9-测试一个包"><a href="#3-9-测试一个包" class="headerlink" title="3.9 测试一个包"></a>3.9 测试一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm test </span><br><span class="line"><span class="comment"># 这将运行在包的 &quot;scripts&quot; 对象的 &quot;test&quot; 属性中指定的预定义命令。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-10-卸载一个包"><a href="#3-10-卸载一个包" class="headerlink" title="3.10 卸载一个包"></a>3.10 卸载一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm uninstall package</span><br><span class="line"><span class="comment"># 别名： unlink, remove, rm, r, un</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将卸载一个包，完全删除代表它安装的所有 npm。</span></span><br><span class="line"><span class="comment"># 它还会从 package.json 中的 dependencies、devDependencies、optionalDependencies 和 peerDependencies 对象中删除包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 --no-save  不会从package.json、npm-shrinkwrap.json 或 package-lock.json 文件中删除。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-11-更新包"><a href="#3-11-更新包" class="headerlink" title="3.11 更新包"></a>3.11 更新包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm update package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名: up, upgrade, udpate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令会将列出的所有包更新到最新版本（由 tag 配置 指定），同时尊重包及其依赖项的 semver 约束（如果它们也需要相同的包）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它还将安装缺少的包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定了 -g 标志，此命令将更新全局安装的包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果未指定包名称，则将更新指定位置（全局或本地）中的所有包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，默认情况下，npm update 不会更新项目 package.json 中直接依赖项的 semver 值，如果你还想更新 package.json 中的值，你可以运行： npm update --save</span></span><br></pre></td></tr></table></figure>


<p>详细的命令来自 <a href="https://npm.nodejs.cn/">npm中文网</a>。</p>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS溢出</title>
    <url>/2022/08/17/CSS%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<p>CSS溢出</p>
<p>在CSS中一切皆盒子，我们可以设置盒子的大小，但是当我们的内容大于盒子的大小的时候，就会导致内容溢出。</p>
<p>控制溢出的几种方式</p>
<p>overflow</p>
<p>默认值：<code>visible</code>，默认情况下溢出是可见的。</p>
<p>如果想让溢出的元素裁减掉，可以使用<code>hidden</code>。</p>
<p>既不裁剪也不希望溢出，<code>scroll</code> 更合适，他会在原本的盒子上加一个滚动条，既保证盒子的大小，也不会将数据裁减掉。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333333</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>This box has a height and a width. This means that if there is too much content to be displayed within the assigned height, there will be an overflow situation. If overflow is set to hidden then any overflow will not be visible.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This content is outside of the box.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2022-08-18_14-22-00.png"></p>
<p>以上的情况确实显示滚动条，但是横向也显示了滚动条，如果只希望在Y轴上显示可以使用<code>overflow-y: scroll</code>。同理x轴：<code>overflow-x: scroll</code>。</p>
<p>使用<code>overflow: auto</code>，由浏览器决定是否显示滚动条。桌面浏览器一般仅仅会在有足以引起溢出的内容的时候这么做。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS盒模型</title>
    <url>/2022/08/17/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><p>在CSS中所有的元素都被一个个的<em>“盒子”</em>包围着，CSS的布局处理元素排列正式通过盒子来实现的。</p>
<p>在CSS中有两种盒子是被广泛使用的：块级（block）盒子和内联（inline）盒子。这两种盒子会在页面上表现出两种不同的行为。</p>
<h2 id="1-块级盒子"><a href="#1-块级盒子" class="headerlink" title="1 块级盒子"></a>1 块级盒子</h2><ul>
<li>盒子会在内联的方向上扩展并占据父容器的在该方向上的所有可用空间，大多数情况下意味着盒子会和父容器一样宽。</li>
<li>每个盒子都会换行。</li>
<li><code>width</code>和<code>hright</code>属性可以发挥作用。</li>
<li>内边距（padding）外边距（margin）和边框（border）会将其他的元素从当前格子周围推开。(相邻两个块级盒子之间的垂直间距会遵循外边距折叠原则被折叠。)</li>
</ul>
<p>除非特殊指定，诸如<code>h1</code>等和段落<code>p</code>默认都是块级的盒子。</p>
<h2 id="2-内联盒子"><a href="#2-内联盒子" class="headerlink" title="2 内联盒子"></a>2 内联盒子</h2><ul>
<li>内联盒子不会产生换行。</li>
<li><code>width</code>和<code>hright</code>属性不起作用。</li>
<li>垂直方向的内边距（padding）外边距（margin）和边框（border）==会被应用==，但是==不会==把其他的处于<code>inline</code>状态的盒子推开。</li>
<li>水平方向的内边距（padding）外边距（margin）和边框（border）==会被应用==，==会==把其他的处于<code>inline</code>状态的盒子推开。</li>
</ul>
<p>针对块级盒子和内联盒子可以使用<code>display</code>属性设置<code>block</code>和<code>inline</code>。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="* 补充"></a>* 补充</h2><p>以上叙述中是CSS盒模型的外部显示类型，决定盒子是内联盒子还是块级盒子。同样盒模型也有一个内部显示类型，它决定了盒子内部是如何布局的，默认是按照<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow">正常文档流布局</a>，但是可以通过<code>flex</code>的<code>display</code>属性来更改内部显示类型。</p>
<p>例如：如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。==该盒子的所有直接子元素都会成为 flex 元素==。会根据==<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">弹性盒子</a>==规则进行布局。</p>
<p>块级和内联是web上默认的行为，它们被称为正常文档流，如果没有其他的说明，盒子的默认布局就是块级或者内联。</p>
<h2 id="3-盒模型的组成部分"><a href="#3-盒模型的组成部分" class="headerlink" title="3 盒模型的组成部分"></a>3 盒模型的组成部分</h2><ul>
<li>Content Box：这个区域使用来显示内容，大小可以通过设置<code>width</code>和<code>height</code>。</li>
<li>Padding Box：包围在内容区域外部的空白区域，大小可以通过<code>padding</code>设置。</li>
<li>Border Box：盒子的边框区域，大小通过<code>border</code>设置。</li>
<li>Margin Box：盒子的最外围区域，是盒子和其他元素之间的空白区域，大小通过<code>margin</code>设置。</li>
</ul>
<p>如下图：</p>
<p><img src="https://tc.chaizz.com/tc/box-model.png"></p>
<h2 id="4-标准盒模型"><a href="#4-标准盒模型" class="headerlink" title="4 标准盒模型"></a>4 标准盒模型</h2><p>在标准盒模型中，给盒子设置width和height，实际设置的是content box padding和border再加上一起设置的width和height再决定了盒子的大小。</p>
<p>假设定义了 <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>和<code>padding</code>:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>计算出的模型宽度 = 410px(350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。</p>
<p><img src="/2022/08/17/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/Users\LHKJ0\Pictures\WEB\CSS\standard-box-model.png"></p>
<blockquote>
<p>注意：margin不计入实际大小，但是它会影响盒子实际占用的空间，影响的是盒子外部的空间，盒子的范围到边框为止，不会延伸到margin。</p>
</blockquote>
<h2 id="5-替代盒模型"><a href="#5-替代盒模型" class="headerlink" title="5 替代盒模型"></a>5 替代盒模型</h2><p>这个模型所有的宽度都是可见宽度，所以内容的宽度是总宽度减去边框的宽度和内边距的宽度。</p>
<p>默认浏览器会使用标准盒模型，需要使用替代模型需要设置 <code>box-sizing:border-box</code>。如果想让所有元素都是用替代模型，只需要在html元上指定<code>box-sizing</code>，然后设置所有元素继承该属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *<span class="selector-pseudo">::before</span>, *<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-盒子模型的属性解析"><a href="#6-盒子模型的属性解析" class="headerlink" title="6 盒子模型的属性解析"></a>6 盒子模型的属性解析</h2><h3 id="6-1-外边距（margin）"><a href="#6-1-外边距（margin）" class="headerlink" title="6.1 外边距（margin）"></a>6.1 外边距（margin）</h3><p>外边距是盒子周围看不到的一些空间，他会把其他的元素从盒子旁边推开，外边距的属性可以为正也可以为负，设置负值会导致和其他的内容重叠。无论是使用标准盒子模型还是替代盒子模型，外边距总是在计算可见部分后额外的添加。</p>
<p>可以使用<code>margin</code>设置四个反向的内容，也可以分别使用四个独立的属性设置：<code>margin-top</code>、<code>margin-right</code>、<code>margin-left</code>、<code>margin-right</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;        <span class="comment">/* 绝对长度 */</span></span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">1em</span>;         <span class="comment">/*相对于字体大小 */</span></span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">5%</span>;          <span class="comment">/*相对于最相邻的父级元素块（block）的宽度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>外边距折叠：如果有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的那个外边距的大小。</p>
<p>有设定<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float">float</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#absolute">position=absolute</a>的元素不会产生外边距重叠行为。</p>
</blockquote>
<h3 id="6-2-内边距（padding）"><a href="#6-2-内边距（padding）" class="headerlink" title="6.2 内边距（padding）"></a>6.2 内边距（padding）</h3><p>内边距位于边框和内容之间，==且不能有负数的形式==，应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>简写属性控制元素所有边，或者每边单独使用等价的普通属性：<code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code>。</p>
<h3 id="6-3-边框（border）"><a href="#6-3-边框（border）" class="headerlink" title="6.3 边框（border）"></a>6.3 边框（border）</h3><p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p>
<p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性一次设置所有四个边框的宽度、颜色和样式。</p>
<p>分别设置每边的宽度、颜色和样式，可以使用：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></p>
<p>设置所有边的颜色、样式或宽度，请使用以下属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></p>
<p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-style"><code>border-top-style</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-color"><code>border-top-color</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-width"><code>border-right-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-style"><code>border-right-style</code></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-color"><code>border-right-color</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-width"><code>border-bottom-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-style"><code>border-bottom-style</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-color"><code>border-bottom-color</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-width"><code>border-left-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-style"><code>border-left-style</code>、</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-color"><code>border-left-color</code></a></p>
<h2 id="7-盒子模型和内联盒子"><a href="#7-盒子模型和内联盒子" class="headerlink" title="7 盒子模型和内联盒子"></a>7 盒子模型和内联盒子</h2><p>以上所有的方法都完全适用于块级盒子，有些属性也可以应用于内联盒子。在内联合中应用宽度、高度、边距、边框和内边距时，宽度和高度是被忽略的，外边距、内边距和边框是生效的。但是他们不会改变其他内容与盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p>
<p><img src="/2022/08/17/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/Users\LHKJ0\Pictures\WEB\CSS\Snipaste_2022-08-17_17-29-30.png"></p>
<p>为了解决以上的问题可以使用：display: inline-block。display 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用：不希望一个元素切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p>
<p>一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果：</p>
<ul>
<li>设置<code>width</code> 和<code>height</code> 属性会生效。</li>
<li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li>
</ul>
<p>但是，它不会跳转到新行，如果显式添加 <code>width</code> 和 <code>height</code> 属性，它只会变得比其内容更大。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS层叠与继承</title>
    <url>/2022/08/16/CSS%E5%B1%82%E5%8F%A0%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS-层叠与继承"><a href="#CSS-层叠与继承" class="headerlink" title="CSS 层叠与继承"></a>CSS 层叠与继承</h1><blockquote>
<p>某些时候项目过程中，会有些样式效果没有生效，很有可能就是创建了应用于两个元素的同一规则。</p>
</blockquote>
<h2 id="1-层叠"><a href="#1-层叠" class="headerlink" title="1 层叠"></a>1 层叠</h2><p>层叠可以理解为覆盖，简单的说就是CSS规则的顺序很重要，当应用两条同级别的规则到同一个元素的时候，最后的一个规则即是生效的规则。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123; </span><br><span class="line">    <span class="attribute">color</span>: red; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123; </span><br><span class="line">    <span class="attribute">color</span>: blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is my heading.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2 优先级"></a>2 优先级</h2><p>浏览器根据优先级决定当多个规则有不同选择器对应相同的元素的时候需要应用那个规则，他基本上是一个衡量选择器具体选择哪些区域的尺度：</p>
<ul>
<li><p>外链CSS地址优先级最低。</p>
</li>
<li><p>标签选择器选择页面上该类型的所有元素，他的优先级低一点。</p>
</li>
<li><p>类选择器相对于标签选择器会具体一点，他会选择页面上中有特定<code>class</code>属性值的元素，所以他的优先级就要高一点。</p>
</li>
<li><p>ID选择器是针对于网页中唯一的标签属性优先级会更高一点。</p>
</li>
<li><p>内联样式优先级最高。</p>
</li>
</ul>
<h3 id="2-1-浏览器如何计算优先级"><a href="#2-1-浏览器如何计算优先级" class="headerlink" title="2.1 浏览器如何计算优先级"></a>2.1 浏览器如何计算优先级</h3><p>不同的选择器会有不同的分值，把这些分值相加就得到特定选择器的权重，然后再进行匹配。</p>
<p>一个选择器有四个部分的分值相加可以认为是：个十百千 四位数的个位数。</p>
<ol>
<li>千位：如果是内联样式，该位得一分，没有声明选择器所以得分是1000（内联样式优先级最高）。</li>
<li>百位：ID选择器得一分。</li>
<li>十位：类选择器得一分（包括属性选择器、伪类选择器）。</li>
<li>元素（标签）选择器，伪元素选择器器得一分。</li>
</ol>
<blockquote>
<p><strong>备注：</strong> 通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
</blockquote>
<blockquote>
<p><strong>警告：</strong> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 1. specificity: 1-0-1 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">/* 2. specificity: 2-0-1 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-id">#inner</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. specificity: 1-0-4 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">div</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. specificity: 1-1-3 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">div</span> <span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5. specificity: 0-2-4 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. specificity: 0-2-3 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> dashed black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. specificity: 0-3-3 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-class">.nav</span><span class="selector-pseudo">:nth-child(2)</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> double black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>针对上面的代码解释：</p>
<ul>
<li>前面两个选择器都是链接背景颜色的样式 — 第二个赢了使得背景变成蓝色因为它多了一个 ID 选择器：优先级 201 vs. 101。</li>
<li>第三四个选择器都是链接文本颜色样式 — 第二个（第四个）赢了使得文本变成白色因为它虽然少一个元素选择器，但是多了一个类选择器，多了 9 分。所以优先级是 113 vs. 104。</li>
<li>第 5 到 7 个选择器都是鼠标悬停时链接边框样式。第六个显然输给第五个优先级是 23 vs. 24 — 少了个元素选择器。 第七个，比第五第六都高 — 子选择器数量相同，但是有一个元素选择器变成类选择器。所以最后优先级是 33 vs. 23 和 24。</li>
</ul>
<p><strong>注意</strong></p>
<p>有一个特殊的CSS可以覆盖上面的所有的优先级计算：<code>!important</code> 用于修改特定属性的值，能够覆盖普通规则的值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#winning</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.better</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;better&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;better&quot;</span> <span class="attr">id</span>=<span class="string">&quot;winning&quot;</span>&gt;</span>One selector to rule them all!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>代码解释：</p>
<p>按照以上代码渲染出的效果应该是：<code>class=&quot;better&quot;</code>的p标签背景是灰色的，字体颜色为白色，内边距为5px，没有边框。</p>
<p><code>id=&quot;winning&quot;</code>的p标签背景色是红色的，字体颜色为白色，内边距为5px。同样没有边框。因为在两个p标签都有类属性：<code>better</code> 且<code>better</code>的<code>border</code>设置了<code>!important</code>。尽管优先级比较低，也使用了这个CSS样式。</p>
<p>__覆盖<code>!important</code>__的方法就是使用另外一个<code>!important</code> 具有相同的优先级且顺序靠后的，或者是优先级跟高。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>相互冲突的声明按照以下顺序适用，后面的覆盖前面的。</p>
<ol>
<li>用户代理样式表中的声明（浏览器的默认样式，在没有设置其他的样式时使用）。</li>
<li>用户样式表中的常规声明 (由用户设置的自定义样式)。</li>
<li>作者样式表中的常规声明 (这些是我们 web 开发人员设置的样式)。</li>
<li>作者样式表中的<code>!important</code>声明。</li>
<li>用户样式表中的<code>!important</code> 声明</li>
</ol>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/2022/08/16/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><blockquote>
<p>CSS中使用选择器来指定网页上我们想要格式化的HTML元素</p>
</blockquote>
<h2 id="1-选择器列表"><a href="#1-选择器列表" class="headerlink" title="1 选择器列表"></a>1 选择器列表</h2><p>如果有多个使用相同样式的CSS选择器，那么这些选择器可以被编排为一个列表。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个标签使用了同样的样式可以写成两个分开的规则，也可以则合起来，在他们之间加上逗号即可组成为一个选择器列表。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>在使用选择器列表时，如果任何一个选择器无效（存在语法错误）那么整条规则都会被疏略。</p>
<h2 id="2-选择器种类"><a href="#2-选择器种类" class="headerlink" title="2 选择器种类"></a>2 选择器种类</h2><table>
<thead>
<tr>
<th><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors">标签选择器</a></th>
<th><code>h1 &#123; &#125;</code></th>
<th align="left">html标签</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">通配选择器</a></td>
<td><code>* &#123; &#125;</code></td>
<td align="left">选择所有元素</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors">类选择器</a></td>
<td><code>.box &#123; &#125;</code></td>
<td align="left">类选择器</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors">ID 选择器</a></td>
<td><code>#unique &#123; &#125;</code></td>
<td align="left">标签选择器</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">标签属性选择器</a></td>
<td><code>a[title] &#123; &#125;</code></td>
<td align="left">根据标签一个元素上某个标签的属性的存在选择元素</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类选择器</a></td>
<td><code>a:hover &#123;&#125;</code></td>
<td align="left">表示一个元素的特定的状态  <em>(在鼠标指针悬浮到一个元素上的时候选择这个元素)</em></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">伪元素选择器</a></td>
<td><code>p::first-line &#123; &#125;</code></td>
<td align="left">选择一个元素的某个部分而不是元素自己 <em>(<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行)</em></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator">后代选择器</a></td>
<td><code>article p</code></td>
<td align="left">（通常用单个空格（” “）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator">子代选择器</a></td>
<td><code>article &gt; p</code></td>
<td align="left">当使用 <code>&gt;</code> 选择符分隔两个元素时，它只会匹配那些作为第一个元素的**直接后代 (**子元素) 的第二元素。与之相比，当两个元素由 <a href="https://developer.mozilla.org/en-US/CSS/Descendant_selectors">后代选择器</a> 相连时，它表示匹配存在的所有由第一个元素作为祖先元素 (但不一定是父元素) 的第二个元素，无论它在 DOM 中”跳跃” 多少次。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator">相邻兄弟选择器</a></td>
<td><code>h1 + p</code></td>
<td align="left">介于两个选择器之间，当第二个元素<em>紧跟在</em>第一个元素之后，并且两个元素都是属于同一个父<code>元素</code>的子元素，则第二个元素将被选中。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">通用兄弟选择器</a></td>
<td><code>h1 ~ p</code></td>
<td align="left">兄弟选择符，位置无须紧邻，只须同层级，<code>A~B</code> 选择<code>A</code>元素之后所有同层级<code>B</code>元素。</td>
</tr>
</tbody></table>
<h3 id="2-1-标签、类和-ID-选择器"><a href="#2-1-标签、类和-ID-选择器" class="headerlink" title="2.1 标签、类和 ID 选择器"></a>2.1 标签、类和 ID 选择器</h3><p><strong>类型选择器</strong>有时也叫做“标签名选择器<em>”</em>或者是”元素选择器“，因为它在文档中选择了一个 HTML 标签/元素的缘故。</p>
<p>类选择器以一个句点（<code>.</code>）开头，会选择文档中应用了这个类的所有元素。</p>
<p>ID 选择器开头为<code>#</code>而非句点，和类选择器是同种用法。</p>
<h4 id="2-1-1-全局选择器"><a href="#2-1-1-全局选择器" class="headerlink" title="2.1.1 全局选择器"></a>2.1.1 全局选择器</h4><p>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容。</p>
<p>更易读的全局选择器， 例如：</p>
<p>如果我想选中任何<code>&lt;article&gt;</code>元素的第一子元素，不论它是什么元素，都给它加粗。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来可能会和 为元素选择器混淆</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:first-child</span></span><br></pre></td></tr></table></figure>
<p>为了避免这种混淆，我们可以向<code>:first-child</code>选择器加入全局选择器，这样选择器所做的事情很容易就能看懂。选择器正选中<code>&lt;article&gt;</code>元素的<em>任何</em>第一子元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> *<span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-属性选择器"><a href="#2-2-属性选择器" class="headerlink" title="2.2 属性选择器"></a>2.2 属性选择器</h3><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr]</code></td>
<td align="left"><code>a[title]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td>
</tr>
<tr>
<td align="left"><code>[attr=value]</code></td>
<td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr~=value]</code></td>
<td align="left"><code>p[class~=&quot;special&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td>
</tr>
<tr>
<td align="left">`[attr</td>
<td align="left">=value]`</td>
<td align="left">`div[lang</td>
</tr>
</tbody></table>
<h4 id="2-2-1-字符串匹配选择器"><a href="#2-2-1-字符串匹配选择器" class="headerlink" title="2.2.1 字符串匹配选择器"></a>2.2.1 字符串匹配选择器</h4><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr^=value]</code></td>
<td align="left"><code>li[class^=&quot;box-&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr$=value]</code></td>
<td align="left"><code>li[class$=&quot;-box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td>
</tr>
<tr>
<td align="left"><code>[attr*=value]</code></td>
<td align="left"><code>li[class*=&quot;box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td>
</tr>
</tbody></table>
<p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。这个标记告诉浏览器，要以大小写不敏感的方式匹配 ASCII 字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式进行匹配，<strong>在HTML中是大小写敏感的</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">li[class^=&quot;a&quot; i] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Case-insensitivity<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;A&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;Ab&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-伪类伪元素选择器"><a href="#2-3-伪类伪元素选择器" class="headerlink" title="2.3 伪类伪元素选择器"></a>2.3 伪类伪元素选择器</h3><h4 id="2-3-1-伪类选择器"><a href="#2-3-1-伪类选择器" class="headerlink" title="2.3.1 伪类选择器"></a>2.3.1 伪类选择器</h4><p>它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。伪元素开头为双单冒号<code>:</code>。</p>
<p>应用案例：</p>
<p>比如要让某个文章的第一段加粗，字体变大。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">            melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">            greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用以上样式的确可以实现需求，但是此时文章开头又加入了一段话，就需要将 <code>class=&quot;first&quot;</code>改到第一段，比较麻烦。此时就可以使用伪类选择器<code>class=&quot;first&quot;</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">            melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">            greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样始终能够保持article下面第一个标签样式被加粗字体变大。</p>
<p>此外还有其他的几个伪类选择器</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a> 父元素的最后一个元素。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a> 匹配没有任何兄弟元素的元素。等效的选择器还可以写成 <code>:first-child:last-child</code>或者<code>:nth-child(1):nth-last-child(1)</code>,当然，前者的权重会低一点。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a> 表示任意内容未通过验证的 <code>input</code>或其他 <code>form</code> 元素， 这个伪类对于突出显示用户的字段错误非常有用。</li>
</ul>
<p>用户行为伪类也叫做动态伪类。表现形式为像是一个类在用户和元素交互的时候加到了元素上一样。</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:hover"><code>:hover</code></a>——上面提到过，只会在用户将指针挪到元素上的时候才会激活，一般就是链接元素。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:focus"><code>:focus</code></a>——只会在用户使用键盘控制，选定元素的时候激活。</li>
</ul>
<h5 id="常见的伪类类型"><a href="#常见的伪类类型" class="headerlink" title="常见的伪类类型"></a>常见的伪类类型</h5><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a></td>
<td align="left">在用户激活（例如点击）元素的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link"><code>:any-link</code></a></td>
<td align="left">匹配一个链接的<code>:link</code>和<code>:visited</code>状态。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:blank"><code>:blank</code></a></td>
<td align="left">匹配空输入值的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">``元素</a>。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked"><code>:checked</code></a></td>
<td align="left">匹配处于选中状态的单选或者复选框。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API"><code>:current</code> </a></td>
<td align="left">匹配正在展示的元素，或者其上级元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default"><code>:default</code></a></td>
<td align="left">匹配一组相似的元素中默认的一个或者更多的 UI 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir"><code>:dir</code></a></td>
<td align="left">基于其方向性（HTML<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir"><code>dir</code></a>属性或者 CSS<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/direction"><code>direction</code></a>属性的值）匹配一个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled"><code>:disabled</code></a></td>
<td align="left">匹配处于关闭状态的用户界面元素</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty"><code>:empty</code></a></td>
<td align="left">匹配除了可能存在的空格外，没有子元素的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled"><code>:enabled</code></a></td>
<td align="left">匹配处于开启状态的用户界面元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first"><code>:first</code></a></td>
<td align="left">匹配<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Paged_Media">分页媒体</a>的第一页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a></td>
<td align="left">匹配兄弟元素中的第一个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type"><code>:first-of-type</code></a></td>
<td align="left">匹配兄弟元素中第一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a></td>
<td align="left">当一个元素有焦点的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible"><code>:focus-visible</code></a></td>
<td align="left">当元素有焦点，且焦点对用户可见的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within"><code>:focus-within</code></a></td>
<td align="left">匹配有焦点的元素，以及子代元素有焦点的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:future"><code>:future</code> </a></td>
<td align="left">匹配当前元素之后的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a></td>
<td align="left">当用户悬浮到一个元素之上的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate"><code>:indeterminate</code></a></td>
<td align="left">匹配未定态值的 UI 元素，通常为<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox">复选框</a>。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range"><code>:in-range</code></a></td>
<td align="left">用一个区间匹配元素，当值处于区间之内时匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>的位于不可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang"><code>:lang</code></a></td>
<td align="left">基于语言（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang">lang</a>属性的值）匹配元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></td>
<td align="left">匹配兄弟元素中最末的那个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type"><code>:last-of-type</code></a></td>
<td align="left">匹配兄弟元素中最后一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left"><code>:left</code></a></td>
<td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 </a>中，匹配左手边的页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a></td>
<td align="left">匹配未曾访问的链接。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:local-link"><code>:local-link</code></a></td>
<td align="left">匹配指向和当前文档同一网站页面的链接。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a></td>
<td align="left">匹配传入的选择器列表中的任何选择器。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not"><code>:not</code></a></td>
<td align="left">匹配作为值传入自身的选择器未匹配的物件。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a></td>
<td align="left">匹配一列兄弟元素中的元素——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type"><code>:nth-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child"><code>:nth-last-child</code></a></td>
<td align="left">匹配一列兄弟元素，从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type"><code>:nth-last-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素），从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></td>
<td align="left">匹配没有兄弟元素的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type"><code>:only-of-type</code></a></td>
<td align="left">匹配兄弟元素中某类型仅有的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional"><code>:optional</code></a></td>
<td align="left">匹配不是必填的 form 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range"><code>:out-of-range</code></a></td>
<td align="left">按区间匹配元素，当值不在区间内的的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:past"><code>:past</code> </a></td>
<td align="left">匹配当前元素之前的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown"><code>:placeholder-shown</code></a></td>
<td align="left">匹配显示占位文字的 input 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:playing"><code>:playing</code> </a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:paused"><code>:paused</code> </a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only"><code>:read-only</code></a></td>
<td align="left">匹配用户不可更改的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write"><code>:read-write</code></a></td>
<td align="left">匹配用户可更改的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required"><code>:required</code></a></td>
<td align="left">匹配必填的 form 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right"><code>:right</code></a></td>
<td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 </a>中，匹配右手边的页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a></td>
<td align="left">匹配文档的根元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope"><code>:scope</code></a></td>
<td align="left">匹配任何为参考点元素的的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid"><code>:valid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>元素的处于可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target"><code>:target</code></a></td>
<td align="left">匹配当前 URL 目标的元素（例如如果它有一个匹配当前<a href="https://en.wikipedia.org/wiki/Fragment_identifier">URL 分段</a>的元素）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a></td>
<td align="left">匹配已访问链接。</td>
</tr>
</tbody></table>
<h4 id="2-3-2-伪元素选择器"><a href="#2-3-2-伪元素选择器" class="headerlink" title="2.3.2 伪元素选择器"></a>2.3.2 伪元素选择器</h4><p>伪元素和伪类的形式差不多，但是是表现得像往标记文本中加入全新的 HTML 元素一样，伪元素开头为双冒号<code>::</code>。</p>
<p>应用案例：</p>
<p>比如要让某个文章的第一行字体加粗，变大。</p>
<p>如果用span来实现，当无法知道屏幕的大小，或者字体大小的时候就无法准确选择第一行，所以伪元素选择器就可以完全很好的实现这一样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">            melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">            greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>特别的伪元素 <code>::before</code>和<code>::after</code>和<code>cotent</code>属性一起使用，使用CSS将内容插入到你的文档中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;This should show before the other content.&quot;</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Content in the box in my HTML page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些伪元素并不会在 Web 浏览器上经常这么做，更推荐的用法是插入一些图标，作为一个视觉性的提示，或者插入一个空字符串，并设计他的样式，使其成为一个视觉的性的提示。</p>
<h5 id="常见的伪元素类型"><a href="#常见的伪元素类型" class="headerlink" title="常见的伪元素类型"></a>常见的伪元素类型</h5><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter"><code>::first-letter</code></a></td>
<td align="left">匹配元素的第一个字母。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line"><code>::first-line</code></a></td>
<td align="left">匹配包含此伪元素的元素的第一行。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error"><code>::grammar-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的语法错误的那部分。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection"><code>::selection</code></a></td>
<td align="left">匹配文档中被选择的那部分。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error"><code>::spelling-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td>
</tr>
</tbody></table>
<h3 id="2-4-关系选择器"><a href="#2-4-关系选择器" class="headerlink" title="2.4 关系选择器"></a>2.4 关系选择器</h3><p>关系选择器都是针对于第二个元素。</p>
<h4 id="2-4-1-后代选择器"><a href="#2-4-1-后代选择器" class="headerlink" title="2.4.1 后代选择器"></a>2.4.1 后代选择器</h4><p>使用空格隔开（“ ”），组合两个选择器，比如第二个选择器的元素被选择，且其余的相同元素都和第二个选择器有同一个祖先的都会被选择。（不管多少代都会被选择）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text in .box<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text in .box2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text in .box<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Text not in .box<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-子代关系选择器"><a href="#2-4-2-子代关系选择器" class="headerlink" title="2.4.2 子代关系选择器"></a>2.4.2 子代关系选择器</h4><p>子代关系选择器是个大于号（<code>&gt;</code>），只会在选择器选中直接子元素的时候匹配。（只选择第一代的所有相同元素）</p>
<h4 id="2-4-3-邻接兄弟选择器"><a href="#2-4-3-邻接兄弟选择器" class="headerlink" title="2.4.3 邻接兄弟选择器"></a>2.4.3 邻接兄弟选择器</h4><p>邻接兄弟选择器（<code>+</code>）用来选中恰好处于另一个在继承关系上同级的元素旁边的元素。</p>
<p>比如要设置紧跟<code>h1</code>的<code>p</code>标签，设计样式，如果在他们之间再加一个其他的标签，就无法应用样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;h2&gt;哈哈哈&lt;/h2&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">        melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">        greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-通用兄弟选择器"><a href="#2-4-4-通用兄弟选择器" class="headerlink" title="2.4.4 通用兄弟选择器"></a>2.4.4 通用兄弟选择器</h4><p>选中一个标签的兄弟标签，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（<code>~</code>）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> ~ <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>I am a div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am another paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>使用关系选择器可以将以上任意选择器组合起来，达到选择某个元素的目的。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Docker镜像瘦身[Python]</title>
    <url>/2022/08/04/%E8%AE%B0%E4%B8%80%E6%AC%A1Docker%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<p>​      </p>
<a id="more"></a>

<blockquote>
<p>前言：</p>
<p>​    在使用Python开发时，需要将镜像发布到私有仓库中或者阿里云仓库中，然后在K8S拉取镜像部署，但是项目经过打包后镜像大小高达3.1G。</p>
<p>​    每次打包镜像需要花费的时间太久且镜像拉取时间太长。</p>
</blockquote>
<h1 id="镜像优化历程"><a href="#镜像优化历程" class="headerlink" title="镜像优化历程"></a>镜像优化历程</h1><h2 id="一、初始版Dockerfile内容"><a href="#一、初始版Dockerfile内容" class="headerlink" title="一、初始版Dockerfile内容"></a>一、初始版Dockerfile内容</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dpkg -i rocketmq-client-cpp-2.0.0.amd64.deb </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -i https://mirrors.aliyun.com/pypi/simple/ --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;run.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>


<p>构建镜像后镜像大小为3个多G</p>
<p>优化解决方案：</p>
<ul>
<li><strong>避免出现多层</strong></li>
<li><strong>使用官方精简版本镜像</strong></li>
</ul>
<h2 id="二、第二版Dockerfile内容"><a href="#二、第二版Dockerfile内容" class="headerlink" title="二、第二版Dockerfile内容"></a>二、第二版Dockerfile内容</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i -E <span class="string">&#x27;s/(deb|security).debian.org/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="bash">  &amp;&amp; dpkg -i rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt update -y \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt install -y python3-dev default-libmysqlclient-dev build-essential \</span></span><br><span class="line"><span class="bash">  &amp;&amp; pip install -i https://pypi.mirrors.ustc.edu.cn/simple/  --no-cache-dir -r requirements_base.txt \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt clean -y \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /var/cache/debconf/* \</span></span><br><span class="line"><span class="bash">    /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    /var/<span class="built_in">log</span>/* \</span></span><br><span class="line"><span class="bash">    /var/tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br></pre></td></tr></table></figure>


<p>因为该项目使用了 <code>rocketmq</code> 所以需要使用 <code>rocketmq-client-cpp-2.0.0.amd64.deb</code> 起初打算使用 <code>python:3.8-alpine</code> 但是 <code>rocketmq</code> 没有 <code>alpine</code> 系统的包，只有 <code>debian</code> 的安装包。如果使用这个 <code>python:3.8-alpine</code>  基础镜像需要自己重新编译，所以选择了<code>python:3.8-slim</code> 这个基础镜像。</p>
<p>此外还需要安装mysqlclient的依赖库，所以需要更新apt源安装依赖。</p>
<p>将更新安装的apt依赖缓存删除。</p>
<p>此次镜像构建钩还有<strong>2.6G</strong>，依然很大。</p>
<p>优化解决方案：</p>
<ul>
<li>避免出现多层</li>
<li>使用官方精简版本镜像</li>
<li><strong>多层构建</strong></li>
</ul>
<h2 id="三、第三版DockerFile内容"><a href="#三、第三版DockerFile内容" class="headerlink" title="三、第三版DockerFile内容"></a>三、第三版DockerFile内容</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span> as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./requirements_base.txt .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -i https://pypi.mirrors.ustc.edu.cn/simple/  --no-cache-dir -r requirements_base.txt \</span></span><br><span class="line"><span class="bash">&amp;&amp; find /usr/<span class="built_in">local</span>/lib -name <span class="string">&#x27;*.pyc&#x27;</span> -delete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder   /usr/<span class="built_in">local</span>/lib/python3.8/site-packages /usr/<span class="built_in">local</span>/lib/python3.8/site-packages</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder  /usr/<span class="built_in">local</span>/bin/celery  /usr/<span class="built_in">local</span>/bin/celery</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder  /usr/lib/x86_64-linux-gnu/libmariadb.so  /usr/lib/x86_64-linux-gnu/libmariadb.so</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./rocketmq-client-cpp-2.0.0.amd64.deb .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  dpkg -i rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt clean -y \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /var/cache/debconf/* \</span></span><br><span class="line"><span class="bash">    /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    /var/<span class="built_in">log</span>/* \</span></span><br><span class="line"><span class="bash">    /var/tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br></pre></td></tr></table></figure>


<p>首先将需要安装的Python依赖安装且作为一个基础镜像，然后将 <code>/usr/local/lib/python3.8/site-packages</code> 安装的依赖复制到新的镜像中。</p>
<p>同样需要复制 <code>celery</code>的 启动文件：<code>/usr/local/bin/celery </code> 到新的镜像中, 否则使用 <code>celry -A pro worker</code> 会提示 <code>celery not found</code>的错误。</p>
<p>mysqlclient的依赖库在debian系统中是 <code>libmariadb.so</code> 也复制到 <code>/usr/lib/x86_64-linux-gnu/libmariadb.so</code> 动态库中去。</p>
<p>至此Python项目镜像大小由原来的<strong>3.1G</strong>缩小为<strong>567M</strong></p>
<p><img src="https://tc.chaizz.com/Snipaste_2022-08-04_18-05-28.png"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Kuboard</title>
    <url>/2022/07/30/%E9%83%A8%E7%BD%B2Kuboard/</url>
    <content><![CDATA[<p>​           </p>
<a id="more"></a>

<p>参考链接</p>
<blockquote>
<p><a href="https://www.kuboard.cn/install/v3/install-built-in.html">安装 Kuboard v3 - 内建用户库 | Kuboard</a></p>
</blockquote>
<blockquote>
<p>Kuboard 是一款专为 Kubernetes 设计的免费管理界面，兼容 Kubernetes 版本 1.13 及以上。Kuboard 每周发布一个 beta 版本，最长每月发布一个正式版本，经过两年的不断迭代和优化，已经具备多集群管理、权限管理、监控套件、日志套件等丰富的功能，并且有 1000+ 的企业将 Kuboard 应用于其生产环境。</p>
</blockquote>
<p>一、前期准备</p>
<ul>
<li><p>搭建完成Kubernetes 集群。 </p>
</li>
<li><p>Docker 安装完毕</p>
</li>
</ul>
<p>二、安装Kuboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard \</span><br><span class="line">  -p 80:80/tcp \</span><br><span class="line">  -p 10081:10081/tcp \</span><br><span class="line">  -e KUBOARD_ENDPOINT=&quot;http://192.158.59.130:80&quot; \</span><br><span class="line">  -e KUBOARD_AGENT_SERVER_TCP_PORT=&quot;10081&quot; \</span><br><span class="line">  -v /root/kuboard-data:/data \</span><br><span class="line">  eipwork/kuboard:v3</span><br></pre></td></tr></table></figure>
<p>三、访问 Kuboard</p>
<p>在浏览器输入 <code>http://your-host-ip:80</code> 即可访问 Kuboard v3.x 的界面，登录方式：</p>
<ul>
<li>用户名： <code>admin</code></li>
<li>密 码： <code>Kuboard123</code></li>
</ul>
]]></content>
      <categories>
        <category>Kubernets</category>
      </categories>
      <tags>
        <tag>Kuboard</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机K8s集群搭建</title>
    <url>/2022/07/30/%E9%83%A8%E7%BD%B2k8S%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<p>参考链接</p>
<blockquote>
<p><a href="https://www.kuboard.cn/install/v3/install.html">安装 Kubernetes 多集群管理工具 - Kuboard v3 | Kuboard</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/Sunzz/p/15184167.html">安装Kubernetes(k8s)保姆级教程—无坑版 - Sunzz - 博客园</a></p>
</blockquote>
<h1 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h1><h2 id="1-1-系统环境"><a href="#1-1-系统环境" class="headerlink" title="1.1 系统环境"></a>1.1 系统环境</h2><p>VMware 虚拟机环境下</p>
<p>系统：Ubuntu 22.04 LTS</p>
<p>CPU：2核 | 内存：4G | 硬盘：50G</p>
<h2 id="1-2-节点信息"><a href="#1-2-节点信息" class="headerlink" title="1.2 节点信息"></a>1.2 节点信息</h2><p><strong>master：</strong> 192.168.59.130</p>
<p><strong>node01：</strong> 192.168.59.131</p>
<p><strong>node02：</strong> 192.168.59.132</p>
<p>确保每个虚拟机唯一节点、网络通畅、开放端口：6443，禁用Swap</p>
<h2 id="1-3-关闭防火墙"><a href="#1-3-关闭防火墙" class="headerlink" title="1.3 关闭防火墙"></a>1.3 关闭防火墙</h2><p>根据使用的网络模式选择，此处关闭。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld &amp;&amp; systemctl disable firewalld &amp;&amp; iptables -F</span><br></pre></td></tr></table></figure>
<h2 id="1-4-关闭-selinux"><a href="#1-4-关闭-selinux" class="headerlink" title="1.4 关闭 selinux"></a>1.4 关闭 selinux</h2><p>安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统）关闭是因为可能会导致一些不明的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config &amp;&amp; setenforce 0</span><br></pre></td></tr></table></figure>
<h2 id="1-5-关闭Swap"><a href="#1-5-关闭Swap" class="headerlink" title="1.5 关闭Swap"></a>1.5 关闭Swap</h2><p>此操作必须执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>
<h2 id="1-6-修改hosts文件设置主机名"><a href="#1-6-修改hosts文件设置主机名" class="headerlink" title="1.6 修改hosts文件设置主机名"></a>1.6 修改hosts文件设置主机名</h2><p>在每个节点上操作，保证每个虚拟机主机名唯一。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加以下内容</span></span><br><span class="line">192.168.59.130 master.local</span><br><span class="line">192.168.59.131 node01.local</span><br><span class="line">192.168.59.132 node02.local</span><br></pre></td></tr></table></figure>
<p>在对应的节点上设置主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> master 节点</span></span><br><span class="line">hostnamectl set-hostname master.local </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node01</span></span><br><span class="line">hostnamectl set-hostname node01.local </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node02</span></span><br><span class="line">hostnamectl set-hostname node02.local </span><br></pre></td></tr></table></figure>
<h2 id="1-7-允许-iptables-检查桥接流量"><a href="#1-7-允许-iptables-检查桥接流量" class="headerlink" title="1.7 允许 iptables 检查桥接流量"></a>1.7 允许 iptables 检查桥接流量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<p>加载ip_vs内核模块 </p>
<p>不清楚什么意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe ip_vs</span><br><span class="line">modprobe ip_vs_rr</span><br><span class="line">modprobe ip_vs_wrr</span><br><span class="line">modprobe ip_vs_sh</span><br><span class="line">modprobe nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>设置开机启动</p>
<p>不清楚什么意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/modules-load.d/ip_vs.conf &lt;&lt; EOF </span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack_ipv4</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h1 id="二、搭建方式"><a href="#二、搭建方式" class="headerlink" title="二、搭建方式"></a>二、搭建方式</h1><p>本次使用命令行方式安装，方面理解各个组件的作用。</p>
<h2 id="2-1-图形化操作"><a href="#2-1-图形化操作" class="headerlink" title="2.1 图形化操作"></a>2.1 图形化操作</h2><p>直接使用[Kuboard-Spray](<a href="https://github.com/eip-work/kuboard-spray">GitHub - eip-work/kuboard-spray: 使用图形化的界面离线安装、维护、升级高可用的 K8S 集群</a>)图形化工具进行搭建。</p>
<h2 id="2-2-命令行安装"><a href="#2-2-命令行安装" class="headerlink" title="2.2 命令行安装"></a>2.2 命令行安装</h2><p><strong>以下操作每个节点都需要执行</strong></p>
<h3 id="2-2-1-安装Docker"><a href="#2-2-1-安装Docker" class="headerlink" title="2.2.1 安装Docker"></a>2.2.1 安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>设置Docker 开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>修改Docker的源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 registry-mirrors 为如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;你的阿里云镜像加速地址&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新加载systemctl配置</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-配置kubernetes源"><a href="#2-2-2-配置kubernetes源" class="headerlink" title="2.2.2 配置kubernetes源"></a>2.2.2 配置kubernetes源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line"></span><br><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - </span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新apt-get</span></span><br><span class="line">sudo att-get upadte -y </span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-安装kubeadm、kubelet、kubectl"><a href="#2-2-3-安装kubeadm、kubelet、kubectl" class="headerlink" title="2.2.3 安装kubeadm、kubelet、kubectl"></a>2.2.3 安装kubeadm、kubelet、kubectl</h3><p>建议安装1.23.6 或以下版本的软件，安装最新版（1.24.+）会有问题，且下面安装kuboard 兼容性未在最新版（1.24.+）验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y kubelet=1.23.6-00  kubeadm=1.23.6-00 kubectl=1.23.6-00</span><br></pre></td></tr></table></figure>
<p>设置开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>
<p><strong>以下操作在master节点执行</strong></p>
<h3 id="2-2-4-master-节点初始化"><a href="#2-2-4-master-节点初始化" class="headerlink" title="2.2.4 master 节点初始化"></a>2.2.4 master 节点初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --kubernetes-version 1.23.6 \</span><br><span class="line">  --apiserver-advertise-address=192.168.59.130 \</span><br><span class="line">  --service-cidr=10.96.0.0/16 \</span><br><span class="line">  --pod-network-cidr=10.245.0.0/16 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubernetes-version 必须与下载的版本一致。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apiserver-advertise-address：API 服务器所公布的其正在监听的 IP 地址（本机内网地址）。如果未设置，则使用默认网络接口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> service-cidr：为服务的虚拟 IP 地址另外指定 IP 地址段， 默认值：10.96.0.0/12。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pod-network-cidr：指明 pod 网络可以使用的 IP 地址段，如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> image-repository：选择用于拉取控制平面镜像的容器仓库，  默认值：k8s.gcr.io。</span></span><br></pre></td></tr></table></figure>
<p>等待拉取镜像，出现以下字样代表master节点初始化成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a Pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  /docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p>记住 <code>kubeadm init</code> 输出的 <code>kubeadm join</code> 命令。 需要使用此命令将子节点加入集群。</p>
<h3 id="2-2-5-配置kubectl"><a href="#2-2-5-配置kubectl" class="headerlink" title="2.2.5 配置kubectl"></a>2.2.5 配置kubectl</h3><p>要使用非 root 用户可以运行 kubectl，请运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p> <code>root</code> 用户，则可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p>使用kubectl 查看节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p>目前是只能看到master节点，状态是NotReady，下面是子节点加入后的状态，且网络集群网络联通后的状态。</p>
<p><img src="https://tc.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png"></p>
<h3 id="2-2-6-子节点加入集群"><a href="#2-2-6-子节点加入集群" class="headerlink" title="2.2.6 子节点加入集群"></a>2.2.6 子节点加入集群</h3><p>使用上面初始化后的提示的指令， 分别在各个子节点上执行指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p>接下来在看看节点状态，下面是子节点加入后的状态，且网络集群网络联通后的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<img title src="https://tc.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png" alt data-align="inline">

<h3 id="2-2-7-安装flannel网络插件"><a href="#2-2-7-安装flannel网络插件" class="headerlink" title="2.2.7 安装flannel网络插件"></a>2.2.7 安装flannel网络插件</h3><p>下载插件，<a href="https://blog.csdn.net/weixin_44293949/article/details/121863559">解决raw.githubusercontent.com无法访问的问题</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>下载到本地后更改第128行，和上文中的<code>pod-network-cidr</code> 一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;Network&quot;: &quot;10.245.0.0/16&quot;</span><br></pre></td></tr></table></figure>
<p>运行 yaml文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yaml</span><br></pre></td></tr></table></figure>
<p>查看flannel 结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get pods -o wide</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/f296cd5a0e3811ed90590242ac140002.png"></p>
<p>再次查看各个node的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png"></p>
<p>至此集群方式的Kubernetes 安装完成。</p>
<hr>
<h1 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h1><h2 id="问题一：出现-initial-timeout-of-40s-passed。"><a href="#问题一：出现-initial-timeout-of-40s-passed。" class="headerlink" title="问题一：出现 initial timeout of 40s passed。"></a>问题一：出现 initial timeout of 40s passed。</h2><p>在一开始部署的时候安装：kubelet、kubeadm、kubectl，没有指定版本，直接使用的最新版（1.24.+），在往上查了半天，找到一篇博客后（地址忘记了）提示说可能是由于版本的问题，然后在重新安装指定版本的kubelet、kubeadm、kubectl 工具，接下来一路畅通。</p>
<p>重新初始化是需要执行 <code>kubeadm reset</code> ，此命令是还原由 <code>kubeadm init</code> 或 <code>kubeadm join</code> 所做的更改。</p>
]]></content>
      <categories>
        <category>Kubernets</category>
      </categories>
      <tags>
        <tag>Kubernets</tag>
      </tags>
  </entry>
  <entry>
    <title>Python三器一闭</title>
    <url>/2022/04/30/Python%E4%B8%89%E5%99%A8%E4%B8%80%E9%97%AD/</url>
    <content><![CDATA[<p>​                              </p>
<a id="more"></a>

<h1 id="1、迭代器"><a href="#1、迭代器" class="headerlink" title="1、迭代器"></a>1、迭代器</h1><h2 id="什么是迭代？"><a href="#什么是迭代？" class="headerlink" title="什么是迭代？"></a>什么是迭代？</h2><blockquote>
<p> 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
</blockquote>
<h2 id="什么是可迭代对象？"><a href="#什么是可迭代对象？" class="headerlink" title="什么是可迭代对象？"></a>什么是可迭代对象？</h2><p>Python中的可迭代对象并不是指某一种具体的数据类型，是指存储了若干个元的容器，且这这个容器中的元素可以通过<code>__iter()__</code> 和 <code>__getitem__()</code> 访问。</p>
<p>常用的可迭代对象有：<code>list</code>、<code>tuple</code>，<code>dict</code>，<code>str</code>，<code>set</code>、生成器和带有<code>yield</code>的生成器函数。</p>
<p>判断一个对象是否是可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>([], Iterable)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>获取可迭代对象的迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">print(<span class="built_in">type</span>(item))  <span class="comment"># &lt;class &#x27;range&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line">print(<span class="built_in">type</span>(iterator)) <span class="comment"># &lt;class &#x27;range_iterator&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>iter()</code> 内部做了什么？</strong></p>
<ul>
<li>检查对象内部是否实现了<code>__iter__()</code> 如果实现了， 则调用它，获取一个迭代器。</li>
<li>如果没有实现<code>__iter__()</code>方法，但是 实现了<code>__getitem__()</code>，python内部会实现一个迭代器。</li>
<li>如果 以上都失败，则会抛出异常：说明对象不可迭代。</li>
</ul>
<p><strong><code>for x in range(10): print(x) </code>循环执行了什么？</strong></p>
<p>获取可迭代对象的迭代器， 然后在调用<code>next()</code>方法获取下一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 获取迭代器</span></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 获取迭代器</span></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 0</span></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 2</span></span><br><span class="line">...</span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p><strong>for 循环即先获取可迭代对象的迭代器，然后在调用<code>next()</code>方法，且在超过迭代对象的长度时，自动捕获错误：<code>StopIteration</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p><strong>如何自定义可迭代对象</strong>？</p>
<p>如上文那样，在一个对象中实现这个<code>__iter__()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterator)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>以上类MyList的对象 实现了<code>__iter__()</code>， 所以他是一个可迭代对象，且 <code>print(isinstance(my_list, Iterable))</code> 判断为True。但是 <code>print(isinstance(my_list, Iterator))</code> 为False</p>
<p><strong>如何实现一个迭代器呢</strong>？</p>
<p>如下面代码所示在可迭代对象中再实现<code>__next__()</code> 方法 即可让改对象成为一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterator)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p><strong>综上所述：</strong></p>
<p>对一个可迭代对象调用<code>iter()</code> 方法，其实内部就是寻找<code>__iter__()</code>，并调用，返回的对象当做迭代器。</p>
<p>对一个迭代器对象调用<code>next()</code> 方法，其实内部就是寻找<code>__next__()</code>，并调用，返回可迭代对象的下一个元素。</p>
<blockquote>
<p><strong>所以一个迭代器一定是个可迭代对象，但是可迭代对象并不一定是个迭代器。</strong></p>
</blockquote>
<h1 id="2、生成器"><a href="#2、生成器" class="headerlink" title="2、生成器"></a>2、生成器</h1><h2 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h2><p>在python 中通俗的理解：一边循环一边计算的机制成为生成器，生成器是一种特殊的迭代器。</p>
<h1 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h1><h1 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h1>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署MySQL8</title>
    <url>/2022/02/19/Docker%E9%83%A8%E7%BD%B2MySQL8/</url>
    <content><![CDATA[<p>​                         </p>
<a id="more"></a>



<p>s</p>
<h1 id="1、安装Docker"><a href="#1、安装Docker" class="headerlink" title="1、安装Docker"></a>1、安装Docker</h1><p>略</p>
<h1 id="2、直接运行命令"><a href="#2、直接运行命令" class="headerlink" title="2、直接运行命令"></a>2、直接运行命令</h1><p>后台启动MySQL，然后进入容器中设置MySQL用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name MYSQL8.0 -e MYSQL_ROOT_PASSWORD=123456  mysql:latest</span><br></pre></td></tr></table></figure>
<h1 id="3、设置MySQL远程连接以及密码"><a href="#3、设置MySQL远程连接以及密码" class="headerlink" title="3、设置MySQL远程连接以及密码"></a>3、设置MySQL远程连接以及密码</h1><h2 id="1、进入容器内部"><a href="#1、进入容器内部" class="headerlink" title="1、进入容器内部"></a>1、进入容器内部</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID/容器名 bash</span><br></pre></td></tr></table></figure>
<h2 id="2、登录MySQL"><a href="#2、登录MySQL" class="headerlink" title="2、登录MySQL"></a>2、登录MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>
<h2 id="3、-设置root用户名以及密码规则"><a href="#3、-设置root用户名以及密码规则" class="headerlink" title="3、 设置root用户名以及密码规则"></a>3、 设置root用户名以及密码规则</h2><p>设置密码不过期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39; password expire never;</span><br></pre></td></tr></table></figure>
<p>设置密码规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;123456&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="4、刷新权限"><a href="#4、刷新权限" class="headerlink" title="4、刷新权限"></a>4、刷新权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>使用Navicat连接 成功 OK！</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar</title>
    <url>/2022/02/13/Pulasr%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>Dockerfile知识总结</title>
    <url>/2021/11/20/Dockerfile%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​            </p>
<a id="more"></a>



<blockquote>
<p>使用Dockerfile 能够构建一个自定义镜像。通常情况下是将自己的应用打包成镜像，在容器中使用。</p>
</blockquote>
<h2 id="Dockerfile-命令"><a href="#Dockerfile-命令" class="headerlink" title="Dockerfile 命令"></a>Dockerfile 命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>表示当前镜像是基于那个镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像的维护者和邮箱</td>
</tr>
<tr>
<td>RUN</td>
<td>构建镜像的时候需要运行的命令</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>容器内对外暴露的端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定创建容器后默认进入容器的工作目录</td>
</tr>
<tr>
<td>ENV</td>
<td>用来构建镜像过程中设置的环境变量 key=value</td>
</tr>
<tr>
<td>ADD</td>
<td>将宿主机下的文件拷贝到容器中，且会自动处理url和压缩包</td>
</tr>
<tr>
<td>COPY</td>
<td>类似于ADD，将从构建的Dockerfile目录中复制镜像的目录中</td>
</tr>
<tr>
<td>VOLUME</td>
<td>容器数据卷</td>
</tr>
<tr>
<td>CMD</td>
<td>制定一个容器运行的命令，如果有多个命令，只执行最后一个。会被docker run 后面的命令替代</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定一个容器启动时要运行的命令和参数，和CMD一样</td>
</tr>
</tbody></table>
<h3 id="1、FROM-命令语法"><a href="#1、FROM-命令语法" class="headerlink" title="1、FROM 命令语法"></a>1、FROM 命令语法</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;]   <span class="comment"># 设置镜像的版本，不写为最新版本  latest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、RUN-命令"><a href="#2、RUN-命令" class="headerlink" title="2、RUN 命令"></a>2、RUN 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RUN 后面直接写shell命令, RUN 的命令是在构建镜像中执行。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello word</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;yum&quot;</span>,<span class="string">&quot;install&quot;</span>,<span class="string">&quot;-y&quot;</span>,<span class="string">&quot;vim&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="3、EXPOSR-命令"><a href="#3、EXPOSR-命令" class="headerlink" title="3、EXPOSR 命令"></a>3、EXPOSR 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对一些需要端口的服务</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<h3 id="4、WORKDIR-命令"><a href="#4、WORKDIR-命令" class="headerlink" title="4、WORKDIR 命令"></a>4、WORKDIR 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来为Dockerfile中的任何 RUN/CMD/ENTRYPOINT/CPOY/ADD/ 指令设置工作目录，如果WORKDIR  不存在，即使他没有在后续得命令中被使用，也将会被创建。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/myserver</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /aaa</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> bb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR 可以使用多次，如果使用的是相对命令 ，会与上一次的路径相对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如上面的命令:docker会创建/opt/myserve，也会创建/aaa/bb，在进入容器内会进入最后的WORKDIR的路径下即：/aaa/bb</span></span><br></pre></td></tr></table></figure>
<h3 id="5、ADD-命令"><a href="#5、ADD-命令" class="headerlink" title="5、ADD 命令"></a>5、ADD 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来从Dockerfile的当前目录中复制文件，目录，或者下载URL,并将他们添加到位于容器内指定的文件中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> bb.txt /aaa/bb</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> https://tc.chaizz.com/497261de494511ec9d7c5254006b8f1d.png /aaa/bb</span></span><br><span class="line"><span class="comment"># 可以将文件复制到容器中，也可以通过URL下载文件到容器中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 apache-tomcat-8.5.73-src.tar.gz 解压到 /aaa/bb </span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-8.5.73-src.tar.gz /aaa/bb</span></span><br><span class="line"><span class="comment"># 将apache-tomcat-8.5.73-src 改名 为tomcat</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv apache-tomcat-8.5.73-src  tomcat</span></span><br><span class="line"><span class="comment"># 将工作目录改为 tomcat</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> tomcat</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6、COPY-命令"><a href="#6、COPY-命令" class="headerlink" title="6、COPY 命令"></a>6、COPY 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件复制到指定容器内部的目录</span></span><br><span class="line"><span class="comment"># COPY a.txt /aaa/bb</span></span><br></pre></td></tr></table></figure>


<h3 id="7、volume-目录"><a href="#7、volume-目录" class="headerlink" title="7、volume 目录"></a>7、volume 目录</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许在容器运行的时候将目录挂载到宿主机的目录上</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /aaa/bb/tomcat/webapps</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="8、ENV-命令"><a href="#8、ENV-命令" class="headerlink" title="8、ENV 命令"></a>8、ENV 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置当前容器的环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> BASE_DIR</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="9、ENTRYPOINT-命令"><a href="#9、ENTRYPOINT-命令" class="headerlink" title="9、ENTRYPOINT 命令"></a>9、ENTRYPOINT 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器运行的命令和参数  ENTRYPOINT的命令是在容器构建完成之后启动的时候执行,要覆盖ENTRYPOINT  他的指令 需要在docker run 的时候加上 --entrypoint ls </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> ls <span class="variable">$BASE_DIR</span>/tomcat</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;<span class="variable">$BASE_DIR</span>/tomcat&quot;</span>]</span></span><br></pre></td></tr></table></figure>


<h3 id="10、CMD-命令"><a href="#10、CMD-命令" class="headerlink" title="10、CMD 命令"></a>10、CMD 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只执行最后一个，如果在 docker run 之后指定了命令(不需要参数) 会将CMD的指令覆盖，不再执行CMD的指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> ls <span class="variable">$BASR_DIR</span></span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;<span class="variable">$BASR_DIR</span>&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常 CMD 和 ENTRYPOINT 结合使用 ：ENTRYPOINT作为固定的命令或者参数， CMD 作为可变的参数，附加在ENTRYPOINT命令之后。 然后ENTRYPOINT + CMD 结合为一条命令。  即可实现在docker run 的时候可以指定参数运行同一个容器</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引问题</title>
    <url>/2021/11/18/MySQL%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>​     </p>
<a id="more"></a>

<p>针对以上索引问题，首先要知道什么是主键索引、非主键索引、聚簇索引、非聚簇索引。</p>
<p>主键索引：即MySQL的索引，如果没有主键那么MySQl会自动在表中挑选一个唯一且非空的字段来当做主键索引，如果没有的话MySQL内部自己会创建一个ROW_ID来当做主键，也会建立主键索引。主键索引的叶子结点存储的是整行的数据。</p>
<p>非主键索引：即非主键以外的列建立的索引。非主键索引存储的是主键索引的值。</p>
<h3 id="什么是索引回表？"><a href="#什么是索引回表？" class="headerlink" title="什么是索引回表？"></a>什么是索引回表？</h3><p>索引回表指的就是在查询某一列数据是判断条件为非主键索引，name查到这条复合条件的所有记录就需要在根据非主键索引获得的主键索引的值，在取主键索引的B+树中在此查询一次才能获取到全部的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ID 是主键索引 ，只需要一次查询就可以获取符合条件的全部记录。</span><br><span class="line">select * from ex_table where ID&#x3D;1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># n 是非主键索引，查询到的结果是符合条件的主键索引的ID，所以还需要早根据主键的ID,再在主键索引的B+树上查询一次</span><br><span class="line">select * from ex_table where n &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>以上情况就是索引回表。</p>
<h3 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h3><p>如果执行的语句是 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select idfrom T where n between 1 and 10;</span><br></pre></td></tr></table></figure>
<p>现在的SQL只需要得到ID 的值，而 ID 的值已经在 n 索引的B+树上了，因此可以直接获得查询结果，不需要回表。也就是说，在这个查询里面，索引 n已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<h3 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h3><p>索引下推（index condition pushdown ）简称ICP，在MySQL5.6的版本上推出，用于优化查询，默认是开启的，可以通过以下的命令关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set optimizer_switch &#x3D; &#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>
<p>当使用索引下推时如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>索引下推的好处：</p>
<p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</strong></p>
<p>假如有以下MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 索引值为 name age 为组合索引。</span><br><span class="line"></span><br><span class="line">select * from user where name like &#39;张%&#39; and age &#x3D; 20;</span><br></pre></td></tr></table></figure>


<p>在关闭索引下推的时候，InnoDB引擎会根据只name找到复合条件的索引字段，如下图中的左边绿色，然后就将数据返回给MySQL服务器，由MySQL服务器去判断其他的符合条件的数据。MySQL服务器会拿着查到的ID：1、2  在进行回表查询。</p>
<p><img src="https://tc.chaizz.com/161026e0486011ec9d7c5254006b8f1d.png"></p>
<p>在使用索引下推的时候，InnoDB会直接找出符合索引条件的字段的ID，将符合条件的结果发送给MySQL服务器，这个过程只需要回表一次。如下图。</p>
<p><img src="https://tc.chaizz.com/a47dc42c486b11ec9d7c5254006b8f1d.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis底层原理</title>
    <url>/2021/11/18/Redis%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="Redis-数据结构底层实现"><a href="#Redis-数据结构底层实现" class="headerlink" title="Redis 数据结构底层实现"></a>Redis 数据结构底层实现</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Redis 是由C实现的，所以Redis的String字符串是由C语言中的String改进而来的。</p>
<p>在C语言中，C的一个字符串是由数组组成的，”sdasd\0”，在C语言中一个字符串是由\0 结尾，但是在Redis中，String类型可以存储任意数据类型，所以使用\0结尾容易发生截断。所以在Redis中实现了一个简单动态字符串 （SDS &gt; simple dynamic string）来存储数据。</p>
<p>SDS ：他自定义了一个数据长度来代表数据的长度，在Redis 内部定义了多种 sdshdr5、sdshdr8、sdshdr16。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct__attribute__ ((__packed__)) sdshdr5&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flages;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct__attribute__ ((__packed__)) sdshdr8&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flages;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://tc.chaizz.com/61cb3042481111ec9d7c5254006b8f1d.png"></p>
<p><img src="https://tc.chaizz.com/a48dbb8e481111ec9d7c5254006b8f1d.png"></p>
<p>如上图，在底层sdshdr5 是这样定义的：==一个flags 占用一个字节，它又有八bit，前三位表示数据类型，后五位描述数据长度。buffer 是存储的实际数据。==</p>
<p>Redis 数据扩容：内部实现就是将原本的数据长度成倍的扩容，</p>
<p>比如原本的数据长度            len：7  </p>
<p>实际的数据长度                    buf [5] ：”aaaaa”</p>
<p>空闲的数据长度                    free：2</p>
<p>现在需要将数据改为 “ aaaaaaaa”  数据长度为8。 那么数据就会变成如下这样：</p>
<p>新的的数据长度                    len：7 * 2 = 14  </p>
<p>实际的数据长度                    buf [8] ：”aaaaaaaa”</p>
<p>空闲的数据长度                    free：6</p>
<p>所以这样情况下不需要重新分配新内存空间。其中Redis的字符串在复制结束的时候也会自动的加上\0字符，也是为了兼容C语言的一个字符操作的库。</p>
<h2 id="Redis底层数据结构的编码"><a href="#Redis底层数据结构的编码" class="headerlink" title="Redis底层数据结构的编码"></a>Redis底层数据结构的编码</h2><p>当我们在使用 set、 hset 、lpush 这些api去设置Redis 的键值的时候，Redis 会根据我们设置的值的不同在内部采用不同的编码格式。当我们在存储一些不同的值的时候，Redis底层也会自动给我们做一些优化。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 不同长度不同类型的数据</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set longstr aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set shortstr aaa</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set intvalue 100</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding shortstr</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding longstr</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding intvalue</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们在查看他们的类型的时候都是String</span> </span><br><span class="line">127.0.0.1:6379&gt; type intvalue</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type longstr</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type shortstr</span><br><span class="line">string</span><br></pre></td></tr></table></figure>


<p>当Value的值小于等于44时，string的编码是 embstr ，大于44是raw。</p>
<p>为什么是44呢？</p>
<p>CPU从内存中拿数据时，是有一个缓存行的概念， 最少的拿的数据长度是64个字节 （64 Byte）。</p>
<p>在Redisobject 中 占了16个字节（16 Byte）</p>
<p>Redis sdshdr8 里面 需要占用4个字节，所以还剩44个字节，Redis为了减少一次缓存IO ， 直接将小于等于44 字节的数据取回来 。所以 超过44个字节就会存储为raw编码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">hash</span> 也有不同的编码格式</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset ahash1 f v</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset ahash f v f2 v2222222222222222222222222222222222222222222222222222222</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; type ahash</span><br><span class="line">hash</span><br><span class="line">127.0.0.1:6379&gt; type ahash1</span><br><span class="line">hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding  ahash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding  ahash1</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpush list1 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; type list1</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; object encoding list1</span><br><span class="line">&quot;quicklist&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>从同一边放同一边出 就是一个栈的数据结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush llist a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>从同一边放另一边出 就是一个类似队列的数据结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list1 a b c</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;c&quot;</span><br></pre></td></tr></table></figure>


<p>List 的数据结构是一个双端链表 ：quicklist 。 在Redis 的底层是一个ziplist  更加紧凑的压缩列表。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。他将所有的元素紧挨着一块存储，分配的是一块连续的内存。<br>当数据量比较多的时候，才会改为quicklist，因为普通的链表需要的附加的指针空间更大，会比较浪费空间。<br>比如列表里面存储的只是Int的类型的数据，结构上还需要两个额外的指针：prev和next。<br><img src="https://tc.chaizz.com/4e0057b4450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist 使用双向指针串起来，这样既满足了插入删除性能，又不会出现太大的空间冗余。如上图所示。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>是一种无序、自动去重的的数据结构（如果是一些整形数（编码为intset），其实是有序的）。</p>
<p>他的底层实现是一个value为null的字典，当数据是整形的时候，set集合会将编码改为intset 数据结构，一下两个条件任意满足时set将使用hashtable 存储数据，</p>
<ul>
<li>元素个数大于set-max-intset-entrires</li>
<li>元素无法用整形表示</li>
</ul>
<p>set-max-intset-entrires （intset最大存储的元素个数）最大为512。超过则用hashtable编码。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>Hash 类型对应的数据机构有两种：ziplist （压缩列表） 和 hashtable（哈希表） ，当field-value 的长度较短且个数较少的时候，使用ziplist，否则使用hashtable。</p>
<p>hash-max-ziplist-entries 512</p>
<p>ziplist 的元素超过512个 将改为hashtable编码</p>
<p>hash-max-zipl;ist-value 64</p>
<p>单个元素大小超过64个字节的时候将改为hashtable</p>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>SortedSet 是Redis的一个特别的数据结构，他的底层使用了两个数据结构 ziplist    skiplist。</p>
<ol>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素的列表</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题汇总</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<h1 id="一、基础试题"><a href="#一、基础试题" class="headerlink" title="一、基础试题"></a>一、基础试题</h1><h2 id="1、对字典d-39-a-39-24-39-b-39-53-39-d-39-56-39-h-39-7-按照字典中的value值排序。"><a href="#1、对字典d-39-a-39-24-39-b-39-53-39-d-39-56-39-h-39-7-按照字典中的value值排序。" class="headerlink" title="1、对字典d = {&#39;a&#39;: 24, &#39;b&#39;: 53, &#39;d&#39;: 56, &#39;h&#39;: 7} 按照字典中的value值排序。"></a>1、对字典<code>d = &#123;&#39;a&#39;: 24, &#39;b&#39;: 53, &#39;d&#39;: 56, &#39;h&#39;: 7&#125;</code> 按照字典中的value值排序。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照字典中的键排序：</span></span><br><span class="line"><span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照字典中的键排序：</span></span><br><span class="line"><span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在转化为字典 使用dict 函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、反转字符串-“aSter”"><a href="#2、反转字符串-“aSter”" class="headerlink" title="2、反转字符串 “aSter”"></a>2、反转字符串 “aSter”</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;aSter&#x27;</span>[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取头不取尾</span></span><br></pre></td></tr></table></figure>
<h2 id="3、按照list1-中的元素的由从大到小排序"><a href="#3、按照list1-中的元素的由从大到小排序" class="headerlink" title="3、按照list1 中的元素的由从大到小排序"></a>3、按照list1 中的元素的由从大到小排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">50</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(list1, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse=True  由大到小 sorted排序默认由小到大</span></span><br></pre></td></tr></table></figure>
<h2 id="4、常用的字符串格式化有哪些？"><a href="#4、常用的字符串格式化有哪些？" class="headerlink" title="4、常用的字符串格式化有哪些？"></a>4、常用的字符串格式化有哪些？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="comment"># 1.占位符 %s</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;%s，你好!&quot;</span> % name</span><br><span class="line"><span class="comment"># 2. format</span></span><br><span class="line">str2 = <span class="string">&quot;&#123;&#125;， 你好!&quot;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure>
<h2 id="5、下面代码的输出结果是什么-？"><a href="#5、下面代码的输出结果是什么-？" class="headerlink" title="5、下面代码的输出结果是什么 ？"></a>5、下面代码的输出结果是什么 ？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>] </span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>[<span class="number">10</span>:])   </span><br><span class="line"></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>输出结果是空 不会产生IndexError错误，尝试用超出成员个数的Index来获取某个列表的成员。</p>
<h2 id="6、写一个列表生成式产生一个等差为11的等差数列。"><a href="#6、写一个列表生成式产生一个等差为11的等差数列。" class="headerlink" title="6、写一个列表生成式产生一个等差为11的等差数列。"></a>6、写一个列表生成式产生一个等差为11的等差数列。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([x*<span class="number">11</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>
<h2 id="7、给定两个列表怎么找出他们相同的元素和不同的元素"><a href="#7、给定两个列表怎么找出他们相同的元素和不同的元素" class="headerlink" title="7、给定两个列表怎么找出他们相同的元素和不同的元素"></a>7、给定两个列表怎么找出他们相同的元素和不同的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list2 = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">set1 = <span class="built_in">set</span>(list1)</span><br><span class="line">set2 = <span class="built_in">set</span>(list2)</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line">print(set1 ^ set2)</span><br></pre></td></tr></table></figure>
<h2 id="8、python代码实现删除一个list的重复的元素"><a href="#8、python代码实现删除一个list的重复的元素" class="headerlink" title="8、python代码实现删除一个list的重复的元素"></a>8、python代码实现删除一个list的重复的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]</span><br><span class="line">print(<span class="built_in">set</span>(list1))</span><br></pre></td></tr></table></figure>
<h2 id="9、举字符串、列表、元祖、字典的五个常用的用法。"><a href="#9、举字符串、列表、元祖、字典的五个常用的用法。" class="headerlink" title="9、举字符串、列表、元祖、字典的五个常用的用法。"></a>9、举字符串、列表、元祖、字典的五个常用的用法。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串：replace、strip、split、reverse、upper、lower、join</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表：append、pop、insert、remove、count、index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元祖：index、count、len()、dir()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典：get、keys、values、popitems、clear、uodate、items</span></span><br></pre></td></tr></table></figure>


<h2 id="10、什么是反射-？-以及他的应用场景。"><a href="#10、什么是反射-？-以及他的应用场景。" class="headerlink" title="10、什么是反射 ？ 以及他的应用场景。"></a>10、什么是反射 ？ 以及他的应用场景。</h2><p>反射就是通过字符串的形式去对象中访问或操作这个未知的属性或变量，是一种基于字符串的事件驱动。</p>
<p>在面向对象中把对象能够访问、查询、修改自身的状态或者行为称之为反射。</p>
<p>在python中，可以通过字符串的的形式来操作对象的属性。这种行为称之为python中的反射。</p>
<p><strong>python</strong> <strong>实现反射的手段：</strong></p>
<p>是通过四个内置函数来实现：<strong>hasattr(object,name)</strong> <strong>getattr(object,name,default=None) setattr(x,y,v) delattr(x,y)</strong></p>
<p>判断对象中是否有这个方法或变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;%s正在交谈&quot;</span>%self.name)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person(<span class="string">&quot;laowang&quot;</span>)    </span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;talk&quot;</span>))  <span class="comment"># True。因为存在talk方法</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;name&quot;</span>))  <span class="comment"># True。因为存在name变量</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;abc&quot;</span>))   <span class="comment"># False。因为不存在abc方法或变量</span></span><br></pre></td></tr></table></figure>


<p><strong>反射的好处 ：</strong></p>
<p>实现可插拔机制、动态导入模块（基于反射原理，获取当前的模块的成员）</p>
<h2 id="11、简述Python的深浅拷贝-，详细见链接。"><a href="#11、简述Python的深浅拷贝-，详细见链接。" class="headerlink" title="11、简述Python的深浅拷贝 ，详细见链接。"></a>11、简述Python的深浅拷贝 ，详细见<a href="https://zhuanlan.zhihu.com/p/54011712">链接</a>。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy() ： 浅拷贝，仅仅拷贝数据集合的第一层</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deepcopy() : 深拷贝，拷贝数据集合的所有层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="number">1</span>:<span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====赋值=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=a</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====浅拷贝=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=copy.copy(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====深拷贝=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"></span><br><span class="line">=====赋值=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line">=====浅拷贝=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919592320</span></span><br><span class="line"></span><br><span class="line">=====深拷贝=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919532928</span></span><br></pre></td></tr></table></figure>
<h2 id="12、Python的垃圾回收机制。网页地址"><a href="#12、Python的垃圾回收机制。网页地址" class="headerlink" title="12、Python的垃圾回收机制。网页地址"></a>12、Python的垃圾回收机制。<a href="https://zhuanlan.zhihu.com/p/83251959">网页地址</a></h2><ol>
<li><strong>引用计数</strong></li>
</ol>
<p>在python中每一个对象的的核心就是一个结构体PyObject，他的内部有一个引用计数器（（ob_refcnt）），程序在运行的过程中他会实时的更新 引用计数器（ob_refcnt）的值，来反映当前对象的名称数量，当某个对象的引用计数为零的时候，那么他的内存就会被释放掉。</p>
<p>导致引用计数加一的情况有 ：对象被创建、对象被引用、对象被作为参数传入一个函数中、对象存储在容器中。</p>
<p>导致引用计数减一的情况有：对象别名被显示销毁 del、对象别名被赋予新的对象、一个对象离开他的作用域、对象所在的容器被销毁或者是从容器中删除对象 。</p>
<p>我们可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数（注意，这里getrefcount()本身会使得引用计数加一）。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<p><strong>引用计数的优点</strong>：</p>
<p>高效、实现逻辑简单、具备实时性，一旦一个对象的引用计数归零，内存就直接释放了。</p>
<p><strong>引用计数的缺点：</strong></p>
<p>逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。</p>
<p>可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。</p>
<p>循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。</p>
<ol start="2">
<li><strong>标记-清除</strong></li>
</ol>
<p>它是解决容器对象（(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)）可能产生的循环引用的问题。不改动真实的而引用计数，而是将引用计数复制一份副本，改动该对象引用的副本，对于副本做得任何改动都不影响生命对象整体的维护。</p>
<p><strong>标记清除的步骤：</strong></p>
<p>标记阶段：GC会把所有活动对象打上标记，这些活动对象就像是一个点，他们之间使用引用关系来连接，最终每个点和边构成了一个有向图。</p>
<p><img src="https://tc.chaizz.com/8d3dc5ea460a11ec9d7c5254006b8f1d.png"></p>
<p>GC从跟对象触发遍历所整个图，如果该对象是可达的（reachable）也就是说还有对象在引用他，那么就标记该对象可达。如上图中从根对象开始遍历1、2、3、4是可达的，5、6、7是不可达的。（整个根对象就是全局对象，调用栈，寄存器）</p>
<p>清除阶段：遍历的对象不可达，就将其回收。通过分代回收来加速清理对象。</p>
<ol start="3">
<li><strong>分代回收</strong></li>
</ol>
<p>在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过**“分代回收”(Generational Collection)**以空间换时间的方法提高垃圾回收效率。</p>
<p>分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</p>
<p>分代回收 根据内存中对象的存活时间将他们分为三代，新生的对象放入0代，如果一个对象能在0代的垃圾回收机制中存活下来，GC就会将它放入1代中，如果1代的对象在1代的垃圾 回收过程中存货下来，则会进入二代。</p>
<p>分代回收的触发机制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果是一个元祖：(700, 10, 10)</p>
<ul>
<li>当分配对象分个数减去释放对象的个数差值大于700时，就会产生一次0代回收。</li>
<li>10次0代回收后进行一次1代回收。</li>
<li>10次1代回收后进行一次2代回收。</li>
</ul>
<p>对于0代的对象他们有可能只会被使用一次，所以需要被经常回收。经过一轮回收之后他们是那些使用比较频繁的对象，而且他们已经存活了很久的时间，大概率还会存活更久，因此二代的会后就不会那么频繁。</p>
<p>可以通过(700, 10, 10) 这三个值进行更改分代回收触发的条件。</p>
<p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<h2 id="13、如何打乱一个排好序的lisit对象"><a href="#13、如何打乱一个排好序的lisit对象" class="headerlink" title="13、如何打乱一个排好序的lisit对象"></a>13、如何打乱一个排好序的lisit对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">random.shuffle(alist)</span><br><span class="line"></span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h2 id="14、从0-99这100个数中随即取出十个数字-要求不能重复。"><a href="#14、从0-99这100个数中随即取出十个数字-要求不能重复。" class="headerlink" title="14、从0-99这100个数中随即取出十个数字 要求不能重复。"></a>14、从0-99这100个数中随即取出十个数字 要求不能重复。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.sample(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">99</span>),k=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>


<h2 id="15、Python如何捕获异常、处理异常-、抛出异常"><a href="#15、Python如何捕获异常、处理异常-、抛出异常" class="headerlink" title="15、Python如何捕获异常、处理异常 、抛出异常"></a>15、Python如何捕获异常、处理异常 、抛出异常</h2><p>捕获异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> </span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#else:不发生异常执行的语句</span></span><br><span class="line"><span class="comment">#finally：无论是否发生异常都执行的语句</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># raise Exception  抛出异常</span></span><br></pre></td></tr></table></figure>
<h2 id="16、python递归的大层数"><a href="#16、python递归的大层数" class="headerlink" title="16、python递归的大层数"></a>16、python递归的大层数</h2><p>最大递归为998</p>
<p>修改最大递归值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="17、列表推导式和生成器表达式-i-2-for-i-in-range-10-和-i-2-for-i-in-range-10-输出的结果分别是什么？"><a href="#17、列表推导式和生成器表达式-i-2-for-i-in-range-10-和-i-2-for-i-in-range-10-输出的结果分别是什么？" class="headerlink" title="17、列表推导式和生成器表达式[i % 2 for i in range(10)] 和 (i % 2 for i in range(10)) 输出的结果分别是什么？"></a>17、列表推导式和生成器表达式<code>[i % 2 for i in range(10)] </code>和 <code>(i % 2 for i in range(10)) </code>输出的结果分别是什么？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print((i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000002AD4E8F09E0</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="18-什么是闭包？"><a href="#18-什么是闭包？" class="headerlink" title="18. 什么是闭包？"></a>18. 什么是闭包？</h2><p>指的是定义在一个函数内部的函数 ，被外层函数包裹着。其特点是可以访问到外层函数的名字。 闭包有两种不同的方式，第一种是在函数内部就直接调用了；第二种是返回一个函数名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种形式 在外层函数中直接调用内层函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mark</span>(<span class="params">name</span>):</span></span><br><span class="line">  num = <span class="number">100</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">weight</span>):</span></span><br><span class="line">​    weight += <span class="number">1</span></span><br><span class="line">​    print(name, weight)</span><br><span class="line">  func(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">mark(<span class="string">&#x27;塞拉斯&#x27;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二种形式:在外层函数中返回内层函数对象    （也就是装饰器）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span>(<span class="params">name</span>):</span></span><br><span class="line">  num = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">height</span>):</span></span><br><span class="line">    height += <span class="number">1</span></span><br><span class="line">    print(name, num, height)</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">a = maker(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">a(<span class="number">999</span>)</span><br></pre></td></tr></table></figure>


<p> “闭包”的作用——保存函数的状态信息，使函数的局部变量信息依然可以保存下来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Maker</span>(<span class="params">step</span>):</span> <span class="comment"># 包装器</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span> <span class="comment"># 内部函数</span></span><br><span class="line">        <span class="comment"># nonlocal关键字的作用和前面的local是一样的，如果不使用该关键字，则不能在中内部函数改变“外部变量”的值</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        <span class="comment"># 改变外部变量的值（如果只是访问外部变量，则不需要适用nonlocal）</span></span><br><span class="line">        num = num + step</span><br><span class="line">        print(num)</span><br><span class="line">    <span class="keyword">return</span> fun1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="comment"># 调用外部包装器</span></span><br><span class="line">func2 = Maker(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 调用内部函数4次 输出的结果是 4、7、10、13</span></span><br><span class="line">    func2() </span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p> 这就是“闭包”的最大的作用——保存局部信息不被销毁。</p>
</blockquote>
<h2 id="19、字典推导式"><a href="#19、字典推导式" class="headerlink" title="19、字典推导式"></a>19、字典推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">d = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(a, b)&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20、python2和python3的差别"><a href="#20、python2和python3的差别" class="headerlink" title="20、python2和python3的差别"></a>20、python2和python3的差别</h2><p>新增的库 asyncio 内置库 asybs/await 原生协程支持异步编程。</p>
<p>Enum(枚举) mock、asyncio、ipaddress</p>
<p>print表达式 改为了方法 print（）</p>
<p>raw_input （） 改为input （）</p>
<p>Python3中的Str类型代表Unicode字符串，Python2中的Str类型代表bytes字节序列。</p>
<p>Python3中的 / 返回浮点数，Python2中根据结果而定，能被整除返回整数，否则返回浮点数</p>
<h2 id="21、文件操作-xreadlines-和Readlines-的区别"><a href="#21、文件操作-xreadlines-和Readlines-的区别" class="headerlink" title="21、文件操作 xreadlines 和Readlines 的区别"></a>21、文件操作 xreadlines 和Readlines 的区别</h2><p>readlines（）是把文件全部读取到内存，并解析成一个list ,当文件体积过大时要占用很多内存。</p>
<p>xreadlines（） 则是返回一个iter() file 迭代器，在python2.3之后，已经不推荐这样使用了，而是直接for循环迭代文件对象。</p>
<p>最好的方式是使用 with open as f，对可迭代对象 f，进行迭代遍历：for line in f，会自动地使用缓冲IO（buffered IO）以及内存管理，而不必担心任何大文件的问题。</p>
<h2 id="22、列举布尔值为False-的常见的值？"><a href="#22、列举布尔值为False-的常见的值？" class="headerlink" title="22、列举布尔值为False 的常见的值？"></a>22、列举布尔值为False 的常见的值？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>、[]、（）、&#123;&#125;、””、<span class="literal">False</span>、 <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<h2 id="23、匿名函数lambda-的用法。"><a href="#23、匿名函数lambda-的用法。" class="headerlink" title="23、匿名函数lambda 的用法。"></a>23、匿名函数lambda 的用法。</h2><p>Lambda 作为一个表达式，定义了一个匿名函数。如果使用lambda，lambda内不要包含循环 。lambda 是为了减少单行函数的定义而存在的。</p>
<h2 id="24、Python类中init-（self）-和-new-cls-的区别："><a href="#24、Python类中init-（self）-和-new-cls-的区别：" class="headerlink" title="24、Python类中init__（self） 和 __new(cls)的区别："></a>24、Python类中<strong>init__（self） 和 __new</strong>(cls)的区别：</h2><p><strong>init</strong>(self) ：负责初始化<strong>new</strong>(cls)创建的对象，是一个对象方法。接受self参数，以及其他初始化的参数 </p>
<p><strong>new</strong>(cls) ：创建<strong>init</strong>(self)初始化的对象。是一个类方法。在调用<strong>new</strong>(cls)之前连对象都没有。只接受一个参数 cls，必须要有返回值，返回实例化的对象。</p>
<h2 id="25、列出5个python标准库"><a href="#25、列出5个python标准库" class="headerlink" title="25、列出5个python标准库"></a>25、列出5个python标准库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准库：sys、os、re、urllib、logging、datetime、random、threading、multiprocessing、base64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三方库：requests、Scrapy、gevent、pygame、pymysql、pymongo、redis-py、Django、Flask、Werkzeug、celery、IPython、pillow</span></span><br></pre></td></tr></table></figure>
<h2 id="26、python中生成随机整数、随机小数、0–1之间小数方法"><a href="#26、python中生成随机整数、随机小数、0–1之间小数方法" class="headerlink" title="26、python中生成随机整数、随机小数、0–1之间小数方法"></a>26、python中生成随机整数、随机小数、0–1之间小数方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机整数</span></span><br><span class="line">print(random.randint(<span class="number">0</span>, <span class="number">99999</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机小数</span></span><br><span class="line">print(np.random.randn())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机 0-1 小数</span></span><br><span class="line">print(random.random())</span><br></pre></td></tr></table></figure>


<h1 id="二、-数据库"><a href="#二、-数据库" class="headerlink" title="二、     数据库"></a>二、     数据库</h1><h2 id="1、什么是事务"><a href="#1、什么是事务" class="headerlink" title="1、什么是事务"></a>1、什么是事务</h2><p><strong>事务</strong>是数据库并发控制的基本单位。相当于对一系列sql语句的集合，事务要么全部执行成功，要么全部失败。</p>
<p>事务的四个特性 ：ACID </p>
<p>A（atomicity）：原子性：一个事务的操作要么全部完成要么全部失败。</p>
<p>C（consistency）：一致性：事务开始前后数据保持完整性没有被破坏。</p>
<p>I（isolation）：隔离性：允许多个事务同时对数据库进行读写和修改。</p>
<p>D（durability）：持久性：事务结束之后，修改是永久的。</p>
<p><strong>事务的并发控制可能产生的问题</strong>：</p>
<p>幻读：一个事务进行第二次查出现第一次没有的结果。</p>
<p>非重复读：一个事务读取两次读到两个不同的结果。</p>
<p>脏读：一个事务读取到另一个事物没有提交的修改。</p>
<p>丢失修改：并发写入导致其中的一些修改丢失。</p>
<p><strong>为了解决并发控制异常，定义了四种事务的隔离级别：</strong></p>
<p>读未提交：别的事务可以读到未提交的改变。</p>
<p>读已提交：只能读到已提交的数据。</p>
<p>可重复读：同一个事务先后读取结果一样。</p>
<p>串行化：事务完全串行化的执行，隔离级别最高，执行效率最低。</p>
<p><strong>解决高并发情况下的插入重复：</strong></p>
<p>   使用数据库的唯一索引。</p>
<p>   使用队列的异步写入。</p>
<p>   使用redis实现分布式锁。</p>
<h2 id="2、Mysql的数据类型："><a href="#2、Mysql的数据类型：" class="headerlink" title="2、Mysql的数据类型："></a>2、Mysql的数据类型：</h2><p>-   Char : 存储定长的字符串。</p>
<p>-   Varchar：存储定长的字符串。</p>
<p>-   Text ：存储文本比较长的类型</p>
<p>-   Tinyint：一个字节，-127 到 255</p>
<p>-   Int：四个字节 （）</p>
<p>-   Datetime：8个字节</p>
<p>-   Timestamp ：四个字节 只能存储到从1970到2038年</p>
<h2 id="3、MYSql-的两个常用的引擎"><a href="#3、MYSql-的两个常用的引擎" class="headerlink" title="3、MYSql 的两个常用的引擎"></a>3、MYSql 的两个常用的引擎</h2><p>Innodb :支持事务，支持外键、支持行锁、支持表锁。不支持全文索引。</p>
<p>Myisam: 不支持事务，不支持外键、只支持表锁 支持全文索引。</p>
<h2 id="4、Mysql-索引的原理以及优化常见的问题"><a href="#4、Mysql-索引的原理以及优化常见的问题" class="headerlink" title="4、Mysql 索引的原理以及优化常见的问题"></a>4、Mysql 索引的原理以及优化常见的问题</h2><p><strong>索引的类型 ：</strong></p>
<p>普通索引 create index</p>
<p>唯一索引 create unique index</p>
<p>多列索引</p>
<p>主键索引 只有一个，全文索引 （innodb 不支持）</p>
<p><strong>那些情况下用索引：</strong></p>
<p>经常用查询需条件的字段去创建索引 （where条件）</p>
<p>经常用坐标链接的字段</p>
<p>经常用在order by group by 后面的字段</p>
<p><strong>创建索引有哪些需要注意的：</strong></p>
<p>不能非空字段上创建索引，</p>
<p>不要在很多字段相同的字段上创建索引</p>
<p>索引的长度不要太长</p>
<p><strong>索引失效的情况：</strong></p>
<ul>
<li><p>对于多列索引，不是使用的第一部分，则不会使用索引（最左匹配原则）</p>
</li>
<li><p>% Like 语句 以%开头索引失效。</p>
</li>
<li><p>如果列类型是字  符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。（隐式转换）</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。</p>
</li>
<li><p> 查询条件使用函数在索引列上，或者 对索引列进行运算， 运算包括(+，-，*，/，! 等) </p>
</li>
<li><p>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</p>
</li>
</ul>
<p><strong>什么是聚集索引 和非聚集索引：</strong></p>
<p>非聚集索引：数据和索引单独存储。myisam ：使用的是非聚集索引。Innodb 主键索引是聚集索引</p>
<p><strong>如何排查慢查询：</strong></p>
<p>开启慢查询日志 slow_query_log_file</p>
<p>通过 explain 排序索引问题。</p>
<p>调整数据修改索引，是不是有隐式转换。</p>
<h2 id="5、SQL语句的编写问题"><a href="#5、SQL语句的编写问题" class="headerlink" title="5、SQL语句的编写问题"></a>5、SQL语句的编写问题</h2><p><strong>内连接：</strong>（Inner join）将左表和右表关联起来的数据进行返回。类似于求两个表的交集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a inner join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p><strong>外链接：</strong></p>
<p>左连接：返回左表中的所有数据，即使右表没有匹配的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a left join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p>右链接 ：返回右表中的所有数据，即使左表没有匹配的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a right join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p>没有匹配的字段都会自动设置为null。</p>
<h2 id="6、MySQL为什么使用B-树数据结构而不用B树，B-树相对于B树有什么优点"><a href="#6、MySQL为什么使用B-树数据结构而不用B树，B-树相对于B树有什么优点" class="headerlink" title="6、MySQL为什么使用B+树数据结构而不用B树，B+树相对于B树有什么优点"></a>6、MySQL为什么使用B+树数据结构而不用B树，B+树相对于B树有什么优点</h2><p>是因为B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，B+树只要遍历叶子节点就可以实现整棵树的遍历。B+树比B树多了一个双向链表，在进行范围查找的时候有更快的效率，且B+树在叶子节点冗余了上面的根节点。</p>
<h2 id="7、MySQL事务的特性以及隔离级别"><a href="#7、MySQL事务的特性以及隔离级别" class="headerlink" title="7、MySQL事务的特性以及隔离级别"></a>7、MySQL事务的特性以及隔离级别</h2><p><strong>事务的四大特性：</strong></p>
<p>原子性（atomicity）：事务的操作要么全部成功要么全部失败，是通过MySQL的undo log 来实现的。</p>
<p>一致性（consistency）：事务开始和结束之后不会对数据破坏，数据是符合预期的。原子性、隔离性、持久性共同实现一致性。</p>
<p>隔离性（isolation）：数据库允许多个事务对数据进行操作，隔离性可以放置数据库并发操作而导致数据的不一致问题。是通过LBCC+MVCC实现的。</p>
<p>持久性（durability）：事务结束之后对数据的改变是永久的，不会因为外界的干扰而导致数据更改。在数据库中是由redo Log 来实现的。</p>
<p><strong>事务的隔离级别：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv8YPTrg9lpFjt5WmnTicwibMqF5XDaZXJcrF9rCDmNxLp5z0gbHPzT11eQ5EyRtYBVdtkOVRQ5WABw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<h2 id="8、MySQL什么情况下会发生死锁，如何解决死锁"><a href="#8、MySQL什么情况下会发生死锁，如何解决死锁" class="headerlink" title="8、MySQL什么情况下会发生死锁，如何解决死锁"></a>8、MySQL什么情况下会发生死锁，如何解决死锁</h2><p><strong>什么是死锁：</strong>多个事务因竞争锁而造成的一种相互等待的僵局。</p>
<p><strong>出现死锁的情况：</strong></p>
<h2 id="9、简述乐观锁和悲观锁的区别以及使用场景"><a href="#9、简述乐观锁和悲观锁的区别以及使用场景" class="headerlink" title="9、简述乐观锁和悲观锁的区别以及使用场景"></a>9、简述乐观锁和悲观锁的区别以及使用场景</h2><p><strong>乐观锁：</strong>每次获取数据的时候，不会担心数据被修改，所以每次获取数据的时候不会对数据加锁，但是在更新数据的时候会判断数据是否被修改过，如果数据被修改过，则不进行数据更新，如果没有被修改过，则进行数据更新。由于数据没有加锁，所以这期间数据有可能被其他线程进行读写操作。</p>
<p><strong>悲观锁：</strong>每次获取数据的时候都会担心数据被修改，所以每次获取数据的时候都会加锁，确保自己在使用的过程中，数据不会被修改，使用完成后释放锁，由于数据被加锁所以其他的线程多数据进行修改需要进行等待。</p>
<p><strong>使用场景：</strong></p>
<p>悲观锁：比较适合写入的操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会加锁，这样会增加大量的开销，降低系统的吞吐量。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写操作，数据发生冲突的可能性就会增加，为了保证数据的一致性，底层就会不断的重新获取数据，会增加大量的查询操作，降低了性能。</p>
<h2 id="10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引"><a href="#10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引" class="headerlink" title="10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引"></a>10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引</h2><p><strong>聚簇索引：</strong>将数据和索引存放到一起，找到索引就找到数据了。innodb引擎使用聚簇索引。</p>
<p><strong>非聚簇索引：</strong>将数据和索引分开存放，索引结构的叶子结点存储的是数据的对应地址的指针，Myisam通过key-buffer把索引先缓存到内存中，当需要访问数据时候，在内存中直接搜索索引，然后通过素银找到对应的数据，这也就是索引不在key-buffer命中时，速度慢的原因。</p>
<h2 id="11、脏读和幻读产生的场景，InnoDB是如何解决幻读的"><a href="#11、脏读和幻读产生的场景，InnoDB是如何解决幻读的" class="headerlink" title="11、脏读和幻读产生的场景，InnoDB是如何解决幻读的"></a>11、脏读和幻读产生的场景，InnoDB是如何解决幻读的</h2><p><strong>脏读：</strong>一个事务在前后两次查询过程中得到的结果不一致由因为读取到另一个事务<strong>未提交</strong>的数据叫产生了脏读。它在事务隔离级别为：读未提交的情况下产生。</p>
<p><strong>幻读：</strong>在一个事务中前后两次查询读取到了不一样的结果数，是由于读取到其他的事务已经提交的新的数据。这种情况产生的叫做幻读，读未提交，读已提交这两种事务隔离级别下都会产生。</p>
<p><strong>解决幻读：</strong></p>
<p>是通过间隙锁+锁住本身的数据（next-key），间隙锁锁住一段范围，所以其他事务无法对这段范围的数据进行插入删除等操作，所以就不存在幻读的问题。</p>
<br> 

<p>如果事务隔离级别是 Read Commit ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。</p>
<p>如果事务的隔离级别是可重读，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.</p>
<h2 id="12、MySQL的主从复制的原理"><a href="#12、MySQL的主从复制的原理" class="headerlink" title="12、MySQL的主从复制的原理"></a>12、MySQL的主从复制的原理</h2><p>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:</p>
<p><img src="https://tc.chaizz.com/69080f8a407611ec9d7c5254006b8f1d.jpeg"></p>
<ul>
<li>从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li>
<li>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</li>
<li>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</li>
</ul>
<h2 id="13、主从复制延迟产生的原因，以及如何解决？"><a href="#13、主从复制延迟产生的原因，以及如何解决？" class="headerlink" title="13、主从复制延迟产生的原因，以及如何解决？"></a>13、主从复制延迟产生的原因，以及如何解决？</h2><p>产生延迟的原因：</p>
<ul>
<li>主从机器性能差异</li>
<li>主机器有大量的写操作，从机器有大量的读操作，从而影响从机器复制的性能。</li>
<li>大事务的执行，本身事物执行消耗了大量时间</li>
</ul>
<h2 id="14、缓存的适用场景？为什么使用缓存？"><a href="#14、缓存的适用场景？为什么使用缓存？" class="headerlink" title="14、缓存的适用场景？为什么使用缓存？"></a>14、缓存的适用场景？为什么使用缓存？</h2><p>-   缓解关系数据库的并发压力，</p>
<p>-   减少响应的时间</p>
<p>-   提升吞吐量</p>
<h2 id="15、Redis-和memcached-的区别："><a href="#15、Redis-和memcached-的区别：" class="headerlink" title="15、Redis 和memcached 的区别："></a>15、Redis 和memcached 的区别：</h2><p><strong>Redis 支持的数据类型：</strong></p>
<p>-   String ： 实现简单的KV键值对存储，计数器</p>
<p>-   List ： 双向链表，实现队列， 用户的的关注或者粉丝表表</p>
<p>-   Hash ： 用来存储彼此相关信息的键值对。</p>
<p>-   Set：存储不重复的元素，例如用户的关注着。</p>
<p>-   Sort set ：有序集合，存储实时信息排行榜</p>
<h2 id="16、Redis实现持久化的方式："><a href="#16、Redis实现持久化的方式：" class="headerlink" title="16、Redis实现持久化的方式："></a>16、<strong>Redis实现持久化的方式：</strong></h2><p>-   快照的方式， 把数据快照放在磁盘二进制文件中，dump.rdb （Redis默认开启）</p>
<p>-   AOF：每写一个命令追加到appendonly.aof 中。</p>
<p>-   修改redis 配置中实现</p>
<h2 id="17、Redis如何实现分布式锁"><a href="#17、Redis如何实现分布式锁" class="headerlink" title="17、Redis如何实现分布式锁"></a>17、<strong>Redis如何实现分布式锁</strong></h2><p>使用setnx 实现加锁，可以同时通过expire 添加超时时间。del删除锁，getset key value 先get在set 先返回key对应的值，如果没有就返回空，然后在将key设置为value。</p>
<ul>
<li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</li>
</ul>
<h2 id="18、缓存的使用模式："><a href="#18、缓存的使用模式：" class="headerlink" title="18、缓存的使用模式："></a>18、<strong>缓存的使用模式：</strong></h2><p>常用的有三种，</p>
<p>cache aside 同时更新缓存和数据库。（数据一致性的问题：解决，都是写入数据库，删除缓存。在更新缓存）Read/write through 先更新缓存。缓存负责同步的更新数据库。</p>
<p>write behind caching 先更新缓存，缓存定期异步更新数据库。</p>
<h2 id="19、如何缓解缓存穿透的问题："><a href="#19、如何缓解缓存穿透的问题：" class="headerlink" title="19、如何缓解缓存穿透的问题："></a>19、<strong>如何缓解缓存穿透的问题：</strong></h2><p><strong>产生的原因一：由于大量的请求查询缓存，查不到就回去数据库去取。数据库也查不到数据。（多数是由于非法攻击）</strong></p>
<p>解决：</p>
<ul>
<li><p>对参数进行合法性校验。</p>
</li>
<li><p>将查不到的数据返回一个none，把none缓存下来，有新的数据插入，在把none 删除，或者设置较短的缓存时间。</p>
</li>
<li><p>使用布隆过滤器</p>
</li>
</ul>
<h3 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个位数组（bitarray），开始所有数据全部置0，当一个元素讲过多个hash函数计算不同的哈希值，并通过哈希值找到对应的bitarray，将值改为1。<strong>（需要说明，布隆过滤器存在误判的可能）数组越长误判率越低，占用的空间也越大。）</strong></p>
<p><img src="https://tc.chaizz.com/128523c846b111ec9d7c5254006b8f1d.png"></p>
<p>以上是一个空的布隆过滤器，现在要插入这个A字段，经过三个hash函数计算得到了2、5、7 所以将将布隆过滤器的相对应的值设置为1。</p>
<p><img src="https://tc.chaizz.com/4c40b08646b211ec9d7c5254006b8f1d.png"></p>
<p>接下来继续插入B字段，计算出来的值为2、4、8，继续往布隆过滤器对相应的位置上设置为1，注意A和B同时hash计算出来的值一致。所以导致了布隆过滤器不能确保某个元素一定存在。</p>
<p><img src="https://tc.chaizz.com/9600ff0a46b211ec9d7c5254006b8f1d.png"></p>
<p>布隆过滤器的查询也很简单，例如我们要找一个字段C，只需要计算出他的hash值，如果该值为2、3、4，那么因为布隆过滤器对应bit位上的数据有一个不为1，所以就断定C不存在，但是如果他计算的值为1、4、8，name就不能确定他一定存在。</p>
<p>因此随着添加的值越来越多，bit位的占用也就就越多，布隆过滤器的误判性也就会越来越高。如果bit位都为1的话，那就是所有的数据都存在 ，这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p>
<h3 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h3><ul>
<li>网页爬虫对URL的去重，避免爬取相同的URL地址</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li>
<li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回，避免缓存及DB挂掉。</li>
<li>黑名单过滤。</li>
</ul>
<h2 id="20、如何缓解缓存击穿的问题"><a href="#20、如何缓解缓存击穿的问题" class="headerlink" title="20、如何缓解缓存击穿的问题"></a>20、如何缓解缓存击穿的问题</h2><p><strong>产生原因一：缓存中没有，数据库中有。</strong>一般是多是出现在数据初始化，以及key过期的情况。他的问题在于重新写入缓存需要一定的时间，如果是在高并发的情况下，过多的请求会打到DB上，给DB造成很大的压力。</p>
<p>解决方案：</p>
<ul>
<li>设置热点的缓存永不过期。要注意永不过期数据一致性会有问题。所以要给value设置一个逻辑过期时间，然后后台再开一个线程，扫描这些key，定期刷新。</li>
</ul>
<p><strong>产生原因二：某些非常热点的数据key 过期，大量的请求打到后端 。</strong></p>
<p>解决：</p>
<ul>
<li><p>分布式锁的线程，从数据库拉数据（允许少数的线程取访问数据库并产生缓存），然后其他的线程等待。</p>
</li>
<li><p>后台任务针对过期的key 自动刷新。（设置随机的过期时间）</p>
</li>
</ul>
<h2 id="21、如何缓解缓存雪崩的问题。"><a href="#21、如何缓解缓存雪崩的问题。" class="headerlink" title="21、如何缓解缓存雪崩的问题。"></a>21、<strong>如何缓解缓存雪崩的问题。</strong></h2><p><strong>产生原因：大量的请求，或者大量的缓存key同时失效，大量的请求同时请求到数据库。</strong></p>
<p>解决：</p>
<ul>
<li><p>多级缓存，不同级别的key设置不同的超时时间。</p>
</li>
<li><p>随机超时，key的超时时间随机设置，防止同时超时</p>
</li>
<li><p>在架构层解决，提升系统可用性，监控，报警完善。</p>
</li>
</ul>
<h2 id="22、如何保证Redis与数据库一致性"><a href="#22、如何保证Redis与数据库一致性" class="headerlink" title="22、如何保证Redis与数据库一致性"></a>22、如何保证Redis与数据库一致性</h2><p>当我们对数据修改的时候，实现删除缓存还是先写入数据库。</p>
<p><strong>操作方式一：先删除缓存，在写数据</strong>。</p>
<p><strong>产生的问题：</strong>在高并发场景下，当第一个线程删除了缓存，还没有来得及写入数据库，第二个线程读取数据时会发现缓存为空，那么就会读取数据库的旧数据，读完之后又会将读取到的结果写入缓存，这样缓存中数据就是脏数据。</p>
<p><strong>解决：</strong> <strong>先操作缓存，但是不删除缓存，将缓存修改为一个特殊值，当客户端读取到这个特殊值时，休眠一会再去查Redis。</strong>（需要注意的问题：①对业务是由侵入的。②：休眠时间对性能有影响）</p>
<p><strong>操作方式二：</strong> <strong>延时双删：先删除缓存，然后再写数据库，休眠一小会在删除缓存。</strong></p>
<p><strong>产生的问题：</strong> 如果过写操作很频繁，同样会有脏数据的的问题。</p>
<p>解决：这种方式主要针对写操作不频繁的场景。</p>
<p><strong>操作方式三： ** **先写数据库，再删除缓存</strong></p>
<p><strong>产生的问题：</strong> 如果数据写完了以后缓存修改失败。数据就会不一致。</p>
<p><strong>解决：</strong></p>
<ul>
<li>给缓存设置过期时间。（在缓存时间内，数据不一致）</li>
<li>引入MQ 保证原子操作。（在MQ重试时间内数据不一致）</li>
</ul>
<h2 id="23、Redis-如何设置key的过期时间。它的键删除策略实现原理是什么"><a href="#23、Redis-如何设置key的过期时间。它的键删除策略实现原理是什么" class="headerlink" title="23、Redis 如何设置key的过期时间。它的键删除策略实现原理是什么"></a>23、Redis 如何设置key的过期时间。它的键删除策略实现原理是什么</h2><p>设置过期时间 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expair key time </span><br><span class="line"></span><br><span class="line">setnx key value time</span><br></pre></td></tr></table></figure>


<p>Redis 过期key删除机制有两种，一种是被动方式，一种是主动方式。</p>
<p>懒汉式式删除（被动）<br>含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步(如果此时还不删除的话，我们就会获取到了已经过期的key了)</p>
<p>定期删除 （主动）<br>含义：每隔一段时间执行一次删除过期key操作</p>
<p>优点：通过平衡控制<strong>执行效率</strong>和<strong>执行时长</strong>，来减少删除操作对CPU时间的占用。</p>
<p>遍历每个database(默认16个)，检查当前库中指定个数的key(默认是20个)，随机抽查这些key，如果有过期的就删除。并且程序中有一个全局变量，用来记录扫描到了哪一个数据库（database）。</p>
<p>Redis 同时使用以上两种删除策略。</p>
<h2 id="24、Redis的RDB和AOF机制"><a href="#24、Redis的RDB和AOF机制" class="headerlink" title="24、Redis的RDB和AOF机制"></a>24、Redis的RDB和AOF机制</h2><p>RDB（redis database）：在指定<strong>时间间隔内</strong>将内存中的<strong>数据集快照</strong>写入磁盘，也就是快照，它恢复是将快照文件直接读到内存里面。（在Redis 的配置文件内设置时间间隔）<strong>RDB 默认开启。</strong></p>
<p>备份是如何执行的：<br>Redis 会单独的创建一个fork子进程来持久化，会先将数据写入一个临时文件中，等持久化过程都结束了，在用这个临时文件替换上次持久化的文件，整个过程主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据的恢复，且对于数据的完整性要求不那么敏感，那么RDB的方式要比AOF的方式更加的额高效，RDB的缺点就是<strong>最后一次持久化的数据可能会丢失。</strong></p>
<p>fork的作用就是复制一个与当前进程一样的进程，新的进程的所有的数据（变量，程序计数器等）都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件解释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查数据完整性、默认值 yes 在存储跨照后让Redis 使用CRC64算法来对数据进行校验。但是这样做会损失大约10%的性能。推荐开启。</span></span><br><span class="line">rdbchecksum  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis 无法写入磁盘的时候，直接关掉Redis的写操作，推荐yes</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 压缩文件</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将数据写入磁盘的时间间隔， 默认 六十分钟1次、五分钟一百次、一分钟一万次</span></span><br><span class="line">save 300 100</span><br></pre></td></tr></table></figure>



<p>RDB的优势：</p>
<ul>
<li>适合大规模数据的恢复。</li>
<li>对数据完整性和一致性要求不高时使用。</li>
<li>节省磁盘空间。</li>
<li>回恢复度快。</li>
</ul>
<p>RDB的劣势：</p>
<ul>
<li>在写入临时快照的时候，数据被克隆了一份，大致两倍的膨胀性需要考虑。</li>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据量庞大还是比较消耗性能。</li>
<li>在备份周期在一定时间间隔内做一次备份，所以如果Redis以外关掉，就会丢失最后一次快照的修改。</li>
</ul>
<p>RDB的备份恢复：<br>默认Redis启动会自动将Redis的快照文件（dump.rdb）读取到内存中。手动恢复的话只需要将快照文件复制到Redis启动目录下。</p>
<p>AOF（Append Only File）：以日志的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的所有<strong>写/修改/删除指令记录下来（读操作不记录）</strong>，只许追加文件但是不可以改文件，Redis启动之初，会自动读取范围见重新构建数据，换言之Redis重启的话就会根据日志文件的内容将写指令重头到尾在执行一遍，以完成数据的恢复工作。<strong>AOF默认不开启。</strong></p>
<p>开启AOF：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认为no 不开启， 将其改为yes 开启。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果RDB和AOF同时开启，Redis 默认会读取AOF的配置文件来恢复数据。</strong> </p>
<p>AOF 异常修复：<br>如果遇到AOF文件损坏，通过 redis-check-aof   –fix  appendonly.aof 进行恢复。</p>
<p>AOF的同步频率设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置AOF的同步频率 。</span></span><br><span class="line">	always：始终同步。</span><br><span class="line">	everysec ：每秒同步，每秒记入日志一次，如果宕机当前秒的数据可能会丢失。</span><br><span class="line">	no：redis 不主动同步，把同步的时机交给操作系统。</span><br><span class="line">appendfsync always   </span><br></pre></td></tr></table></figure>

<p>Rewrite 压缩<br>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过设置的阈值时，Redis回启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p>重写的原理：<br>AOF文件持续增长而过大时， 会fork 出一条新的进程将文件重写（也是先写临时文件最后在rename）Redis4.0后的版本重写，实际上就是把RDB的快照，以二进制的形式附在新的aof的头部，作为已有的历史数据，替换掉原来的流水操作。</p>
<p>AOF持久化的流程：</p>
<ul>
<li>客户端的请求命令会被append追加到AOF的缓冲区内。</li>
<li>AOF缓冲区根据AOF持久化策略（always/everysec/no）将操作sync同步到磁盘中的.aof文件中去。</li>
<li>AOF文件大小超过重写策略或者手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。</li>
</ul>
<h3 id="AOF与RDB对比："><a href="#AOF与RDB对比：" class="headerlink" title="AOF与RDB对比："></a>AOF与RDB对比：</h3><ul>
<li>AOF文件比RDB大，且更安全，但恢复速度慢。</li>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>RDB性能比AOF好。</li>
<li>如果两个都加载了Redis默认优先加载AOF。</li>
</ul>
<h2 id="25、Redis-主从复制核心原理"><a href="#25、Redis-主从复制核心原理" class="headerlink" title="25、Redis 主从复制核心原理"></a>25、Redis 主从复制核心原理</h2><p>主从复制配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">核心原理：通过执行slaveof 命令，让一个服务器复制另一个服务器的数据，主数据库负责写操作，从数据库负责读操作，当写操作导致数据变化时，会自动将数据同步给从数据库。</span><br><span class="line"></span><br><span class="line">全量复制：</span><br><span class="line"></span><br><span class="line">- 主节点通过bgsave命令fork子进程，进行RDB持久化（该过程是非常消耗CPU、内存的、硬盘IOd的）。</span><br><span class="line">- 主节点通过网络将RDB文件发送给从节点，对从节点的带宽会有很大的消耗。</span><br><span class="line">- 从节点清空老数据，载入新的RDB文件是阻塞的，无法响应客户端的命令，如果从节点执行bgrewriteof，也会带来额外的消耗。</span><br><span class="line"></span><br><span class="line">增量复制：</span><br><span class="line"></span><br><span class="line">- 复制偏移量：执行复制的双方主从节点分别会维护一个复制偏移量offset。</span><br><span class="line">- 复制及压缓冲区：主节点内部维护一个固定长度的、先进先出的队列作为复制缓冲区，如果缓冲区超过最大长度，那么只能进行全量复制。</span><br><span class="line">- 每个Redis启动都会产生一个ID， 主节点还会将自己的ID发送给从节点，如果主节点挂掉重新选举，主节点ID不一致那么只能全量复制。如果一致那就继续使用增量复制。</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;2e7fbffc46d411ec9d7c5254006b8f1d.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 26、 索引回表 索引覆盖  索引下推</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">针对以上索引问题，首先要知道什么是主键索引、非主键索引、聚簇索引、非聚簇索引。</span><br><span class="line"></span><br><span class="line">主键索引：即MySQL的索引，如果没有主键那么MySQl会自动在表中挑选一个唯一且非空的字段来当做主键索引，如果没有的话MySQL内部自己会创建一个ROW_ID来当做主键，也会建立主键索引。主键索引的叶子结点存储的是整行的数据。</span><br><span class="line"></span><br><span class="line">非主键索引：即非主键以外的列建立的索引。非主键索引存储的是主键索引的值。</span><br><span class="line"></span><br><span class="line">### 什么是索引回表？</span><br><span class="line"></span><br><span class="line">索引回表指的就是在查询某一列数据是判断条件为非主键索引，name查到这条复合条件的所有记录就需要在根据非主键索引获得的主键索引的值，在取主键索引的B+树中在此查询一次才能获取到全部的数据。例如：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line"># ID 是主键索引 ，只需要一次查询就可以获取符合条件的全部记录。</span><br><span class="line">select * from ex_table where ID&#x3D;1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># n 是非主键索引，查询到的结果是符合条件的主键索引的ID，所以还需要早根据主键的ID,再在主键索引的B+树上查询一次</span><br><span class="line">select * from ex_table where n &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>以上情况就是索引回表。</p>
<h3 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h3><p>如果执行的语句是 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select idfrom T where n between 1 and 10;</span><br></pre></td></tr></table></figure>
<p>现在的SQL只需要得到ID 的值，而 ID 的值已经在 n 索引的B+树上了，因此可以直接获得查询结果，不需要回表。也就是说，在这个查询里面，索引 n已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<h3 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h3><p>索引下推（index condition pushdown ）简称ICP，在MySQL5.6的版本上推出，用于优化查询，默认是开启的，可以通过以下的命令关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch &#x3D; &#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>
<p>当使用索引下推时如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>索引下推的好处：</p>
<p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</strong></p>
<p>假如有以下MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 索引值为 name age 为组合索引。</span><br><span class="line"></span><br><span class="line">select * from user where name like &#39;张%&#39; and age &#x3D; 20;</span><br></pre></td></tr></table></figure>


<p>在关闭索引下推的时候，InnoDB引擎会根据只name找到复合条件的索引字段，如下图中的左边绿色，然后就将数据返回给MySQL服务器，由MySQL服务器去判断其他的符合条件的数据。MySQL服务器会拿着查到的ID：1、2  在进行回表查询。</p>
<p><img src="https://tc.chaizz.com/161026e0486011ec9d7c5254006b8f1d.png"></p>
<p>在使用索引下推的时候，InnoDB会直接找出符合索引条件的字段的ID，将符合条件的结果发送给MySQL服务器，这个过程只需要回表一次。</p>
<h1 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p><strong>CPU密集型计算（CPU-bound）：</strong>Io可以再很短的时间结束 ，而需要CPU进行大量的计算。</p>
<p>比如： 压缩解压缩， 加密解密，正则的表达式搜索</p>
<p><strong>IO密集型计算(I/O-bound)：</strong>指系统大部分时间是在等IO写入读取操作，CPU占用比较低。</p>
<p>比如：文件处理，网络爬虫操作，读写数据</p>
<p><strong>进程</strong>：是对程序运行的封装，是操作系统调度资源的基本单位。进程切换消耗的资源比较大。效率比较低。</p>
<p><strong>线程</strong>：是进程的基本单位，一个进程至少一个线程。可以实现进程的并发（并发是假的并行，相当于来回切换）。线程切换需要的资源一般，效率也一般。（在不考虑GIL的情况下）。</p>
<p>一个进程包括多个线程，线程依赖进程存在，共享进程的内存。</p>
<p>共享数据会导致线程安全。可以使用线程锁。或者在程序设计的时候就避免这种情况出现。</p>
<p><strong>为什么进程切换比线程切换消耗大：</strong></p>
<p>进程切换需要两步：①：切换页目录，使用新的地址空间。②：切换内核和硬件上下文。</p>
<p>对于Linux来说线程和进程最大的区别就是在于虚拟地址空间，每个进程都有自己的虚拟地址空间，而线程是共享进程的地址空间的，因此同一个进程中线程的切换不涉及到虚拟地址空间的转换。把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB(Translation Lookaside Buffer)来缓存页地址，用来加速页表查找。当进程切换后页表也要进行切换，页表切换后TLB就失效了，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快。</p>
<p><strong>保证线程安全的方式：</strong></p>
<ul>
<li><p>互斥锁：通过互斥机制防止多个线程同时访问公共资源。</p>
</li>
<li><p>信号量：控制同一时刻多个线程访问资源的线程数。</p>
</li>
<li><p>事件（信号）：通过通知的方式实现。</p>
</li>
</ul>
<p><strong>进程之间通信的方式：</strong></p>
<ul>
<li><p>匿名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li><p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
</li>
<li><p>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>消息队列（Queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<ul>
<li>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。</li>
<li>RabbitMQ : 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。</li>
</ul>
</li>
<li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。</p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p>套接字（socket） 用的比较多。套接字（socket）为通信的端点，每个套接字由一个 IP 地址和一个端口号组成。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。</p>
<ul>
<li>服务进程：socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;read()-&gt;write()-&gt;…-&gt;close()</li>
<li>客户进程：socket()-&gt;connect()-&gt;write()-&gt;read()-&gt;…-&gt;close();</li>
</ul>
</li>
</ul>
<p><strong>线程之间的通信方式：</strong></p>
<p>共享变量、共享内存、共享数据库、消息队列</p>
<p>Python中如何使用对进程（在CPU密集型中使用）：</p>
<p>Multiprocessing ：多进程模块  </p>
<h2 id="2、五种IO模型"><a href="#2、五种IO模型" class="headerlink" title="2、五种IO模型"></a>2、五种IO模型</h2><p>阻塞式IO （Blocking IO）</p>
<p>非阻塞式IO （NonBlocking IO）</p>
<p>IO 多路复用 （IO Multiplexing）</p>
<p>信号驱动IO（Signal Driven IO）不常用</p>
<p>异步IO （Asynchronous IO）不常用</p>
<h2 id="3、操作系统实现多路复用的方法"><a href="#3、操作系统实现多路复用的方法" class="headerlink" title="3、操作系统实现多路复用的方法"></a>3、操作系统实现多路复用的方法</h2><p>IO多路复用的本质就是select/poll/epoll 去监听多个socket对象，如果其中的socket对象有变化，只要有变化，用户进程就知道了。</p>
<p>Select 是不断的轮询监听的socket， socket的个数有限制，一般为1024个。</p>
<p>Poll 还是采用轮询的方式监听，之不过没有个数的限制。</p>
<p>Epoll 并不是采用轮训的方式去监听，而是当socket有变化的时候通过回调的方式主动地告知用户进程。</p>
<p>表面上看epoll的性能最好，但是在连接数少，连接数十分活跃的情况下，selecthe poll性能会比epoll好。因为epoll的通知机制需要很多回调函数。</p>
<h2 id="4、Python-实现IO多路复用的方法："><a href="#4、Python-实现IO多路复用的方法：" class="headerlink" title="4、Python 实现IO多路复用的方法："></a>4、Python 实现IO多路复用的方法：</h2><p>也是基于操作系统的select ,poll epoll方法。Pyhon3 中实现了selectors 模块。</p>
<p>事件类型：EVENT_READ 、EVENT_WRITE </p>
<p>DefaultSelector：自动根据系统来选择IO模型。其中的一些方法</p>
<p>a)   register（fileobj events data = none）</p>
<p>b)  unregister（fileobj）</p>
<p>c)   Modifiy(fileobj events data = none)</p>
<p>d)  Select(timeout=none, returns[keys, events])</p>
<p>e)   Close()</p>
<h2 id="5、Python的并发网络库："><a href="#5、Python的并发网络库：" class="headerlink" title="5、Python的并发网络库："></a>5、Python的并发网络库：</h2><p>Gevent 、asyncio、tornado</p>
<p>Tornado：是一个并发网络编程库，也是一个Web框架。</p>
<p>Gevent：基于几个绿色线程实现并发。底层是基于c语言实现的。基于 monkey patch gevent修改了内置的socket 改为非阻塞。 经常配合gunnicorn 部署作为wsgi server 。 </p>
<p>Asyncio ：基于原生的协程实现的。</p>
<h2 id="6、Linux中有哪些调度算法？"><a href="#6、Linux中有哪些调度算法？" class="headerlink" title="6、Linux中有哪些调度算法？"></a>6、Linux中有哪些调度算法？</h2><p>先来先服务调度算法和短作业优先调度算法</p>
<h2 id="7、操作系统如何管理内存的？"><a href="#7、操作系统如何管理内存的？" class="headerlink" title="7、操作系统如何管理内存的？"></a>7、操作系统如何管理内存的？</h2><p>内存又分为虚拟内存和物理内存。</p>
<p>虚拟内存的基本思想就是每个进程都有独立的逻辑地址空间，内存被分为大小相等的块，称为页，每个页都是一段连续的地址，对于进程来看貌似有很多的内存空间，但切实只有一部分是物理内存地址。</p>
<p>缺页中断，</p>
<h2 id="8、LRU-最近最少使用-Least-Recently-Used-算法"><a href="#8、LRU-最近最少使用-Least-Recently-Used-算法" class="headerlink" title="8、LRU:最近最少使用(Least Recently Used)算法"></a>8、LRU:最近最少使用(Least Recently Used)算法</h2><p>基于最近使用的也慢数据在未来一段时间仍有很大可能被使用，已经很久没有使用的数据在未来的很长一段时间内也仍然不会被使用这种思想的一种淘汰机制，它的主要衡量指标是时间，第二衡量指标是次数。利用双向链表来实现。</p>
<h2 id="9、LFU（Least-Frequently-Used）算法"><a href="#9、LFU（Least-Frequently-Used）算法" class="headerlink" title="9、LFU（Least Frequently Used）算法"></a>9、LFU（Least Frequently Used）算法</h2><p>即最少访问算法，根据访问缓存的历史频率来淘汰数据，核心思想是“如果数据在过去一段时间被访问的次数很少，那么将来被访问的概率也会很低”。</p>
<p>数据结构： 一般会维护两个数据结构：</p>
<p>哈希：用来提供对外部的访问，查询效率更高；</p>
<p>双向链表或队列：维护了对元素访问次数的排序</p>
<p><strong>优点：</strong></p>
<p>一般情况下，LFU效率要优于LRU，能够避免周期性或者偶发性的操作导致缓存命中率下降的问题</p>
<p><strong>缺点：</strong></p>
<p>复杂度较高：需要额外维护一个队列或双向链表，复杂度较高</p>
<p>对新缓存不友好：新加入的缓存容易被清理掉，即使可能会被经常访问</p>
<p>缓存污染：一旦缓存的访问模式发生变化，访问记录的历史存量，会导致缓存污染；</p>
<p>内存开销：需要对每一项缓存数据维护一个访问次数，内存成本较大；</p>
<p>处理器开销：需要对访问次数排序，会增加一定的处理器开销</p>
<h1 id="四、网络"><a href="#四、网络" class="headerlink" title="四、网络"></a>四、网络</h1><h2 id="1、Python-底层的网络编程模块有哪些？"><a href="#1、Python-底层的网络编程模块有哪些？" class="headerlink" title="1、Python 底层的网络编程模块有哪些？"></a>1、Python 底层的网络编程模块有哪些？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Socket 、urllib、requests、grab、pycurl</span><br></pre></td></tr></table></figure>


<h2 id="2、简述OSI七层含义"><a href="#2、简述OSI七层含义" class="headerlink" title="2、简述OSI七层含义"></a>2、简述OSI七层含义</h2><p>-   应用层：HTTP、FTP、NFS</p>
<p>-   表示层：Telnet、SNMP</p>
<p>-   会话层：SMTP、DNS</p>
<p>-   传输层：TCP、UDP</p>
<p>-   网络层：IP、TCP、ARP</p>
<p>-   数据链路层：Etherent、PPP、PDN、SLIP、FDDI</p>
<p>-   物理层：TEEE 802.1A、TEEE 802.11</p>
<p>应用层、表示层、会话层 也可以称之为应用层。</p>
<h2 id="3、输入一个URL中间的过程："><a href="#3、输入一个URL中间的过程：" class="headerlink" title="3、输入一个URL中间的过程："></a>3、输入一个URL中间的过程：</h2><ul>
<li>首先首先浏览器会解析域名找到对应的IP地址。<ul>
<li>浏览器会首先搜索浏览器自身的DNS缓存，(缓存时间较短，大概只有一分钟，且只能容纳1000条缓存)，看自身缓存是否有该域名对应的条目，而且没有过期，如果有且没有过期解析到此此结束。</li>
<li>如果浏览器自身的缓存李，没有找到对应的条目，那么浏览器就会搜索系统自身的DNS缓存，如果找到且没有过期，则停止搜索，解析结束。</li>
<li>如果在系统的DNS缓存也没有找到，那么尝试读取hosts文件，看看这里面是否有对应的IP地址，如果有则解析成功。</li>
<li>如果hosts文件也没有，浏览器就是发起一个DNS系统的调用，就会向本地配置的首选DNS服务器(一般是电信运营商提供的)，发起域名解析请求（通过UDP协议向DNS的53端口发期请求，这个请求是递归请求，也就是运行商必须提供给我们该域名的IP地址），运行商的DNS服务器首先查找自身的缓存，找到对应的条目且没有过期，则解析成功，如果没有，则由运营商的DNS代我们我们的浏览器发送迭代DNS解析,首先会找根域的DNS的I地址（这个DNS服务器都内置13台根域的DNS的IP地址），然后进一步请求，一般四部就可以找到域名对应的IP地址的。</li>
</ul>
</li>
<li>浏览器调用socket 函数，发起TCP 请求 （三次握手）与服务器建立连接。</li>
<li>建立连接之后发起应用层http的请求，如果有代理的话 到达nginx 然后再到uwsgi 最后再到web应用响应。</li>
<li>浏览器得到并解析解析html代码。</li>
<li>然后web应用在执行他的逻辑，然后返回response，通过tcp返回给用户，最后就会执行TCP的四次挥手。</li>
</ul>
<h2 id="4、TCP的三次握手四次分手："><a href="#4、TCP的三次握手四次分手：" class="headerlink" title="4、TCP的三次握手四次分手："></a>4、TCP的三次握手四次分手：</h2><p><strong>第一次握手：</strong></p>
<p>客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。</p>
<p><strong>第二次握手：</strong></p>
<p>服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD（同步已发送状态）状态。</p>
<p><strong>第三次握手：</strong></p>
<p>客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED（已建立连接）状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<p>三次握手：<br> “喂，你听得到吗？”<br> “我听得到呀，你听得到我吗？”<br> “我能听到你，今天 balabala……”</p>
<p><strong>TCP的四次挥手</strong>：</p>
<p> <strong>第一次分手：</strong></p>
<p>Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。</p>
<p><strong>第二次分手：</strong></p>
<p>Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。</p>
<p><strong>第三次分手：</strong></p>
<p>Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。</p>
<p><strong>第四次分手 ：</strong></p>
<p>Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</p>
<h2 id="5、为什么TCP需要四次分手呢？"><a href="#5、为什么TCP需要四次分手呢？" class="headerlink" title="5、为什么TCP需要四次分手呢？"></a>5、为什么TCP需要四次分手呢？</h2><p>因为建立连接时ACK和SYN可以放在一个报文里面来发送，而关闭连接时，被动的关闭方，可能还需要发送一些数据，再发送DIN报文确认同意可以关闭连接了，所以这里的ACK和Fin报文是分开发送的。</p>
<h2 id="6、TCP-UDP的区别："><a href="#6、TCP-UDP的区别：" class="headerlink" title="6、TCP/UDP的区别："></a>6、TCP/UDP的区别：</h2><p><strong>相同点：</strong></p>
<p>UDP协议和TCP协议都是传输层协议。</p>
<p><strong>不同点：</strong></p>
<p>-   TCP：面向有连接的（建立之前必选建立连接，结束之后关闭连接），可靠的、 基于字节流的。</p>
<p>-   UDP：无连接的（知道对端的IP和端口号就直接进行传输, 不需要建立连接。）不可靠（没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。）。面向报文的（应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。）。</p>
<p>TCP 只支持点对点的，UD支持一对一，一对多，多对多的交互通信。</p>
<h2 id="7、UDP如何尽量保持可靠"><a href="#7、UDP如何尽量保持可靠" class="headerlink" title="7、UDP如何尽量保持可靠"></a>7、UDP如何尽量保持可靠</h2><p>UDP他不属于连接性协议，因为具有资源消耗小，处理速度快的优点，随意即时通许，音视频数据在传输是使用UDP比较多，因为他们偶尔丢一两个包对数据也不会造成太大的影响，传输层无法保证数据的可靠传输，只能在应用层来实现，实现的方式可以参考TCP的可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>关键在于两点：</p>
<ul>
<li>提供超时重传，能避免数据丢失</li>
<li>提供确认序列号，可以对报文进行确认和排序。</li>
</ul>
<h2 id="8、TCP的keepalive和-http-的keep-alive的区别"><a href="#8、TCP的keepalive和-http-的keep-alive的区别" class="headerlink" title="8、TCP的keepalive和 http 的keep alive的区别"></a>8、TCP的keepalive和 http 的keep alive的区别</h2><p>http的keep-alive是为了让TCP活的更久一点，一边在同一个连接上传送多个http，提供socket效率，而TCP的keep-alicve是TCP的一种检测TCP连接的保鲜机制。检查TCP连接是否活跃。</p>
<h2 id="9、HTTP的1-0-、1-1、2-0-的主要区别"><a href="#9、HTTP的1-0-、1-1、2-0-的主要区别" class="headerlink" title="9、HTTP的1.0 、1.1、2.0 的主要区别"></a>9、HTTP的1.0 、1.1、2.0 的主要区别</h2><p><strong>HTTP1.0：</strong></p>
<ul>
<li>无状态，无连接的</li>
</ul>
<p><strong>HTTP1.1:</strong></p>
<ul>
<li>支持长连接，请求管道化，请求并行发送，响应仍然有序返回</li>
<li>增加缓存的处理，新的字段：cache-control</li>
<li>增加Host字段，适应虚机主机技术发展，即一台服务器支持多台主机。</li>
<li>支持断点传输</li>
</ul>
<p><strong>HTTP2.0</strong>:</p>
<ul>
<li>二进制分帧</li>
<li>多路复用（连接共享）</li>
<li>头部压缩（encoder）</li>
<li>服务器推送</li>
</ul>
<h2 id="10、HTTP请求的组成"><a href="#10、HTTP请求的组成" class="headerlink" title="10、HTTP请求的组成"></a>10、HTTP请求的组成</h2><p>状态行：请求码、请求方法（method）、路径、版本</p>
<p>请求头：HOST，数据类型（content_type），数据长度(content_length)，接收编码（accept-encoding）连接（keep-alive）、user-agent</p>
<p>请求体内容</p>
<h2 id="11、HTTP响应的组成："><a href="#11、HTTP响应的组成：" class="headerlink" title="11、HTTP响应的组成："></a>11、HTTP响应的组成：</h2><p>状态行：响应码、请求方法（method）、路径、版本</p>
<p>响应头：缓存（cache-contral）、数据类型（content_type），数据长度(content_length)、连接（cinnection）、</p>
<p>响应正文：内容</p>
<h2 id="12、HTTP响应的状态码："><a href="#12、HTTP响应的状态码：" class="headerlink" title="12、HTTP响应的状态码："></a>12、HTTP响应的状态码：</h2><p>1xx：服务器已经收到 需要请求者继续操作</p>
<p>2xx：成功，操作成功并接受处理</p>
<p>3xx：重定向 （301：用久重定向，302：临时重定向，304：not modified）</p>
<p>4xx：客户端错误（401：未认证，403：forbidben 没权限，404：not found 405：请求不被允许）</p>
<p>5xx：服务端错误；（500：服务错误，502：对用户访问请求超时）</p>
<h2 id="13、HTTP请求方法"><a href="#13、HTTP请求方法" class="headerlink" title="13、HTTP请求方法"></a>13、HTTP请求方法</h2><p>GET/POST/PUT/DELETE</p>
<h2 id="14、GET-POST的区别："><a href="#14、GET-POST的区别：" class="headerlink" title="14、GET/POST的区别："></a>14、GET/POST的区别：</h2><p>GET的请求参数是放在URL上面的，是明文的（长度是有限的）。POST是放在请求体里面的相对更安全。</p>
<h2 id="15、HTTP长连接："><a href="#15、HTTP长连接：" class="headerlink" title="15、HTTP长连接："></a>15、HTTP长连接：</h2><p>短连接：建立连接，数据传输，关闭连接，（连接建立和关闭的开销大）。</p>
<p>长连接：Connection:keep-alive, 来保持TCP不断开。</p>
<h2 id="16、Cookie-和-Session-的区别："><a href="#16、Cookie-和-Session-的区别：" class="headerlink" title="16、Cookie 和 Session 的区别："></a>16、Cookie 和 Session 的区别：</h2><p>Session 是服务器生成之后返回给客户端，通过URL或者是cookie</p>
<p>Cookie 是实现session的一种机制，通过http cookie 字段实现。</p>
<p>Session 是通过服务器保存session识别用户，cookie保存在客户端。</p>
<h2 id="17、-网络TCP-socket-编程实现原理"><a href="#17、-网络TCP-socket-编程实现原理" class="headerlink" title="17、 网络TCP socket 编程实现原理"></a>17、 网络TCP socket 编程实现原理</h2><p>服务进程：socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;read()-&gt;write()-&gt;…-&gt;close()</p>
<p>客户进程：socket()-&gt;connect()-&gt;write()-&gt;read()-&gt;…-&gt;close();</p>
<p><strong>创建客户端：</strong></p>
<ol>
<li><p>首先创建sokect对象</p>
</li>
<li><p>创建连接 connection </p>
</li>
</ol>
<p><strong>创建服务端</strong></p>
<ol>
<li><p>创建socket 对象。</p>
</li>
<li><p>绑定本地地址</p>
</li>
<li><p>Socket对象监听</p>
</li>
</ol>
<p><strong>使用socket 发送http请求：</strong></p>
<ol>
<li><p>创建socket 对象。</p>
</li>
<li><p>连接http 地址。</p>
</li>
<li><p>发送http请求。</p>
</li>
<li><p>接收返回对像。</p>
</li>
<li><p>关闭请求连接。</p>
</li>
</ol>
<h1 id="五、Python-WSGI-与WEB框架的常考问题"><a href="#五、Python-WSGI-与WEB框架的常考问题" class="headerlink" title="五、Python WSGI 与WEB框架的常考问题"></a>五、Python WSGI 与WEB框架的常考问题</h1><h2 id="1-什么是WSGI：和web框架交互的一个规范。"><a href="#1-什么是WSGI：和web框架交互的一个规范。" class="headerlink" title="1.   什么是WSGI：和web框架交互的一个规范。"></a>1.   什么是WSGI：和web框架交互的一个规范。</h2><p>主要是解决python web server 乱象 mod_python 、CGI、FastCGI 等。描述了 web server (Gunicorn/Uwsgi) 如何与web框架（django/flask）交互，web 框架如何处理请求。</p>
<h2 id="2、django请求的生命周期？"><a href="#2、django请求的生命周期？" class="headerlink" title="2、django请求的生命周期？"></a>2、django请求的生命周期？</h2><p>​    </p>
<p>用户在浏览器输入URL的时候，浏览器会生成请求头，和请求体发送给服务端。请求头he请求体中会包括浏览器的动作（这个动作通常为GET或者POST 体现在URL中）。</p>
<p>URL经过Django的服务器uwsgi,（如果有代理服务器的话，先经过代理服务器在由代理服务器设置的代理，转到uwsgi）然后请求到达django项目的中间件。通过中间件以后在到达路列表，进行匹配，匹配到路由规则，在访问视图层。</p>
<p>视图函数根据客户端的请求查询相应的数据，返回给django，然后django在把获取的序列化的数据返回。</p>
<h2 id="3、列举django中间件的五个方法"><a href="#3、列举django中间件的五个方法" class="headerlink" title="3、列举django中间件的五个方法"></a>3、列举django中间件的五个方法</h2><p>自定义中间件需要继承父类 （MiddlewareMixin）。</p>
<p><strong>process_request(request) ：</strong>此方法是在视图函数执行之前执行的。该方法包含一个参数 request。这个request和视图函数中的request是一样的。返回值可以是NONE 也可以是HttpeRsponse ，如果是none 那就走下一个中间件，如果是HttpeRsponse，django 将不会再走后面的视图函数，那就直接已改中间件为起点，倒序执行中间件，且执行的是视图函数执行之后的方法。该方法的应用场景：可以做认证、权限先关的事情。</p>
<p><strong>process_resopnse（request，response）：</strong>此方法是在视图函数执行之后执行的。该方法 有两个参数，request是请求对象，response是视图函数返回的httpresponse。该方法必须要有返回值，而且必须是response。</p>
<p><strong>process_exception(request, exception) ：</strong>此方法有两个函数，request 是HttpRequest 对象，exception 是视图函数异常产生的 Exception 对象。该方法只有在视图函数中出现异常了才执行，按照 settings 的注册倒序执行。在视图函数之后，在 process_response 方法之前执行。方法的返回值可以是一个 None 也可以是一个 HttpResponse 对象。如果是NONE 则会直接返回一个500的状态码，不会往下执行视图函数，如果是返回HttpResponse ，页面不会报错没返回状态码200，视图函数不执行，该中间件后续的 process_exception 方法也不执行，直接从最后一个中间件的 process_response 方法倒序开始执行。</p>
<p> <strong>process_view(request,view_func, view_args, view_kwargs) ：</strong>此方法是在视图函数之前，process_request 方法之后执行的。该方法有四个参数request 是 HttpRequest 对象；view_func 是 Django 即将使用的视图函数；view_args 是将传递给视图的位置参数的列表；view_kwargs 是将传递给视图的关键字参数的字典。返回值可以是 None、view_func(request) 或 HttpResponse 对象</p>
<p><strong>process_template_responseprocess（）</strong> ：这个渲染模板的时候执行的。</p>
<h2 id="4、简述什么叫FBV和CBV"><a href="#4、简述什么叫FBV和CBV" class="headerlink" title="4、简述什么叫FBV和CBV"></a>4、简述什么叫FBV和CBV</h2><p>FBV 叫做基于函数的视图，CBV是基于类的视图，使用CBV的优点，提高代码的复用性，使用面向对象的技术，可以用不同的函数（get()/post()）针对不同的请求处理，而不是通过if 判断请求方式。</p>
<h2 id="5、Django的内置组件"><a href="#5、Django的内置组件" class="headerlink" title="5、Django的内置组件"></a>5、Django的内置组件</h2><p>admin 是对modle 中的数据记性可视化的增删改查的组件。</p>
<p>model 数据库数据结构的映射对象。</p>
<p>form 生成html的代码，对数据进行检验，校验数据并返回。</p>
<h2 id="6、django的request对象是在什么时候创建的？"><a href="#6、django的request对象是在什么时候创建的？" class="headerlink" title="6、django的request对象是在什么时候创建的？"></a>6、django的request对象是在什么时候创建的？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIHandler</span>(<span class="params">base.BaseHandler</span>):</span></span><br><span class="line"></span><br><span class="line">    request = self.request_class(environ)</span><br></pre></td></tr></table></figure>
<p>请求走到WSGIHandler类的时候，执行cell方法，将environ封装成了request</p>
<h2 id="7、如何给CBV的程序添加装饰器。"><a href="#7、如何给CBV的程序添加装饰器。" class="headerlink" title="7、如何给CBV的程序添加装饰器。"></a>7、如何给CBV的程序添加装饰器。</h2><p>可以使用method_decorator 在类的get/post方法上添加 例如：@ method_decorator（func）</p>
<p>给类添加在类名上 例如：@ method_decorator（func，name=post）</p>
<h2 id="8、列举django-ORM中方法"><a href="#8、列举django-ORM中方法" class="headerlink" title="8、列举django ORM中方法"></a>8、列举django ORM中方法</h2><p>all():         查询所有结果 </p>
<p>filter(**kwargs):    它包含了与所给筛选条件相匹配的对象。获取不到返回None</p>
<p>get(**kwargs):    返回与所给筛选条件相匹配的对象，返回结果有且只有一个。 如果符合筛选条件的对象超过一个或者没有都会抛出错误。</p>
<p>exclude(**kwargs):   它包含了与所给筛选条件不匹配的对象</p>
<p>order_by(*field):    对查询结果排序</p>
<p>reverse():       对查询结果反向排序 </p>
<p>count():        返回数据库中匹配查询(QuerySet)的对象数量。 </p>
<p>first():        返回第一条记录 </p>
<p>last():        返回最后一条记录 </p>
<p>exists():       如果QuerySet包含数据，就返回True，否则返回False</p>
<p>values(*field):    返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系 model的实例化对象，而是一个可迭代的字典序列。</p>
<p>values_list(*field):  它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列</p>
<p>distinct():      从返回结果中剔除重复纪录</p>
<h2 id="9、select-related和prefetch-related的区别？"><a href="#9、select-related和prefetch-related的区别？" class="headerlink" title="9、select_related和prefetch_related的区别？"></a>9、select_related和prefetch_related的区别？</h2><p>前提：有外键存在时，可以很好的减少数据库请求的次数,提高性能</p>
<p>select_related通过多表join关联查询,一次性获得所有数据,只执行一次SQL查询。（针对于 一对一和一对多）</p>
<p>prefetch_related分别查询每个表,然后根据它们之间的关系进行处理,执行两次查询。（针对多对多）</p>
<p>select_related方法执行一次数据库查询，prefetch_related方法执行两次数据库查询</p>
<h2 id="10、列举django-ORM-中三张能写sql语句的方法。"><a href="#10、列举django-ORM-中三张能写sql语句的方法。" class="headerlink" title="10、列举django ORM 中三张能写sql语句的方法。"></a>10、列举django ORM 中三张能写sql语句的方法。</h2><p>使用execute(sql语句) 类似pymysql的形式。</p>
<p>使用extra() 方法 quersyt.extra(select={“key” ：“原生SQL语句”})</p>
<p>使用raw()方法  对象.objects.raw(sql语句)</p>
<h2 id="11、values和values-list的区别？"><a href="#11、values和values-list的区别？" class="headerlink" title="11、values和values_list的区别？"></a>11、values和values_list的区别？</h2><p>values : queryset类型的列表中是字典</p>
<p>values_list : queryset类型的列表中是元组</p>
<h2 id="12、Django的queryset有哪些特性？"><a href="#12、Django的queryset有哪些特性？" class="headerlink" title="12、Django的queryset有哪些特性？"></a>12、Django的queryset有哪些特性？</h2><p>主要有两个特性，一个是惰性的，另一个是的自带缓存。</p>
<p>惰性：在使用查询语句的时候，Django不会去主动的查询数据库，只有你使用了查询的对象，Django才会去访问数据库。</p>
<p>缓存：第一次访问数据库以后Django会把得到的数据保存在queryset内置的cache中。Django就不需要在进行重复的查询了。</p>
<h2 id="13、Django的模型继承有哪几种方式-它们有什么区别以及何时使用它们"><a href="#13、Django的模型继承有哪几种方式-它们有什么区别以及何时使用它们" class="headerlink" title="13、Django的模型继承有哪几种方式? 它们有什么区别以及何时使用它们?"></a>13、Django的模型继承有哪几种方式? 它们有什么区别以及何时使用它们?</h2><p>Django的模型继承有如下三种：</p>
<p>抽象模型（avstract model）：Django不会为抽象模型在数据库中生成自己的表，父类Meta 中的abstract=True 也不会传递给子类，如果被你发现多模型有很多共同字段的时，需要用抽象模型继承。</p>
<p>多表模型继承（multi-table-inheritance）：多表模型继承与抽象模型继承最大的区别在于Django也会为父类模型建立自己的数据库表。同时隐士的在父类和子类之间建立一个一对一关系。</p>
<p>代理模型（proxy model）：如果我们只改变某个模型的行为方法，而不是添加额外的字段或者创建额外的数据表，我们就可以使用代理模型，设置一个代理模型需要子类模型meta选项中设置proxy=True，django不会为代理模型生成新的数据表。</p>
<h2 id="14、简单说说看-Django的CSRF防御机制。"><a href="#14、简单说说看-Django的CSRF防御机制。" class="headerlink" title="14、简单说说看 Django的CSRF防御机制。"></a>14、简单说说看 Django的CSRF防御机制。</h2><p>Django的CSRF是通过Django的中间件 （django.middleware.csrf.CsrfViewMiddleware）来实现的。主要流程如下：</p>
<p>Django相应来自客户端的请求的时候，会在服务器生成一个csrftoken（一串64位的随机码），把这个token放在请求头的cookie里发给客户端返回给用户。</p>
<p>所有通过POSt提交的额表单，都要携带一个隐藏字段，通过模板文件中的<code>&#123;%csrf_token%&#125;</code>标签生成。</p>
<p>当用户通过提教交POST的时候，django会从请求头cookie中获取这个token的值，与生成的只比较是否一致。</p>
<h2 id="16、如何从数据表中获取一个随机的对象。"><a href="#16、如何从数据表中获取一个随机的对象。" class="headerlink" title="16、如何从数据表中获取一个随机的对象。"></a>16、如何从数据表中获取一个随机的对象。</h2><p>可以使用order_by（”?”）.first()</p>
<h2 id="17、说说aggregate和annotate方法的作用。"><a href="#17、说说aggregate和annotate方法的作用。" class="headerlink" title="17、说说aggregate和annotate方法的作用。"></a>17、说说aggregate和annotate方法的作用。</h2><p>Aggregate 是聚合的意思，是对一组值(比如queryset的某个字段)进行统计计算，并以字典(Dict)格式返回统计计算结果。支持 count（）max(),min()sun()avg()。</p>
<p>Annotate ：可以理解为分组，对数据集先进行分组然后再进行某些聚合操作或排序时，需要使用annotate方法来实现。与aggregate方法不同的是，annotate方法返回结果的不仅仅是含有统计结果的一个字典，而是包含有新增统计字段的查询集(queryset）</p>
<h2 id="18、常用的框架Django-Flask-Tornado-的对比。"><a href="#18、常用的框架Django-Flask-Tornado-的对比。" class="headerlink" title="18、常用的框架Django/Flask/Tornado 的对比。"></a>18、常用的框架Django/Flask/Tornado 的对比。</h2><p>Django ：大而全，内置ORM、Admin, 第三方的插件比较多。</p>
<p>Flask ：微框架、插件机制，比较灵活。</p>
<p>Tornado ：支持异步的微框架，和异步网络库。</p>
<h2 id="19、Django-常用的第三方插件："><a href="#19、Django-常用的第三方插件：" class="headerlink" title="19、Django 常用的第三方插件："></a>19、Django 常用的第三方插件：</h2><p>django-taggit 可以在文章中当作标签使用</p>
<p>django- Celery 异步分布式的队列。</p>
<p>djangorestframework REST API 的框架。可以做 序列化，分页。权限的管理，认证机制。</p>
<p>django-cors-headers ：管理跨域操作的插件。</p>
<p>django-haystack 全文检索引擎 </p>
<p>django -simple 后台UI界面 </p>
<p>django -captcha Django的验证码</p>
<p>django-debug-toolbar debug 调试工具</p>
<h2 id="20、Django中如何使用redis作为缓存"><a href="#20、Django中如何使用redis作为缓存" class="headerlink" title="20、Django中如何使用redis作为缓存"></a>20、Django中如何使用redis作为缓存</h2><p>安装django-redis ，在settings 设置缓存的服务期设置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django_redis.cache.RedisCache&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;redis://your_host_ip:6379&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;OPTIONS&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;CLIENT_CLASS&quot;</span>: <span class="string">&quot;django_redis.client.DefaultClient&quot;</span>,</span><br><span class="line">       <span class="string">&quot;PASSWORD&quot;</span>: <span class="string">&quot;yourpassword&quot;</span>,</span><br><span class="line">    		&#125;,</span><br><span class="line">  		&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>也可是设置超时时间 ：REDIS_TIMEOUT=7<em>24</em>60*60</p>
<h2 id="21、如何在模板中获取当前访问url地址"><a href="#21、如何在模板中获取当前访问url地址" class="headerlink" title="21、如何在模板中获取当前访问url地址"></a>21、如何在模板中获取当前访问url地址</h2><table>
<thead>
<tr>
<th>Method</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>request.path</td>
<td>/search/</td>
</tr>
<tr>
<td>request.get_full_path</td>
<td>search/?keyword=django</td>
</tr>
<tr>
<td>request.build_absolute_uri</td>
<td><a href="https://jackeygao.io/search/?keyword=django">https://jackeygao.io/search/?keyword=django</a></td>
</tr>
</tbody></table>
<h2 id="22、Django信号-Signals-的工作原理-主要应用场景及内置信号。"><a href="#22、Django信号-Signals-的工作原理-主要应用场景及内置信号。" class="headerlink" title="22、Django信号(Signals)的工作原理, 主要应用场景及内置信号。"></a>22、Django信号(Signals)的工作原理, 主要应用场景及内置信号。</h2><p>Django 提供一个了“信号分发器”机制，允许解耦的应用在框架的其它地方发生操作时会被通知到。通俗而讲Django信号的工作原理就是当某个事件发生的时候会发出一个信号(signals), 而监听这个信号的函数(receivers)就会立即执行。应用场景有很多比如：创建用户的时候在创建一个一对一关系的用户信息的模型对象。或者是用户下订单的时候邮件通知管理员的情况。</p>
<p>Django的内置信号 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django.db.models.signals.pre_save &amp; post_save在数据模型调用 save()方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.pre_init&amp; post_init在模型调用_init_方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.pre_delete &amp; post_delete在模型调用delete()方法或查询集调用delete() 方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.m2m_changed在模型多对多关系改变后发送。</span><br><span class="line"></span><br><span class="line">django.core.signals.request_started &amp; request_finished Django建立或关闭HTTP 请求时发送。</span><br></pre></td></tr></table></figure>


<h2 id="23、什么情况下需要自定义context-processors-上下文处理器"><a href="#23、什么情况下需要自定义context-processors-上下文处理器" class="headerlink" title="23、什么情况下需要自定义context_processors(上下文处理器)"></a>23、什么情况下需要自定义context_processors(上下文处理器)</h2><p>当你需要一个视图函数或者模板提供或设置全局变量的时候，需要用上下文管理器，我们在试图和模板中随意使用request这个变量，就是因为django.core.contenxt_process_request 把request变成了一个全局变量。上下文管理器（content_process）很多地方都有用，例如：一些博客的标签、归档，这些公共的信息，是每个文章都会用的东西，如果存在数据库中，就会每次使用都要从数据库查询回去数据，造成资源浪费，如果通过context_process 设置为全局变量，就不需要再每次都要查询数据库了。</p>
<h2 id="24、Django如何实现高并发？"><a href="#24、Django如何实现高并发？" class="headerlink" title="24、Django如何实现高并发？"></a>24、Django如何实现高并发？</h2><p>使用NGINX进行反向代理。</p>
<p>数据库的分库和读写分离(主从复制)。</p>
<p>使用redis做缓存。</p>
<p>耗时任务(收发邮件/写入文件)使用celery 异步处理。</p>
<p>使用Gzip压缩静态文件。</p>
<p>使用CDN加速静态文件。</p>
<h2 id="25、什么是MVC-："><a href="#25、什么是MVC-：" class="headerlink" title="25、什么是MVC ："></a>25、什么是MVC ：</h2><p>Modle：数据层，数据业务对象和数据库的交互(ORM)。</p>
<p>View：视图层，负责与用户交互和展示。 </p>
<p>Controller ：接收请求参数,调佣模型和视图完成请求。</p>
<h2 id="26、什么是ORM"><a href="#26、什么是ORM" class="headerlink" title="26、什么是ORM"></a>26、什么是ORM</h2><p>对象关系映射，用于实现业务对象与数据库表中字段映射。类似的有sqlalchemy 、Django 的 ORm 还有 Peewee</p>
<p>好处：代码更加的面向对象，代码量更少，灵活性更高，提升代码的开发效率。</p>
<h2 id="27、WEB安全的问题"><a href="#27、WEB安全的问题" class="headerlink" title="27、WEB安全的问题"></a>27、WEB安全的问题</h2><p>什么是SQL 注入：</p>
<p>通过特殊的参数传入web应用，导致后端执行了恶意代码。在动态的拼接SQL的时候产生。</p>
<p>如何防范：</p>
<p>永远不要相信用户的人任何输入</p>
<p>对输入的参数最好检查，过滤和转义特殊字符。</p>
<p>不要直接拼接sql使用ORM可以大大降低sql注入的风险。</p>
<p>数据库层：做好明文管理，不要存储明文敏感信息。</p>
<h2 id="28、什么是XSS"><a href="#28、什么是XSS" class="headerlink" title="28、什么是XSS :"></a>28、什么是XSS :</h2><p>恶意用户将代码植入到提供给其他用户使用的页面中。未经转义的恶意代码输出到其他的用户浏览器被执行。</p>
<p>嵌入到页面中的js脚本被执行，攻击用户。</p>
<h2 id="29、什么是前后端？有哪些优势。"><a href="#29、什么是前后端？有哪些优势。" class="headerlink" title="29、什么是前后端？有哪些优势。"></a>29、什么是前后端？有哪些优势。</h2><p>后端只负责提供数据，不再渲染模板。前端获取接口实现。</p>
<p>好处：前后端解耦，接口复用，减少开发量。提升工作效率。更利于调试，测试和部署。</p>
<p>缺点：动态加载不利于SEO。</p>
<h2 id="30、什么是-RESTful"><a href="#30、什么是-RESTful" class="headerlink" title="30、什么是 RESTful"></a>30、什么是 RESTful</h2><p>是一种以资源为中心的WEB软件架构风格，可以用ajax 和restful web服务架构应用。</p>
<p>设计概念和准则：</p>
<p>所有的事物抽象为资源，资源对应唯一的标识。</p>
<p>资源通过接口进行操作实现状态转移。操作本身是无状态的。</p>
<h1 id="六、数据结构算法"><a href="#六、数据结构算法" class="headerlink" title="六、数据结构算法"></a>六、数据结构算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># n = len(a)  # 获取列表的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j + <span class="number">1</span>]:</span><br><span class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="keyword">if</span> li[min_index] &gt; li[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            li[i], li[min_index] = li[min_index], li[i]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL性能优化总结</title>
    <url>/2021/11/13/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<h1 id="Mysql-性能优化总结"><a href="#Mysql-性能优化总结" class="headerlink" title="Mysql 性能优化总结"></a>Mysql 性能优化总结</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv8YPTrg9lpFjt5WmnTicwibMbFhqkh287yQXUbdAeBficySb7mroxZiaeWbQdZLpF5T8mCNUC3OibbxJw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="1-客户端方向："><a href="#1-客户端方向：" class="headerlink" title="1 客户端方向："></a>1 客户端方向：</h2><h3 id="1-1、客户端使用连接池，"><a href="#1-1、客户端使用连接池，" class="headerlink" title="1.1、客户端使用连接池，"></a>1.1、客户端使用连接池，</h3><h2 id="2-服务器端方向："><a href="#2-服务器端方向：" class="headerlink" title="2 服务器端方向："></a>2 服务器端方向：</h2><ul>
<li>服务端连接数改大。</li>
<li>使用缓存组件：例如redis等。 </li>
<li>基于主从复制的读写分离。</li>
<li>垂直分库，水平分库分表。</li>
<li>开启慢查询日志</li>
<li>SQL和索引的优化</li>
</ul>
<p>需要在mysql的配置文件中去开启</p>
<p>查看是否开启：<code>show variables like &#39;slow_query%&#39;;</code></p>
<p>查看多久算是慢查询语句：<code>show variables like &#39;long_query_time&#39;;</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv8YPTrg9lpFjt5WmnTicwibMibRnvc7Dw7ZG6hx9hvAtQ5jYicsAAibaQDR7qvRsuRvZj4U09NudwYXoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="3-多张表联合查询，是先查小表还是大表？"><a href="#3-多张表联合查询，是先查小表还是大表？" class="headerlink" title="3 多张表联合查询，是先查小表还是大表？"></a>3 多张表联合查询，是先查小表还是大表？</h2><p>小表驱动大表的思想：两表查询结果的笛卡尔乘积，越小越好，它的中间结果就会小一些，减少内存的消耗。所以在连接查询的时候左表建议是小表。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引原理</title>
    <url>/2021/11/13/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<blockquote>
<p>索引是帮助MySQL高效获取数据的排好序的数据结构。</p>
</blockquote>
<p><strong>在MySQL的InnoDB和MyISAM存储引擎中索引的数据结构都是B+树和HASH。</strong></p>
<p><strong>首先说数据结构中的一些树，比较常见的有二叉树、二叉查找树、平衡二叉树、红黑树、B树、B+树等。</strong></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>定义：是N（N&gt;=0）个节点的有限集合。该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。</p>
<p><img src="https://tc.chaizz.com/f387e3b8447411ec9d7c5254006b8f1d.png" alt="图片"></p>
<center> 普通二叉树（图源网络）</center>

<p>特点：</p>
<ul>
<li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li>
</ul>
<p>二叉树又有满二叉树和完全二叉树，在此不做详解。</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>定义：二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。是数据结构中的一类。在一般情况下，查询效率比链表结构要高。</p>
<p>特点</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的结点。</li>
</ul>
<p><img src="https://tc.chaizz.com/09ef2b34447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>二叉查找树（图源网络）</center>



<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>定义：平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p>
<p>特点：</p>
<ul>
<li>非叶子节点最多拥有两个子节点；</li>
<li>非叶子节点值大于左边子节点、小于右边子节点；</li>
<li>树的左右两边的层级数相差不会大于1;</li>
<li>没有值相等重复的节点;</li>
</ul>
<p><img src="https://tc.chaizz.com/1d670808447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>平衡二叉树（图源网络）</center>





<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>定义：红黑树是一种含有红黑结点并能<strong>自平衡</strong>的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个为NIL叶子节点是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li>
<li>如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</li>
</ul>
<p>红黑树通过三种操作实现自平衡：左旋、右旋、变色。</p>
<p>左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如下图所示。</p>
<p><img src="https://tc.chaizz.com/4b99132e447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>左旋（图源网络）</center>



<p>右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如下图所示。</p>
<p><img src="https://tc.chaizz.com/5da9ea52447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>右旋（图源网络）</center>

<h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>定义：是一种多路平衡查找树（不是二叉树），是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。</p>
<p>特点：</p>
<ul>
<li>根结点至少有两个子节点。</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 。</li>
<li>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 。</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</li>
</ul>
<p><img src="https://tc.chaizz.com/7a76deec447511ec9d7c5254006b8f1d.jpeg" alt="图片"></p>
<center>B 树（图源网络）</center>





<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>定义：B+树是B树的变种，在b树特点的基础上修改了一些特点。</p>
<p>B+树的特点:</p>
<ol>
<li>拥有B树的特点.。</li>
<li>叶子结点之间有指针连接。</li>
<li>非叶子节点不存储数据。</li>
<li>非叶子节点的元素,在叶子节点上都冗余了,也就是叶子结点存储了所有的元素,并且已经排好序。</li>
</ol>
<p><img src="https://tc.chaizz.com/8e88e36c447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>B+树（图源网络）</center>



<blockquote>
<p>Mysql 的索引使用的是B+树,因为索引是用来加速查询的，而B+树通过对数据进行排序,是可以提高查询速度的,然后通过一个节点中可以存储多个元素，从而使得B+树的高度不会太高,在Mysql中的一个innodb页就是一个B+树节点,一个innodb页默认为16kb，所以一般情况下B+树可以存大概两千多万行的数据,然后通过利用B+数叶子结点存储了所有的数据并且进行了排序,并且叶子结点之间有指针，可以很好的支持全表扫描,范 围查询等SQL语句。</p>
</blockquote>
<p>MyISAM 引擎的<strong>主键</strong>索引实现是B+树，存放在.myi 文件中。索引文件和数据文件是分开存储的。（非聚集索引）</p>
<p><img src="https://tc.chaizz.com/9a83ff08447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p>InnoDB 引擎<strong>主键</strong>索引实现（聚集索引）。</p>
<p>表数据文件本身就是按照一个B+树组织的一个索引文件结构，存储在 .idb 文件中。</p>
<p><img src="https://tc.chaizz.com/a92ff2a0447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p><strong>引出的问题：</strong></p>
<p><strong>1、MyISAM 和 InnoDB 都是B+树结构他们的区别在哪里？</strong></p>
<ul>
<li>myisam 索引文件和数据文件是分开存储的，即非聚集索引，所以B+树的叶子结点存储的数据文件的指针。</li>
<li>innodb 索引文件和数据文件存储在一个文件中，即聚集索引，该文件结构是按照一个B+树组织的一个索引文件结构。所以叶子节点直接存储的就是数据。</li>
</ul>
<p><strong>2、为什么建议InnoDB引擎的表必须设置主键，并且推荐使用自增主键？</strong></p>
<ul>
<li>因为Mysql的索引就是一个B+树组织的文件，如果没有设置主键，Mysql 会主动找表里面唯一的列，如果没有则会自己创建一个虚拟列，来维护B+树的索引值。在B+树的同一层节点中节点值是连续的从左到右增大。使用自增主键在B+树中进行对比查找效率更高，存储空间更小。如果使用UUID，判断连续需要占用大量的计算。</li>
</ul>
<p><strong>3、为什么非主键索引结构叶子结点存储的是主键值？</strong></p>
<ul>
<li>因为B+树的节点都是有序的，如果是非自增的主键，在插入的时候会导致性能下降。</li>
</ul>
<h2 id="Hash-索引结构"><a href="#Hash-索引结构" class="headerlink" title="Hash 索引结构"></a>Hash 索引结构</h2><p>定义：Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中。hash索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。Memory引擎默认使用的是此种索引。</p>
<p>特点：</p>
<ul>
<li>hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。</li>
</ul>
<ul>
<li>Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</li>
</ul>
<ul>
<li>Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</li>
</ul>
<ul>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li>
</ul>
<p><img src="https://tc.chaizz.com/b71e58b6447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p>Hash 索引结构和B+树索引结构的区别就是 hash索引结构的特点。</p>
<p>联合索引结构：</p>
<ul>
<li>命名规则：表名_字段</li>
<li>需要加索引的字段，要在where条件中</li>
<li>数据量少的字段不需要加索引</li>
<li>如果where条件中是OR关系，加索引不起作用</li>
<li>符合最左前缀原则</li>
</ul>
<p>联合索引又叫复合索引。对于复合索引:MySQL从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a |  a,b | a,b,c 3种组合进行查找，但不支持 b,c进行查找 ，当最左侧字段是常量引用时，索引就十分有效。</p>
<p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
<h2 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h2><ul>
<li>大大的加快数据查询速度。</li>
</ul>
<h2 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h2><ul>
<li>索引文件需要维护，消耗数据库资源。</li>
<li>可能会占用大量磁盘空间。</li>
<li>当对表的数据进行修改/删除时，会影响效率。（数据库需要对索引结构进行维护）</li>
</ul>
<h2 id="索引的分类："><a href="#索引的分类：" class="headerlink" title="索引的分类："></a>索引的分类：</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul>
<li><p>设定主键后数据库会自动设置索引，无需手动创建。innodb为聚集索引。</p>
</li>
<li><p>如果不指定主键，数据库会自动查找一列非空的列，设置为主键索引，如果没有唯一数据，数据库则会自动创建一个类似于row_id 来当做主键 索引。</p>
</li>
<li><p>唯一且非空。</p>
</li>
</ul>
<h3 id="单列索引（单值索引、普通索引）"><a href="#单列索引（单值索引、普通索引）" class="headerlink" title="单列索引（单值索引、普通索引）"></a>单列索引（单值索引、普通索引）</h3><ul>
<li>即一个索引只包含一个列，一个表可以有多个单列索引。</li>
</ul>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul>
<li>索引的值必须是唯一的，但是允许为空，只允许一个空值。</li>
</ul>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul>
<li>即一个索引包含多个列。</li>
<li>遵循最左前缀原则。但是数据库也会自适应最左前缀。</li>
</ul>
<h3 id="Full-Text-（全文索引，只能用于MyISAM-）"><a href="#Full-Text-（全文索引，只能用于MyISAM-）" class="headerlink" title="Full Text （全文索引，只能用于MyISAM ）"></a>Full Text （全文索引，只能用于MyISAM ）</h3><ul>
<li>全文索引类型为Full Text ,在定义的索引的列上支持全文查找，允许在这些列上插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型上创建。</li>
</ul>
<ol>
<li><h2 id="索引的基本操作"><a href="#索引的基本操作" class="headerlink" title="索引的基本操作"></a><strong>索引的基本操作</strong></h2></li>
</ol>
<h3 id="创建普通索引的方式："><a href="#创建普通索引的方式：" class="headerlink" title="创建普通索引的方式："></a>创建普通索引的方式：</h3><ol>
<li><p>建表之后创建：</p>
</li>
<li><p>```sql</p>
<h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><p>create table index_user ( </p>
<pre><code>id INT PRIMARY KEY, NAME VARCHAR ( 20 ) 
</code></pre>
<p>);</p>
<h1 id="为表的某个字段创建索引格式："><a href="#为表的某个字段创建索引格式：" class="headerlink" title="为表的某个字段创建索引格式："></a>为表的某个字段创建索引格式：</h1><p>create index 索引名 on 表名（表的某一列）</p>
<p>create index name_index on index_user(name);</p>
<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><p>show index from index_user;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 建表时创建索引：</span><br><span class="line">6. 创建表无法指定索引名字，索引名默认为列名。</span><br><span class="line"></span><br><span class="line">7. &#96;&#96;&#96;sql</span><br><span class="line">   CREATE TABLE index_user_1 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), KEY ( NAME ) );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
</ol>
<h3 id="创建唯一索引的方式："><a href="#创建唯一索引的方式：" class="headerlink" title="创建唯一索引的方式："></a>创建唯一索引的方式：</h3><ol>
<li><p>建表之后创建索</p>
</li>
<li><p>```sql<br>CREATE UNIQUE INDEX id_card_index ON index_user_2 ( id_card );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 建表时创建索引</span><br><span class="line">6. &#96;&#96;&#96;sql</span><br><span class="line">   CREATE TABLE index_user_2 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), id_card VARCHAR ( 18 ), UNIQUE ( NAME ) );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
</ol>
<h3 id="创建复合索引的方式："><a href="#创建复合索引的方式：" class="headerlink" title="创建复合索引的方式："></a>创建复合索引的方式：</h3><ol>
<li><p>创建表时创建：</p>
</li>
<li><p>```sql<br>CREATE TABLE index_user_3 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), id_card VARCHAR ( 18 ), KEY ( NAME, id_card ) );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 创建表后创建索引</span><br><span class="line">6. &#96;&#96;&#96;</span><br><span class="line">   CREATE INDEX name_idcard_index ON index_user_3 ( NAME, id_card );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
<li><p><strong>复合索引的最左前缀原则：如果索引不包括第一顺序的索引，数据库则不会使用索引查询。MySQL为了更好的利用索引，在查询过程中，回动态的调整索引的顺序，索引当最左的索引不在第一顺序是数据库也能自动的调整顺序。</strong></p>
</li>
</ol>
<h2 id="聚集索引非聚集索引知识点："><a href="#聚集索引非聚集索引知识点：" class="headerlink" title="聚集索引非聚集索引知识点："></a><strong>聚集索引非聚集索引知识点：</strong></h2><p><strong>聚集索引：</strong>将数据存储与索引放在一起，索引结构的叶子结点保存了行数据。</p>
<p><strong>非聚集索引：</strong>将数据与索引分开，索引结构的叶子结点存储的是指向数据文件的指针。</p>
<p>==<strong>注意：在innodb 中，在聚集索引上创建的索引为辅助索引，非聚集索引都是f辅助索引，像复合索引、普通索引、唯一索引。辅助索引叶子结点保存的不是数据行的物理位置 而是主键的值，辅助索引访问数据都是二次查找。</strong>==</p>
<p><strong>InnoDB中使用的是聚集索引，将主键组织到一个B+树中，而行数据就存储在叶子结点上，若使用where id= 1 这样的条件查找主键则按照B+树的检索算法即可快算找到对应的的叶子结点之后获得行数据。</strong></p>
<p><strong>若是对name列进行查找，则需要两个步骤，第一步在辅助索引B+树中检索name，到达辅助索引的叶子结点获得主键索引的ID，第二步在主键索引B+树上根据主键ID进行查找，到达叶子结点节课获取数据行。</strong></p>
<p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
<p><strong>MyISAM 使用的是非聚集索引，B+树结构没什么不同只不过叶子节点上存储的内容不同，主键索引存储了主键，辅助索引存储了辅助键，表数据存储在了独立的地方。以下图中B+树的叶子结点都使用一个内存指针指==向了真正的数据，对于表数据来说，这两个键没有任何差别。由于索引是独立的，通过辅助索引检索无需访问主键索引树。==（索引MyISAM 引擎用来做只含有大量的找找的功能比较合适。）</strong></p>
<p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
<h3 id="聚集索引的优势："><a href="#聚集索引的优势：" class="headerlink" title="聚集索引的优势："></a><strong>聚集索引的优势：</strong></h3><p><strong>每次使用辅助索引都要经过两次B+树查找，看上去聚集索引的效率要低于非聚集索引，这不是多此一举吗，聚集索引的优势在哪里？</strong></p>
<ul>
<li>由于行数据和聚集索引的叶子结点存储在一起，同一页中会有多条行数据，访问同一页数据的不同行数据时，已经把叶加载到了缓存中，再次访问时会在内存中完成访问，不需要再次访问磁盘，这样主键荷航数据是一起被到渠道内存中的，找到叶子结点就可以直接将数据返回。如果按照主键ID寻找数据则会更快。</li>
<li>辅助索引的叶子结点存储的是主键值，而不是数据的，好处是当行数据发生改变时索引树的节点也要分裂变化（对索引进行重新排序），或者是我们需要查找的数据在上一次IO读写的时在缓存中没有，需要在发生一次IO操作，可以避免辅助索引的维护工作，另一个好处是辅助索引存储的是主键的值，减少了辅助索引占用的空间的大小。</li>
</ul>
<h3 id="聚集索引需要注意什么？"><a href="#聚集索引需要注意什么？" class="headerlink" title="聚集索引需要注意什么？"></a><strong>聚集索引需要注意什么？</strong></h3><p>使用主键为聚集索引时，最好不要用UUID，因为UUID太过离散，不适合排序，而且可能出现新增记录的UUID会插入到索引树的中间位置，导致索引树的调整复杂度变大，消耗时间和资源。</p>
<p>建议使用Int类型的自增，方便排序并且会在索引树的末尾增加主键值，对索引树的结构影响最小，而且主键占用的存储空间越大，辅助索引中保存的主键值也会变大占用存储空间，也会影响IO操作读取的数据量。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="什么时候无法使用索引？"><a href="#什么时候无法使用索引？" class="headerlink" title="什么时候无法使用索引？"></a>什么时候无法使用索引？</h3><ul>
<li><p>在查询语句中使用like关键字，如果匹配的第一个字符为“%”，索引不会被使用，如果“%”不是在第一个位置，索引就会被使用。</p>
</li>
<li><p>查询的索引字段类型不一致。（隐式类型转换，但不全部都无法使用索引）<strong>可以理解为对字段进行操作的都会失效</strong>。</p>
<p>在Mysql中会自动进行类型转换具体分多种情况：  </p>
<p>1、如果查询条件为单纯的字符串怎MySQL会自动转化为数字 0。  </p>
<p><code>select 0 = &#39;aasd&#39; </code> 结果为 1 代表相等  <code>select 1 = &#39;aasd&#39; </code> 结果为 0 代表不相等<code> select 1 = &#39;1&#39;</code> 结果为 1 代表相等   。</p>
<p>2、如果条件包含带数字和字母的字符串则会转化为该字符串中的数字的值。  <code>select 1 = &#39;1aasd&#39; </code> 结果为 1 代表相等  <code>select 12 = &#39;12aasd&#39; </code> 结果为1 代表相等。</p>
</li>
<li><p>查询中使用多列索引，查询条件不符合最左原则。（不包括最左前缀字段）。</p>
</li>
<li><p>查询语句中使用or 关键字，如果or前后两个都有索引会使用索引，如果有一个没有索引，就不会去使用索引查询。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务与锁机制</title>
    <url>/2021/10/08/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p><strong>MySQL支持事务的储引擎：InnoDB</strong></p>
<blockquote>
<p>事务是一条或者一组SQL操作语句。</p>
</blockquote>
<p>事务的四大特性：A （atomicity）、C（consistency）、I（isolation）、D（durability）。</p>
<p>满足以上特性的事务操作，才能被称作完整的事务。</p>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>A（atomicity）原子性 ：指一个事务中的所有的操作，要么全部完成，要么全部失败回滚。即像化学中的原子一样是最小单位，不能被分割 。在数据库中是由undo Log（回滚日志） 来实现的。</p>
<p>D（Durability）持久性：事务结束之后对数据的改变是永久的，不会因为外界的干扰而导致数据更改。在数据库中是由redo Log 来实现的。</p>
<p>I（Isolation）隔离性：数据库允许多个事务并发的对数据库同时操作，隔离性可以防止多个事务并发执行而导致的数据不一致。隔离又分为多个隔离级别。在数据库中是由LBCC+MVCC实现的。</p>
<p>C（Consistency）一致性：事务开始前后没数据没有被破坏，开始前后的数据符合预期。</p>
<p>原子性、持久性、隔离性都是为了保证数据的一致性。</p>
<h2 id="事务并发会出现的问题"><a href="#事务并发会出现的问题" class="headerlink" title="事务并发会出现的问题"></a>事务并发会出现的问题</h2><p>事务的并发在没有隔离性控制的情况下会出现<strong>读一致性</strong>的问题</p>
<p>1、脏读：在一个事务中<strong>前后两次查询（针对同一条记录）</strong>得到的不一样的结果是由于其读取到其他的事务<strong>未提交</strong>的数据，这种情况叫做脏读。（未在磁盘中持久化，未提交的数据称为脏数据，所以称为脏读。）</p>
<p>2、不可重复读：在一个事务中<strong>前后两次查询（针对同一条记录）</strong>得到的不一样的结果是由于其读取到其他的事务<strong>已经提交</strong>的数据，这种情况叫不可重复读。</p>
<p>3、幻读：在一个事务中<strong>前后两次查询</strong>得到了不一样的结果数，是由于其读取到其他的事务<strong>已经提交</strong>的<strong>新的（新插入的）</strong>数据，这种情况叫幻读。</p>
<h2 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h2><p><strong>针对以上的事务的并发出现的问题，MySQL给出了四种隔离级别：</strong></p>
<p>1、Read Uncommitted (读未提交) ：未解决事务的并发问题，事务提交的数据对于其他事务也是可见的会出现脏读。</p>
<p>2、Read Committed （读已提交）：解决了脏读的问题，一个事务开始之后只能看到已提交的事务的所做的修改，但是会出现不可重复读的问题。 </p>
<p>3、Repeatable Read（可重复读）：解决不可重复读问题，在同一个事务中，多次读取同样的数据结果是一样的，这种隔离级别解决幻读的问题。</p>
<p>4、Serializable（串行化）：解决所有的问题，最高的隔离级别，让事务强制串行化执行。</p>
<p>在MySQL的InnoDB的存储引擎中实现的隔离级别如下图所示：(全部解决)</p>
<p><img src="https://tc.chaizz.com/640.jpg" alt="图片"></p>
<h2 id="以上隔离级别是如何实现？"><a href="#以上隔离级别是如何实现？" class="headerlink" title="以上隔离级别是如何实现？"></a>以上隔离级别是如何实现？</h2><p>第一种方案：</p>
<p>加锁。在读取数据前，对数据进行加锁，阻止其他的事务对其进行操作。（LBCC：Lock Based Concurrency Control）</p>
<p>第二种方案：</p>
<p>生成一个数据请求时间点的一致性数据快照（snapshot），并用这个快照来提供一定级别的（语句级或者事务级）的一致性读取。（MVCC：Multi Version Concurrency Control） 这种方案只在RC和RR 中使用。</p>
<p><strong>首先MVCC 的大致实现原理：</strong></p>
<p>他的宗旨就是创建多个版本的数据，然后对多个版本的数据进行修改查询，从而实现事务的隔离性。</p>
<p><strong>实现MVCC需要的条件：</strong></p>
<ul>
<li>事务需要被记录版本号（即事务的ID：DB_TRX_ID）在数据库表中以隐藏列的形式存在。</li>
<li>数据库表的聚集索引列ID（<strong>DB_ROW_ID</strong>）。</li>
<li>数据库表中另外的隐藏列：<strong>DB_ROLL_PTR</strong> 是指向undo Log的指针。</li>
<li>undo Log（记录数据被修改之前的日志，数据被修改时会把之前的数据拷贝到undolog，当数据进行回滚时，就根据undolog中的数据进行回滚）。</li>
<li>Read View（可以理解为维护的一个活跃事务ID的列表）。</li>
</ul>
<p>开启一个事务A：会产生一个事务的ID号，同时会在readview中维护当前活跃事务的ID，DB_ROLL_PTR 指针指向事务开启之前的数据的undo Log的地址，事务A的操作始终是在当前记录的undo Log 的那些数据中记性操作，如果有其他的事务对数据操作也会指向一个undo Log的指针，操作他的undo Log的数据，所以事务之间的操作并不会影响。</p>
<h1 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h1><blockquote>
<p>锁是计算机协调多个进程和线程并发访问某一资源的一种机制，锁使用独占的方式来保证在只有一个版本的情况下事务之间的隔离，所以锁可以理解为单版本控制。</p>
</blockquote>
<blockquote>
<p>引入锁之后就可以支持并行处理事务，如果事务之间涉及到相同的数据时，会使用排它锁，或者叫互斥锁，先进入的事务独占数据之后，其他的事务被阻塞，等待前面的事务被释放。</p>
</blockquote>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>  mysql的存储引擎 <strong>InnoDB</strong> 既支持<strong>行锁</strong>也支持<strong>表锁</strong>，<strong>MyISAM 只支持表锁。</strong></p>
<h3 id="从锁的粒度分：表级锁、行级锁、页级锁。"><a href="#从锁的粒度分：表级锁、行级锁、页级锁。" class="headerlink" title="从锁的粒度分：表级锁、行级锁、页级锁。"></a>从锁的<strong>粒度</strong>分：表级锁、行级锁、页级锁。</h3><p>MyISAm引擎在执行查询语句之前，会自动给涉及的表加上读锁，在执行增删改之前会自动给表加上写锁。</p>
<p><strong>简而言之读锁会阻塞写而不会阻塞读，而写锁会将读和写全部阻塞。</strong></p>
<p>行锁与表锁的区别：</p>
<p>锁定的粒度：表锁 &gt; 行锁</p>
<p>加锁的效率：表锁 &gt; 行锁</p>
<p>冲突的概率：表锁 &gt; 行锁</p>
<p>并发的性能：表锁 &lt; 行锁</p>
<p><strong>表级锁：</strong></p>
<p>应用在MyISAM、InnoDB 存储引擎中，但偏向MyISAM引擎，开销小，加锁快，无死锁，锁定的粒度大，发生锁冲突的概率大，并发度比较低。偏向于读操作</p>
<p>MySQL的表级锁有两种，一种是表锁，一种是元数据锁。</p>
<ul>
<li><p>表锁 （手动加锁）</p>
<ul>
<li>Read Lock  （加读锁后可以在加读锁，不能加写锁）</li>
<li>Write Lock （加写锁后不能加读锁和写锁）</li>
</ul>
</li>
<li><p>元数据锁 （自动加锁）</p>
<p>当对表记录进行操作的时候（增删改查），MySQL会自动给表加上一个元数据读锁。即不能对表结构进行修改。</p>
<ul>
<li>DML（对表记录进行操作：增删改）加读锁</li>
<li>DDL （对表结构进行修改） 加写锁</li>
</ul>
</li>
<li><p>意向锁：当为行添加一个共享锁的时候，存储引擎会自动在表上加一个意向共享锁，意向排它锁也是一样。他的作用是提升加表锁的效率。</p>
<ul>
<li>意向共享读锁 </li>
<li>意向排他写锁</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 给book添加写锁 </span><br><span class="line">lock table book write;</span><br><span class="line"></span><br><span class="line"># 给book添加读锁 </span><br><span class="line">lock table &lt;table_name&gt; read;</span><br></pre></td></tr></table></figure>
<p>表锁分析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br><span class="line">In_use 为<span class="number">1</span> 代表该表被锁定</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/254cc64a420c11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;tables%&#x27;</span>;</span><br></pre></td></tr></table></figure>


<p><img src="https://tc.chaizz.com/ab54b6ee420c11ec9d7c5254006b8f1d.png"></p>
<p>这里有两个状态变量记录MySQL表锁定的情况：</p>
<p>Table_locks_immediate：产生表级锁定的次数。</p>
<p><strong>Table_locks_waited：出现表级锁争用二发生的等待的次数。此值越高说明存在着大量的报表级锁竞争情况。</strong></p>
<p>此外MyISAM引擎，的读写锁调度是写优先，这也是MyISAM引擎不适合用作写操作比较多的情况，因为写锁后，其他的线程不能做任何操作，只能被阻塞。</p>
<p><strong>行级别锁：</strong></p>
<p>是由存储引擎InnoDB实现，行级锁，每次锁住一行数据，锁定的粒度最小，发生锁冲突的概率比较小，并发度比较高。</p>
<p>行级锁从锁定的力度上分为：</p>
<p>Record Lock：（记录锁）锁定单个行记录，对精确匹配或者范围匹配在范围内的数据加锁。RC、RR隔离级别都支持。</p>
<p>Gap Lock：（间隙锁）锁定索引记录间隙，确保索引记录的间隙不变。对范围匹配且符合范围条件但不在范围内的数据也进行加锁。RR隔离级别支持。（防止insert）</p>
<p>Next-key Lock：（临建锁）行锁和间隙锁的组合，同时锁住记录和索引间隙。RR隔离级别支持。 </p>
<ul>
<li>共享锁（又称为读锁，S锁） （手动加锁）<ul>
<li><code>select ... lock in sare mode</code></li>
</ul>
</li>
<li>排他锁（又称为写锁，X锁） <ul>
<li>DML（对表记录进行操作：增删改） delete/update/insert 默认加排它锁</li>
<li><code>select ... for update</code>  （当前读）</li>
</ul>
</li>
</ul>
<p>行锁分析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/15c2bdb2421411ec9d7c5254006b8f1d.png"></p>
<p><strong>Innodb_row_lock_current_waits：当前正在等待锁定的数量 （比较重要）</strong></p>
<p>Innodb_row_lock_time：从系统启动到现在锁定的总时间长度</p>
<p>Innodb_row_lock_time_avg：每次等待所花的平均时间</p>
<p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p>
<p><strong>Innodb_row_lock_waits：系统启动后到现在总共等待的次数（比较重要）</strong></p>
<p><strong>页级别锁：</strong></p>
<p>开销和加锁时间介于表锁与行锁之间，会出现死锁，锁定的粒度也是介于表锁与行锁之间，并发度一般。</p>
<h3 id="从锁的操作上来说分为读锁和写锁。"><a href="#从锁的操作上来说分为读锁和写锁。" class="headerlink" title="从锁的操作上来说分为读锁和写锁。"></a>从锁的<strong>操作</strong>上来说分为读锁和写锁。</h3><ul>
<li>读锁：针对同一份数据，多个读操作可以同时进行而不会互相影响。所以也叫作共享锁。</li>
<li>写锁：针对同一份数据，当前写操作没有释放锁之前，其他的事务无法对数据进行加锁操作，不管是读锁还是写锁。所以也叫排它锁。</li>
</ul>
<p>读锁可以让读和读并行，而读和写、写和读、写和写要加排它锁。</p>
<h3 id="从实现方式上分为乐观锁和悲观锁。"><a href="#从实现方式上分为乐观锁和悲观锁。" class="headerlink" title="从实现方式上分为乐观锁和悲观锁。"></a>从<strong>实现方式</strong>上分为乐观锁和悲观锁。</h3><h2 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景"></a>锁的使用场景</h2><p>修改数据库表结构会自动加表级锁。</p>
<p>更新数据未使用索引，行锁会上升到表锁。</p>
<p>更新数据使用索引会使用行锁。</p>
<p><code>select ... for update </code> 会使用行级别锁。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQLMVCC机制</title>
    <url>/2021/10/08/MySQL%E7%9A%84MVCC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<blockquote>
<p>数据库事务的四大特性：</p>
<p>原子性：atomicity 是通过undo log 来实现的。</p>
<p>一致性：consistency  原子性、隔离性、持久性来共同保持一致性。</p>
<p>隔离性：isolation 通过加锁以及MVCC来实现的。</p>
<p>持久性：durability 是通过redo log 实现的。</p>
</blockquote>
<h1 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h1><p>MVCC（Multi - Version - Concurrency - Control）全称是<strong>多版本并发控制</strong>。主要是为了提高数据库的并发性能。MVCC只在<strong>读已提交</strong>和<strong>可重复读</strong>的两个事务级别下有效。主要是用于处理读请求。</p>
<h1 id="MySQL的快照读和当前读是什么？"><a href="#MySQL的快照读和当前读是什么？" class="headerlink" title="MySQL的快照读和当前读是什么？"></a>MySQL的快照读和当前读是什么？</h1><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>他读取数据库记录都是当前最新的版本，会对当前读取的数据进行加锁，防止其他的事务对数据修改，属于悲观锁的一种。</p>
<p>以下操作都是当前读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select lock in share mode # (共享锁)</span><br><span class="line"></span><br><span class="line">select for update  #(排他锁)</span><br><span class="line"></span><br><span class="line">update # (排他锁)</span><br><span class="line"></span><br><span class="line">insert #(排它锁)</span><br><span class="line"></span><br><span class="line">delete  #(排它锁)</span><br><span class="line"></span><br><span class="line"># 串行化事务隔离级别</span><br></pre></td></tr></table></figure>


<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>快照读是基于和 undo log 来实现的，适用于简单 select 语句。           </p>
<p>首先MySQL一条记录里面包含三个隐藏列：<strong>row_id</strong>、<strong>trx_id</strong>、<strong>roll_pointer</strong>以及<strong>ReadView</strong>。</p>
<ul>
<li>row_id ：MySQL的B+树索引特性要求每个表必须要有一个主键。如果没有设置的话，会自动寻找第一个不包含NULL的唯一索引列作为主键。如果还是找不到，就会在这个DB_ROW_ID上自动生成一个唯一值，以此来当作主键。</li>
<li>trx_id：自增的事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID（DELETE语句被当做是UPDATE语句的特殊情况，后面会进行说明）</li>
<li>roll_pointer：回滚指针，通过它可以将不同的版本串联起来，形成版本链。相当于链表的next指针。</li>
</ul>
<h3 id="一张图理解undo-log"><a href="#一张图理解undo-log" class="headerlink" title="一张图理解undo log"></a>一张图理解undo log</h3><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-10-08_22-43-53.png"></p>
<p>以上图中最新的记录name为赵六，他指向前一个版本name为王五，依次类推，王五的上一个版本是李四，李四的上一版本是张三。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p><strong>ReadView的作用？</strong></p>
<p>就是根据事务ID查找对应的数据。那些事务应该读取到那些数据。</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-10-08_22-56-42.png"></p>
<p>m_ids ：当前MySQL中所有的<strong>活跃</strong>（<strong>指未提交的</strong>）的事务的ID。</p>
<p>min_trx_id：表示m_ids 中最小的事务ID。、</p>
<p>max_trx_id：表示生成ReadView时系统应该分配给下一个事物的ID。、</p>
<p>creator_trx_id：生成该ReadView的ID。</p>
<p><strong>ReadView如何判断哪个版本可用？</strong></p>
<ul>
<li>trx_id == creator_trx_id    如果事务ID等于当前生成ReadView的vreator_trx_id ，那么可以访问这个版本。</li>
<li>trx_id  &lt; mix_trx_id 事务ID小于当前ReadView中的最小的活跃事务的ID，说明该事务是已经提交的了事务。那么可以访问。</li>
<li>trx_id  &gt; max_trx_id 事务ID大于当前ReadView中的要分配的事务的ID，说明max_trx_id  是创建ReadView之后生成的ID，已经超出版本链的事务的ID，所以无法读取。</li>
<li>min_trx_id  &lt;=  trx_id  &lt;= max_trx_id 分两种情况：<ul>
<li>① 当trx_id   在min_trx_id   中，说明是活跃的事务的ID，未提交的事务，那么不能访问当前版本。</li>
<li>②当trx_id  不在min_trx_id   中，说明不是活跃的事务的ID，而且小于系统下一个事务的ID，那么可以访问当前版本。</li>
</ul>
</li>
</ul>
<h2 id="MVCC如何实现RR-（可重复读）和RC（读已提交）的？"><a href="#MVCC如何实现RR-（可重复读）和RC（读已提交）的？" class="headerlink" title="MVCC如何实现RR （可重复读）和RC（读已提交）的？"></a>MVCC如何实现RR （可重复读）和RC（读已提交）的？</h2><p><strong>实现RC</strong></p>
<p>RC生成ReadView的时间是每次select查询的时候就会生成一个ReadView，他是以每个select查询为单位的，比如一个事务中有两个select语句，那么这两个select就会生成两个ReadView，所以在一个事务中就可以读取到其他事务已经提交的数据，就会产生不可重复读的问题。</p>
<p><strong>实现RR</strong></p>
<p>RR 生成ReadView 是根据事务来生成，他是以每个事务为单位生成的。在一个事务中不管有多少查询语句，查询的ReadView还是同一个，所以只能读取到当前版本的数据，就可以解决不可重复读的问题。</p>
<p>InndDB 解决幻读：是通过间隙锁+锁住本身的数据（next-key），间隙锁锁住一段范围，所以其他事务无法对这段范围的数据进行插入删除等操作，所以就不存在幻读的问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerCompose知识总结</title>
    <url>/2021/09/29/DockerCompose%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​     </p>
<a id="more"></a>

<h1 id="一、DockerCompose理解"><a href="#一、DockerCompose理解" class="headerlink" title="一、DockerCompose理解"></a>一、DockerCompose理解</h1><blockquote>
<p><a href="https://docs.docker.com/compose/">Docker Compose</a> is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.</p>
<p>The <em>big</em> advantage of using Compose is you can define your application stack in a file, keep it at the root of your project repo (it’s now version controlled), and easily enable someone else to contribute to your project. Someone would only need to clone your repo and start the compose app. In fact, you might see quite a few projects on GitHub/GitLab doing exactly this now.</p>
</blockquote>
<p>Docker compose 是来管理多个容器的一个工具。</p>
<h2 id="1、安装Docker-Compose"><a href="#1、安装Docker-Compose" class="headerlink" title="1、安装Docker Compose"></a>1、安装Docker Compose</h2><p><a href="https://github.com/docker/compose/releases/download/v2.0.0/docker-compose-linux-amd64">Docker-compose地址</a></p>
<h3 id="1-1-创建cli-plugins-目录"><a href="#1-1-创建cli-plugins-目录" class="headerlink" title="1.1 创建cli-plugins 目录"></a>1.1 创建cli-plugins 目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在github上下载最新版docker-compose ,放在 docker安装用户家目录下 ：root/.docker/cli-plugins</span></span><br><span class="line"></span><br><span class="line">cd .docker</span><br><span class="line">mkdir cli-plugins</span><br></pre></td></tr></table></figure>
<h3 id="1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose"><a href="#1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose" class="headerlink" title="1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose"></a>1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在root/.docker/cli-plugins 目录下</span></span><br><span class="line">mv docker-compose-linux-amd64 docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-3-添加执行权限"><a href="#1-3-添加执行权限" class="headerlink" title="1.3 添加执行权限"></a>1.3 添加执行权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x root/.docker/cli-plugins/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-4-安装低版本"><a href="#1-4-安装低版本" class="headerlink" title="1.4 安装低版本"></a>1.4 安装低版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> docker-compose --version</span><br></pre></td></tr></table></figure>


<p><strong>v2.0.0版本命令为 <code>docker compose </code>中间没有横杠</strong></p>
<h2 id="2、Docker-Componse-官网示例（创建一个Python-web应用）："><a href="#2、Docker-Componse-官网示例（创建一个Python-web应用）：" class="headerlink" title="2、Docker Componse 官网示例（创建一个Python web应用）："></a>2、Docker Componse 官网示例（创建一个Python web应用）：</h2><h3 id="2-1、创建app-py"><a href="#2-1、创建app-py" class="headerlink" title="2.1、创建app.py"></a>2.1、创建<code>app.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span>():</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure>


<h3 id="2-2、创建包文件夹-requirements-txt："><a href="#2-2、创建包文件夹-requirements-txt：" class="headerlink" title="2.2、创建包文件夹 requirements.txt："></a>2.2、创建包文件夹 <code>requirements.txt</code>：</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建Dockerfile文件"><a href="#2-3-创建Dockerfile文件" class="headerlink" title="2.3 创建Dockerfile文件"></a>2.3 创建<code>Dockerfile</code>文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建-docker-compose-yml文件-："><a href="#2-4-创建-docker-compose-yml文件-：" class="headerlink" title="2.4 创建 docker-compose.yml文件 ："></a>2.4 创建 <code>docker-compose.yml</code>文件 ：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-5-在-docker-compose-yml-目录下运行命令"><a href="#2-5-在-docker-compose-yml-目录下运行命令" class="headerlink" title="2.5 在 docker-compose.yml 目录下运行命令"></a>2.5 在 <code>docker-compose.yml</code> 目录下运行命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose up	</span><br></pre></td></tr></table></figure>


<p>出现错误 ：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-29_19-51-36.png"></p>
<p>解决：在Dockerfile中添加下面这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完整的Dockerfile：</span></span><br><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-5-运行成功"><a href="#2-5-运行成功" class="headerlink" title="2.5 运行成功"></a>2.5 运行成功</h3><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-29_20-48-16.png"></p>
<h1 id="二、docker-compose-命令详解"><a href="#二、docker-compose-命令详解" class="headerlink" title="二、docker compose 命令详解"></a>二、docker compose 命令详解</h1><p>结合docker compose 部署多个服务</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line"><span class="comment">#  web:</span></span><br><span class="line"><span class="comment">#    # 用来使用自定义的Dockerfile ，</span></span><br><span class="line"><span class="comment">#    # 使用自己构建的镜像，然后在运行容器</span></span><br><span class="line"><span class="comment">#    build:</span></span><br><span class="line"><span class="comment">#      # 启动服务是先将制定的Dockerfile 构建一个镜像。</span></span><br><span class="line"><span class="comment">#      context: .   #这个路径可以是相对的或者绝对的。一般是dockercompose.yml的当前路径</span></span><br><span class="line"><span class="comment">#      dockerfile:</span></span><br><span class="line"><span class="comment">#    expose: # 对外暴露端口</span></span><br><span class="line"><span class="comment">#      - &quot;8000&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    depends_on:  # 代表这个容器必须依赖其他的容器才能启动（服务名）</span></span><br><span class="line"><span class="comment">#      - my_tomcat2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - &quot;8000:8000&quot;   # 制定映射容器内端口</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    networks:</span></span><br><span class="line"><span class="comment">#      - hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_tomcat2: <span class="comment"># 服务器名称</span></span><br><span class="line">    container_name: tomcat2   <span class="comment"># 自定义容器名称  docker run --name</span></span><br><span class="line">    image: tomcat   <span class="comment"># 镜像名称</span></span><br><span class="line">    restart: always</span><br><span class="line">    ports: <span class="comment">#  端口建议使用字符串    docker run -p</span></span><br><span class="line">      - <span class="string">&quot;8082:8080&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment">#      - /opt/webapps:/usr/local/tomcat/webapps # 自定义路径映射</span></span><br><span class="line">      - <span class="string">&quot;./env/webapps:/usr/local/tomcat/webapps&quot;</span> <span class="comment">#使用数据库名映射</span></span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    depends_on: <span class="comment"># 代表这个容器必须依赖其他的容器才能启动（服务名）</span></span><br><span class="line">      - my_mysql</span><br><span class="line">      - my_redis</span><br><span class="line"></span><br><span class="line">    <span class="keyword">healthcheck</span><span class="bash">: <span class="comment"># 通过命令检测容器是否正常运行</span></span></span><br><span class="line">      test: [ <span class="string">&quot;CMD&quot;</span>,<span class="string">&quot;curl&quot;</span>,<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;http://localhost&quot;</span> ]</span><br><span class="line">      interval: <span class="number">1</span>m30s</span><br><span class="line">      timeout: <span class="number">10</span>s</span><br><span class="line">      retries: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    ulimits:   # 用来修改容器内部的最大进程数</span></span><br><span class="line"><span class="comment">#      nproc: 65535</span></span><br><span class="line"><span class="comment">#      nofile:</span></span><br><span class="line"><span class="comment">#        soft: 20000</span></span><br><span class="line"><span class="comment">#        hard: 40000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    sysctls:   # 用来修改容器内部内核参数，并不是必须的，有些容器启动收到操作系统参数限制需要用到这个命令</span></span><br><span class="line"><span class="comment">#      - net.core.somaxconn=1024</span></span><br><span class="line"><span class="comment">#      - net.ipv4.tcp_syncookies=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_mysql:</span><br><span class="line">    image: mysql:<span class="number">5.7</span></span><br><span class="line">    container_name: mysql</span><br><span class="line">    privileged: true</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./env/mysql/conf.d:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      - <span class="string">&quot;./env/mysql/mysqldata:/var/lib/mysql&quot;</span></span><br><span class="line">      - <span class="string">&quot;./env/mysql/mysqllogs:/logs&quot;</span></span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#      MYSQL_ROOT_PASSWORD: &quot;123456&quot;</span></span><br><span class="line"><span class="comment">#      TZ: Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">    env_file:  <span class="comment"># 将环境变量中的值设置在文件中  必须是以.env 结尾的文件   必须要是键值对的形式或者A=B的形式</span></span><br><span class="line">      - ./<span class="keyword">env</span>/mysql/mysql.<span class="keyword">env</span>    <span class="comment"># 这个文件中就写   MYSQL_ROOT_PASSWORD: &quot;123456&quot;就可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># environment和env_file 写一个就可以</span></span><br><span class="line"></span><br><span class="line">    command:</span><br><span class="line">      --wait_timeout=<span class="number">31536000</span></span><br><span class="line">      --interactive_timeout=<span class="number">31536000</span></span><br><span class="line">      --max_connections=<span class="number">1000</span></span><br><span class="line">      --default-authentication-plugin=mysql_native_password</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_redis:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;6379&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/data:/data</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/conf:/usr/local/etc/redis</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/logs:/logs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意 redis.conf 中的 daemonize no   要设置为前台运行。</span></span><br><span class="line">    <span class="comment">#要不然运行了docker compose up , redis自动关闭</span></span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  nginx:</span><br><span class="line">    container_name: nginx</span><br><span class="line">    restart: always</span><br><span class="line">    image: nginx:<span class="number">1.11</span>.<span class="number">6</span>-alpine</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/logs:/var/log/nginx</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/www:/var/www</span><br><span class="line">      - /etc/letsencrypt:/etc/letsencrypt</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># compose 中运行 portainer</span></span><br><span class="line">  portainer:</span><br><span class="line">    image: portainer/portainer</span><br><span class="line">    container_name: portainer</span><br><span class="line">    volumes:</span><br><span class="line">      - /var/<span class="keyword">run</span><span class="bash">/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      - /opt/portainer/data:/data</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">8000</span>:<span class="number">8000</span></span><br><span class="line">      - <span class="number">9000</span>:<span class="number">9000</span></span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#volumes:</span></span><br><span class="line"><span class="comment">#  tomcat1webapps:   # 声明指定的卷名，compose会自动加上docker-compose.yml 的外层目录名</span></span><br><span class="line"><span class="comment">#    external:   # 使用自定义的卷名，前提必须存在：需要手动执行docker volume create tomcatwebapps</span></span><br><span class="line"><span class="comment">#      false</span></span><br><span class="line"><span class="comment">#  webapps:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">networks:   <span class="comment"># 声明上面创建的 hello 网桥</span></span><br><span class="line">  hello:</span><br><span class="line">    external:   <span class="comment"># 使用自定义的网桥，前提必须存在 ：需要手动执行docker networks create -d bridge hello</span></span><br><span class="line">      false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker compose up                ：启动所有服务</span></span><br><span class="line">    <span class="comment">#   -f  ：指定dockercompose.yml 文件</span></span><br><span class="line">    <span class="comment">#   -p  ：指项目名称</span></span><br><span class="line">    <span class="comment">#   -d  ：设置所有服务后台运行</span></span><br><span class="line"><span class="comment">#   docker compose down         ：关闭dcokercompose所有服务，会移除网络，不会移除数据卷</span></span><br><span class="line"><span class="comment">#   docker compose exec  [服务名]  ：进入服务对应的容器</span></span><br><span class="line"><span class="comment">#   docker compose ps           ：列出所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose restart   [服务名]  ：列出所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose rm   [服务名]  ：列出所有的容器</span></span><br><span class="line">    <span class="comment"># -f 强制删除</span></span><br><span class="line">    <span class="comment"># -v 删除服务对应容器挂载的数据卷</span></span><br><span class="line"><span class="comment">#   docker compose start   [服务名]  ：启动所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose stop   [服务名]  ：停止所有的容器 （不会移除网络）</span></span><br><span class="line"><span class="comment">#   docker compose top   [服务名]  ：查看所有容器内运行的进程</span></span><br><span class="line"><span class="comment">#   docker compose unpause   [服务名]  ：将挂起的服务恢复</span></span><br><span class="line"><span class="comment">#   docker compose pause   [服务名]  ：挂起某一个服务</span></span><br><span class="line"><span class="comment">#   docker compose logs   [服务名]  ：查看所有服务的日志</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="三、安装Portainer是Docker可视化软件"><a href="#三、安装Portainer是Docker可视化软件" class="headerlink" title="三、安装Portainer是Docker可视化软件"></a>三、安装Portainer是Docker可视化软件</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">docker pull portainer/portainer</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 9000:9000 --name=portainer --restart=always -v /opt/portainer/data:/data -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载汉化版  指定汉化版镜像</span></span><br><span class="line"></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --name=portainer -p 9000:9000 --restart=always -d  --rm  -v /var/run/docker.sock:/var/run/docker.sock -v /opt/portainer/data:/data registry.cn-shenzhen.aliyuncs.com/infrastlabs/portainer-cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问公网IP <span class="doctag">xxx:</span>9000   设置默认密码 ：至少八位</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerSwarm理解</title>
    <url>/2021/09/29/DockerSwarm%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、DockerSwarm理解"><a href="#一、DockerSwarm理解" class="headerlink" title="一、DockerSwarm理解"></a>一、DockerSwarm理解</h1><blockquote>
<p>官网解释：</p>
<p>Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.</p>
<p>Docker Engine 1.12 引入了 swarm 模式，使您能够创建一个由一个或多个 Docker 引擎组成的集群，称为 swarm。 swarm 由一个或多个节点组成：在 swarm 模式下运行 Docker Engine 1.12 或更高版本的物理或虚拟机。</p>
</blockquote>
<a id="more"></a>

<p><a href="https://docs.docker.com/engine/swarm/">官网地址</a></p>
<p><img src="https://tc.chaizz.com/tc/swarm-diagram.png"></p>
<h2 id="1、Swarm-中有两种类型的节点："><a href="#1、Swarm-中有两种类型的节点：" class="headerlink" title="1、Swarm 中有两种类型的节点："></a>1、Swarm 中有两种类型的节点：</h2><h3 id="1-1、managers-的作用"><a href="#1-1、managers-的作用" class="headerlink" title="1.1、managers 的作用"></a>1.1、managers 的作用</h3><ul>
<li>维护集群状态</li>
<li>集群调度</li>
<li>给集群提供API</li>
</ul>
<p>Swarm 使用Raft来保证分布式一致性。</p>
<blockquote>
<p><a href="https://raft.github.io/">Raft </a>是一种更为简单方便易于理解的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/1372646">分布式算法</a>，主要解决了分布式中的一致性问题。相比传统的<a href="https://baike.baidu.com/item/Paxos%E7%AE%97%E6%B3%95/6632960">Paxos算法</a>，Raft将大量的计算问题分解成为了一些简单的相对<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%AB%8B/3259">独立</a>的子问题。</p>
<p>相比于传统的一致性算法Paxos，Raft有一些自己的独特的特性。比如增加了强领导性，优化了领导的选举过程，在成员发生变化之后依然能够很好的进行工作。</p>
</blockquote>
<p>三个管理器的群体最多可以容忍一个管理器的损失。<br>一个五管理器群可以容忍最大同时丢失两个管理器节点。<br>N 个管理器集群最多可以容忍 (N-1)/2 个管理器的丢失。<br>Docker 建议一个集群最多有七个管理器节点。</p>
<p>在一些分布式任务重，节点个数往往是奇数。是为了能够成功选举出领导，如果是偶数肯能会有得票一致的情况。</p>
<h3 id="1-2、workers"><a href="#1-2、workers" class="headerlink" title="1.2、workers"></a>1.2、workers</h3><p>worker 节点 就是docekr引擎的实例，他的唯一的目的就是执行容器。worker节点不参与 Raft 分布式状态，不做出调度决策，也不为群模式 HTTP API 提供服务。</p>
<h1 id="二、创建集群"><a href="#二、创建集群" class="headerlink" title="二、创建集群"></a>二、创建集群</h1><h2 id="1、初始化集群"><a href="#1、初始化集群" class="headerlink" title="1、初始化集群"></a>1、初始化集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化主节点，使用主节点创建不同类型的节点令牌</span></span><br><span class="line">docker swarm init --advertise-addr 内网地址</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建manager令牌</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建worker令牌</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入一个节点</span></span><br><span class="line">docker swarm join ---token 令牌</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看节点名称</span></span><br><span class="line">docker node ls</span><br></pre></td></tr></table></figure>


<h1 id="三、Docker-服务弹性扩容"><a href="#三、Docker-服务弹性扩容" class="headerlink" title="三、Docker 服务弹性扩容"></a>三、Docker 服务弹性扩容</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Swarm manager 节点下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个服务，具备扩缩容的功能</span></span><br><span class="line">docker service create -p 8888:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接启动三个副本。</span></span><br><span class="line">docker service update --replicas 3 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker知识总结</title>
    <url>/2021/09/27/Docker%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<blockquote>
<p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production.</p>
</blockquote>
<h1 id="一、Docker-是什么"><a href="#一、Docker-是什么" class="headerlink" title="一、Docker 是什么"></a>一、Docker 是什么</h1><h2 id="1、Docker-简介"><a href="#1、Docker-简介" class="headerlink" title="1、Docker 简介"></a>1、Docker 简介</h2><p> Docker 是一个用于开发、传送和运行应用程序的开放平台。Docker 使您能够将应用程序与基础设施分开，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产中运行代码之间的延迟。</p>
<p>Docker是基于Google的Go语言开发的。</p>
<h2 id="2、Dcoker-能干什么？"><a href="#2、Dcoker-能干什么？" class="headerlink" title="2、Dcoker 能干什么？"></a>2、Dcoker 能干什么？</h2><p>Docker 能方便的将开发环境打包起来，包括Python、Nginx 、Redis、Mysql、Tomcat等等的开发环境只需要一次部署，然后将他们打包为镜像，接下来只需要拿着这个镜像在不同的服务器中的docker中运行即可得到一个全新的与之前部署的环境完全一样的环境。有点类似于布尔玛的万能胶囊，只是有点..</p>
<h1 id="二、Docker与虚拟机的区别"><a href="#二、Docker与虚拟机的区别" class="headerlink" title="二、Docker与虚拟机的区别"></a>二、Docker与虚拟机的区别</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/271846374">https://zhuanlan.zhihu.com/p/271846374</a></p>
</blockquote>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_16-03-32.png"></p>
<p>传统的虚拟机技术：由于虚拟机是把这个系统内核、系统依赖、硬件资源配置全部打包，组成一个新的系统。他是在硬件的基础上实现虚拟化。所以虚拟机占用的资源比较大，切换比较耗时。</p>
<p>Docker技术：它是直接运行在宿主机上，是系统层面的虚拟化，他不需要自己拥有单独的内核，也没有打包硬件资源，所以他是很轻便的，而且每个容器之间是相互隔离的，类似于一个沙箱。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级·</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘空间</td>
<td>一般为几十MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>操作系统</td>
<td>与宿主机共享OS</td>
<td>在宿主机上运行虚拟机的OS</td>
</tr>
</tbody></table>
<p>Docker的优点：</p>
<ul>
<li>对系统资源能够更高效的利用。</li>
<li>启动速度更快。</li>
<li>一致的运行环境。</li>
<li>维护和扩展更加的容易。</li>
<li>应用更快的交付与部署</li>
</ul>
<h1 id="三、Docker-的基本组成"><a href="#三、Docker-的基本组成" class="headerlink" title="三、Docker 的基本组成"></a>三、Docker 的基本组成</h1><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_16-23-06.png"></p>
<h2 id="Docker的三大组件："><a href="#Docker的三大组件：" class="headerlink" title="Docker的三大组件："></a>Docker的三大组件：</h2><h3 id="1、镜像："><a href="#1、镜像：" class="headerlink" title="1、镜像："></a>1、镜像：</h3><p>Docker的镜像好比一个文件模板（分层的），有各种各样的模板，这个模板就是一些具体的应用以及对应的资源。比如说一个Nginx 镜像 就是一个包含Nginx的模板。他需要在一个Ubuntu或者其他系统镜像上安装那么就是一个可运行的Nginx镜像。</p>
<h3 id="2、容器："><a href="#2、容器：" class="headerlink" title="2、容器："></a>2、容器：</h3><p>容器类似于一个沙箱，是基于镜像来创建的，多个镜像可以组成一个容器，他是独立运行的，可以启动、暂停、删除容器等操作。</p>
<h3 id="3、仓库："><a href="#3、仓库：" class="headerlink" title="3、仓库："></a>3、仓库：</h3><p>仓库就是用来存放镜像的地方，这个概念和git是一样的，有共有仓库和私有仓库。</p>
<h1 id="四、Dcoker的安装与卸载"><a href="#四、Dcoker的安装与卸载" class="headerlink" title="四、Dcoker的安装与卸载"></a>四、Dcoker的安装与卸载</h1><h2 id="1、Ubuntu-18-04-手动安装下安装"><a href="#1、Ubuntu-18-04-手动安装下安装" class="headerlink" title="1、Ubuntu 18.04 手动安装下安装"></a>1、Ubuntu 18.04 手动安装下安装</h2><blockquote>
<p>安装前提：</p>
<p>系统：Ubuntu 18.04 LTS   </p>
<p>系统内核 ：4.15.0-136-generic</p>
</blockquote>
<p>具体的操作系统根据Docker的<a href="https://docs.docker.com/engine/install/ubuntu/">官网</a>来选择不同的安装方法。</p>
<h3 id="1、卸载旧版本"><a href="#1、卸载旧版本" class="headerlink" title="1、卸载旧版本"></a>1、卸载旧版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
<h3 id="2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库"><a href="#2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库" class="headerlink" title="2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库"></a>2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>
<h3 id="3、添加Docker官方的GPG密钥"><a href="#3、添加Docker官方的GPG密钥" class="headerlink" title="3、添加Docker官方的GPG密钥"></a>3、添加Docker官方的GPG密钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>
<h3 id="4、设置稳定存储库"><a href="#4、设置稳定存储库" class="headerlink" title="4、设置稳定存储库"></a>4、设置稳定存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h3 id="5、安装Docker"><a href="#5、安装Docker" class="headerlink" title="5、安装Docker"></a>5、安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<h3 id="6、验证是否安装成功"><a href="#6、验证是否安装成功" class="headerlink" title="6、验证是否安装成功"></a>6、验证是否安装成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<h3 id="7、卸载Docker"><a href="#7、卸载Docker" class="headerlink" title="7、卸载Docker"></a>7、卸载Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>
<h3 id="8、配置阿里云镜像加速"><a href="#8、配置阿里云镜像加速" class="headerlink" title="8、配置阿里云镜像加速"></a>8、配置阿里云镜像加速</h3><p>直接在阿里云首页搜索<strong>容器镜像服务</strong>，登录注册后 –&gt; 进入镜像工具 –&gt; 镜像加速器。具体页面如下：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_17-03-26.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://1xxxxxx5.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="2、官网也提供了一种方便的脚本安装方法："><a href="#2、官网也提供了一种方便的脚本安装方法：" class="headerlink" title="2、官网也提供了一种方便的脚本安装方法："></a>2、官网也提供了一种方便的脚本安装方法：</h2><h3 id="1、只需要两条命令："><a href="#1、只需要两条命令：" class="headerlink" title="1、只需要两条命令："></a>1、只需要两条命令：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line"></span><br><span class="line">sudo sh test-docker.sh</span><br></pre></td></tr></table></figure>
<p>运行第一条命令后可能会出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to get.docker.com:443</span><br></pre></td></tr></table></figure>
<p>原因大概就是无法访问外国的网站，加个提子就行。</p>
<p>接下来运行 执行脚本命令。即可等待自动安装。</p>
<p>使用以下命令可查看 在执行命令过程中运行了那些命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DRY_RUN=1 sh ./get-docker.sh</span><br></pre></td></tr></table></figure>
<h3 id="2、安装完毕后检查docker是否启动"><a href="#2、安装完毕后检查docker是否启动" class="headerlink" title="2、安装完毕后检查docker是否启动"></a>2、安装完毕后检查docker是否启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<h3 id="3、启动docker"><a href="#3、启动docker" class="headerlink" title="3、启动docker"></a>3、启动docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="4、安装完毕后查看是否正确安装：-提示docker的一些信息"><a href="#4、安装完毕后查看是否正确安装：-提示docker的一些信息" class="headerlink" title="4、安装完毕后查看是否正确安装：(提示docker的一些信息)"></a>4、安装完毕后查看是否正确安装：(提示docker的一些信息)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info </span><br></pre></td></tr></table></figure>
<h3 id="5、设置docker开机自动启动"><a href="#5、设置docker开机自动启动" class="headerlink" title="5、设置docker开机自动启动"></a>5、设置docker开机自动启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure>
<h3 id="6、建立docker组-将root用户加入docker组-（此步骤可做可不做）"><a href="#6、建立docker组-将root用户加入docker组-（此步骤可做可不做）" class="headerlink" title="6、建立docker组 将root用户加入docker组 （此步骤可做可不做）"></a>6、建立docker组 将root用户加入docker组 （此步骤可做可不做）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd docker</span><br><span class="line"></span><br><span class="line">usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<h3 id="7、重启docker"><a href="#7、重启docker" class="headerlink" title="7、重启docker"></a>7、重启docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="8、配置镜像加速与上面一致"><a href="#8、配置镜像加速与上面一致" class="headerlink" title="8、配置镜像加速与上面一致"></a>8、配置镜像加速与上面一致</h3><h3 id="9、安装docker-compose-v2"><a href="#9、安装docker-compose-v2" class="headerlink" title="9、安装docker-compose v2"></a>9、安装docker-compose v2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录  针对所有用户</span></span><br><span class="line">mkdir -p /usr/local/lib/docker/cli-plugins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者在家目录下创建  针对当前用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /.docker/cli-plugins</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载二进制版本文件 地址：https://github.com/docker/compose/releases</span></span><br><span class="line">wget https://github.com/docker/compose/releases/download/v2.1.1/docker-compose-linux-x86_64 -O docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为可执行文件</span></span><br><span class="line">chmod +x /usr/local/lib/docker/cli-plugins/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否安装成功</span></span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure>
<h1 id="五、Docker-基本命令"><a href="#五、Docker-基本命令" class="headerlink" title="五、Docker 基本命令"></a>五、Docker 基本命令</h1><p><a href="https://docs.docker.com/reference/">Docker 官网文档命令</a></p>
<h2 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示docker版本</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助信息</span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h2 id="2、镜像基础命令"><a href="#2、镜像基础命令" class="headerlink" title="2、镜像基础命令"></a>2、镜像基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">-a   显示全部的镜像</span><br><span class="line">-q   只显示全部的镜像ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索镜像</span></span><br><span class="line">docker search &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line">--filter=starts==300   根据镜像starts搜索，大于3000的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像，如果不写版本默认拉取最新版</span></span><br><span class="line">docker pull &lt;镜像名&gt;[:tag]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定镜像版本</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的镜像  （可删除多个镜像）</span></span><br><span class="line">docker rmi &lt;镜像ID&gt;   &lt;镜像ID&gt;   &lt;镜像ID&gt; </span><br><span class="line">-f  强制删除</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除全部的镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过Dockerfile 构建镜像   myimage：镜像名  0.0.1：镜像名标签</span></span><br><span class="line">docker build -t myimage:0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="3、容器基础命令"><a href="#3、容器基础命令" class="headerlink" title="3、容器基础命令"></a>3、容器基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建容器并启动</span></span><br><span class="line">docker run [--options] images</span><br><span class="line"></span><br><span class="line">--name=&quot;Name&quot;   给容器起别名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过后台的方式启动的时候，在使用docker ps 发现没有正在运行的容器，是因为docker发现前台没有使用当前容器就会自动杀死当前容器。</span> </span><br><span class="line">-d             后台方式启动 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-it            使用交互方式运行，进入容器查看内容</span><br><span class="line">-p             指定容器的端口    8080:8080</span><br><span class="line">    -p IP:主机端口：容器端口 (常用)</span><br><span class="line">    -p 主机端口：容器端口 (常用)</span><br><span class="line">    -p 容器端口</span><br><span class="line"></span><br><span class="line">-P             随机指定端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前所有正在运行的容器</span></span><br><span class="line">dcoker ps</span><br><span class="line"></span><br><span class="line">-a             列出当前所有正在运行的容器和历史运行的容器</span><br><span class="line">-n=?           列出最近运行的容器</span><br><span class="line">-q             只显示容器的ID</span><br><span class="line"></span><br><span class="line">-v </span><br><span class="line">--rm            容器退出升级删除挂载的数据卷  （在调试时使用）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">直接停止容器并退出容器</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">不停止容器并退出容器</span></span><br><span class="line">ctrl + p + q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定容器</span></span><br><span class="line">dcoker rm 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除所有容器</span></span><br><span class="line">dcoker rm -f  %(dcoker ps -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">docker start 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器</span></span><br><span class="line">docker restart 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制停止容器</span></span><br><span class="line">docker kill 容器ID</span><br></pre></td></tr></table></figure>
<h2 id="4、其他常用命令"><a href="#4、其他常用命令" class="headerlink" title="4、其他常用命令"></a>4、其他常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看docker日志</span></span><br><span class="line">docker logs  -tf --tail 10 容器ID</span><br><span class="line"></span><br><span class="line">-t            显示时间戳</span><br><span class="line">-f            跟踪日志输出</span><br><span class="line">--tail 10     输出指定行数       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器进程信息</span></span><br><span class="line">docker top 容器ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器的元数据</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (以交互式，进入容器开启一个新的终端)</span></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (进入正在运行的命令终端，如果没有进入默认终端)</span></span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从容器内拷贝文件到宿主机上</span></span><br><span class="line">docker cp 容器Id:文件路径  目的主机路径 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看数据卷的信息 xxx:数据卷名</span></span><br><span class="line">docker inspect xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除挂载的数据卷   xxx:数据卷名</span></span><br><span class="line">docker volume rm xxx</span><br></pre></td></tr></table></figure>
<h1 id="六、运行常见服务容器"><a href="#六、运行常见服务容器" class="headerlink" title="六、运行常见服务容器"></a>六、运行常见服务容器</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建MySQL配制间文件以及数据文件挂载目录</span></span></span><br><span class="line">mkdir /opt/mysqldata</span><br><span class="line">mkdir /opt/mysqlconf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取指定版本镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行容器</span></span><br><span class="line">docker run --name mysql-name -p 3307:3306 --restart=always -v /opt/mysql_volume/mysqldata:/var/lib/mysql -v /opt/mysql_volume/mysqllogs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 --character-set-server=utf8mb4</span><br></pre></td></tr></table></figure>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建Redis配制间文件以及数据文件挂载目录</span></span></span><br><span class="line">mkdir /opt/redisdata    存放redis rdb 持久化的数据</span><br><span class="line">mkdir /opt/redisconf   # 存放redis 的配置文件 redis.conf  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取指定版本镜像</span></span><br><span class="line">docker pull redis:5.0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis 配置文件</span> </span><br><span class="line"></span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 6388</span><br><span class="line">appendonly yes</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定配置文件启动</span></span><br><span class="line">docker run -d --name redis-name -p 6388:6388 --restart=always -v /opt/redis_volume/redisdata:/data -v /opt/redis_volume/redisconf:/usr/local/etc/redis -e TZ=Asia/Shanghai redis:5.0.1 redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<h2 id="Elasticsearch-、Kibana"><a href="#Elasticsearch-、Kibana" class="headerlink" title="Elasticsearch 、Kibana"></a>Elasticsearch 、Kibana</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建网桥 ， 可以不用。</span></span><br><span class="line">docker network create somenetwork</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  -e <span class="string">&quot;discovery.type=single-node&quot;</span>   以单节点的形式启动 ， 可以不加</span></span><br><span class="line">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag</span><br></pre></td></tr></table></figure>
<p>使用docker ps 查看，发现elasticsearch没有正在运行， 使用docker logs -f  容器ID 提示一下错误：大致就是没有足够的内存供 Java 运行时环境继续使用。</p>
<p><img src="https://tc.chaizz.com/497261de494511ec9d7c5254006b8f1d.png"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开文件</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在末尾加上  值为262144或者更大。</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存 启用</span></span><br><span class="line">sysctl -p </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂在数据和配置文件  （单节点启动）</span></span><br><span class="line"></span><br><span class="line">docker pull elasticsearch:7.14.2</span><br><span class="line"></span><br><span class="line">docker run -d --restart=always --name elasticsearch -p 9200:9200 -p 9300:9300  -v esdata:/usr/share/elasticsearch/data -v esconfig:/usr/share/elasticsearch/config -v esplugins:/usr/share/elasticsearch/plugins -e &quot;discovery.type=single-node&quot; elasticsearch:7.14.2</span><br></pre></td></tr></table></figure>
<p>下载 Kibana </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.14.2</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name kibana -p 5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://101.35.188.40:9200&quot; -e &quot;I18N_LOCALE=zh-CN&quot; kibana:7.14.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将kibana的配置文件挂载出来，在配置文件中连接elasticsearch</span></span><br><span class="line">docker run -d --restart=always --name kibana -p 5601:5601 -v kibanaconf:/usr/share/kibana/config -e &quot;I18N_LOCALE=zh-CN&quot; kibana:7.14.2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora设置七牛云图床</title>
    <url>/2021/09/26/Typora%E8%AE%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>Markdown是一种<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/52671915">轻量级标记语言</a>，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的<a href="https://baike.baidu.com/item/%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/9862288">纯文本格式</a>编写文档，然后转换成有效的<a href="https://baike.baidu.com/item/XHTML/316621">XHTML</a>（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
<p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如<a href="https://baike.baidu.com/item/GitHub/10145341">GitHub</a>、<a href="https://baike.baidu.com/item/Reddit/1272010">Reddit</a>、<a href="https://baike.baidu.com/item/Diaspora/10726893">Diaspora</a>、[Stack Exchange](<a href="https://baike.baidu.com/item/Stack">https://baike.baidu.com/item/Stack</a> Exchange/13777796)、<a href="https://baike.baidu.com/item/OpenStreetMap/3171606">OpenStreetMap</a> 、<a href="https://baike.baidu.com/item/SourceForge/6562141">SourceForge</a>、<a href="https://baike.baidu.com/item/%E7%AE%80%E4%B9%A6/5782216">简书</a>等，甚至还能被使用来撰写<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E4%B9%A6/346054">电子书</a>。</p>
</blockquote>
<a id="more"></a>


<h1 id="一、设置前提："><a href="#一、设置前提：" class="headerlink" title="一、设置前提："></a>一、设置前提：</h1><p>Typora 版本：0.11.8|<br>已注册七牛云账号：</p>
<ul>
<li>秘钥AK ：virqOxxxxxxxxxxxxxxxxxxxxxxxxMnNIK</li>
<li>秘钥SK：dDFGSasdfxxxxxxxxxxxxxxxxxxxiZiOVu</li>
<li>存储空间名称：cz-tuchuang</li>
<li>自定义域名：<a href="https://tc.chaizz.com/">https://tc.chaizz.com</a></li>
<li>存储区域代码：我的是华北  所以就是 ：z1<br><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-26_19-22-09.png"></li>
</ul>
<h1 id="二、开始设置"><a href="#二、开始设置" class="headerlink" title="二、开始设置"></a>二、开始设置</h1><p>打开Typora  偏好设置–&gt; 图像 –&gt;插入图片时… –&gt; 上传服务 –&gt; 选择 上传图片。</p>
<p>打开Typora  偏好设置–&gt; 图像 –&gt;上传服务设定 –&gt; 上传服务 –&gt; 选择 PicGo-Core (command line)。</p>
<p>点击<strong>下载或更新</strong>按钮，会提示下载一个PicGo插件，等待下载完成点击<strong>打开配置文件</strong>，打开以后默认是空的。复制下面代码覆盖打开的文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;qiniu&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;qiniu&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;accessKey&quot;</span>: <span class="string">&quot;virqOxxxxxxxxxxxxxxxxxIK&quot;</span>,  <span class="comment">// 你的七牛云AK</span></span><br><span class="line">			<span class="attr">&quot;secretKey&quot;</span>: <span class="string">&quot;dDFGSxxxxxxxxxxxxxxxxxVu&quot;</span>,  <span class="comment">// 你的七牛云SK</span></span><br><span class="line">			<span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;cz-tuchuang&quot;</span>,                  <span class="comment">// 你的七牛云存储空间名</span></span><br><span class="line">			<span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://tc.chaizz.com&quot;</span>,           <span class="comment">// 你的七牛云自定义域名</span></span><br><span class="line">			<span class="attr">&quot;area&quot;</span>: <span class="string">&quot;z1&quot;</span>,                             <span class="comment">// 存储区域编号</span></span><br><span class="line">			<span class="attr">&quot;options&quot;</span>: <span class="string">&quot;&quot;</span>,                            <span class="comment">// 网址后缀,可不填</span></span><br><span class="line">			<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;tc/&quot;</span>,                            <span class="comment">// 自定义存储路径，比如 img/ 可不填</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	<span class="attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来点击 <strong>验证图片上传选项</strong> 按钮。上传成功会提示图下图所示：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-26_19-35-24.png"></p>
<p>点击OK ，重启Typora上传图片即可上传到七牛云了。</p>
]]></content>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识巩固</title>
    <url>/2021/09/26/Redis%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
</blockquote>
<h1 id="一、Redis-安装"><a href="#一、Redis-安装" class="headerlink" title="一、Redis 安装"></a>一、Redis 安装</h1><p>安装前提：Linux 系统 ubuntu 18.04  / Redis 版本：<a href="https://download.redis.io/releases/redis-6.2.5.tar.gz">6.2.5</a><br>1、检查系统是否安装了gcc 编译器。如果已经安装了 则会显示gcc 的版本号信息，如果没有安装，则使用系统的包管理器安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 gcc</span></span><br><span class="line">sudo apt-get install gcc </span><br></pre></td></tr></table></figure>

<p>2、在Redis官网下载Redis压缩包并解压。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.5.tar.gz</span><br><span class="line">tar -zxvf redis-6.2.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、进入解压后的Redis目录，编译安装Redis。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.5</span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>

<p>4、Redis 默认安装在Linux的usr/local/bin 目录下。</p>
<p>5、启动Redis 。（这种方式是在前台运行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line">    # 后台运行 ，首先更改Redis的配置文件（redis.conf），找到daemonize no 将 no 改为yes 。然后再启动Redis 即可在后台运行。</span><br></pre></td></tr></table></figure>


<h1 id="二、Redis-基础命令"><a href="#二、Redis-基础命令" class="headerlink" title="二、Redis 基础命令"></a>二、Redis 基础命令</h1><p>Redis<a href="http://redis.cn/commands.html">的命令文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择Redis数据库 一共0到15 16个数据库，默认使用0数据库。</span></span><br><span class="line">select 0-15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前库所有的key</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断key是否存在</span></span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的类型</span></span><br><span class="line">type key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除key</span></span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据value选择非阻塞删除（异步删除）</span></span><br><span class="line">unlink key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为给定的key 设置超时时间 （以秒为单位）</span></span><br><span class="line">expire key 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的过期时间 （获取的值为-1:代表永不过期，-2：已经过期）</span></span><br><span class="line">ttl key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看库中的key的数量</span></span><br><span class="line">dbsise</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空当前库</span></span><br><span class="line">flushdb </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通杀全部库</span></span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>

<h1 id="三、Redis-五大常用数据类型"><a href="#三、Redis-五大常用数据类型" class="headerlink" title="三、Redis 五大常用数据类型"></a>三、Redis 五大常用数据类型</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h2><p>String是Redis常用的基本类型，对应的格式是一个key对应一个value，String是二进制安全的，意味着string可以存储任意的类型，包括图片或者序列化的对象。一个Redis中String类型value的值最多可以是512M。</p>
<h3 id="1-1-String-的基本命令"><a href="#1-1-String-的基本命令" class="headerlink" title="1.1 String 的基本命令"></a>1.1 String 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置key value</span></span><br><span class="line">set &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的值</span></span><br><span class="line">get &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的长度</span></span><br><span class="line">strlen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key value   只有key不存在时 设置key的值</span></span><br><span class="line">setnx &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增1</span></span><br><span class="line">incr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增自定义的大小（值为负数则相反）</span></span><br><span class="line">incrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减1</span></span><br><span class="line">decr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减自定义大小 （值为负数则相反）</span></span><br><span class="line">decrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value</span></span><br><span class="line">mset &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value  (当且仅当所有的key都不存在，才能设置成功)</span></span><br><span class="line">msetnx &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取值的范围  （起始位置，结束位置 都包括在内）</span></span><br><span class="line">getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用新的value覆盖key存储的value,索引从0开始</span></span><br><span class="line">setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key的过期时间 ,单位是秒</span></span><br><span class="line">setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以新换旧，设置了新的值，同时获得旧值</span></span><br><span class="line">getset &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-String-的数据结构"><a href="#1-2-String-的数据结构" class="headerlink" title="1.2 String 的数据结构"></a>1.2 String 的数据结构</h3><p>String 的数据结构为简单的动态的字符串（Simple Dynamic String 缩写SDS），是可以修改的字符串，采用预分配冗余空间的方式，来减少内存的频繁分配。<br><img src="https://tc.chaizz.com/44e5fba2450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h2><p>List 是简单的字符串列表，按照插入的顺序排序，可以添加一个元素到字符串的头部或者尾部。他的底层实际上十个双向链表，对两端的操作性能很高，通过索引下标操作中间的节点性能比较差。</p>
<h3 id="2-1-List的基本命令"><a href="#2-1-List的基本命令" class="headerlink" title="2.1 List的基本命令"></a>2.1 List的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从左边插入一个或者多个值， 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">lpush &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右边插入一个或者多个值 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">rpush  &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值  值在键在 ，值光键亡</span></span><br><span class="line">lpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值 值在键在 ，值光键亡</span></span><br><span class="line">rpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key1列表右边取一个值，放到key2左边</span></span><br><span class="line">rpoplpush &lt;key1&gt; &lt;key2&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照索引下标获取元素 （从左到右）  0 -1 ：代表获取所有的值</span></span><br><span class="line">lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据索引下标获取元素，</span>    </span><br><span class="line">lindex &lt;key&gt; &lt;index&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表长度</span></span><br><span class="line">llen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在value的前/后面插入新的value</span></span><br><span class="line">linsert &lt;key&gt; before/after &lt;value&gt; &lt;new value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边删除第n个value   (从左到右)</span></span><br><span class="line">lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将列表key 下标为index的值替换为value</span></span><br><span class="line">lset &lt;key&gt;  &lt;index&gt;  &lt;value&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-List-的数据结构"><a href="#2-2-List-的数据结构" class="headerlink" title="2.2 List 的数据结构"></a>2.2 List 的数据结构</h3><p>List 的数据结构为quicklist。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。他将所有的元素紧挨着一块存储，分配的是一块连续的内存。<br>当数据量比较多的时候，才会改为quicklist，因为普通的链表需要的附加的指针空间更大，会比较浪费空间。<br>比如列表里面存储的只是Int的类型的数据，结构上还需要两个额外的指针：prev和next。<br><img src="https://tc.chaizz.com/4e0057b4450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist 使用双向指针串起来，这样既满足了插入删除性能，又不会出现太大的空间冗余。如上图所示。</p>
<h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h2><h3 id="3-1-Set的基本命令"><a href="#3-1-Set的基本命令" class="headerlink" title="3.1  Set的基本命令"></a>3.1  Set的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素添加到集合key中，已经存在的member元素将会被忽略</span></span><br><span class="line">sadd &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出该集合的所有值</span></span><br><span class="line">smembers &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断集合key是否有该value值，存在为1 不存在为0</span></span><br><span class="line">sismember &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该集合的元素个数</span></span><br><span class="line">scard &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合的某些个元素</span></span><br><span class="line">srem &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  随机丛集中吐出一个值，会从该集合中删除</span></span><br><span class="line">spop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 随机从该集合中取出n个值, 不会从该集合中删除</span></span><br><span class="line">srandmember &lt;key&gt; &lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把集合中一个值移动到另一个集合中</span></span><br><span class="line">smove &lt;key1&gt; &lt;key2&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的交集元素</span></span><br><span class="line">sinter &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的并集元素</span></span><br><span class="line">sunion &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  返回两个集合的差集元素（key1 中的 不包括Key2中的）</span></span><br><span class="line">sdiff &lt;key1&gt; &lt;key2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Set-的数据结构"><a href="#3-2-Set-的数据结构" class="headerlink" title="3.2 Set 的数据结构"></a>3.2 Set 的数据结构</h3><p>Set 的数据结构是dict字典，字典是使用哈希表实现的。所有的value 都指向同一个内部的值。</p>
<h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4 Hash"></a>4 Hash</h2><h3 id="4-1-Hash的基本命令"><a href="#4-1-Hash的基本命令" class="headerlink" title="4.1 Hash的基本命令"></a>4.1 Hash的基本命令</h3><p>Redis 的Hash是一个键值对集合，是一个String类型的field和value 的映射表，Hash特别适合存储对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给key集合中的field 键赋值value</span></span><br><span class="line">hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key集合field中取出value</span></span><br><span class="line">hget &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置<span class="built_in">hash</span>的值</span></span><br><span class="line">hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; &lt;field3&gt; &lt;value3&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看<span class="built_in">hash</span>表key中,给定域field 是否存在 ，存在返回1 不存在返回0</span></span><br><span class="line">hxists &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的field</span></span><br><span class="line">hkeys &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的value</span></span><br><span class="line">hvals &lt;keys&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值加上增量1 -1</span> </span><br><span class="line">hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值设置为value 当且仅当该域不存在</span></span><br><span class="line">hsetnx  &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-Hsh-的数据结构"><a href="#4-2-Hsh-的数据结构" class="headerlink" title="4.2 Hsh 的数据结构"></a>4.2 Hsh 的数据结构</h3><p>Hash 类型对应的数据机构有两种：ziplist （压缩列表） 和 hashlist（哈希列表） ，当field-value 的长度较短且个数较少的时候，使用ziplist，否则使用hashlist。</p>
<h2 id="5-ZSet"><a href="#5-ZSet" class="headerlink" title="5 ZSet"></a>5 ZSet</h2><p>Redis的有序集合和Set 类似，是一个没有重复元素的字符串集合，不同之处是有序集合的每个成员都关联了一个<strong>评分</strong>，这个<strong>评分</strong>被用来按照从最低到最高的方式排序集合中的成员，<strong>集合的成员是唯一的，但是评分可以重复。</strong></p>
<p>因为元素是有序的，所以可以很快的根据评分或者次序来获得一个范围的元素。</p>
<p>访问集合中的元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="5-1-ZSet-的基命令"><a href="#5-1-ZSet-的基命令" class="headerlink" title="5.1 ZSet 的基命令"></a>5.1 ZSet 的基命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素及其其score值加入到有序集key当中</span></span><br><span class="line">zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，下标在 &lt;start&gt; &lt;stop&gt; 之间的元素, 带 withscores可以让分数一起和值返回到结果集</span></span><br><span class="line">zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，所有的score值介于min 和max 之间 （包括min 或者 max）的成员，有序集成员按照score值递增(从小到大依次排列)</span></span><br><span class="line">zrangebyscore &lt;key &gt; &lt;min&gt; &lt;max&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，改为由大到小排列</span></span><br><span class="line">zrangebyscore &lt;key&gt; &lt;max&gt; &lt;min&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为元素的score加上增量</span></span><br><span class="line">zinceby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除该集合下 指定值的元素</span></span><br><span class="line">zrem &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计该集合，分数区间的元素个数</span></span><br><span class="line">zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该值在集合中的排名， 从0开始</span></span><br><span class="line">zrank &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Zset-的数据结构"><a href="#5-2-Zset-的数据结构" class="headerlink" title="5.2 Zset 的数据结构"></a>5.2 Zset 的数据结构</h3><p>SortedSet 是Redis的一个特别的数据结构，他的底层使用了两个数据结构。</p>
<ol>
<li>hash，hash 的作用就是关联元素value和权重score，保障元素value的唯一性们可以通过元素value找到相应的score。</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素的列表。</li>
</ol>
<h2 id="6-Bitmaps"><a href="#6-Bitmaps" class="headerlink" title="6  Bitmaps"></a>6  Bitmaps</h2><p>BItmaps 本身并不是一种数据类型，实际上他就是字符串，key-value ,但是他可以对字符串进行位操作。<br>Bitmaps 单独提供了一套目命令，所以在Redis 中使用Bitmaps和使用字符串方法不一样，可以吧Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1数组的下标在Bitmaps中叫偏移量。</p>
<h3 id="6-1-Bitmaps-的基本命令"><a href="#6-1-Bitmaps-的基本命令" class="headerlink" title="6.1  Bitmaps 的基本命令"></a>6.1  Bitmaps 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  设置Bitmaps 中某个偏移量的值 0 或 1， offset的偏移量从0开始</span></span><br><span class="line">setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取Bitmaps中某个偏移量的值</span></span><br><span class="line">getbit &lt;key&gt; &lt;offset&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计字符串被设置为1的Bit数,一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start end 参数，可以让计数只在特定的位上进行，start和end都可以使用负值，比如-1表示最后一位,-2表示倒数第二个，start 和end是指bit组的字节下标数，二者皆包含。</span></span><br><span class="line">bitcount &lt;key&gt; &lt;start&gt; &lt;end&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> bitop  是一个复合操作，他可以做多个bitmaps的and （交集）、or（并集）、not (非)、xor（异或）操作，并将结果保存在destkey中。</span></span><br><span class="line">bitop  and/or/not/xor &lt;destkey&gt; &lt;key&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7  HyperLogLog"></a>7  HyperLogLog</h2><h3 id="7-1-HyperLogLog-的基本命令"><a href="#7-1-HyperLogLog-的基本命令" class="headerlink" title="7.1 HyperLogLog 的基本命令"></a>7.1 HyperLogLog 的基本命令</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常大的时候计算基数所需要空间总是固定的，并且是很小的。<br>在Redis里面每个HyperLogLog 键只需要花费12KB内存，就可以计算接近2^64个不同的基数，这和计算基数时元素越多消耗内存就越多的集合形成鲜明对比。<br>但是HyperLogLog 只会根据输入元素计算基数，而不会存储输入数据本身，所以HyperLogLog并不能像集合那样返回输入的各个元素。<br>什么是基数？<br>比如数据集：{1、3、5、7、5、7、9} 那么这个数据集的基数就是：{1、3、5、7、9} 基数（不重复元素）为5。基数估计 就是在误差可以收的范围内快速计算基数。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定元素到 HyperLogLog  中</span></span><br><span class="line">pfadd &lt;key&gt; &lt;element&gt; &lt;element&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的近似基数  可以计算多个key，</span></span><br><span class="line">pfcount &lt;key&gt;  [key key ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个key合并后的结果存储在另一个key中。</span></span><br><span class="line">pfmerge &lt;key&gt;  &lt;key1&gt;  &lt;key2&gt;</span><br></pre></td></tr></table></figure>



<h2 id="8-Geospatial"><a href="#8-Geospatial" class="headerlink" title="8 Geospatial"></a>8 Geospatial</h2><p>Redis 3.2 中增加对GEO类型的支持，GEO是Geographic地理信息的缩写。该类型就是元素的二维坐标，在地图上就是经纬度，Redis基于该类型提供了经纬度设置，范围查询。距离查询。经纬度Hash等操作。</p>
<h3 id="8-1-Geospatial的基本命令"><a href="#8-1-Geospatial的基本命令" class="headerlink" title="8.1 Geospatial的基本命令"></a>8.1 Geospatial的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加地理位置 经度 纬度 名称, 两级无法添加，一般会下载城市经纬度数据，直接导入。有效的经度从-180 到180 纬度 -85.05112878 到 85.05112878 ,超出范围会返回错误。</span></span><br><span class="line">geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;  &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取指定地区的坐标值</span></span><br><span class="line">geopos &lt;key&gt; &lt;member&gt; [member]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取两个位置的直线距离，单位有 m km ft(英尺) mi (英里) ，不指定为单位 默认是 m (米)</span></span><br><span class="line">geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; m/km/ft/mi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以给定的经纬度为中心，找出某一半径内的元素</span></span><br><span class="line">georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius m/km/ft/mi</span><br></pre></td></tr></table></figure>

<h1 id="四、Redis-的事务操作"><a href="#四、Redis-的事务操作" class="headerlink" title="四、Redis 的事务操作"></a>四、Redis 的事务操作</h1><p>Redis 的事务 是一个单独的隔离的操作，事务中所有的命令都会序列化、按顺序的执行，事务在执行过程中，不会被其他的客户端发送过来的命令请求打断。<br>Redis的事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p>
<p>从输入Multi 开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过Discard来放弃组队。</p>
<p><img src="https://tc.chaizz.com/5c2866ec450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="1-Redis-事务的错误处理"><a href="#1-Redis-事务的错误处理" class="headerlink" title="1  Redis 事务的错误处理"></a>1  Redis 事务的错误处理</h2><h3 id="1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"><a href="#1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。" class="headerlink" title="1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"></a>1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。</h3><p><strong><img src="https://tc.chaizz.com/62e8c936450e11ec9d7c5254006b8f1d.png"></strong></p>
<h3 id="1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"><a href="#1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。" class="headerlink" title="1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"></a>1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。</h3><p><img src="https://tc.chaizz.com/6a3b5302450e11ec9d7c5254006b8f1d.png"> </p>
<h3 id="1-3-Redis的事务冲突，以及解决办法。"><a href="#1-3-Redis的事务冲突，以及解决办法。" class="headerlink" title="1.3 Redis的事务冲突，以及解决办法。"></a>1.3 Redis的事务冲突，以及解决办法。</h3><h4 id="1-3-1-悲观锁"><a href="#1-3-1-悲观锁" class="headerlink" title="1.3.1 悲观锁"></a>1.3.1 悲观锁</h4><p>每次去获取数据都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人就只能等到锁释放才能能拿到数据。传统的关系型数据库很多地方都用到了悲观锁：比如行锁、表锁、读锁、写锁等。</p>
<p><img src="https://tc.chaizz.com/751786ec450e11ec9d7c5254006b8f1d.png"></p>
<h4 id="1-3-2-乐观锁"><a href="#1-3-2-乐观锁" class="headerlink" title="1.3.2 乐观锁"></a>1.3.2 乐观锁</h4><p>每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有更新这数据，可以使用版本号等机制。乐观锁适用于多读的场景，这样可以以高吞吐量，Redis 就是利用这用check-and-set的机制实现事务的。实际应用场景：例如买票，很多人都可以抢到，但是付款只有一个人可以付款成功。</p>
<p><img src="https://tc.chaizz.com/7bd4e6be450e11ec9d7c5254006b8f1d.png"></p>
<p>在Redis 中使用乐观锁<br>在执行Multi 之前先执行 watch key 可以监听一个或者多个key，如果事务执行之前这个key被其他的命令所修改，那么事务将会被打断。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给Redis加乐观锁</span></span><br><span class="line">watch key </span><br></pre></td></tr></table></figure>
<h3 id="1-4-Redis-事务的三特性"><a href="#1-4-Redis-事务的三特性" class="headerlink" title="1.4 Redis 事务的三特性"></a>1.4 Redis 事务的三特性</h3><h4 id="1-4-1单独的隔离操作"><a href="#1-4-1单独的隔离操作" class="headerlink" title="1.4.1单独的隔离操作"></a>1.4.1单独的隔离操作</h4><p>事务中所有的命令都会序列化，按照顺序执行，事务在执行过程中没不会被其他的可短短发送来的命令请求打断。</p>
<h4 id="1-4-2-没有隔离级别的概念"><a href="#1-4-2-没有隔离级别的概念" class="headerlink" title="1.4.2 没有隔离级别的概念"></a>1.4.2 没有隔离级别的概念</h4><p>队列中的命令没有提交之前都不会被实际的执行，因为事务提交之前（exec）任何指令都不会被执行。</p>
<h4 id="1-4-3-不保证原子性"><a href="#1-4-3-不保证原子性" class="headerlink" title="1.4.3 不保证原子性"></a>1.4.3 不保证原子性</h4><p>事务中如果有一天命令执行失败，其他的命令仍然会被执行，不会回滚。</p>
<h1 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h1><h2 id="1-RDB-（Redis-Database）-方式"><a href="#1-RDB-（Redis-Database）-方式" class="headerlink" title="1  RDB （Redis Database） 方式"></a>1  RDB （Redis Database） 方式</h2><p>在指定<strong>时间间隔内</strong>将内存中的<strong>数据集快照</strong>写入磁盘，也就是快照，它恢复是将快照文件直接读到内存里面。（在Redis 的配置文件内设置时间间隔）<strong>RDB 默认开启。</strong></p>
<p>备份是如何执行的：<br>Redis 会单独的创建一个fork子进程来持久化，会先将数据写入一个临时文件中，等持久化过程都结束了，在用这个临时文件替换上次持久化的文件，整个过程主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据的恢复，且对于数据的完整性要求不那么敏感，那么RDB的方式要比AOF的方式更加的额高效，RDB的缺点就是<strong>最后一次持久化的数据可能会丢失。</strong></p>
<p>fork的作用就是复制一个与当前进程一样的进程，新的进程的所有的数据（变量，程序计数器等）都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件解释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查数据完整性、默认值 yes 在存储跨照后让Redis 使用CRC64算法来对数据进行校验。但是这样做会损失大约10%的性能。推荐开启。</span></span><br><span class="line">rdbchecksum  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis 无法写入磁盘的时候，直接关掉Redis的写操作，推荐yes</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 压缩文件</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将数据写入磁盘的时间间隔， 默认 六十分钟1次、五分钟一百次、一分钟一万次</span></span><br><span class="line">save 300 100</span><br></pre></td></tr></table></figure>



<p>RDB的优势：</p>
<ul>
<li>适合大规模数据的恢复。</li>
<li>对数据完整性和一致性要求不高时使用。</li>
<li>节省磁盘空间。</li>
<li>回恢复度快。</li>
</ul>
<p>RDB的劣势：</p>
<ul>
<li>在写入临时快照的时候，数据被克隆了一份，大致两倍的膨胀性需要考虑。</li>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据量庞大还是比较消耗性能。</li>
<li>在备份周期在一定时间间隔内做一次备份，所以如果Redis以外关掉，就会丢失最后一次快照的修改。</li>
</ul>
<p>RDB的备份恢复：<br>默认Redis启动会自动将Redis的快照文件（dump.rdb）读取到内存中。手动恢复的话只需要将快照文件复制到Redis启动目录下。</p>
<h2 id="2-AOF（Append-Only-File）方式"><a href="#2-AOF（Append-Only-File）方式" class="headerlink" title="2  AOF（Append Only File）方式"></a>2  AOF（Append Only File）方式</h2><p>以日志的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的所有<strong>写/修改/删除指令记录下来（读操作不记录）</strong>，只许追加文件但是不可以改文件，Redis启动之初，会自动读取范围见重新构建数据，换言之Redis重启的话就会根据日志文件的内容将写指令重头到尾在执行一遍，以完成数据的恢复工作。<strong>AOF默认不开启。</strong></p>
<p>开启AOF：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认为no 不开启， 将其改为yes 开启。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果RDB和AOF同时开启，Redis 默认会读取AOF的配置文件来恢复数据。</strong> </p>
<p>AOF 异常修复：<br>如果遇到AOF文件损坏，通过 redis-check-aof   –fix  appendonly.aof 进行恢复。</p>
<p>AOF的同步频率设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置AOF的同步频率 。</span></span><br><span class="line">	always：始终同步。</span><br><span class="line">	everysec ：每秒同步，每秒记入日志一次，如果宕机当前秒的数据可能会丢失。</span><br><span class="line">	no：redis 不主动同步，把同步的时机交给操作系统。</span><br><span class="line">appendfsync always   </span><br></pre></td></tr></table></figure>

<p>Rewrite 压缩<br>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过设置的阈值时，Redis回启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p>重写的原理：<br>AOF文件持续增长而过大时， 会fork 出一条新的进程将文件重写（也是先写临时文件最后在rename）Redis4.0后的版本重写，实际上就是把RDB的快照，以二进制的形式附在新的aof的头部，作为已有的历史数据，替换掉原来的流水操作。</p>
<p>AOF持久化的流程：</p>
<ul>
<li>客户端的请求命令会被append追加到AOF的缓冲区内。</li>
<li>AOF缓冲区根据AOF持久化策略（always/everysec/no）将操作sync同步到磁盘中的.aof文件中去。</li>
<li>AOF文件大小超过重写策略或者手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。</li>
</ul>
<h1 id="六、Redis主从复制"><a href="#六、Redis主从复制" class="headerlink" title="六、Redis主从复制"></a>六、Redis主从复制</h1><p><img src="https://tc.chaizz.com/84964932450e11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Redis 主从复制配置文件设置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 丛机配置文件主要用户读操作，所以 aof 以及edb配置相关关掉即可。</span></span><br><span class="line"></span><br><span class="line">requirepass  &quot;admin.123&quot;  　　#设置redis登录密码</span><br><span class="line"></span><br><span class="line">masterauth  &quot;admin.123&quot; 　　#主从认证密码，否则主从不能同步</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在某个从机中配置为从机：这种设置从服务器是暂时的，重启之后就又会变成主服务器。</span></span><br><span class="line">slaveof ip port</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在主服务器中使用命令查看主从信息：</span></span><br><span class="line">info relication</span><br></pre></td></tr></table></figure>

<p><img src="https://tc.chaizz.com/9167c1cc450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="1-主从复制的原理："><a href="#1-主从复制的原理：" class="headerlink" title="1 主从复制的原理："></a>1 主从复制的原理：</h2><ul>
<li>当从服务器连接上主服务器上以后，从服务器向主服务器发送数据同步消息即一个sync命令。</li>
<li>主服务器接到从服务器送过来的同步消息，把主服务器的数据进行持久化，把RDB文件发送到从服务器，从服务器拿到RDB进行读取。（从服务器主动请求同步）</li>
<li>全量复制：从服务器在接受数据库数据后将其存盘并加载到内存中。</li>
<li>增量复制：主服务器将新的所有收集到的修改的命令依次传输给从服务器完成同步。</li>
</ul>
<h2 id="2-主从复制之薪火相传"><a href="#2-主从复制之薪火相传" class="headerlink" title="2 主从复制之薪火相传"></a>2 主从复制之薪火相传</h2><p>Redis 主从模式为 一个主，其他的为从。其中第三个从为第二个从的主，类似于排队的节点，每一节点都是前面的从。也可以多个从节点。 </p>
<p><img src="https://tc.chaizz.com/9c1ab480450e11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置方法：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在从服务器中配置他的从服务器</span></span><br><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure>
<h2 id="3-Redis主从之反客为主"><a href="#3-Redis主从之反客为主" class="headerlink" title="3  Redis主从之反客为主"></a>3  Redis主从之反客为主</h2><p>反客为主在薪火相传的基础上给某个从服务器加上能够变为主服务器的命令。使其能够在主服务器挂掉的时候充当主服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若果想让从服务器在主服务器挂掉之后自动变为主服务器设置方法： 需要手动操作，全自动实现 需要使用哨兵模式</span></span><br><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>


<h2 id="4-Redis主从之哨兵模式"><a href="#4-Redis主从之哨兵模式" class="headerlink" title="4 Redis主从之哨兵模式"></a>4 Redis主从之哨兵模式</h2><p>配置哨兵模式：<br><strong>定义配置文件 senttinel.conf   （文件名不能错） 文件内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mymaster 是为监控对象起的名称， 1 代表至少有多少个哨兵同意迁徙的数量。</span></span><br><span class="line">sentinel monitor mymaster IP PORT 1</span><br></pre></td></tr></table></figure>
<p>哨兵故障恢复：<br>从下线的主服务器的从服务器中挑选一个将其转成主服务器。选择的条件依次为：1. 优先级最靠前的。2. 选择偏移量最大的，3. 选择runid 最小的。</p>
<p>挑选出新的主服务器后sentinel 向原先的主服务器的从服务器发送slaveof 命令，复制新的master，当已经下线的主服务器上线时，sentinel 向其发送slaveof 命令让其成为新主的从。</p>
<p>优先级在Redis.conf 中默认：replica-priority 100 值越小 优先级越高。<br>偏移量是指获取原主机数据最全的。<br>每个Redis示例启动后都会随机生成一个40位runid。</p>
<h1 id="七、Redis-集群"><a href="#七、Redis-集群" class="headerlink" title="七、Redis 集群"></a>七、Redis 集群</h1><p>Redis 的主从模式，薪火相传。主机宕机，会导致IP的地址变化，应用程序中配置需要修改对应主机啊的地址没端口等信息。之前通过代理主机来解决，Redis 3.0 提供了解决方案，就是无中心化集群方案。</p>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个Redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区，来提供一定程度的可用性，：即使集群中有部分节点失效或者无法进行通讯，集群也能够继续处理命令请求。</p>
<h2 id="1-Redis-集群配置"><a href="#1-Redis-集群配置" class="headerlink" title="1 Redis 集群配置"></a>1 Redis 集群配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 包含redis主配置文件</span></span><br><span class="line">include /myredis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置pid文件位置 (注意区别每个节点文件名要不一致)</span></span><br><span class="line">pidfile /var/run/redis-6379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置持久化文件名  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群配置</span></span><br><span class="line">cluster-enabled  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置当前节点的配置文件的名字  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置失联时间</span>   </span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保集群配置文件没有出错，查看Redis 服务是否正常启动，以及Redis对应的几点文件是否生成。</span></span><br></pre></td></tr></table></figure>
<p><strong><img src="https://tc.chaizz.com/a51f728c450e11ec9d7c5254006b8f1d.png"></strong></p>
<p>以上配置生成了Redis的集群节点，但是还没有将每个节点相结合。以下操作将各个节点结合配置为集群。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果是低版本Redis需要安装ruby环境，此版本不需要安装。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先进入到解压后Redis目录中</span></span><br><span class="line">cd /opt/redis-6.2.5/src</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行合并集群命令。</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处使用本机地址 生产环境使用本机IP地址</span></span><br><span class="line">1： 表示一个主节点对应一个从节点 </span><br><span class="line"></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6389 127.0.0.1:6390 127.0.0.1:6391</span><br></pre></td></tr></table></figure>
<p>设置成功如下图所示：<br><img src="https://tc.chaizz.com/abdb9a88450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="2-Redis-集群连接"><a href="#2-Redis-集群连接" class="headerlink" title="2 Redis 集群连接"></a>2 Redis 集群连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 集群连接</span> </span><br><span class="line">redis-cli -c -p 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群节点信息</span></span><br><span class="line">cluster nodes </span><br></pre></td></tr></table></figure>

<p><img src="https://tc.chaizz.com/b7277e5c450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 如何分配至少三个主节点？</p>
<p>首先分配原则尽量保证，每个主数据库运行在不同的IP地址中，每个从库和主库不在同一个IP地址中。</p>
<p>什么是slots？</p>
<p>当Redis集群设置成功后会提示 ： <code>All 16384 slots covered</code>，代表一个集群包含16384个插槽，数据库的每个键都会存储到这些个插槽中去，集群使用公式 CRC16(key)%16384 来计算key属于那个插槽，其中CRC16(key) 用于计算key的CRC16校验和。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算集群的中的key的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的插槽值</span></span><br><span class="line">cluster keyslot &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算插槽值里面有多少个key ,只能查看自己插槽中的key值</span></span><br><span class="line">cluster countkeysinslot &lt;slot&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回count个slot中的键 ,返回插槽中的键的数量。</span></span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt; </span><br></pre></td></tr></table></figure>

<h2 id="3-故障恢复"><a href="#3-故障恢复" class="headerlink" title="3 故障恢复"></a>3 故障恢复</h2><p>Redis 集群中的某个主服务宕机，他的从服务器会直接成为主服务器，来保持运行。（通过配置文件的失联时间来判断是和否能够正常使用：cluster-node-timeout 15000）<br>如果Redis的集群中的某个节点的主从全部挂掉，他的情况 需要根据配置文件来说明：</p>
<ul>
<li>如果配置文件中的<code>cluster-require-full-coverage</code> 的值为 <code>yes</code> ， 则整个集群都挂掉。</li>
<li>如果值为 <code>no</code> 则该插槽服务挂掉，无法写入读取数据，但是不会影响其他的集群节点。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>部署YoloV5</title>
    <url>/2021/07/10/%E9%83%A8%E7%BD%B2YoloV5/</url>
    <content><![CDATA[<p>​                                    </p>
<a id="more"></a>

<p>一、安装Ubuntu 20.04 系统。</p>
<p>二、更换Ubuntu 源为国内源。（尽量不要用阿里源）</p>
<p>三、升级包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update    </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>四、下载Nvidia 驱动。<a href="https://www.nvidia.cn/content/DriverDownload-March2009/confirmation.php?url=/XFree86/Linux-x86_64/460.84/NVIDIA-Linux-x86_64-460.84.run&lang=cn&type=TITAN">下载地址</a>。根据自己的显卡查找驱动。</p>
<ul>
<li><p>禁用nouveau驱动</p>
<ul>
<li><p>编辑 /etc/modprobe.d/blacklist-nouveau.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>提示gcc 问题：</p>
</li>
</ul>
</li>
<li><p>直接安装  <code>sudo apt-get install gcc g++</code></p>
</li>
</ul>
<p>提示make问题：</p>
<ul>
<li>直接安装 <code>sudo apt-get install  make</code></li>
</ul>
<p>五、安装CUDA。（需要根据pytorch 的版本选择CUDA版本。这里选择的是CUDA 11.1）  下载地址：<a href="https://developer.nvidia.com/cuda-11.1.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=2004&target_type=runfilelocal">CUDA地址</a>。</p>
<p>官网安装步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run</span><br><span class="line">sudo sh cuda_11.1.0_455.23.05_linux.run</span><br></pre></td></tr></table></figure>
<p>接下来按照提示输入。</p>
<p>选择安装界面：因为上面已经安装过驱动，所以取消选择第一个 driver ，然后选中 按下回车。</p>
<p>配置CUDA环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.1/lib64</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-11.1/bin</span><br><span class="line">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda-11.1</span><br><span class="line">source  ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>验证是CUDA否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line">输出CUDA版本即安装成功</span><br></pre></td></tr></table></figure>
<p>六、安装CUDNN。 下载地址：<a href>CUDNN</a> 。 需要登录账户 。</p>
<p>七、配置Python 虚拟环境 （Pyenv）</p>
<ul>
<li><p>安装步骤</p>
<ul>
<li><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git    </span><br><span class="line">git clone https://github.com/yyuu/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">输入以下内容：</span></span><br><span class="line">export PATH=~/.pyenv/bin:$PATH</span><br><span class="line">export PYENV_ROOT=~/.pyenv</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">刷新环境变量</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看可安装的Python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装指定版本的Python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.8.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xxx表示要切换的版本</span><br><span class="line">**有三种切换方式 glocal local shell**</span><br><span class="line">　　1. glocal 全局环境,在未再次使用 glocal切换环境之前，一直使用此环境。</span><br><span class="line">　　2. local 本次登录环境。重启后，则环境失效，并返回当前glocal的环境。</span><br><span class="line">　　3. shell 局部（临时）环境。关闭命令行窗口，则环境失效，并返回当前glocal的环境。</span><br><span class="line">pyenv glocal xxx  </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装virtualenv   创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-virtualenv.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-virtualenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cho &#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.7.0 yolo385</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;.pyenv&#x2F;versions&#x2F;env370</span><br></pre></td></tr></table></figure>
<p>八、安装pytorch</p>
</li>
</ul>
</li>
</ul>
<p>torch 官网 ：<a href="https://pytorch.org/">torch</a></p>
<p>按照自己的配置选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install torch&#x3D;&#x3D;1.9.0+cu111 torchvision&#x3D;&#x3D;0.10.0+cu111 torchaudio&#x3D;&#x3D;0.9.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</span><br></pre></td></tr></table></figure>
<p>出现 not import _lzma :</p>
<p>解决办法 ：重新安装pandas</p>
]]></content>
      <categories>
        <category>YoloV5</category>
      </categories>
      <tags>
        <tag>YoloV5</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装RabbitMQ</title>
    <url>/2021/07/10/Ubuntu%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<p>​        </p>
<a id="more"></a>

<blockquote>
<p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>均有与代理接口通讯的<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>库。</p>
</blockquote>
<p>安装前提：首先需要安装Erlang</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install erlang-nox</span><br></pre></td></tr></table></figure>
<p>1、 使用apt-get 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>2、安装完毕配置文件默认在：/etc/rabbitmq/ 下。</p>
<p><strong>如果已经安装了redis ,再启动之前现将redis 启动。</strong></p>
<p>操作命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-server start</span><br><span class="line">sudo rabbitmq-server stop</span><br><span class="line">sudo rabbitmq-server restart</span><br><span class="line">sudo rabbitmqctl status</span><br></pre></td></tr></table></figure>
<p>3、创建用户</p>
<p>创建用户名为： admin  密码：admin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl add_user  admin  admin  </span><br></pre></td></tr></table></figure>
<p>设置用户标签 为：administrator  （添加远程访问必须为 ：administrator  ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
<p>设置当前 / 虚拟主机下的权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一个“.*”用于配置资产实体的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第二个“.*”表示对实体的写权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第三个“.*” 用于读取物理的权限</span></span><br><span class="line">sudo rabbitmqctl  set_permissions -p / admin &#x27;.*&#x27; &#x27;.*&#x27; &#x27;.*&#x27;</span><br></pre></td></tr></table></figure>
<p>4、列出集群中的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>
<p>5、删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_user &#39;用户名&#39;</span><br></pre></td></tr></table></figure>
<p>6、撤销用户在虚拟主机中的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl clear_permissions -p &quot;custom-vhost&quot;  &quot;用户名&quot;</span><br></pre></td></tr></table></figure>
<p>7、看虚拟主机列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_vhosts</span><br></pre></td></tr></table></figure>
<p>8、每个rabbitmqctl权限管理操作的范围仅限于单个虚拟主机。</p>
<p>授予用户对所有虚拟主机的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for v in $(rabbitmqctl list_vhosts --silent); do rabbitmqctl set_permissions -p $v &quot;a-user&quot; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;; done</span><br></pre></td></tr></table></figure>


<p>设置RabbitMQ可以远程访问</p>
<p>在/etc/rabbitmq/rabbitmq-env.conf 中添加以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">loopback_users=none</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsdian插件</title>
    <url>/2021/07/10/obsdian%20%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>​        </p>
<a id="more"></a>

<h1 id="Obsdian插件"><a href="#Obsdian插件" class="headerlink" title="Obsdian插件"></a>Obsdian插件</h1><p>直接在obsdian的插件面板直接搜索想要的插件相关关键字。</p>
<blockquote>
<p>s在插件面板中搜索 markdown转化为world文件类型。</p>
</blockquote>
<p>插件推荐：</p>
<ol>
<li><p>统计笔记的数量：File Explorer Note Count</p>
</li>
<li><p> 最近访问的笔记：Recent File</p>
</li>
<li><p>Markdown 转化为 World 文件类型：Pandoc</p>
</li>
<li><p>将大纲内容转化为思维导图形式： Mindmap</p>
</li>
<li><p>绘制手绘风格流程图：Excaldraw</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Obsdian</category>
      </categories>
      <tags>
        <tag>Obsdian</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda3安装虚拟环境</title>
    <url>/2021/05/09/Miniconda3%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>​                   </p>
<a id="more"></a>

<p>创建虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n [name] python=版本 -y </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 激活环境</span></span><br><span class="line">conda activate name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭环境</span></span><br><span class="line">deactivate </span><br></pre></td></tr></table></figure>
<p>在对应的环境中安装包 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install xxx</span><br><span class="line">conda install xxx</span><br></pre></td></tr></table></figure>
<p>运行jupyter notebook 遇到错误 </p>
<ul>
<li>提示无法导入某个包</li>
</ul>
<p>问题原因：</p>
<p>jupyter notebook 使用的还是原来的python 包，无法使用新的虚拟环境的包。</p>
<p>点击 jupyter notebook 的new 查看是否能够找到新创建的环境。</p>
<p><img src="https://tc.chaizz.com/Snipaste_2021-05-08_18-59-42.png"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipykernel在虚拟环境下安装 ipykernel。</span></span><br><span class="line">conda install -n 环境名称 ipykernel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将创建的新的虚拟环境，添加到核心。</span></span><br><span class="line">python -m ipykernel install --user --name 环境名称 --display-name &quot;环境名称&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来重新打开 jupyter notebook即可。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行代码时提示：内核似乎已经死了 . 它会自动重启 。</li>
</ul>
<p>问题原因：</p>
<p>再学习DIVE INTO DEEP LEARNING 这本书中的代码时，运行某一段输出图表的内容的时候，提示内核似乎已经死了 . 它会自动重启 。 无法输出图表。</p>
<p>在Pycharm 上提示的错误为 ：</p>
<p><img src="https://tc.chaizz.com/Snipaste_2021-05-08_19-10-19.png"></p>
<p>解决办法：</p>
<p>在代码前导入以下代码即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;KMP_DUPLICATE_LIB_OK&#x27;</span>] = <span class="string">&#x27;TRUE&#x27;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p><a href="https://blog.csdn.net/qq_43382616/article/details/108642590">jupyter notebook无法使用conda环境的模块</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/scar2016/article/details/115710308">jupyter notebook内核挂掉了，需要重启</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Miniconda</category>
      </categories>
      <tags>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 部署YoloV5</title>
    <url>/2021/05/09/Ubuntu%20%E9%83%A8%E7%BD%B2YoloV5/</url>
    <content><![CDATA[<p>​                   </p>
<a id="more"></a>

<h2 id="Ubuntu-部署YoloV5"><a href="#Ubuntu-部署YoloV5" class="headerlink" title="Ubuntu 部署YoloV5"></a>Ubuntu 部署YoloV5</h2><p>一、安装Ubuntu 20.04 系统。</p>
<p>二、更换Ubuntu 源为国内源。（尽量不要用阿里源）</p>
<p>三、升级包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update	</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>四、下载Nvidia 驱动。<a href="https://www.nvidia.cn/content/DriverDownload-March2009/confirmation.php?url=/XFree86/Linux-x86_64/460.84/NVIDIA-Linux-x86_64-460.84.run&lang=cn&type=TITAN">下载地址</a>。根据自己的显卡查找驱动。</p>
<ul>
<li><p>禁用nouveau驱动</p>
<ul>
<li><p>编辑 /etc/modprobe.d/blacklist-nouveau.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure></li>
<li><p>接下来然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</span><br></pre></td></tr></table></figure></li>
<li><p>然后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>提示gcc 问题：</p>
</li>
</ul>
</li>
<li><p>直接安装  <code>sudo apt-get install gcc g++</code></p>
</li>
</ul>
<p>提示make问题：</p>
<ul>
<li>直接安装 <code>sudo apt-get install  make</code></li>
</ul>
<p>五、安装CUDA。（需要根据pytorch 的版本选择CUDA版本。这里选择的是CUDA 11.1）  下载地址：<a href="https://developer.nvidia.com/cuda-11.1.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=2004&target_type=runfilelocal">CUDA地址</a>。</p>
<p>官网安装步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run</span><br><span class="line">sudo sh cuda_11.1.0_455.23.05_linux.run</span><br></pre></td></tr></table></figure>
<p>接下来按照提示输入。</p>
<p>选择安装界面：因为上面已经安装过驱动，所以取消选择第一个 driver ，然后选中 按下回车。</p>
<p>配置CUDA环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.1/lib64</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-11.1/bin</span><br><span class="line">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda-11.1</span><br><span class="line">source  ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>验证是CUDA否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line">输出CUDA版本即安装成功</span><br></pre></td></tr></table></figure>
<p>六、安装CUDNN。 下载地址：<a href>CUDNN</a> 。 需要登录账户 。</p>
<p>七、配置Python 虚拟环境 （Pyenv）</p>
<ul>
<li><p>安装步骤</p>
<ul>
<li><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git	</span><br><span class="line">git clone https://github.com/yyuu/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure></li>
<li><p>打开环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">输入以下内容：</span></span><br><span class="line">export PATH=~/.pyenv/bin:$PATH</span><br><span class="line">export PYENV_ROOT=~/.pyenv</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">刷新环境变量</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>查看可安装的Python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure></li>
<li><p>安装指定版本的Python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.8.5</span><br></pre></td></tr></table></figure></li>
<li><p>更新数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure></li>
<li><p>切换python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xxx表示要切换的版本</span><br><span class="line">**有三种切换方式 glocal local shell**</span><br><span class="line">　　1. glocal 全局环境,在未再次使用 glocal切换环境之前，一直使用此环境。</span><br><span class="line">　　2. local 本次登录环境。重启后，则环境失效，并返回当前glocal的环境。</span><br><span class="line">　　3. shell 局部（临时）环境。关闭命令行窗口，则环境失效，并返回当前glocal的环境。</span><br><span class="line">pyenv glocal xxx  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>卸载已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall xxx</span><br></pre></td></tr></table></figure></li>
<li><p>安装virtualenv   创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-virtualenv.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-virtualenv</span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cho &#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.7.0 yolo385</span><br></pre></td></tr></table></figure></li>
<li><p>删除虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;.pyenv&#x2F;versions&#x2F;env370</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p>八、安装pytorch</p>
<p>torch 官网 ：<a href="https://pytorch.org/">torch</a></p>
<p>按照自己的配置选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install torch&#x3D;&#x3D;1.9.0+cu111 torchvision&#x3D;&#x3D;0.10.0+cu111 torchaudio&#x3D;&#x3D;0.9.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</span><br></pre></td></tr></table></figure>
<p>出现 not import _lzma :</p>
<p>解决办法 ：重新安装pandas</p>
<p>项目运行：</p>
<ul>
<li><p>进入虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv activate yolo3v385</span><br></pre></td></tr></table></figure></li>
<li><p>进入项目目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;hziwei&#x2F;yoloapp</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>YoloV5</category>
      </categories>
      <tags>
        <tag>YoloV5</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat连接Oracle数据库</title>
    <url>/2021/05/09/%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<p>Navicat连接Oracle出现错误信息 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">oracle library is not loaded</span><br></pre></td></tr></table></figure>
<p>Navicat版本 ：12.1.11</p>
<p>Navicat 连接Oracle数据库需要配下载Oracle 官方提供的插件 ：<a href="https://www.oracle.com/database/technologies/instant-client/downloads.html">instantclient_19_9</a>，选择自己的系统（我的是windows），将此文件下载解压后放在Navicat安装文件路径下。</p>
<p>然后打开Navicat 的 ：工具-&gt;选项-&gt;环境-&gt;OCI 如下图所示。</p>
<p><img src="https://tc.chaizz.com/3b0b7af0e15211eb9d7c5254006b8f1d.png"></p>
<p>将instantclient_19_9 路径下的oci.dll 文件路径复制到此路径下。</p>
<p>接下来重启Navicat 即可。</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装Apex</title>
    <url>/2021/04/24/Centos7%E5%AE%89%E8%A3%85Apex/</url>
    <content><![CDATA[<p>封面图片由<a href="https://pixabay.com/zh/users/khirulislam898-12875647/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">MD KHIRUL ISLAM</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">Pixabay</a>上发布。</p>
<a id="more"></a>

<h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><blockquote>
<p>系统：Centos 7.6</p>
<p>所需 文件：java jdk  、 tomcat9 、Oracle 19c、   Ords 20.4 、 apex 20.2</p>
</blockquote>
<p>安装高版本的JDK和Tomcat会导致出现下面这个问题。建议选择低版本进行安装，低版本和高版本安装大致方法一直，或者采用以下脚本执行。</p>
<p><img src="https://tc.chaizz.com/%E6%89%93%E5%BC%80ords%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98.png"></p>
<h3 id="一、脚本文件方式安装JDK和tomcat"><a href="#一、脚本文件方式安装JDK和tomcat" class="headerlink" title="一、脚本文件方式安装JDK和tomcat"></a>一、脚本文件方式安装JDK和tomcat</h3><p>该脚本文件来自 ：<a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用于安装tomcat</span></span><br><span class="line">JAVA_VER=271</span><br><span class="line">JAVA_DIR=/usr/local/jdk</span><br><span class="line">TOMCAT_VER=9.0.45</span><br><span class="line">Pro=tomcat</span><br><span class="line">CATALINA_HOME=/usr/local/$Pro</span><br><span class="line">[ ! -d /software/ ] &amp;&amp; mkdir /software</span><br><span class="line"><span class="meta">#</span><span class="bash">安装依赖包</span></span><br><span class="line">install_java()&#123;</span><br><span class="line">    cd /software</span><br><span class="line">    #卸载openjdk</span><br><span class="line">    m=`rpm -qa |grep openjdk |wc -l`</span><br><span class="line">    [ $m -ne 0 ] &amp;&amp; rpm -qa |grep openjdk |xargs rpm -e</span><br><span class="line">    #安装java</span><br><span class="line">    if [ ! -f jdk-8u$JAVA_VER-linux-x64.tar.gz ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[31m请手动下载jdk到/software\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    else</span><br><span class="line">        tar xf jdk-8u$JAVA_VER-linux-x64.tar.gz</span><br><span class="line">        [ ! -d $JAVA_DIR ] &amp;&amp; mv jdk1.8.0_$JAVA_VER $JAVA_DIR</span><br><span class="line">        n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; /etc/profile |wc -l`</span><br><span class="line">        if [ $n -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo &quot;JAVA_HOME=$JAVA_DIR&quot; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/jre/lib&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;export JAVA_HOME PATH CLASSPATH&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            source /etc/profile</span><br><span class="line">        else</span><br><span class="line">            source /etc/profile</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">    java -version</span><br><span class="line">    if [ $? -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[36mjdk安装完成\033[0m&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\033[31mjdk安装失败\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装tomcat</span></span><br><span class="line">install_tomcat()&#123;</span><br><span class="line">    #下载tomcat</span><br><span class="line">    [ ! -f apache-tomcat-$TOMCAT_VER.tar.gz ] &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v$TOMCAT_VER/bin/apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    #解压</span><br><span class="line">    [ ! -d apache-tomcat-$TOMCAT_VER ] &amp;&amp; tar xf apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    [ ! -d $CATALINA_HOME ] &amp;&amp; mv apache-tomcat-$TOMCAT_VER $CATALINA_HOME</span><br><span class="line">    #设置环境变量</span><br><span class="line">    n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; $CATALINA_HOME/bin/catalina.sh |wc -l`</span><br><span class="line">    if [ $n -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        sed -i &quot;124a JAVA_HOME=$&#123;JAVA_DIR&#125;&quot; $CATALINA_HOME/bin/catalina.sh</span><br><span class="line">    fi</span><br><span class="line">    #配置启动脚本</span><br><span class="line">    cat &gt; /etc/systemd/system/$Pro\.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Apache Tomcat 9 Servlet Container</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Type=forking</span><br><span class="line">LimitNOFILE=131070</span><br><span class="line">Environment=CATALINA_PID=$&#123;CATALINA_HOME&#125;/bin/tomcat.pid</span><br><span class="line">Environment=CATALINA_HOME=$&#123;CATALINA_HOME&#125;</span><br><span class="line">Environment=CATALINA_BASE=$&#123;CATALINA_HOME&#125;</span><br><span class="line">ExecStart=$&#123;CATALINA_HOME&#125;/bin/startup.sh</span><br><span class="line">ExecStop=$&#123;CATALINA_HOME&#125;/bin/shutdown.sh</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    #tomcat开机启动</span><br><span class="line">    systemctl daemon-reload &amp;&amp; systemctl enable $Pro</span><br><span class="line"></span><br><span class="line">    if [ `systemctl status $Pro | grep &#x27;running&#x27;| wc -l` -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        systemctl start $Pro</span><br><span class="line">        if [ $? -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo -e &quot;\033[36m$Pro安装完毕\033[0m&quot;</span><br><span class="line">        else</span><br><span class="line">            echo -e &quot;\03331m$Pro安装失败\033[0m&quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_java</span><br><span class="line">install_tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将此脚本复制到系统制定目录下，在根目录下创建/software 。并将JDK 和 tomcat 包放在/software下。</p>
<p>将此脚本文件设置为可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 filename.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后执行此文件</span></span><br><span class="line">sh filename.sh </span><br></pre></td></tr></table></figure>
<p>如果显示以下错误：则表示脚本文件中存在乱码。</p>
<p><img src="https://ae01.alicdn.com/kf/U42528946957d48ff8d31a1fd8b4a3034I.jpg"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 vim -b  模式打开文件</span></span><br><span class="line">vim -b filename.sh</span><br></pre></td></tr></table></figure>
<p>打开发现如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U3b6e1138b0b742eea8f46daa886d3296w.jpg"></p>
<p>快速处理办法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\r//g&#x27; filename.sh</span><br></pre></td></tr></table></figure>
<p>接下来再打开就可以执行了。</p>
<p>等待程序运行完毕即可。</p>
<h3 id="一、安装java和tomcat环境。"><a href="#一、安装java和tomcat环境。" class="headerlink" title="一、安装java和tomcat环境。"></a>一、安装java和tomcat环境。</h3><p>1、下载java SE <a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html">文件下载地址</a>，本次选择的是java SE 16 版本。tomcat 版本10.0.5<a href="https://tomcat.apache.org/download-10.cgi">文件下载地址</a>。</p>
<p>将下载的压缩包挤压到指定文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压文件</span></span><br><span class="line">tar -zxvf jdk-16_linux-x64_bin.tar</span><br></pre></td></tr></table></figure>
<p>2、设置环境变量</p>
<p>以下是<em>错误的配置</em>：（在终端输入java -version 没有问题 但是运行tomcat 会出现提示启动成功，但是后台服务不启动。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/var/oracle/jdk-16</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>原因： 因为是使用JDK16，是新版的JDK，网上查找的答案，说是从11开始就不会自动生成jre文件了。</p>
<p>可用的java 环境变量配置如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/var/oracle/jdk-16/</span><br><span class="line">JRE_HOME=$JAVA_HOME</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib</span><br><span class="line">PATH=$JRE_HOME/bin:$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>
<p>将JRE_HOME的路径设置为 JAVA_HOME的路径，即可解决。但是启动tomcat的时候，日志文件会打印一些列NOTE。如下图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U0185a411b5804effb0c78bcf086a09b2g.jpg"></p>
<p>此问题不影响tomcat使用，目前未解决。</p>
<p>3、测试是否安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在终端输入以下命令，测试java是否安装成功，如提示java 版本信息，代表已经安装成功。</span></span><br><span class="line">java -version </span><br></pre></td></tr></table></figure>
<p>4、安装tomcat。</p>
<p>将tomcat 解压至指定文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf  apache-tomcat-10.0.5.tar</span><br><span class="line">mv /apache-tomcat-10.0.5  /var/oracle/tomcat</span><br></pre></td></tr></table></figure>
<p>配置tomcat 环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CATALINA_BASE=/var/oracle/tomcat</span><br><span class="line">PATH=$CATALINA_BASE/bin:$PATH</span><br><span class="line">export PATH CATALINA_BASE</span><br></pre></td></tr></table></figure>
<p>tomcat 的启动命令在 /tomcat/bin/start.sh 可直接启动即可。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./start.sh </span><br></pre></td></tr></table></figure>
<p>查看tomcat是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat</span><br></pre></td></tr></table></figure>
<p>启动成功如下图所示</p>
<p><img src="https://ae01.alicdn.com/kf/Ud8527b3539e34383867eff8fd2b89cb3E.jpg"></p>
<p>如果以上java 的环境变量设置不对的话，会导致tomcat 无法启动。虽然提示tomcat启动成功，但是后并没有该服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">此时终端输入验证是否启动成功</span></span><br><span class="line">curl http://ip:8080</span><br></pre></td></tr></table></figure>
<p>如未显示tomcat启动页面HTML，可排查防火墙，是否开启了8080端口 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查防火墙是否启动</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如未开启 则开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查80端口 是否被开启，如开启 则提示  “8080/tcp”</span> </span><br><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如未开启 则需要开启，开启成功会提示 “success”</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证开启的8080端口是否生效， 如果生效则提示 “yes”</span></span><br><span class="line">firewall-cmd --zone=public --query-port=8080/tcp</span><br></pre></td></tr></table></figure>
<p>8080端口开放，再次访问 IP:8080  即可看到tomcat访问成功信息。 </p>
<h3 id="二、安装oracle"><a href="#二、安装oracle" class="headerlink" title="二、安装oracle"></a>二、安装oracle</h3><p>1、以上Java jdk 和 tomcat 安装完毕以后安装 oracle 。</p>
<p>2、在根目录下创建oracle 安装文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;oracle  </span><br></pre></td></tr></table></figure>
<p>3、切换到该目录下执行以下安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先执行</span> </span><br><span class="line">yum localinstall  oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">等待执行结束，在执行</span></span><br><span class="line">yum localinstall oracle-database-ee-19c-1.0-1.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>中途卡断 可重新安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用yum命令 查询更刚刚安装的包, 找到Oracle的包名</span></span><br><span class="line">yum list installed shell</span><br><span class="line"><span class="meta">#</span><span class="bash">先使用以下命令卸载已安装的包。</span></span><br><span class="line">yum remove oracle-database-preinstall-19c-1.0-1.el7.x86_64</span><br><span class="line">yum remove oracle-database-ee-19c-1.0-1.x86_64</span><br></pre></td></tr></table></figure>
<p>4、过一段时间安装完毕成功会提示如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/Ua0442ba6df124404871dd091810d949e2.jpg"></p>
<p>oracle 的安装文件地址为：/opt/oracle   默认配置文件路径为：/etc/sysconfig/oracledb_ORCLCDB-19c.conf</p>
<p>5、接下来初始化数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c configure</span><br></pre></td></tr></table></figure>
<p>等待数据库初始化。过程中切记不用中断操作。初始化时间可能会很长。只要后台服务还在就说明没问题。</p>
<p>6、切换至Oracle 用户 修改数据库系统账户密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su oracle </span><br><span class="line"><span class="meta">#</span><span class="bash">登录数据库</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#修改sys 和 <span class="keyword">system</span> 的密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> sys identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">system</span> identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line">shutdown immediate;</span><br><span class="line"></span><br><span class="line">startup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;</span><br><span class="line"></span><br><span class="line">startup;</span><br></pre></td></tr></table></figure>
<p>7、配置数据库的环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">在最下面添加以下内容：</span></span><br><span class="line">export ORACLE_HOME=/opt/oracle/product/19c/dbhome_1</span><br><span class="line">export ORACLE_SID=ORCLCDB</span><br><span class="line">export PATH=$PATH:/opt/oracle/product/19c/dbhome_1/bin</span><br><span class="line">export NLS_LANG=American_America.AL32UTF8</span><br></pre></td></tr></table></figure>
<p>8、启动停止oracle</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c start</span><br><span class="line"></span><br><span class="line">/etc/init.d/oracledb_ORCLCDB-19c stop</span><br></pre></td></tr></table></figure>


<h3 id="三、安装apex"><a href="#三、安装apex" class="headerlink" title="三、安装apex"></a>三、安装apex</h3><p>1、解压apex的压缩包</p>
<p>使用oracle 用户需要将 apex保存的文件富裕oracle 权限。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R oracle:dba /var/oracle/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压到当前文件夹下</span></span><br><span class="line">unzip -q apex_20.2.zip </span><br></pre></td></tr></table></figure>
<p>2、进入oracle数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、登录数据库</span></span><br><span class="line">sqlplus / as sysdba  </span><br></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按顺序执行以下代码</span></span><br><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;   </span><br><span class="line"></span><br><span class="line"><span class="comment">--3、设置系统默认表空间</span></span><br><span class="line"><span class="variable">@apexins</span>.<span class="keyword">sql</span> APEX APEX TEMP <span class="operator">/</span>i<span class="operator">/</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">--接下来等待安装 ，会持续一段时间....。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--4、创建 apex 实例管理员</span></span><br><span class="line"><span class="variable">@apxchpwd</span>.<span class="keyword">sql</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码必须包含：(!&quot;#$%&amp;()``*+,-/:;?_) 和 至少一个大写字母。</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">--5、 修改APEX_PUBLIC_USER 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> APEX_PUBLIC_USER ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -6、 修改flows_files 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> flows_files ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"><span class="variable">@apex</span>_rest_config.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10       </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_LISTENER <span class="keyword">user</span>: Test123_</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11        </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_REST_PUBLIC_USER <span class="keyword">user</span>: Test123_</span><br><span class="line">            </span><br></pre></td></tr></table></figure>


<p>3、汉化apex </p>
<p>切换到，apex/builder/zh-cn/ 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、 登录sql</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、设置CURRENT_SCHEMA </span></span><br><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> <span class="built_in">CURRENT_SCHEMA</span> <span class="operator">=</span> APEX_200200;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、加载sql</span></span><br><span class="line"><span class="variable">@load</span>_zh<span class="operator">-</span>cn.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等待一段时间即可...</span></span><br></pre></td></tr></table></figure>


<h3 id="四、安装ords"><a href="#四、安装ords" class="headerlink" title="四、安装ords"></a>四、安装ords</h3><p>1、解压文件到当前目录下</p>
<p>2、执行ords安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ords.war install advanced</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来选择会提示输入：</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">This Oracle REST Data Services instance has not yet been configured.</span><br><span class="line">Please complete the following prompts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter the location to store configuration data: /opt/ords/config  # 配置存储路径</span><br><span class="line">Specify the database connection type to use.</span><br><span class="line">Enter number for [1] Basic  [2] TNS  [3] Custom URL [1]:1    </span><br><span class="line">Enter the name of the database server [localhost]:localhost  </span><br><span class="line">Enter the database listen port [1521]:1520                   </span><br><span class="line">Enter 1 to specify the database service name, or 2 to specify the database SID [1]:1</span><br><span class="line">Enter the database service name:ORCLPDB1</span><br><span class="line">Enter 1 if you want to verify/install Oracle REST Data Services schema or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for ORDS_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Xisland2020</span><br><span class="line">Requires to login with administrator privileges to verify Oracle REST Data Services schema.</span><br><span class="line"></span><br><span class="line">Enter the administrator username:SYS                #oracle数据库账号</span><br><span class="line">Enter the database password for SYS AS SYSDBA:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Connecting to database user: SYS AS SYSDBA url: jdbc:oracle:thin:@//localhost:1521/ORCLPDB1</span><br><span class="line"></span><br><span class="line">Retrieving information.</span><br><span class="line">Enter 1 if you want to install ORDS or 2 to skip this step [1]:1</span><br><span class="line">Enter the default tablespace for ORDS_METADATA [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_METADATA [TEMP]:TEMP</span><br><span class="line">Enter the default tablespace for ORDS_PUBLIC_USER [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_PUBLIC_USER [TEMP]:TEMP</span><br><span class="line">Enter 1 if you want to use PL/SQL Gateway or 2 to skip this step.</span><br><span class="line">If using Oracle Application Express or migrating from mod_plsql then you must enter 1 [1]:1</span><br><span class="line">Enter the PL/SQL Gateway database user name [APEX_PUBLIC_USER]:APEX_PUBLIC_USER</span><br><span class="line">Enter the database password for APEX_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter 1 to specify passwords for Application Express RESTful Services database users (APEX_LISTENER, APEX_REST_PUBLIC_USER) or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for APEX_LISTENER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter the database password for APEX_REST_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter a number to select a feature to enable:</span><br><span class="line">   [1] SQL Developer Web  (Enables all features)</span><br><span class="line">   [2] REST Enabled SQL</span><br><span class="line">   [3] Database API</span><br><span class="line">   [4] REST Enabled SQL and Database API</span><br><span class="line">   [5] None</span><br><span class="line">Choose [1]:1</span><br><span class="line">2021-02-02T08:45:42.287Z INFO        reloaded pools: []</span><br><span class="line">Installing Oracle REST Data Services version 20.4.1.r0131644</span><br><span class="line">... Log file written to /root/ords_install_core_2021-02-02_164542_00395.log</span><br><span class="line">... Verified database prerequisites</span><br><span class="line">... Created Oracle REST Data Services proxy user</span><br><span class="line">... Created Oracle REST Data Services schema</span><br><span class="line">... Granted privileges to Oracle REST Data Services</span><br><span class="line">... Created Oracle REST Data Services database objects</span><br><span class="line">... Log file written to /root/ords_install_datamodel_2021-02-02_164559_00321.log</span><br><span class="line">... Log file written to /root/ords_install_apex_2021-02-02_164600_00696.log</span><br><span class="line">Completed installation for Oracle REST Data Services version 20.4.1.r0131644. Elapsed time: 00:00:19.722 </span><br><span class="line"></span><br><span class="line">Enter 1 if you wish to start in standalone mode or 2 to exit [1]:2</span><br></pre></td></tr></table></figure>
<p>至此ords安装配置结束。</p>
<h3 id="五、部署到tomcat-上"><a href="#五、部署到tomcat-上" class="headerlink" title="五、部署到tomcat 上"></a>五、部署到tomcat 上</h3><p>1、将apex 的静态文件放到tomcat的webapps 下。 路径为你的apex 安装路径：/var/oracle/apex/images</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -a /var/oracle/apex/images/* /var/oracle/apache-tomcat-10.0.5/webapps/apex</span><br></pre></td></tr></table></figure>
<p>2、将ords.war 包 复制到tomcat 的web apｐｓ下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;var&#x2F;oracle&#x2F;ords&#x2F;ords.war &#x2F;var&#x2F;oracle&#x2F;apache-tomcat-10.0.5&#x2F;webapps&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="六、使用nginx-代理"><a href="#六、使用nginx-代理" class="headerlink" title="六、使用nginx 代理"></a>六、使用nginx 代理</h3><p>Nginx 的server配置文件为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 域名;</span><br><span class="line">    </span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Origin &quot;&quot; ;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_connect_timeout 120s;</span><br><span class="line">        proxy_read_timeout    120s;</span><br><span class="line">        proxy_send_timeout    120s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重启nginx 即可。</p>
<h3 id="七、完成"><a href="#七、完成" class="headerlink" title="七、完成"></a>七、完成</h3><p>浏览器输入域名即可打开APEX登录页面。</p>
<p>创建的密码相关：</p>
<ul>
<li><p>apex 创建实例 用户名：admin</p>
</li>
<li><p>密码：Test123_</p>
</li>
<li><p>APEX_LISTENER  user：Test1123_</p>
</li>
<li><p>数据库用户sys密码：test12</p>
</li>
<li><p>数据库用户system密码：test123</p>
</li>
</ul>
<p>参考文章：</p>
<blockquote>
<p><a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_41092687/article/details/89879061">https://blog.csdn.net/weixin_41092687/article/details/89879061</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_39400984/article/details/98104599">https://blog.csdn.net/qq_39400984/article/details/98104599</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/xzm5708796/article/details/88344074">https://blog.csdn.net/xzm5708796/article/details/88344074</a></p>
</blockquote>
]]></content>
      <categories>
        <category>ORACLE-APEX</category>
      </categories>
      <tags>
        <tag>ORACLE-APEX</tag>
      </tags>
  </entry>
  <entry>
    <title>Python代码规范（pep8/Google-style）</title>
    <url>/2021/03/19/Python%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88pep8-Google-style%EF%BC%89/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<blockquote>
<p>Guido van Rossum（吉多·范罗苏姆，Python 创始人 ）说过，代码的阅读频率远高于编写代码的频率。</p>
</blockquote>
<p>毕竟，即使是在编写代码的时候，你也需要对代码进行反复阅读和调试，来确认代码能够按照期望运行。</p>
<p>本文来自极客时间规范篇学习总结。</p>
<h2 id="PEP8规范："><a href="#PEP8规范：" class="headerlink" title="PEP8规范："></a>PEP8规范：</h2><p>PEP 是 Python Enhancement Proposal 的缩写，翻译过来叫“Python 增强规范”。正如我们写文章，会有句式、标点、段落格式、开头缩进等标准的规范一样，Python 书写自然也有一套较为官方的规范。PEP 8 就是这样一种规范，它存在的意义，就是让 Python 更易阅读，换句话，增强代码可读性。</p>
<h3 id="缩进规范"><a href="#缩进规范" class="headerlink" title="缩进规范"></a>缩进规范</h3><p>Python 和 C++ / Java 最大的不同在于，后者完全使用大括号来区分代码块，而前者依靠不同行和不同的缩进来进行分块。</p>
<p>Python 的缩进其实可以写成很多种，Tab、双空格、四空格、空格和 Tab 混合等。而 PEP 8 规范告诉我们，<strong>请选择四个空格的缩进，不要使用 Tab，更不要 Tab 和空格混着用。</strong></p>
<p>第二个要注意的是，<strong>每行最大长度请限制在 79 个字符</strong>。</p>
<p>这个原则主要有两个优点：</p>
<ol>
<li>很多工程师在编程的时候，习惯一个屏幕并列竖排展示多个源代码。如果某个源代码的某些行过长，你就需要拖动横向滚动条来阅读，或者需要软回车将本行内容放入下一行，这就极大地影响了编码和阅读效率。</li>
<li>需要有一定经验的编程经验后更容易理解：因为当代码的嵌套层数过高，比如超过三层之后，一行的内容就很容易超过 79 个字符了。所以，这条规定另一方面也在制约着程序员，不要写迭代过深的代码，而是要思考继续把代码分解成其他函数或逻辑块，来优化自己的代码结构。</li>
</ol>
<h3 id="空行规范"><a href="#空行规范" class="headerlink" title="空行规范"></a>空行规范</h3><p>Python 中的空行对 Python 解释器的执行没有影响，但对阅读体验有很深刻的影响。</p>
<p>PEP 8 规定，<strong>全局的类和函数的上方需要空两个空行，而类的函数之间需要空一个空行。</strong>当然，函数内部也可以使用空行，和英语的段落一样，用来区分不同意群之间的代码块。但是记住最多空一行，千万不要滥用。</p>
<p>另外，Python 本身允许把多行合并为一行，使用分号隔开，但这是 PEP 8 不推荐的做法。所以，即使是使用控制语句 if / while / for，你的执行语句哪怕只有一行命令，也请另起一行，这样可以更大程度提升阅读效率。至于代码的尾部，每个代码文件的最后一行为空行，并且只有这一个空行。</p>
<h3 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h3><p>我们再来看一下，代码块中，每行语句中空格的使用。函数的参数列表中，调用函数的参数列表中会出现逗号，请注意逗号后要跟一个空格，这是英语的使用习惯，也能让每个参数独立阅读，更清晰。同理，冒号经常被用来初始化字典，冒号后面也要跟一个空格。另外，Python 中我们可以使用#进行单独注释，请记得要在#后、注释前加一个空格。对于操作符，例如+，-，*，/，&amp;，|，=，==，!=，请在两边都保留空格。不过与此对应，括号内的两端并不需要空格。</p>
<h3 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h3><p>接下来我们说说文档规范。先来看看最常用的 import 函数。</p>
<p>首先，所有 import 尽量放在开头，这个没什么说的，毕竟到处 import 会让人很难看清楚文件之间的依赖关系，运行时 import 也可能会导致潜在的效率问题和其他风险。</p>
<p>其次，不要使用 import 一次导入多个模块。虽然我们可以在一行中 import 多个模块，并用逗号分隔，但请不要这么做。import time, os 是 PEP 8 不推荐的做法。</p>
<p>如果你采用 <code>from module import func</code> 这样的语句，请确保 func 在本文件中不会出现命名冲突。不过，你其实可以通过<code> from module import func as new_func</code> 来进行重命名，从而避免冲突。</p>
<h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>有句话这么说：错误的注释，不如没有注释。所以，当你改动代码的时候，一定要注意检查周围的注释是否需要更新。</p>
<p>对于大的逻辑块，我们可以在最开始相同的缩进处以 # 开始写注释。即使是注释，你也应该把它当成完整的文章来书写。如果英文注释，请注意开头大写及结尾标点，注意避免语法错误和逻辑错误，同时精简要表达的意思。中文注释也是同样的要求。一份优秀的代码，离不开优秀的注释。</p>
<p>至于行注释，如空格规范中所讲，我们可以在一行后面跟两个空格，然后以 # 开头加入注释。不过，请注意，行注释并不是很推荐的方式。</p>
<h3 id="文档描述"><a href="#文档描述" class="headerlink" title="文档描述"></a>文档描述</h3><p>docstring 的写法，它是用三个双引号开始、三个双引号结尾。我们首先用一句话简单说明这个函数做什么，然后跟一段话来详细解释；再往后是参数列表、参数格式、返回值格式。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>“计算机科学的两件难事：缓存失效和命名。”命名对程序员来说，是一个不算省心的事。</p>
<ol>
<li>变量命名。变量名请拒绝使用 a b c d 这样毫无意义的单字符，我们应该使用能够代表其意思的变量名。一般来说，变量使用小写，通过下划线串联起来，例如：data_format、input_spec、image_data_set。唯一可以使用单字符的地方是迭代，比如 for i in range(n) 这种，为了精简可以使用。如果是类的私有变量，请记得前面增加两个下划线。</li>
<li>常量命名，最好的做法是全部大写，并通过下划线连接，例如：WAIT_TIME、SERVER_ADDRESS、PORT_NUMBER。</li>
<li>函数名，也使用小写的方式，通过下划线连接起来，例如：launch_nuclear_missile()、check_input_validation()。</li>
<li>类名，则应该首字母大写，然后合并起来，例如：class SpatialDropout2D()、class FeatureSet()。</li>
</ol>
<p>总之，不要过于吝啬一个变量名的长度。当然，在合理描述这个变量背后代表的对象后，一定的精简能力也是必要的。</p>
<h3 id="代码分解技巧"><a href="#代码分解技巧" class="headerlink" title="代码分解技巧"></a>代码分解技巧</h3><p>编程中一个核心思想是，不写重复代码。重复代码大概率可以通过使用条件、循环、构造函数和类来解决。而另一个核心思想则是，减少迭代层数，尽可能让 Python 代码扁平化，毕竟，人的大脑无法处理过多的栈操作。</p>
<p>一个函数的粒度应该尽可能细，不要让一个函数做太多的事情。所以，对待一个复杂的函数，我们需要尽可能地把它拆分成几个功能简单的函数，然后合并起来。</p>
]]></content>
      <categories>
        <category>PEP8</category>
      </categories>
      <tags>
        <tag>PEP8</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter-notebook的安装与基本使用</title>
    <url>/2021/03/13/Jupyter-notebook%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​              </p>
<a id="more"></a>

<blockquote>
<h4 id="The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more"><a href="#The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more" class="headerlink" title="The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more."></a>The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.</h4></blockquote>
<p>以上为Jupyter notebook 的官方解释。</p>
<blockquote>
<p>Jupyter Notebook是一个开源Web应用程序，可让您创建和共享包含实时代码，方程式，可视化效果和叙述文本的文档。 用途包括：数据清理和转换，数值模拟，统计建模，数据可视化，机器学习等.</p>
</blockquote>
<h2 id="一、windows下安装Jupyter-notebook"><a href="#一、windows下安装Jupyter-notebook" class="headerlink" title="一、windows下安装Jupyter notebook"></a>一、windows下安装Jupyter notebook</h2><p>Jupyter notebook 是基于Python 的首先要安装Python环境，或者直接安装Anaconda（直接包含Python和Jupyter notebook）。以上环境省略自行安装。</p>
<h3 id="在Python环境下直接安装。（最好是新版本Python）"><a href="#在Python环境下直接安装。（最好是新版本Python）" class="headerlink" title="在Python环境下直接安装。（最好是新版本Python）"></a>在Python环境下直接安装。（最好是新版本Python）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>
<p>等待命令安装完毕，如果比较慢的话，建议更换Python的源为清华或者淘宝网易的源下载安装速度会快很多。</p>
<h3 id="启动Jupyter-notebook"><a href="#启动Jupyter-notebook" class="headerlink" title="启动Jupyter notebook"></a>启动Jupyter notebook</h3><p>系统会自动启动浏览器，打开本地的8888端口。（端口没有被占用的情况下。如果被占用端口号会自动加一，启动多个Jupyter notebook应用，端口号也会自动向后加一来启动多个应用。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook </span><br></pre></td></tr></table></figure>
<p>如果在使用过程中关闭了当前终端，应用也会随之无法连接，无法使用Jupyter notebook应用。</p>
<p>如果要以不同的端口号启动Jupyter notebook应用，使用一下的方式启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook --port 8899</span><br></pre></td></tr></table></figure>
<h2 id="二、Jupyter-notebook-界面"><a href="#二、Jupyter-notebook-界面" class="headerlink" title="二、Jupyter notebook 界面"></a>二、Jupyter notebook 界面</h2><p>Jupyter notebook 的默认存储文件的地址为当前用户的文件路径。每个人里面的文件都不太一样。</p>
<h3 id="更改默认的存储路径。"><a href="#更改默认的存储路径。" class="headerlink" title="更改默认的存储路径。"></a>更改默认的存储路径。</h3><p>Jupyter notebook  的默认的配置文件在当前用户下的一个隐藏文件（以.jupyter开头的文件）文件下名为jupyter_notebook_config.py 即为jupyter notebook 的配置文件。</p>
<p>打开文件搜索找到 <code>c.NotebookApp.notebook_dir</code> 开头的配置，即是存储文件路径的配置。只需要将你想要修改的路径添加并取消注释即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir &#x3D; &#39;C:&#x2F;Users&#x2F;xxx&#x2F;Desktop&#x2F;Project&#x2F;Jupyter Notebook&#39;</span><br></pre></td></tr></table></figure>
<p>重启启动 Jupyter notebook。此时页面文件目录是空的。</p>
<h2 id="三、使用-Jupyter-notebook"><a href="#三、使用-Jupyter-notebook" class="headerlink" title="三、使用 Jupyter notebook"></a>三、使用 Jupyter notebook</h2><p>新建一个页面。 点击右上角的 new 按钮可以新建一个工程文件或者文本文件或者文件夹。</p>
<p><img src="https://tc.chaizz.com/717fe24c4ade11ec9d7c5254006b8f1d.png"></p>
<p>例如 新建一个python3文件。新页面样式如图所示。</p>
<p><img src="https://tc.chaizz.com/7fcf69304ade11ec9d7c5254006b8f1d.png"></p>
<p>可在单元格（cell）中输入代码并执行。</p>
<h2 id="四、Jupyter-notebook-快捷键"><a href="#四、Jupyter-notebook-快捷键" class="headerlink" title="四、Jupyter notebook 快捷键"></a>四、Jupyter notebook 快捷键</h2><p>A：在当前单元格的上方添加一行单元格</p>
<p>B：在当前单元格的下方添加一行单元格</p>
<p>M：选中单元格将单元格代码格式改为Markdown格式</p>
<p>Y：选中单元格将单元格代码格式改为代码格式</p>
<p>X：剪切当前单元格</p>
<p>V：在当前单元格下方粘贴复制或者剪切的单元格</p>
<p>Enter：在当前单元格换行</p>
<p>Shift+Enter：代码模式下执行当前单元格代码</p>
<p>shift+V：在当前单元格上方粘贴复制或者剪切的单元格</p>
<p>D D ：连续两个D 删除当前单元格</p>
<p>Z：撤销删除单元格</p>
<p>还有很多快捷键按H都可以找到。</p>
<h2 id="五、Jupyter-notebook-插件"><a href="#五、Jupyter-notebook-插件" class="headerlink" title="五、Jupyter notebook 插件"></a>五、Jupyter notebook 插件</h2><p>在安装插件之前首先需要安装<strong>jupyter_contrib_nbextensions</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用 jupyter_contrib_nbextensions</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure>
<p>此时 Jupyter notebook 界面就会出现一个新的菜单栏。</p>
<p><img src="https://tc.chaizz.com/8a881e4e4ade11ec9d7c5254006b8f1d.png"></p>
<p>选中此按钮进入配置插件的页面。</p>
<p>取消勾选此按钮。否则无法选择插件。</p>
<p><img src="https://tc.chaizz.com/941816a84ade11ec9d7c5254006b8f1d.png"></p>
<p>推荐插件：</p>
<ul>
<li><strong>Notify</strong> ：能在任务处理完后及时向你发送通知</li>
<li><strong>Hinterland</strong> ：自动补全代码</li>
<li><strong>Codefolding</strong>  ：折叠代码</li>
<li><strong>Table of Contents(2)</strong>  ：自动生成导航目录</li>
<li><strong>Autopep8</strong> ：自动格式化代码。（需要安装python库：autopep8）</li>
<li><strong>ExecuteTime</strong> ：显示单元格的运行时间和耗时 </li>
<li><strong>Split Cells Notebook</strong> ：类似于多窗口编辑，将单行排列的单元格放置为多行排列。</li>
<li><strong>Collapsible Headings</strong> ：折叠单元格</li>
</ul>
]]></content>
      <categories>
        <category>Jupyter-notebook</category>
      </categories>
      <tags>
        <tag>Jupyter-notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件目录</title>
    <url>/2021/02/02/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
</ul>
<a id="more"></a>

<ul>
<li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</li>
<li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
<p><img src="/2021/02/02/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/linuxfile.jpg"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件目录</title>
    <url>/2021/02/02/Linux%20%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<a id="more"></a>



<p><img src="/2021/02/02/Linux%20%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/linuxfile.jpg"></p>
<ul>
<li><p><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</li>
<li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装mysql-python插件</title>
    <url>/2021/02/02/Ubuntu%E5%AE%89%E8%A3%85mysql-python%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>​      </p>
<a id="more"></a>

<blockquote>
<p>运行FLASK 提示 ：ERROR:flask.app:No module named MySQLdb</p>
</blockquote>
<h3 id="安装-mysql-python"><a href="#安装-mysql-python" class="headerlink" title="安装 mysql-python"></a>安装 mysql-python</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install mysql-python</span><br></pre></td></tr></table></figure>
<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p><img src="/2021/02/02/Ubuntu%E5%AE%89%E8%A3%85mysql-python%E6%8F%92%E4%BB%B6/snipaste_20190917_205355.jpg" alt="snipaste_20190917_205355"></p>
<h3 id="接下来安装依赖包"><a href="#接下来安装依赖包" class="headerlink" title="接下来安装依赖包"></a>接下来安装依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
<h3 id="如果还是不行安装依赖"><a href="#如果还是不行安装依赖" class="headerlink" title="如果还是不行安装依赖"></a>如果还是不行安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install python-MySQLdb</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>MySQL-Python</category>
      </categories>
      <tags>
        <tag>MySQL-Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.5源码安装postgresql-12</title>
    <url>/2021/02/02/Centos7-5%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85postgresql-12/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><ol>
<li><p>首先安装readline 和readline-devel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install readline </span><br><span class="line">yum install readline-devel</span><br></pre></td></tr></table></figure>
<p>虽然已经安装了readline，但是不安装readlene-devel 在执行 <code>./configure --prefix=/opt/postgresql</code> 的时候会提示，<code>configure: error: readline library not found</code>。</p>
</li>
<li><p>接下来在执行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/postgresql</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li><p>将postgresql 加入环境变量，打开文件 /etc/profile  在末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PG_HOME=/opt/postgresql  #为安装postgresql的地址</span><br><span class="line">export PATH=$PG_HOME/bin:$PATH</span><br><span class="line">source /etc/profile    #更新环境变量</span><br></pre></td></tr></table></figure></li>
<li><p>创建postgresql 的用户以及用户组 可创建可不创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd postgresql   #创建用户组</span><br><span class="line">useradd -G postgresql postgresql   #创建用户</span><br><span class="line">passwd ********    #设置密码  </span><br></pre></td></tr></table></figure>
</li>
<li><p>初始数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl -D /opt/postgresdata initdb&#x27; #初始化数据库</span><br><span class="line">su postgresql   ：使用这个用户进行操作</span><br><span class="line">/opt/postgresdata：地址为存放初始化的文件路径可自定义，   这个文件的用户权限要为 postgresql可操作</span><br><span class="line">pg_ctl  ：postgresql 的控制器，可以对postgresql 进行启动停止等操作</span><br></pre></td></tr></table></figure>
<p>执行以上语句后会再  /opt/postgresdata 路径下生成一些文件</p>
<p><img src="/2021/02/02/Centos7-5%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85postgresql-12/postgresql0.jpg"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>postmaster.pid</td>
<td>首行记录了进程PID</td>
</tr>
<tr>
<td>serverlog</td>
<td>数据库日志</td>
</tr>
<tr>
<td>postgresql.conf</td>
<td>主配置文件(可做定制</td>
</tr>
<tr>
<td>pg_hba.conf</td>
<td>鉴权相关文件</td>
</tr>
<tr>
<td>PG_VERSION</td>
<td>当前主版本号</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>启动数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl start -D /opt/postgredata -l serverlog&#x27;</span><br></pre></td></tr></table></figure>

</li>
<li><p>设置远程访问,在 pg_hba.conf文文件末尾加上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">host all all 0.0.0.0/0 md5</span><br></pre></td></tr></table></figure></li>
<li><p>为了让 postgresql用户可以远程访问，可以通过 psql 设置密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user postgresql with password &#39;*********&#39;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="9">
<li><p>开启远程访问，默认情况下 postgresql 仅仅监听本机的端口，需要编辑 <strong>/opt/postgredata/ postgresql.conf</strong> 文件开启远程IP的访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_addresses &#x3D; &#39;*&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果需要定制端口，可以执行脚本：</span></span><br><span class="line">postgres -p 5430 -D /opt/postgredata &gt;serverlog 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">检查进程是否存活：</span></span><br><span class="line">netstat -nlp |grep `head -1 /opt/postgredata/postmaster.pid`</span><br><span class="line"><span class="meta">#</span><span class="bash">停止数据库进程</span></span><br><span class="line">kill -INT `head -1 /opt/postgredata/postmaster.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>配置自启动</p>
<p>找到源码目录中 <strong><em>contrib/start-scripts/linux\</em></strong>脚本文件，拷贝为 <strong>/etc/init.d/postgressql</strong>。修改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序所在目录</span></span><br><span class="line">prefix=/opt/postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据目录</span></span><br><span class="line">PGDATA=&quot;/opt/postgredata&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行用户</span></span><br><span class="line">PGUSER=postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">PGLOG=&quot;$PGDATA/serverlog&quot;</span><br></pre></td></tr></table></figure>
<p>设置执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/init.d/postgressql		</span><br></pre></td></tr></table></figure>

<p>此后，执行以下命令可以方便的启停服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//手动启动服务</span><br><span class="line">service postgressql start</span><br><span class="line"></span><br><span class="line">//查看服务状态</span><br><span class="line">service postgressql status</span><br><span class="line"></span><br><span class="line">//手动停止服务</span><br><span class="line">service postgressql stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机启动 ,执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add postgressql</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p> <a href="https://www.postgresql.org/download/linux/redhat/">官网安装教程地址</a></p>
<p>安装完成会自动创建一个用户为：postgres  </p>
<p>首先使用管理员用户修改密码，然后登录以后，运行psql 即可使用，</p>
<p>允许远程访问，yum安装的ppostgresql 的配置文件在<code>/var/lib/pgsql/12/data</code> 目录下</p>
<p>修改配置文件 <code>postgresql.conf</code> 将 <code>listen_addresses = &#39;localhost&#39; </code>改为 <code>listen_addresses = &#39;*&#39; </code></p>
<p>然后在修改 <code>pg_hba_conf</code> 在最后一行添加 <code>host all  all  0.0.0.0/0  md5</code>  允许所有IIP访问， 如果限定IP,将0.0.0.0 改为指定IP。</p>
<p>重启命令postgresql  ：<code>systemctl restart postgresql-12</code></p>
<p>参考材料：<a href> https://www.cnblogs.com/littleatp/p/10542137.html </a></p>
]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python压缩图片作为缩略图</title>
    <url>/2021/02/02/Python%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<p>​           </p>
<a id="more"></a>

<p>将图片压缩，作为缩略图，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFile</span><br><span class="line">ImageFile.LOAD_TRUNCATED_IMAGES = <span class="literal">True</span>    <span class="comment">#   OSError: image file is truncated   图像被截断错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize_by_size</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;按照生成图片文件大小进行处理(单位KB)&quot;&quot;&quot;</span></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">        im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">        size_tmp = os.path.getsize(infile)</span><br><span class="line">        q = <span class="number">100</span></span><br><span class="line">        <span class="keyword">while</span> size_tmp &gt; <span class="number">10240</span> <span class="keyword">and</span> q &gt; <span class="number">0</span>:</span><br><span class="line">            out = im.resize(im.size, Image.ANTIALIAS)</span><br><span class="line">            out.save(outfile, quality=q)</span><br><span class="line">            size_tmp = os.path.getsize(outfile)</span><br><span class="line">            q -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> q == <span class="number">100</span>:</span><br><span class="line">            shutil.copy(infile,outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equal_img</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    修改大小</span></span><br><span class="line"><span class="string">    :param cls:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.startswith(<span class="string">&#x27;thumbnail&#x27;</span>) <span class="keyword">or</span> file_name.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 判断是不是图片。不是的话，忽略</span></span><br><span class="line">        <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>,<span class="string">&#x27;JPEG&#x27;</span>]:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&#x27;file_name：&#x27;,outfilename)</span></span><br><span class="line">            outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">            <span class="comment"># print(u&#x27;path：&#x27;,outfile)</span></span><br><span class="line">            im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">            width = im.size[<span class="number">0</span>]   <span class="comment"># 获取宽度</span></span><br><span class="line">            height = im.size[<span class="number">1</span>]   <span class="comment"># 获取高度</span></span><br><span class="line">            print(<span class="string">u&#x27;width：height：&#x27;</span>,width,height)</span><br><span class="line">            <span class="keyword">if</span> width &lt;= <span class="number">200</span>:</span><br><span class="line">                shutil.copy(infile,outfile)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coe = <span class="built_in">float</span>(<span class="string">&#x27;%.2f&#x27;</span>%(<span class="number">200</span>/width))   <span class="comment">#保留两位小数可能是0.00，</span></span><br><span class="line">                print(<span class="string">u&#x27;coe：&#x27;</span>,coe)</span><br><span class="line">                <span class="keyword">if</span> coe &lt;= <span class="number">0</span>:</span><br><span class="line">                    coe = <span class="number">0.15</span></span><br><span class="line">                <span class="keyword">if</span> im.mode == <span class="string">&quot;P&quot;</span>:</span><br><span class="line">                    im = im.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">                out = im.resize((<span class="built_in">int</span>(width*coe), <span class="built_in">int</span>(height*coe)), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">                out.save(outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gci</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="comment">#遍历filepath下所有文件，包括子目录</span></span><br><span class="line">    files = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> fi <span class="keyword">in</span> files:</span><br><span class="line">        fi_d = os.path.join(filepath,fi)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(fi_d):</span><br><span class="line">            gci(fi_d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># resize_by_size(os.path.join(filepath,fi_d))</span></span><br><span class="line">            equal_img(os.path.join(filepath,fi_d))</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归遍历/root目录下所有文件</span></span><br><span class="line"><span class="comment"># gci(&#x27;/var/local/www/edu_online1/media/works&#x27;)</span></span><br><span class="line"><span class="comment"># gci(&#x27;/root/www/edu_online1/media/works/13360067818/tradition&#x27;)  #正式</span></span><br><span class="line">gci(<span class="string">&#x27;/root/www/edu_online1/media/works/13265647342/udict/1552525240000/䤋&#x27;</span>)  <span class="comment">#正式</span></span><br><span class="line"><span class="comment"># gci(r&#x27;F:\desktop\䤋&#x27;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python压缩图片</tag>
      </tags>
  </entry>
  <entry>
    <title>flaskshell创建索引出错</title>
    <url>/2021/02/02/flaskshell%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<p>遇到的问题：flask 环境中使用 flask shell  使用flask Whoosh 创建索引失败</p>
<h3 id="解决办法-："><a href="#解决办法-：" class="headerlink" title="解决办法 ："></a>解决办法 ：</h3><pre><code>export FLASK_APP=manage.py
flask shell 
</code></pre>
<p>然后导出 flask 创建的whoosh的whoosh对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 项目内的文件 import whoosh</span><br><span class="line">whoosh.create_index()</span><br></pre></td></tr></table></figure>

<p>​    </p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Python + Elestatcsearch</title>
    <url>/2021/02/02/Python-Elestatcsearch/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<blockquote>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p> ElasticSearch是一个基于<a href="https://baike.baidu.com/item/Lucene/6753302">Lucene</a>的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353">云计算</a>中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。 </p>
<h2 id="有关概念"><a href="#有关概念" class="headerlink" title="有关概念"></a>有关概念</h2><p>cluster：代表一个<a href="https://baike.baidu.com/item/%E9%9B%86%E7%BE%A4">集群</a>，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</p>
<p>shards：代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</p>
<p>replicas：代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的<a href="https://baike.baidu.com/item/%E5%AE%B9%E9%94%99%E6%80%A7">容错性</a>，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</p>
<p>recovery：代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</p>
<p>river：代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。</p>
<p>gateway：代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分布式文件系统</a>，Hadoop的HDFS和amazon的s3<a href="https://baike.baidu.com/item/%E4%BA%91%E5%AD%98%E5%82%A8">云存储</a>服务。</p>
<p>discovery.zen：代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%92%AD">多播</a>协议来进行节点之间的通信，同时也支持<a href="https://baike.baidu.com/item/%E7%82%B9%E5%AF%B9%E7%82%B9">点对点</a>的交互。</p>
<p>Transport：代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、<a href="https://baike.baidu.com/item/thrift">thrift</a>、servlet、memcached、zeroMQ等的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">传输协议</a>（通过<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6">插件</a>方式集成）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Elestaticsearch</category>
      </categories>
      <tags>
        <tag>Elestaticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Aarch64架构-Linux-编译安装rocketmq-client-cpp</title>
    <url>/2021/02/02/aarch64%E6%9E%B6%E6%9E%84-Linux-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85rocketmq-client-cpp%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Python3.8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>​      </p>
<a id="more"></a>

<h1 id="Aarch64架构-Linux-编译安装rocketmq-client-cpp"><a href="#Aarch64架构-Linux-编译安装rocketmq-client-cpp" class="headerlink" title="Aarch64架构-Linux-编译安装rocketmq-client-cpp"></a>Aarch64架构-Linux-编译安装rocketmq-client-cpp</h1><h2 id="1、安装-Rocketmq-client-cpp-所需工具"><a href="#1、安装-Rocketmq-client-cpp-所需工具" class="headerlink" title="1、安装 Rocketmq-client-cpp 所需工具"></a>1、安装 Rocketmq-client-cpp 所需工具</h2><ul>
<li>gcc-c++ 4.8.2: c++ compiler while need support C++11</li>
<li>cmake 2.8.0: build jsoncpp require it</li>
<li>automake 1.11.1: build libevent require it</li>
<li>autoconf 2.65: build libevent require it</li>
<li>libtool 2.2.6: build libevent require it</li>
</ul>
<h3 id="1-1-检查各项工具是否可用"><a href="#1-1-检查各项工具是否可用" class="headerlink" title="1.1 检查各项工具是否可用"></a>1.1 检查各项工具是否可用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如下提示代表已经安装， 需要指定gcc 版本为 4.8.2 (4.8.5 也可以安装成功)</span></span><br><span class="line">gcc version 10.2.1 20210110 (Raspbian 10.2.1-6+rpi1) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake  -version</span><br><span class="line"></span><br><span class="line">安装地址：https://zhuanlan.zhihu.com/p/110793004</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">automake --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如下提示代表已经安装</span></span><br><span class="line">automake (GNU automake) 1.16.1</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">automake --version</span><br><span class="line"></span><br><span class="line">autoconf (GNU Autoconf) 2.69</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">libtool --version</span><br><span class="line"></span><br><span class="line">libtool (GNU libtool) 2.4.6</span><br></pre></td></tr></table></figure>


<h3 id="1-2-命令行安装-cmake、automake-、autoconf-、libtool-推荐apt-get-安装"><a href="#1-2-命令行安装-cmake、automake-、autoconf-、libtool-推荐apt-get-安装" class="headerlink" title="1.2 命令行安装 cmake、automake 、autoconf 、libtool  (推荐apt-get 安装)"></a>1.2 命令行安装 cmake、automake 、autoconf 、libtool  (推荐apt-get 安装)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake, aotumake, autoconf, libtool, libtool-bin</span><br></pre></td></tr></table></figure>


<h3 id="1-3-源码安装-gcc、cmake、automake-、autoconf-、libtool"><a href="#1-3-源码安装-gcc、cmake、automake-、autoconf-、libtool" class="headerlink" title="1.3 源码安装 gcc、cmake、automake 、autoconf 、libtool"></a>1.3 源码安装 gcc、cmake、automake 、autoconf 、libtool</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mi shellrrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-4.8.2/gcc-4.8.2.tar.gz</span><br><span class="line">tar zxvf  gcc-4.8.2.tar.gz</span><br><span class="line"></span><br><span class="line">configure --prefix=/home/share/tools/usr/gcc-4.8.2 --enable-threads=posix --disable-checking --disable-multilib --enable-languages=c,c+</span><br><span class="line"></span><br><span class="line">make  &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -OL https://github.com/Kitware/CMake/releases/download/v3.23.1/cmake-3.23.1.tar.gz</span><br><span class="line">tar zxvf cmake-3.22.4.tar.gz</span><br><span class="line">cd cmake-3.22.4</span><br><span class="line">./configure --prefix=/home/share/tools/usr/cmake-3.22.4 &amp;&amp; make  &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -OL http://ftpmirror.gnu.org/automake/automake-1.11.1.tar.gz</span><br><span class="line">tar -xzf automake-1.11.1.tar.gz</span><br><span class="line">cd automake-1.11.1</span><br><span class="line">./configure --prefix=/home/share/tools/usr/automake-1.11.1 &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -OL http://ftpmirror.gnu.org/autoconf/autoconf-2.65.tar.gz</span><br><span class="line">tar -xzf autoconf-2.65.tar.gz </span><br><span class="line">cd autoconf-2.65</span><br><span class="line">./configure --prefix=/home/share/tools/us/autoconf &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">curl -OL http://ftpmirror.gnu.org/libtool/libtool-2.2.6.tar.gz</span><br><span class="line">tar -xzf libtool-2.2.6.tar.gz</span><br><span class="line">cd libtool-2.2.6</span><br><span class="line">./configure --prefix=/home/share/tools/usr/libtool-2.2.6 &amp;&amp; make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="2、安装-Rocketma-client-cpp-所需依赖"><a href="#2、安装-Rocketma-client-cpp-所需依赖" class="headerlink" title="2、安装 Rocketma-client-cpp 所需依赖"></a>2、安装 Rocketma-client-cpp 所需依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bzip2-devel</span> </span><br><span class="line"></span><br><span class="line">sudo apt-get install zlib1g</span><br><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zlib-devel</span></span><br><span class="line">sudo apt-get install libbz2-dev</span><br></pre></td></tr></table></figure>

<h2 id="3、安装rocketmq-cpp"><a href="#3、安装rocketmq-cpp" class="headerlink" title="3、安装rocketmq-cpp"></a>3、安装rocketmq-cpp</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd rocketmq-client-cpp-2.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行安装命令， 等待安装。</span></span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure>


<h2 id="4、将编译安装好的so文件建立连接"><a href="#4、将编译安装好的so文件建立连接" class="headerlink" title="4、将编译安装好的so文件建立连接"></a>4、将编译安装好的so文件建立连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /home/zjj/rocketmq/librocketmq.so /usr/lib/librocketmq.so</span><br></pre></td></tr></table></figure>




<h1 id="安装python3-8"><a href="#安装python3-8" class="headerlink" title="安装python3.8"></a>安装python3.8</h1><h2 id="1、下载安装Python"><a href="#1、下载安装Python" class="headerlink" title="1、下载安装Python"></a>1、下载安装Python</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf Python-3.8.13.tgz</span><br><span class="line">cd Python-3.8.13</span><br><span class="line">sudo ./configure </span><br><span class="line">sudo make &amp;&amp; makeinstall</span><br></pre></td></tr></table></figure>
<h2 id="2、设置软连接"><a href="#2、设置软连接" class="headerlink" title="2、设置软连接"></a>2、设置软连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /usr/bin/python3.8/python 编译后的文件地址</span></span><br><span class="line">sudo ln -s /usr/bin/python3.8/python /usr/bin/python38</span><br></pre></td></tr></table></figure>
<h2 id="3、安装-pip"><a href="#3、安装-pip" class="headerlink" title="3、安装 pip"></a>3、安装 pip</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py --no-check-certificate</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>




<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unable to locally verify the issuer&#x27;s authority.</span><br><span class="line">To connect to github.com insecurely, use `--no-check-certificate&#x27;.</span><br></pre></td></tr></table></figure>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p><a href="https://blog.csdn.net/iMatt/article/details/109570935">https://blog.csdn.net/iMatt/article/details/109570935</a></p>
<h2 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unable to resolve host topeet: Name or service not knowncd</span><br></pre></td></tr></table></figure>
<h2 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h2><p><a href="https://blog.csdn.net/ichuzhen/article/details/8241847">https://blog.csdn.net/ichuzhen/article/details/8241847</a></p>
<h2 id="问题3："><a href="#问题3：" class="headerlink" title="问题3："></a>问题3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装libevent提示：</span><br><span class="line">openssl is a must but can not be found.</span><br></pre></td></tr></table></figure>
<h2 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure>


<h2 id="问题4："><a href="#问题4：" class="headerlink" title="问题4："></a>问题4：</h2><p>安装gcc 缺少依赖：GMP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gnu&#x2F;gmp&#x2F;gmp-4.2.tar.gz</span><br><span class="line">tar -zxvf gmp-4.2.tar.gz</span><br><span class="line">cd gmp-4.2</span><br><span class="line">configure --prefix&#x3D;&#x2F;home&#x2F;share&#x2F;tools&#x2F;usr&#x2F;gmp-4.2</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>遇到问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure: error: cannot guess build type; you must specify one</span><br></pre></td></tr></table></figure>
<h2 id="解决：-3"><a href="#解决：-3" class="headerlink" title="解决："></a>解决：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前系统的型号</span></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据钱型号测试</span></span><br><span class="line">configure --prefix=/home/share/tools/usr/gmp-4.2 --build=aarch64-linnx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示错误</span></span><br><span class="line">Invalid configuration `aarch64-linux&#x27;: machine `aarch64&#x27; not recognize</span><br></pre></td></tr></table></figure>
<p>查阅资料：<a href="https://blog.csdn.net/lile777/article/details/81389098">解决</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 gmp-4.2 目录下，根据文章方法下载 config.guess 和 config.sub 文件， 然后替换掉原来的同名文件</span></span><br><span class="line">wget -O config.guess &#x27;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget -O config.sub &#x27;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD&#x27;</span><br></pre></td></tr></table></figure>
<p>再重新配置编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure --prefix=/home/share/tools/usr/gmp-4.2</span><br></pre></td></tr></table></figure>
<p>GMP 安装成功</p>
<h2 id="问题5："><a href="#问题5：" class="headerlink" title="问题5："></a>问题5：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找不到 jsoncpp.a 文件</span><br></pre></td></tr></table></figure>
<h2 id="解决：-4"><a href="#解决：-4" class="headerlink" title="解决："></a>解决：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将  &#x2F;bin&#x2F;aarch64-linux  目录下的jsoncpp.a 文件移动到 &#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>


<h2 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/var/local/mq/producer.py&quot;, line 12, in &lt;module&gt;</span><br><span class="line">    from rocketmq.client import Producer, Message</span><br><span class="line">  File &quot;/usr/local/lib64/python3.8/site-packages/rocketmq/client.py&quot;, line 24, in &lt;module&gt;</span><br><span class="line">    from .ffi import (</span><br><span class="line">  File &quot;/usr/local/lib64/python3.8/site-packages/rocketmq/ffi.py&quot;, line 42, in &lt;module&gt;</span><br><span class="line">    dll = ctypes.cdll.LoadLibrary(_DYLIB_PATH)</span><br><span class="line">  File &quot;/usr/lib64/python3.8/ctypes/__init__.py&quot;, line 451, in LoadLibrary</span><br><span class="line">    return self._dlltype(name)</span><br><span class="line">  File &quot;/usr/lib64/python3.8/ctypes/__init__.py&quot;, line 373, in __init__</span><br><span class="line">    self._handle = _dlopen(self._name, mode)</span><br><span class="line">OSError: librocketmq.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>


<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将librocketmq.so 文件软连接到/usr/lib/librocketmq.so</span> </span><br><span class="line"></span><br><span class="line">ln -s /usr/local/lib/librocketmq.so /usr/lib</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ldconfig </span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h2><p><a href="https://blog.csdn.net/qq_34174198/article/details/120663608">https://blog.csdn.net/qq_34174198/article/details/120663608</a></p>
]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>两台linux 互相传输文件</title>
    <url>/2021/02/02/%E4%B8%A4%E5%8F%B0linux-%E4%BA%92%E7%9B%B8%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<blockquote>
<h4 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h4><h6 id="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"><a href="#rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。" class="headerlink" title="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"></a>rsync是linux系统下的数据<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a><a href="https://baike.baidu.com/item/%E5%A4%87%E4%BB%BD">备份</a>工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。</h6><h5 id="它的特性如下："><a href="#它的特性如下：" class="headerlink" title="它的特性如下："></a>它的特性如下：</h5><ul>
<li><p>可以<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a>保存整个目录树和文件系统。</p>
</li>
<li><p>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</p>
</li>
<li><p>无须特殊权限即可安装。</p>
</li>
<li><p>快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync 在传输数据的过程中可以实行压缩及<a href="https://baike.baidu.com/item/%E8%A7%A3%E5%8E%8B%E7%BC%A9">解压缩</a>操作，因此可以使用更少的带宽。</p>
</li>
<li><p>安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。</p>
</li>
<li><p>支持匿名传输，以方便进行网站镜像。 </p>
</li>
</ul>
</blockquote>
<h4 id="1、Rsync参数说明"><a href="#1、Rsync参数说明" class="headerlink" title="1、Rsync参数说明"></a>1、Rsync参数说明</h4><ol>
<li><p>使用 rsync + ssh 进行加密传输  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh /home/ubuntu/remote_test ubuntu@193.112.102.63:/home/ubuntu/remote_test</span><br></pre></td></tr></table></figure></li>
<li><p>参数设置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v, --verbose 详细模式输出</span><br><span class="line">   -q, --quiet 精简输出模式</span><br><span class="line">   -c, --checksum 打开校验开关，强制对文件传输进行校验</span><br><span class="line">   -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span><br><span class="line">   -r, --recursive 对子目录以递归模式处理</span><br><span class="line">   -R, --relative 使用相对路径信息</span><br><span class="line">   -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">   --backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">   -suffix&#x3D;SUFFIX 定义备份文件前缀</span><br><span class="line">   -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)</span><br><span class="line">   -l, --links 保留软链结</span><br><span class="line">   -L, --copy-links 像对待常规文件一样处理软链接</span><br><span class="line">   --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链接</span><br><span class="line">   --safe-links 忽略指向SRC路径目录树以外的链接</span><br><span class="line">   -H, --hard-links 保留硬链接</span><br><span class="line">   -p, --perms 保持文件权限</span><br><span class="line">   -o, --owner 保持文件属主信息</span><br><span class="line">   -g, --group 保持文件属组信息</span><br><span class="line">   -D, --devices 保持设备文件信息</span><br><span class="line">   -t, --times 保持文件时间信息</span><br><span class="line">   -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间</span><br><span class="line">   -n, --dry-run显示哪些文件将被传输</span><br><span class="line">   -W, --whole-file 拷贝文件，不进行增量检测</span><br><span class="line">   -x, --one-file-system 不要跨越文件系统边界</span><br><span class="line">   -B, --block-size&#x3D;SIZE 检验算法使用的块尺寸，默认是700字节</span><br><span class="line">   -e, --rsh&#x3D;COMMAND 指定使用rsh、ssh方式进行数据同步</span><br><span class="line">   --rsync-path&#x3D;PATH 指定远程服务器上的rsync命令所在路径信息</span><br><span class="line">   -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件</span><br><span class="line">   --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件</span><br><span class="line">   --delete 删除那些DST中SRC没有的文件</span><br><span class="line">   --delete-excluded 同样删除接收端那些被该选项指定排除的文件</span><br><span class="line">   --delete-after 传输结束以后再删除</span><br><span class="line">   --ignore-errors 即使出现IO错误也进行删除</span><br><span class="line">   --max-delete&#x3D;NUM 最多删除NUM个文件</span><br><span class="line">   --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span><br><span class="line">   --force 强制删除目录，即使不为空</span><br><span class="line">   --numeric-ids 不将数字的用户和组ID匹配为用户名和组名</span><br><span class="line">   --timeout&#x3D;TIME IP超时时间，单位为秒</span><br><span class="line">   -I, --ignore-times 不跳过那些有同样的时间和长度的文件</span><br><span class="line">   --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间</span><br><span class="line">   --modify-window&#x3D;NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0</span><br><span class="line">   -T --temp-dir&#x3D;DIR 在DIR中创建临时文件</span><br><span class="line">   --compare-dest&#x3D;DIR 同样比较DIR中的文件来决定是否需要备份</span><br><span class="line">   -P 等同于 --partial</span><br><span class="line">   --progress 显示备份过程</span><br><span class="line">   -z, --compress 对备份的文件在传输时进行压缩处理</span><br><span class="line">   --exclude&#x3D;PATTERN 指定排除不需要传输的文件模式</span><br><span class="line">   --include&#x3D;PATTERN 指定不排除而需要传输的文件模式</span><br><span class="line">   --exclude-from&#x3D;FILE 排除FILE中指定模式的文件</span><br><span class="line">   --include-from&#x3D;FILE 不排除FILE指定模式匹配的文件</span><br><span class="line">   --version 打印版本信息</span><br><span class="line">   --address 绑定到特定的地址</span><br><span class="line">   --config&#x3D;FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件</span><br><span class="line">   --port&#x3D;PORT 指定其他的rsync服务端口</span><br><span class="line">   --blocking-io 对远程shell使用阻塞IO</span><br><span class="line">   -stats 给出某些文件的传输状态</span><br><span class="line">   --progress 在传输时显示传输过程</span><br><span class="line">   --log-format&#x3D;formAT 指定日志文件格式</span><br><span class="line">   --password-file&#x3D;FILE 从FILE中得到密码</span><br><span class="line">   --bwlimit&#x3D;KBPS 限制I&#x2F;O带宽，KBytes per second</span><br><span class="line">   -h, --help 显示帮助信息</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2、目的"><a href="#2、目的" class="headerlink" title="2、目的"></a>2、目的</h4><ul>
<li><p>实现两台服务器之间做增量备份。A服务器作为服务端，B服务器作为客户端。</p>
</li>
<li><p>B服务器每天定时将某个目录下产生的文件发送到A服务器中。</p>
</li>
</ul>
<h4 id="3、操作方法"><a href="#3、操作方法" class="headerlink" title="3、操作方法"></a>3、操作方法</h4><p>在A服务器中安装 rsync ，查看服务器是否安装rsync。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync --version</span><br><span class="line">#显示如下  代表已经安装  版本为：3.1.1  (确保两台服务器之前安装的版本的一致，不一致可能造成无法同步数据)</span><br><span class="line">rsync  version 3.1.2  protocol version 31</span><br><span class="line">Copyright (C) 1996-2015 by Andrew Tridgell, Wayne Davison, and others.</span><br><span class="line">Web site: http:&#x2F;&#x2F;rsync.samba.org&#x2F;</span><br><span class="line">Capabilities:</span><br><span class="line">    64-bit files, 64-bit inums, 64-bit timestamps, 64-bit long ints,</span><br><span class="line">    socketpairs, hardlinks, symlinks, IPv6, batchfiles, inplace,</span><br><span class="line">    append, ACLs, xattrs, iconv, symtimes, prealloc</span><br><span class="line"></span><br><span class="line">rsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you</span><br><span class="line">are welcome to redistribute it under certain conditions.  See the GNU</span><br><span class="line">General Public Licence for details.</span><br></pre></td></tr></table></figure>
<p>两边都安装完成了以后，就可以使用了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh 001 ubuntu@193.112.102.63:/home/ubuntu/remote_test   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ssh模式连接 需要输入密码</span></span><br></pre></td></tr></table></figure>
<h5 id="1-将A服务器作为服务端"><a href="#1-将A服务器作为服务端" class="headerlink" title="1. 将A服务器作为服务端"></a>1. 将A服务器作为服务端</h5><p>编辑文件 <code>/etc/vi /etc/rsyncd.conf</code>默认不存在， 直接创建 。编辑输入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务端配置文件 (和上面一样)</span></span><br><span class="line">motd file = /etc/rsyncd.motd</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsyncd.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line">[workspace]  #模块名 在客户端需要用到</span><br><span class="line">path = /devdata/backres   #需要备份的路径</span><br><span class="line">comment = Test</span><br><span class="line">uid = root   #使用的用户</span><br><span class="line">gid = root   #同上 </span><br><span class="line">read only = false   #是否可写</span><br><span class="line">auth users = root   #验证的用户</span><br><span class="line">secrets file = /etc/rsyncd.pass   #密码文件  文件的权限：600</span><br><span class="line">transfer logging = yes   #日志输出</span><br><span class="line">hosts allow=123.207.165.19   #允许的可短的IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建密码文件 在上述的conf文件中，倒数第三行。内容为当前用户名以及密码 。格式：user：password。密码文件拥有用户必须为当前用户 ubuntu 且权限必须为 600</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu:123456</span><br></pre></td></tr></table></figure>
<p>查看rsync 状态 ： <code>service rsync status</code>。 重启rsync服务： <code>service rsync restart</code></p>
<h5 id="2-将b服务器作为客户端"><a href="#2-将b服务器作为客户端" class="headerlink" title="2. 将b服务器作为客户端"></a>2. 将b服务器作为客户端</h5><p>客户端不需要设置太多内容可直接运行命令，不过需要手动输入密码，可将密码存在一个文件内，使用<code>--password-file=FILE</code> 进行从文件中读取密码。这个文件路径任意。文件内容只包含服务端密码即可。但是必须为root用户拥有且权限为600。</p>
<p>使用命令 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rsync -aqr --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数解释：</span></span><br><span class="line">-a：--archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，</span><br><span class="line">-q：--quiet 精简输出模式</span><br><span class="line">-r：--recursive 对子目录以递归模式处理</span><br><span class="line">workspace：即服务端的模块名</span><br></pre></td></tr></table></figure>
<h5 id="3-设置定时任务"><a href="#3-设置定时任务" class="headerlink" title="3. 设置定时任务"></a>3. 设置定时任务</h5><p>使用ubuntu 的crontab </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>第一次打开会选择的编辑器，一般选择vim,输入数字即可。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Select an editor.  To change later, run &#x27;select-editor&#x27;.</span><br><span class="line">  1. /bin/ed</span><br><span class="line">  2. /bin/nano        &lt;---- easiest</span><br><span class="line">  3. /usr/bin/vim.basic</span><br><span class="line">  4. /usr/bin/vim.tiny</span><br></pre></td></tr></table></figure>
<p>定时任务格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* * * * * command    </span><br><span class="line">用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</span><br><span class="line">minute hour day month week command</span><br><span class="line">其中：</span><br><span class="line">minute：表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</span><br><span class="line">/ 斜杠代表频率 例如：</span><br><span class="line">如果想每分钟都执行一次的话就采用默认的 * * * * *</span><br><span class="line">如果想每五分钟执行一次可以 */5 * * * * </span><br><span class="line">如果是每两个小时执行一次的话 那就是 *  */2 * * *来设置;</span><br></pre></td></tr></table></figure>
<p>在定时任务中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">30 23 * * * sudo rsync -r --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br><span class="line"><span class="meta">#</span><span class="bash">表示 在每天的23:30 进行数据备份</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN的工作原理</title>
    <url>/2021/02/01/CDN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="CDN访问的两个阶段"><a href="#CDN访问的两个阶段" class="headerlink" title="CDN访问的两个阶段"></a>CDN访问的两个阶段</h3><ul>
<li>1.域名解析</li>
<li>2.内容请求</li>
</ul>
<a id="more"></a>

<h3 id="使用CDN得两种方式："><a href="#使用CDN得两种方式：" class="headerlink" title="使用CDN得两种方式："></a>使用CDN得两种方式：</h3><ul>
<li>手工上传静态资源文件到CDN</li>
<li>tongguo Tengine 把本机的静态资源开放发哦web上，CDN自动回流到Tengine。</li>
</ul>
<h4 id="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"><a href="#以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。" class="headerlink" title="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"></a>以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。</h4><ul>
<li>生成静态文件上传到阿里元OSS。</li>
<li>配置CDN域名，回源地址指向OSS Bucket，配置Referer 防盗链的白名单。</li>
<li>配置OSS Buket 的匿名可以读。</li>
<li>设置STATIC_URL， 直接指向CDN地址，同时注释掉 OssStaticStorage。</li>
</ul>
]]></content>
      <tags>
        <tag>HTTP、前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之美：dajngo的常用插件</title>
    <url>/2021/02/01/Django%E4%B9%8B%E7%BE%8E%EF%BC%9Adajngo%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<h1 id="Djgnao-常用扩展"><a href="#Djgnao-常用扩展" class="headerlink" title="Djgnao 常用扩展"></a>Djgnao 常用扩展</h1><ul>
<li><p><a href="https://django-debug-toolbar.readthedocs.io/en/latest/">django_debug_toolbar </a>：提供一个可以查看debug信息的面板（包括SQL执行时间，页面耗时）</p>
</li>
<li><p><a href="https://github.com/jazzband/django-silk">django-silk</a>：django性能瓶颈分析</p>
</li>
<li><p><a href="https://simpleui.72wo.com/docs/simpleui/doc.html">Simple-UI</a> ：于Element UI 和 VUE 的django admin 主题。</p>
</li>
<li><p><a href="https://django-haystack.readthedocs.io/en/master/">haystack django</a> ：模块化搜索方案</p>
</li>
<li><p><a href="https://github.com/django-notifications/django-notifications">django-notifications</a>：发送消息通知插件</p>
</li>
<li><p><a href="https://github.com/agusmakmun/django-markdown-editor">django markdown editor</a> ：Markdown 编辑器</p>
</li>
<li><p><a href="https://github.com/django-crispy-forms/django-crispy-forms">django-crispy-forms</a>：Crispy 表单，以一种非常优雅的、干净的方式来创建表单。</p>
</li>
<li><p><a href="https://github.com/mbi/django-simple-captcha">django-simple-captcha</a>：Django验证码</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 8.0 连接数据库错误</title>
    <url>/2021/02/01/Mysql%208.0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<p>MySQl 8.0 连接数据库出现以下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The user specified as a definer (‘mysql.infoschema‘@‘localhost‘) does not exist</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ol>
<li>重新创建该用户（mysql.infoschema）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;mysql.infoschema&#x27;</span> @ <span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>给用户赋予权限</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;mysql.infoschema&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>刷新数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
