<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>域名出售</title>
    <url>/2023/10/16/%E5%9F%9F%E5%90%8D%E5%87%BA%E5%94%AE/</url>
    <content><![CDATA[<h1 id="域名出售"><a href="#域名出售" class="headerlink" title="域名出售"></a>域名出售</h1><table>
<thead>
<tr>
<th align="center">域名</th>
<th align="center">释义</th>
<th align="center">出售状态</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="http://bieshen.com/">bieshen.com</a></td>
<td align="center">别神？鳖神</td>
<td align="center">未出售</td>
<td>￥768</td>
</tr>
<tr>
<td align="center"><a href="http://paobuquan.com/">paobuquan.com</a></td>
<td align="center">跑步圈?</td>
<td align="center">未出售</td>
<td>￥1200</td>
</tr>
<tr>
<td align="center"><a href="http://shoupiaobao.com/">shoupiaobao.com</a></td>
<td align="center">售票宝?</td>
<td align="center">未出售</td>
<td>￥1200</td>
</tr>
<tr>
<td align="center"><a href="http://ruannai.com/">ruannai.com</a></td>
<td align="center">软、奶?</td>
<td align="center">未出售</td>
<td>￥900</td>
</tr>
<tr>
<td align="center"><a href="http://ninth.games/">ninth.games</a></td>
<td align="center">第九艺术-游戏?</td>
<td align="center">未出售</td>
<td>￥1500</td>
</tr>
</tbody></table>
<p>联系邮箱：<a href="mailto:&#99;&#104;&#97;&#105;&#x7a;&#122;&#x6f;&#107;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;">&#99;&#104;&#97;&#105;&#x7a;&#122;&#x6f;&#107;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;</a></p>
]]></content>
  </entry>
  <entry>
    <title>Flask源码解析之启动流程（FlaskV3.0.x）</title>
    <url>/2023/11/10/Flask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>​                  </p>
<a id="more"></a>

<h1 id="Flask源码解析之启动流程"><a href="#Flask源码解析之启动流程" class="headerlink" title="Flask源码解析之启动流程"></a>Flask源码解析之启动流程</h1><h2 id="1-最小的-Flask-程序"><a href="#1-最小的-Flask-程序" class="headerlink" title="1. 最小的 Flask 程序"></a>1. 最小的 Flask 程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask <span class="comment"># ①</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__) <span class="comment"># ②</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>) </span><span class="comment"># ③</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;p&gt;Hello， World!&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run() <span class="comment"># ④</span></span><br></pre></td></tr></table></figure>
<p>我们先从使用代码启动的方式来看， 暂时不看使用命令行的方式启动的过程。</p>
<p>我们安装代码的执行顺序从上往下看</p>
<p>①第一步 导入<code>Flask</code>对象。</p>
<p>②实例化<code>app</code>对象。在内部执行类的<code>__init__</code>方法。</p>
<p>③创建路由和视图函数。</p>
<p>④执行 <code>app.run()</code>。</p>
<h2 id="2-查看-app-源码"><a href="#2-查看-app-源码" class="headerlink" title="2. 查看 app 源码"></a>2. 查看 app 源码</h2><p>我们进入<code>app</code>的源码中查看<code>__init__</code>发生了什么（其他的一些类属性先不管）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params">App</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self，</span></span></span><br><span class="line"><span class="function"><span class="params">        import_name: <span class="built_in">str</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        static_url_path: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        static_folder: <span class="built_in">str</span> | os.PathLike | <span class="literal">None</span> = <span class="string">&quot;static&quot;</span>， <span class="comment"># ①</span></span></span></span><br><span class="line"><span class="function"><span class="params">        static_host: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        host_matching: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        subdomain_matching: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        template_folder: <span class="built_in">str</span> | os.PathLike | <span class="literal">None</span> = <span class="string">&quot;templates&quot;</span>， <span class="comment"># ①</span></span></span></span><br><span class="line"><span class="function"><span class="params">        instance_path: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        instance_relative_config: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        root_path: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(</span><br><span class="line">            import_name=import_name，</span><br><span class="line">            static_url_path=static_url_path，</span><br><span class="line">            static_folder=static_folder，</span><br><span class="line">            static_host=static_host，</span><br><span class="line">            host_matching=host_matching，</span><br><span class="line">            subdomain_matching=subdomain_matching，</span><br><span class="line">            template_folder=template_folder，</span><br><span class="line">            instance_path=instance_path，</span><br><span class="line">            instance_relative_config=instance_relative_config，</span><br><span class="line">            root_path=root_path，</span><br><span class="line">        ) <span class="comment"># ②</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.has_static_folder:</span><br><span class="line">            <span class="keyword">assert</span> (</span><br><span class="line">                <span class="built_in">bool</span>(static_host) == host_matching</span><br><span class="line">            )， <span class="string">&quot;Invalid static_host/host_matching combination&quot;</span></span><br><span class="line"></span><br><span class="line">            self_ref = weakref.ref(self)</span><br><span class="line">            self.add_url_rule( <span class="comment"># ③</span></span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;self.static_url_path&#125;</span>/&lt;path:filename&gt;&quot;</span>，</span><br><span class="line">                endpoint=<span class="string">&quot;static&quot;</span>，</span><br><span class="line">                host=static_host，</span><br><span class="line">                view_func=<span class="keyword">lambda</span> **kw: self_ref().send_static_file(**kw)，</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<p>在①处<code>Flask</code>设置了静态文件默认路径和模板文件的路径。</p>
<p>在②处执行了父类的<code>init</code>文件。</p>
<p>在③的地方添加了静态文件的路由， 所以<code>Flask</code>在初始化的时候，我们不指定配置文件时，会有默认的路由创建。</p>
<h2 id="3-我们再看-app-run-的方法"><a href="#3-我们再看-app-run-的方法" class="headerlink" title="3. 我们再看 app.run()的方法"></a>3. 我们再看 app.run()的方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params">App</span>):</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self，</span></span></span><br><span class="line"><span class="function"><span class="params">        host: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        port: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        debug: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        load_dotenv: <span class="built_in">bool</span> = <span class="literal">True</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        **options: t.Any，</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        “”“</span><br><span class="line">         本地开发的启动方式， 不要再生产服务器使用的一些注意事项</span><br><span class="line">        ”“”</span><br><span class="line">        <span class="comment"># ... </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> run_simple</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            run_simple(t.cast(<span class="built_in">str</span>， host)， port， self， **options) <span class="comment"># ①</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._got_first_request = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>在①的上面都是针对<code>host</code>、<code>port</code>以及环境变量的的一些配置。<code>run</code>方法中真正执行的是<code>werkzeug</code>的<code>run_simple</code>方法。他接受了一个<code>host</code>参数，一个<code>port</code>参数，和一个<code>self</code>， 这个<code>self</code>就是<code>Flask</code>本身的实例。</p>
<h2 id="4-run-simple-的源码。"><a href="#4-run-simple-的源码。" class="headerlink" title="4. run_simple 的源码。"></a>4. run_simple 的源码。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_simple</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    hostname: <span class="built_in">str</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    port: <span class="built_in">int</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    application: WSGIApplication，</span></span></span><br><span class="line"><span class="function"><span class="params">    use_reloader: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    use_debugger: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    use_evalex: <span class="built_in">bool</span> = <span class="literal">True</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    extra_files: t.Iterable[<span class="built_in">str</span>] | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    exclude_patterns: t.Iterable[<span class="built_in">str</span>] | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    reloader_interval: <span class="built_in">int</span> = <span class="number">1</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    reloader_type: <span class="built_in">str</span> = <span class="string">&quot;auto&quot;</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    threaded: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    processes: <span class="built_in">int</span> = <span class="number">1</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    request_handler: <span class="built_in">type</span>[WSGIRequestHandler] | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    static_files: <span class="built_in">dict</span>[<span class="built_in">str</span>， <span class="built_in">str</span> | <span class="built_in">tuple</span>[<span class="built_in">str</span>， <span class="built_in">str</span>]] | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    passthrough_errors: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    ssl_context: _TSSLContextArg | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在内部启动了WSGI服务器， 即socket服务， 然后等待用户访问具体的路由。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(port， <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;port must be an integer&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> static_files:</span><br><span class="line">        <span class="keyword">from</span> .middleware.shared_data <span class="keyword">import</span> SharedDataMiddleware</span><br><span class="line"></span><br><span class="line">        application = SharedDataMiddleware(application， static_files)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> use_debugger:</span><br><span class="line">        <span class="keyword">from</span> .debug <span class="keyword">import</span> DebuggedApplication</span><br><span class="line"></span><br><span class="line">        application = DebuggedApplication(application， evalex=use_evalex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_running_from_reloader():</span><br><span class="line">        fd = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fd = <span class="built_in">int</span>(os.environ[<span class="string">&quot;WERKZEUG_SERVER_FD&quot;</span>])</span><br><span class="line"></span><br><span class="line">    srv = make_server(</span><br><span class="line">        hostname，</span><br><span class="line">        port，</span><br><span class="line">        application，</span><br><span class="line">        threaded，</span><br><span class="line">        processes，</span><br><span class="line">        request_handler，</span><br><span class="line">        passthrough_errors，</span><br><span class="line">        ssl_context，</span><br><span class="line">        fd=fd，</span><br><span class="line">    ) <span class="comment"># ①</span></span><br><span class="line">    srv.socket.set_inheritable(<span class="literal">True</span>)</span><br><span class="line">    os.environ[<span class="string">&quot;WERKZEUG_SERVER_FD&quot;</span>] = <span class="built_in">str</span>(srv.fileno())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_running_from_reloader():</span><br><span class="line">        srv.log_startup()</span><br><span class="line">        _log(<span class="string">&quot;info&quot;</span>， _ansi_style(<span class="string">&quot;Press CTRL+C to quit&quot;</span>， <span class="string">&quot;yellow&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> use_reloader:</span><br><span class="line">        <span class="keyword">from</span> ._reloader <span class="keyword">import</span> run_with_reloader</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            run_with_reloader(</span><br><span class="line">                srv.serve_forever，</span><br><span class="line">                extra_files=extra_files，</span><br><span class="line">                exclude_patterns=exclude_patterns，</span><br><span class="line">                interval=reloader_interval，</span><br><span class="line">                reloader_type=reloader_type，</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            srv.server_close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        srv.serve_forever() <span class="comment"># ②</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在①处滴调用<code>make_server</code>方法返回了实例化后的<code>WSGI</code>服务对象，并在②处调用<code>serve_forever</code>方法，启动服务等待接受请求。而<code>WSGI</code>对象内部实现了一个<code>socket</code>服务，他继承了<code>HTTPServer</code>，<code>HTTPServer</code>又继承了<code>socketserver.TCPServer</code>。</p>
<h2 id="5-make-server"><a href="#5-make-server" class="headerlink" title="5. make_server"></a>5. make_server</h2><p>不考虑其他的情况，我们看到返回了一个实例化的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_server</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    host: <span class="built_in">str</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    port: <span class="built_in">int</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    app: WSGIApplication，</span></span></span><br><span class="line"><span class="function"><span class="params">    threaded: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    processes: <span class="built_in">int</span> = <span class="number">1</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    request_handler: <span class="built_in">type</span>[WSGIRequestHandler] | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    passthrough_errors: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    ssl_context: _TSSLContextArg | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    fd: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) -&gt; BaseWSGIServer:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BaseWSGIServer(</span><br><span class="line">        host， port， app， request_handler， passthrough_errors， ssl_context， fd=fd</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>其实到这里<code>Flask</code>启动的流程已经大致结束了，但是我们可以结合上一篇文章《Flask源码解析之路由》来看看一个路由到来的整个流程。</p>
<h2 id="6-整个服务启动请求流程"><a href="#6-整个服务启动请求流程" class="headerlink" title="6. 整个服务启动请求流程"></a>6. 整个服务启动请求流程</h2><h3 id="6-1前置知识"><a href="#6-1前置知识" class="headerlink" title="6.1前置知识"></a>6.1前置知识</h3><h4 id="6-1-1-TCP-服务的执行流程"><a href="#6-1-1-TCP-服务的执行流程" class="headerlink" title="6.1.1 TCP 服务的执行流程"></a>6.1.1 TCP 服务的执行流程</h4><p>我们可以通过查看<code>Python</code>的文档，去看看如何实现一个<code>TCPServer</code>。</p>
<p><img src="https://origin.chaizz.com/tc/image-20231113103006592.png" alt="image-20231113103006592"></p>
<p>在启动一个<code>TCPServer</code>的时候他接受一个继承<code>BaseHTTPRequestHandler的Handler</code>对象，然后当请求到来的时候执行内部的<code>handle</code>方法。具体的<code>TCPServer</code>执行流程大致如下：</p>
<h4 id="6-1-2-with语句"><a href="#6-1-2-with语句" class="headerlink" title="6.1.2 with语句"></a>6.1.2 with语句</h4><p>通过<code>with</code>语句创建<code>tcp</code>对象，初始化一些参数，创建<code>socket</code>对象，绑定地址和开启监听。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span>(<span class="params">BaseServer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self， server_address， RequestHandlerClass， bind_and_activate=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="comment"># 执行父类的初始化方法</span></span><br><span class="line">        BaseServer.__init__(self， server_address， RequestHandlerClass)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        self.server_bind()</span><br><span class="line">        self.server_activate()</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">server_bind</span>(<span class="params">self</span>):</span> ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_activate</span>(<span class="params">self</span>):</span> ...</span><br></pre></td></tr></table></figure>
<h4 id="6-1-3-serve-forever-方法"><a href="#6-1-3-serve-forever-方法" class="headerlink" title="6.1.3 serve_forever 方法"></a>6.1.3 serve_forever 方法</h4><p>父类的<code>with</code>语句<code>__enter__</code>方法返回<code>self</code>， 调用<code>self.serve_forever</code>方法，<code>TCPServer</code>未实现所以查找<code>BaseServer</code>的<code>serve_forever</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseServer</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self， server_address， RequestHandlerClass</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor.  May be extended， do not override.&quot;&quot;&quot;</span></span><br><span class="line">        self.server_address = server_address</span><br><span class="line">        self.RequestHandlerClass = RequestHandlerClass</span><br><span class="line">        self.__is_shut_down = threading.Event()</span><br><span class="line">        self.__shutdown_request = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span>(<span class="params">self， poll_interval=<span class="number">0.5</span></span>):</span></span><br><span class="line">        self.__is_shut_down.clear()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> _ServerSelector() <span class="keyword">as</span> selector:</span><br><span class="line">                selector.register(self， selectors.EVENT_READ)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">not</span> self.__shutdown_request:</span><br><span class="line">                    ready = selector.select(poll_interval)</span><br><span class="line">                    <span class="keyword">if</span> self.__shutdown_request:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> ready:</span><br><span class="line">                        <span class="comment"># 执行此方法，获取请求</span></span><br><span class="line">                        self._handle_request_noblock()</span><br><span class="line"></span><br><span class="line">                    self.service_actions()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.__shutdown_request = <span class="literal">False</span></span><br><span class="line">            self.__is_shut_down.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>
<h4 id="6-1-4-handle-request-noblock-方法"><a href="#6-1-4-handle-request-noblock-方法" class="headerlink" title="6.1.4 _handle_request_noblock 方法"></a>6.1.4 _handle_request_noblock 方法</h4><p>在<code>serve_forever</code>中执行了<code>_handle_request_noblock</code>方法获取请求。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseServer</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_handle_request_noblock</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取socket接受的对象</span></span><br><span class="line">            request， client_address = self.get_request()</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 验证请求</span></span><br><span class="line">        <span class="keyword">if</span> self.verify_request(request， client_address):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 处理请求</span></span><br><span class="line">                self.process_request(request， client_address)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                self.handle_error(request， client_address)</span><br><span class="line">                self.shutdown_request(request)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.shutdown_request(request)</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self， request， client_address</span>):</span></span><br><span class="line">        self.finish_request(request， client_address)</span><br><span class="line">        self.shutdown_request(request)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish_request</span>(<span class="params">self， request， client_address</span>):</span></span><br><span class="line">        <span class="comment"># 调用 处理请求类。</span></span><br><span class="line">        self.RequestHandlerClass(request， client_address， self)</span><br></pre></td></tr></table></figure>
<h4 id="6-1-5-RequestHandlerClass"><a href="#6-1-5-RequestHandlerClass" class="headerlink" title="6.1.5 RequestHandlerClass"></a>6.1.5 RequestHandlerClass</h4><p>接下来我们再看<code>TCPServer</code>中的<code>RequestHandlerClass</code>是如何实现的。在上面<code>Python</code>官方文档示例中：<code>TCPServer</code>自定义了一个<code>MyTCPHandler</code>他继承了<code>socketserver.BaseRequestHandler</code>。我们查看这个类的实现方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequestHandler</span>:</span></span><br><span class="line">    “”“</span><br><span class="line">    	这个类是为要处理的每个请求实例化的。构造函数设置实例变量request、client_address 			server，然后调用handle（）方法。要实现一个特定的服务，您所需要做的就是派生一个定义			handle（）方法的类。</span><br><span class="line">    “”“</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self， request， client_address， server</span>):</span></span><br><span class="line">        self.request = request</span><br><span class="line">        self.client_address = client_address</span><br><span class="line">        self.server = server</span><br><span class="line">        self.setup()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 执行handle 方法</span></span><br><span class="line">            self.handle 方法()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.finish()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>我们可以根据注释了解到，他是一个专门处理请求类的基类，我们要自定义<code>TCPServcer</code>，就要继承他实现一个子类。在他的<code>init</code>方法中调用<code>handle</code>方法。</p>
<p>这下我们终于知道了为什么我们自己写一个<code>TCPServer</code>时，为什么要自己实现一个<code>Handler</code>类，且要实现<code>handle</code>方法了。</p>
<h2 id="7-WSGIRequestHandler"><a href="#7-WSGIRequestHandler" class="headerlink" title="7. WSGIRequestHandler"></a>7. WSGIRequestHandler</h2><p>让我们再回到<code>Flask</code>的源码中，在<code>BaseWSGIServer</code>中同样有属性是<code>handle</code>， 他的的类型是，<code>WSGIRequestHandler</code>。但是他不是直接继承<code>socketserver.BaseRequestHandler</code>而是<code>socketserver.StreamRequestHandler</code>， 其实也是一样的，只不过<code>StreamRequestHandler</code>在对<code>BaseRequestHandler</code>封装了一层而已。接下来我们看<code>WSGIRequestHandler</code>的源码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIRequestHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 调用了父类的 handle 方法</span></span><br><span class="line">            <span class="built_in">super</span>().handle()</span><br><span class="line">        <span class="keyword">except</span> (ConnectionError， socket.timeout) <span class="keyword">as</span> e:</span><br><span class="line">            self.connection_dropped(e)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> self.server.ssl_context <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> is_ssl_error(e):</span><br><span class="line">                self.log_error(<span class="string">&quot;SSL error occurred: %s&quot;</span>， e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<p>在<code>handle</code>中调用了父类的<code>handle</code>方法，我们再看父类的<code>handle</code>方法。执行了<code>handle_one_request</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHTTPRequestHandler</span>(<span class="params">socketserver.StreamRequestHandler</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_one_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.raw_requestline = self.rfile.readline(<span class="number">65537</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.raw_requestline) &gt; <span class="number">65536</span>:</span><br><span class="line">                self.requestline = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                self.request_version = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                self.command = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                self.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.raw_requestline:</span><br><span class="line">                self.close_connection = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.parse_request():</span><br><span class="line">                <span class="comment"># An error code has been sent， just exit</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mname = <span class="string">&#x27;do_&#x27;</span> + self.command</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(self， mname):</span><br><span class="line">                self.send_error(</span><br><span class="line">                    HTTPStatus.NOT_IMPLEMENTED，</span><br><span class="line">                    <span class="string">&quot;Unsupported method (%r)&quot;</span> % self.command)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 通过 getattr 获取 mname， 然后执行 mname 方法</span></span><br><span class="line">            method = <span class="built_in">getattr</span>(self， mname)</span><br><span class="line">            method()</span><br><span class="line">            self.wfile.flush() <span class="comment">#actually send the response if not already done.</span></span><br><span class="line">        <span class="keyword">except</span> TimeoutError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment">#a read or a write timed out.  Discard this connection</span></span><br><span class="line">            self.log_error(<span class="string">&quot;Request timed out: %r&quot;</span>， e)</span><br><span class="line">            self.close_connection = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Handle multiple requests if necessary.&quot;&quot;&quot;</span></span><br><span class="line">        self.close_connection = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        self.handle_one_request()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.close_connection:</span><br><span class="line">            self.handle_one_request()</span><br></pre></td></tr></table></figure>
<h3 id="7-1-getattr-方法"><a href="#7-1-getattr-方法" class="headerlink" title="7.1  _getattr_ 方法"></a>7.1  <em>_getattr_</em> 方法</h3><p>此方法中重要的一段代码是执行了<code>method</code>方法。这个方法是通过<code>getattr</code>获取的。 <code>getattr</code>方法会执行 类中的<code>__getattr__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIRequestHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self， name: <span class="built_in">str</span></span>) -&gt; t.Any:</span></span><br><span class="line">        <span class="comment"># All HTTP methods are handled by run_wsgi.</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&quot;do_&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> self.run_wsgi</span><br><span class="line"></span><br><span class="line">        <span class="comment"># All other attributes are forwarded to the base class.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(<span class="built_in">super</span>()， name)</span><br></pre></td></tr></table></figure>
<h3 id="7-2-run-wsgi-方法"><a href="#7-2-run-wsgi-方法" class="headerlink" title="7.2 run_wsgi 方法"></a>7.2 run_wsgi 方法</h3><p>它又调用了<code>run_wsgi</code>方法，再看<code>run_wsgi</code>的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIRequestHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_wsgi</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">		<span class="comment"># ...</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">app: WSGIApplication</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">            application_iter = app(environ， start_response)</span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">try</span>:            </span><br><span class="line">            <span class="comment"># ================= 重点 =================</span></span><br><span class="line">            execute(self.server.app)</span><br><span class="line">            <span class="comment"># ================= 重点 =================</span></span><br><span class="line">        <span class="keyword">except</span> (ConnectionError， socket.timeout) <span class="keyword">as</span> e:</span><br><span class="line">            self.connection_dropped(e， environ)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">			<span class="comment"># ...</span></span><br></pre></td></tr></table></figure>


<h3 id="7-3-execute方法"><a href="#7-3-execute方法" class="headerlink" title="7.3 execute方法"></a>7.3 execute方法</h3><p>在<code>run_wsgi</code>方法中最终执行了<code>execute</code>方法，它接受了一个参数<code>self.server.app</code>， 我可以先看看这个<code>self.server.app</code>参数是谁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIRequestHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span>        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">app: WSGIApplication</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        application_iter = app(environ， start_response)</span><br><span class="line">		<span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-excute-的参数-self-server-app"><a href="#7-4-excute-的参数-self-server-app" class="headerlink" title="7.4 excute 的参数 self.server.app"></a>7.4 excute 的参数 self.server.app</h3><p>我们先回到【6.1.4 _handle_request_noblock 方法】步骤， 在<code>finish_request</code>方法中实例化了<code>self.RequestHandlerClass(request, client_address, self)</code> 这个 <code>RequestHandlerClass</code> 也就是我们现在看到的 <code>WSGIRequestHandler</code> ，但是他没有初始化的步骤，所以是继承了基类的初始化方法。我们看代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequestHandler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self， request， client_address， server</span>):</span></span><br><span class="line">        self.request = request</span><br><span class="line">        self.client_address = client_address</span><br><span class="line">        <span class="comment"># 赋值 server 给 self.server</span></span><br><span class="line">        self.server = server</span><br><span class="line">        self.setup()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.handle()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.finish()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamRequestHandler</span>(<span class="params">BaseRequestHandler</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHTTPRequestHandler</span>(<span class="params">socketserver.StreamRequestHandler</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIRequestHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这里的<code>self.server</code>正是<code>BaseServer</code>类或者是他的子类。<code>self.server.app</code>正是<code>BaseServer</code>的<code>app</code>属性。</p>
<p>我们再回到 第四步<code>run_simple</code>的源码中，它调用了<code>make_server</code>方法 创建了<code>BaseWSGIServer</code>实例，所以上面的这句话【 这里的<code>self.server</code>正是<code>BaseServer</code>类或者是他的子类】中指的类</p>
<p>就是<code>BaseWSGIServer</code>这个类。 我们看代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseServer</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span>(<span class="params">BaseServer</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPServer</span>(<span class="params">TCPServer</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseWSGIServer</span>(<span class="params">HTTPServer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self，</span></span></span><br><span class="line"><span class="function"><span class="params">        host: <span class="built_in">str</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        port: <span class="built_in">int</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        app: WSGIApplication，</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="built_in">type</span>[WSGIRequestHandler] | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        passthrough_errors: <span class="built_in">bool</span> = <span class="literal">False</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        ssl_context: _TSSLContextArg | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        fd: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            handler = WSGIRequestHandler</span><br><span class="line"></span><br><span class="line">        self.app = app</span><br></pre></td></tr></table></figure>


<p>所以<code>self.server.app</code>指的就是<code>BaseWSGIServer</code>中初始化传过来的<code>app</code>实参。 那<code>app</code>是谁呢， 就很显而易见了。</p>
<p>是由<code>run_simple(hostname， port， application，...) --&gt;  make_server(hostname， port， application，...) --&gt;  BaseWSGIServer(hostname， port， application，...)</code></p>
<p>一步一步传过来的。</p>
<p><code>run_simple</code>又是在<code>Flask</code>的<code>run</code>方法中调用的， 第三个参数正是<code>self</code>，即<code>Flask</code>实例对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params">App</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self，</span></span></span><br><span class="line"><span class="function"><span class="params">        host: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        port: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        debug: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        load_dotenv: <span class="built_in">bool</span> = <span class="literal">True</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">        **options: t.Any，</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> run_simple</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            run_simple(t.cast(<span class="built_in">str</span>， host)， port， self， **options)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._got_first_request = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>所以<code>excute</code>的参数<code>self.server.app</code>正是<code>Flask</code>实例对象。</p>
<p>我们再回到 【7.3 execute方法】，在其内部执行了<code>app(environ, start_response)</code>， 也就是执行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flask_obj = Flask()</span><br><span class="line">flask_obj()</span><br></pre></td></tr></table></figure>
<p>当我们调用实例对象的方法时， 其实是执行了类的<code>__call__</code>方法。</p>
<h2 id="8-Flask-的-call-方法"><a href="#8-Flask-的-call-方法" class="headerlink" title="8. Flask 的 _call_ 方法"></a>8. Flask 的 <em>_call_</em> 方法</h2><blockquote>
<p>所以当前一个请求过来，执行了<code>WSGIRequestHandler</code>的<code>handle</code>方法，<code>handle</code>方法又经过七拐八拐回到了<code>Flask</code>的对象中。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params">App</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">self， environ: <span class="built_in">dict</span>， start_response: t.Callable</span>) -&gt; t.Any:</span></span><br><span class="line">		<span class="comment"># 创建请求上下文对象</span></span><br><span class="line">        ctx = self.request_context(environ)</span><br><span class="line">        error: BaseException | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 在其中判断是否含有应用上下文，</span></span><br><span class="line">                ctx.push()</span><br><span class="line">                <span class="comment"># </span></span><br><span class="line">                response = self.full_dispatch_request()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                error = e</span><br><span class="line">                response = self.handle_exception(e)</span><br><span class="line">            <span class="keyword">except</span>:  <span class="comment"># noqa: B001</span></span><br><span class="line">                error = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">return</span> response(environ， start_response)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;werkzeug.debug.preserve_context&quot;</span> <span class="keyword">in</span> environ:</span><br><span class="line">                environ[<span class="string">&quot;werkzeug.debug.preserve_context&quot;</span>](_cv_app.get())</span><br><span class="line">                environ[<span class="string">&quot;werkzeug.debug.preserve_context&quot;</span>](_cv_request.get())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> error <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.should_ignore_error(error):</span><br><span class="line">                error = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            ctx.pop(error)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self， environ: <span class="built_in">dict</span>， start_response: t.Callable</span>) -&gt; t.Any:</span></span><br><span class="line">        <span class="keyword">return</span> self.wsgi_app(environ， start_response)</span><br></pre></td></tr></table></figure>


<p>接下来就按照<code>self.full_dispatch_request()</code>的请求进行执行， </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params">App</span>):</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span>():</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        	执行视图函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        req = request_ctx.request</span><br><span class="line">        <span class="keyword">if</span> req.routing_exception <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.raise_routing_exception(req)</span><br><span class="line">        rule: Rule = req.url_rule  <span class="comment"># type: ignore[assignment]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="built_in">getattr</span>(rule， <span class="string">&quot;provide_automatic_options&quot;</span>， <span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">and</span> req.method == <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">        ):</span><br><span class="line">            <span class="keyword">return</span> self.make_default_options_response()</span><br><span class="line">        <span class="comment"># otherwise dispatch to the handler for that endpoint</span></span><br><span class="line">        view_args: <span class="built_in">dict</span>[<span class="built_in">str</span>， t.Any] = req.view_args  <span class="comment"># type: ignore[assignment]</span></span><br><span class="line">        <span class="comment"># 根据endpoint 去到view_functions 中去匹配路由和视图。并执行。</span></span><br><span class="line">        <span class="keyword">return</span> self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preprocess_request</span>(<span class="params">self</span>) -&gt; ft.ResponseReturnValue | <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        	在请求之前调用，如果有 brfore_request 中间件，则直接调用，如果不返回None， 则直接返  		  回，不走具体的视图方法。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        names = (<span class="literal">None</span>， *<span class="built_in">reversed</span>(request.blueprints))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> self.url_value_preprocessors:</span><br><span class="line">                <span class="keyword">for</span> url_func <span class="keyword">in</span> self.url_value_preprocessors[name]:</span><br><span class="line">                    url_func(request.endpoint， request.view_args)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> self.before_request_funcs:</span><br><span class="line">                <span class="keyword">for</span> before_func <span class="keyword">in</span> self.before_request_funcs[name]:</span><br><span class="line">                    rv = self.ensure_sync(before_func)()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span>(<span class="params">self</span>) -&gt; Response:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        	完整的请求执行流程。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._got_first_request = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request_started.send(self， _async_wrapper=self.ensure_sync)</span><br><span class="line">            <span class="comment"># 预处理请求， 前置中间件</span></span><br><span class="line">            rv = self.preprocess_request()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 执行具体的视图</span></span><br><span class="line">                rv = self.dispatch_request()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            rv = self.handle_user_exception(e)</span><br><span class="line">        <span class="comment"># 对请求进行后置处理</span></span><br><span class="line">        <span class="keyword">return</span> self.finalize_request(rv)</span><br></pre></td></tr></table></figure>


<p>总的来说，<code>Flask</code>的请求逻辑是由<code>werkzeug</code>处理<code>sockrt</code>底层逻辑， 由<code>Flask</code>执行请求视图逻辑。</p>
<p>精简后的代码执行顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params">App</span>):</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        host: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        port: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        debug: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        load_dotenv: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        **options: t.Any,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1 ===&gt; 服务启动执行 run 方法， 然后调用 werkzeug 的 run_simple 方法。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> run_simple</span><br><span class="line">        run_simple(t.cast(<span class="built_in">str</span>, host), port, self, **options)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span>(<span class="params">self</span>) -&gt; ft.ResponseReturnValue:</span></span><br><span class="line">        view_args: <span class="built_in">dict</span>[<span class="built_in">str</span>, t.Any] = req.view_args  <span class="comment"># type: ignore[assignment]</span></span><br><span class="line">        <span class="comment"># ===&gt; 6.6.1 执行 endpoint 对应的视图函数。</span></span><br><span class="line">        <span class="keyword">return</span> self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span>(<span class="params">self</span>) -&gt; Response:</span></span><br><span class="line">        self._got_first_request = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># ===&gt; 6.5 在请求之前处理一些中间件 brfore_request</span></span><br><span class="line">            rv = self.preprocess_request()</span><br><span class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># ===&gt; 6.6 分发请求。</span></span><br><span class="line">                rv = self.dispatch_request()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            rv = self.handle_user_exception(e)</span><br><span class="line">        <span class="comment"># ===&gt; 6.7 请求结束之后处理相关操作 after_request</span></span><br><span class="line">        <span class="keyword">return</span> self.finalize_request(rv)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">self, environ: <span class="built_in">dict</span>, start_response: t.Callable</span>) -&gt; t.Any:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ===&gt; 6.1 执行具体的请求逻辑。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ===&gt; 6.2 构建请求上下文</span></span><br><span class="line">        ctx = self.request_context(environ)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># ===&gt; 6.3 判断是否有应用上下文</span></span><br><span class="line">            ctx.push()</span><br><span class="line">            <span class="comment"># ===&gt; 6.4 执行完整的请求</span></span><br><span class="line">            response = self.full_dispatch_request()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            error = e</span><br><span class="line">            response = self.handle_exception(e)</span><br><span class="line">        <span class="keyword">except</span>:  <span class="comment"># noqa: B001</span></span><br><span class="line">            error = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, environ: <span class="built_in">dict</span>, start_response: t.Callable</span>) -&gt; t.Any:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ===&gt; 6 调用 wsgi_app 方法</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br></pre></td></tr></table></figure>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_server</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    host: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    port: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    app: WSGIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    threaded: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    processes: <span class="built_in">int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    request_handler: <span class="built_in">type</span>[WSGIRequestHandler] | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    passthrough_errors: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ssl_context: _TSSLContextArg | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    fd: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) -&gt; BaseWSGIServer:</span></span><br><span class="line">    <span class="comment"># ===&gt; 2.1 创建 wsgi 服务</span></span><br><span class="line">    <span class="keyword">return</span> BaseWSGIServer(</span><br><span class="line">        host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_simple</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    hostname: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    port: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    application: WSGIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    use_reloader: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    use_debugger: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    use_evalex: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    extra_files: t.Iterable[<span class="built_in">str</span>] | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    exclude_patterns: t.Iterable[<span class="built_in">str</span>] | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    reloader_interval: <span class="built_in">int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    reloader_type: <span class="built_in">str</span> = <span class="string">&quot;auto&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    threaded: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    processes: <span class="built_in">int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    request_handler: <span class="built_in">type</span>[WSGIRequestHandler] | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    static_files: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span> | <span class="built_in">tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]] | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    passthrough_errors: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ssl_context: _TSSLContextArg | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="comment"># ===&gt; 2 调用 make_server 创建  wsgi 服务，然后等待请求。</span></span><br><span class="line">    srv = make_server(</span><br><span class="line">        hostname,</span><br><span class="line">        port,</span><br><span class="line">        application,</span><br><span class="line">        threaded,</span><br><span class="line">        processes,</span><br><span class="line">        request_handler,</span><br><span class="line">        passthrough_errors,</span><br><span class="line">        ssl_context,</span><br><span class="line">        fd=fd,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># ===&gt; 3 调用基类的方法，启动服务，等待请求。</span></span><br><span class="line">    srv.serve_forever()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseServer</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    BaseWSGIServer 类的基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, RequestHandlerClass</span>):</span></span><br><span class="line">        <span class="comment"># 初始化时接收请求处理类：RequestHandlerClass</span></span><br><span class="line">        self.RequestHandlerClass = RequestHandlerClass</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span>(<span class="params">self, poll_interval=<span class="number">0.5</span></span>):</span></span><br><span class="line">        self.__is_shut_down.clear()</span><br><span class="line">        <span class="keyword">with</span> _ServerSelector() <span class="keyword">as</span> selector:</span><br><span class="line">            selector.register(self, selectors.EVENT_READ)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.__shutdown_request:</span><br><span class="line">                ready = selector.select(poll_interval)</span><br><span class="line">                <span class="keyword">if</span> self.__shutdown_request:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> ready:</span><br><span class="line">                    <span class="comment"># ===&gt; 4 请求到来执行的方法</span></span><br><span class="line">                    self._handle_request_noblock()</span><br><span class="line"></span><br><span class="line">                self.service_actions()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_handle_request_noblock</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># ===&gt; 4.1 接收 socket 请求</span></span><br><span class="line">            request, client_address = self.get_request()</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.verify_request(request, client_address):</span><br><span class="line">            <span class="comment"># ===&gt; 4.2 处理请求</span></span><br><span class="line">            self.process_request(request, client_address)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request, client_address</span>):</span></span><br><span class="line">        self.finish_request(request, client_address)</span><br><span class="line">        self.shutdown_request(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish_request</span>(<span class="params">self, request, client_address</span>):</span></span><br><span class="line">        <span class="comment"># ===&gt; 4.3 初始化 RequestHandlerClass 将 self 作为第三个参数传参</span></span><br><span class="line">        self.RequestHandlerClass(request, client_address, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># with 语句返回值</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.server_close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span>(<span class="params">BaseServer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server_address, RequestHandlerClass, bind_and_activate=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span></span><br><span class="line">        BaseServer.__init__(self, server_address, RequestHandlerClass)</span><br><span class="line">        <span class="comment"># ===&gt; 2.3 创建 socket 对象，</span></span><br><span class="line">        self.socket = socket.socket(self.address_family, self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> bind_and_activate:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.server_bind()</span><br><span class="line">                self.server_activate()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.server_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_activate</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ===&gt; 2.5 开启 socket 监听</span></span><br><span class="line">        self.socket.listen(self.request_queue_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 接受 socket 对象 </span></span><br><span class="line">        <span class="keyword">return</span> self.socket.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPServer</span>(<span class="params">socketserver.TCPServer</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_bind</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># ===&gt; 2.4 重写 server_bind 以存储服务器名称。</span></span><br><span class="line">        socketserver.TCPServer.server_bind(self)</span><br><span class="line">        host, port = self.server_address[:<span class="number">2</span>]</span><br><span class="line">        self.server_name = socket.getfqdn(host)</span><br><span class="line">        self.server_port = port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseWSGIServer</span>(<span class="params">HTTPServer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        host: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        port: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        app: WSGIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="built_in">type</span>[WSGIRequestHandler] | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        passthrough_errors: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        ssl_context: _TSSLContextArg | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        fd: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># ===&gt; 2.2 将 WSGIRequestHandler 类赋值给 handler 属性</span></span><br><span class="line">            handler = WSGIRequestHandler</span><br><span class="line"></span><br><span class="line">        self.app = app</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ===&gt; 2.3 调用父类的 初始化方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(</span><br><span class="line">            server_address,</span><br><span class="line">            handler,</span><br><span class="line">            bind_and_activate=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequestHandler</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    请求处理类基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, request, client_address, server</span>):</span></span><br><span class="line">        self.request = request</span><br><span class="line">        self.client_address = client_address</span><br><span class="line">        self.server = server</span><br><span class="line">        self.setup()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># ===&gt; 5 在初始化时调用 handle 方法</span></span><br><span class="line">            self.handle()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.finish()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamRequestHandler</span>(<span class="params">BaseRequestHandler</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHTTPRequestHandler</span>(<span class="params">socketserver.StreamRequestHandler</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    请求处理基类，该类的注释详细的说明了作者解析HTTP协议的标准。具体课参阅源码。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        解析 HTTP 请求，得到请求方法 GET 或者 POST 等</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.command = <span class="literal">None</span>  </span><br><span class="line">        command, path = words[:<span class="number">2</span>]</span><br><span class="line">        self.command, self.path = command, path</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_one_request</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理某一个请求</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            mname = <span class="string">&#x27;do_&#x27;</span> + self.command</span><br><span class="line">            method = <span class="built_in">getattr</span>(self, mname)</span><br><span class="line">            <span class="comment"># ===&gt; 5.3 调用 GET 或者 POST 的方法 </span></span><br><span class="line">            method()</span><br><span class="line">        <span class="keyword">except</span> TimeoutError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Handle multiple requests if necessary.&quot;&quot;&quot;</span></span><br><span class="line">        self.close_connection = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ===&gt; 5.2 调用请求方法。</span></span><br><span class="line">        self.handle_one_request()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.close_connection:</span><br><span class="line">            self.handle_one_request()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIRequestHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span></span><br><span class="line">    server: BaseWSGIServer</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_wsgi</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">app: WSGIApplication</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">            <span class="comment"># ===&gt; 5.6 执行 app(environ, start_response)</span></span><br><span class="line">            application_iter = app(environ, start_response)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># ===&gt; 5.5 执行 execute 方法 </span></span><br><span class="line">            execute(self.server.app)</span><br><span class="line">        <span class="keyword">except</span> (ConnectionError, socket.timeout) <span class="keyword">as</span> e:</span><br><span class="line">            self.connection_dropped(e, environ)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> self.server.passthrough_errors:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> status_sent <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> chunk_response:</span><br><span class="line">                self.close_connection = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># if we haven&#x27;t yet sent the headers but they are set</span></span><br><span class="line">                <span class="comment"># we roll back to be able to set them again.</span></span><br><span class="line">                <span class="keyword">if</span> status_sent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    status_set = <span class="literal">None</span></span><br><span class="line">                    headers_set = <span class="literal">None</span></span><br><span class="line">                execute(InternalServerError())</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">from</span> .debug.tbtools <span class="keyword">import</span> DebugTraceback</span><br><span class="line"></span><br><span class="line">            msg = DebugTraceback(e).render_traceback_text()</span><br><span class="line">            self.server.log(<span class="string">&quot;error&quot;</span>, <span class="string">f&quot;Error on request:\n<span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># ===&gt; 5.1 执行 父类的 handle</span></span><br><span class="line">        <span class="built_in">super</span>().handle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; t.Any:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&quot;do_&quot;</span>):</span><br><span class="line">            <span class="comment"># ===&gt; 5.4 调用 run_wsgi 方法 </span></span><br><span class="line">            <span class="keyword">return</span> self.run_wsgi</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(<span class="built_in">super</span>(), name)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>源码解析</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask源码解析之路由（FlaskV3.0.x）</title>
    <url>/2023/11/07/Flask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<p>​                  </p>
<a id="more"></a>

<h1 id="Flask源码解析之路由"><a href="#Flask源码解析之路由" class="headerlink" title="Flask源码解析之路由"></a>Flask源码解析之路由</h1><blockquote>
<p>须知：</p>
<p>Flask 版本 3.0.x Flask 在3.0 版本对代码进行了重构，使 Flask 和 Blueprint 类具有 Sans-IO 基础。</p>
</blockquote>
<h2 id="1-FBV-模式"><a href="#1-FBV-模式" class="headerlink" title="1. FBV 模式"></a>1. FBV 模式</h2><p>我们从最小的<code>Flask</code>程序开始入手</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>


<p>路由是使用<code>app.route</code>使用装饰器的方式进行声明，装饰器的执行逻辑：</p>
<ol>
<li>先执行 <code>app.route(&#39;/&#39;)</code> ，得到一个返回值是一个函数<code>decorator</code>。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码内容：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scaffold</span>:</span></span><br><span class="line">    <span class="comment"># 省略 ... </span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @setupmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">route</span>(<span class="params">self, rule: <span class="built_in">str</span>, **options: t.Any</span>) -&gt; t.Callable[[T_route], T_route]:</span></span><br><span class="line">        <span class="comment"># 省略 ... </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">f: T_route</span>) -&gt; T_route:</span></span><br><span class="line">            endpoint = options.pop(<span class="string">&quot;endpoint&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">            self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>app.route</code>点击进去跳转到了<code>Scaffold </code>这个类中的<code>route</code>方法，在<code>Flask 3.0</code>版本中，源码进行了比较大的更改，不过不影响核心流程。</p>
<p>既然能跳转到另外的一个类中， 那么<code>app</code>对象肯定也继承了此类，否则无法跳转过来， 我们可以再看看<code>Flask</code>的源码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>(<span class="params">App</span>):</span></span><br><span class="line">	<span class="comment"># 省略 ... </span></span><br></pre></td></tr></table></figure>
<p><code>Flask</code> 继承了<code>App</code>这个类， 我们再看<code>App</code>这个类的源码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>(<span class="params">Scaffold</span>):</span></span><br><span class="line">    <span class="comment"># 省略 ... </span></span><br></pre></td></tr></table></figure>
<p>正向我们前面所说的， <code>Flask </code>类使用多重继承，继承了<code>Scaffold</code>，所以我们点击<code>app.route</code>进入到了<code>Scaffold</code>这个类的<code>route</code>方法。</p>
<ol start="2">
<li>我们继续看，<code>route</code>方法返回值得到一个函数<code>decorator</code>。那么整个路由可以写为以下的格式。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>接下来再执行<code> decorator(hello_world)</code>，那么<code>hello_world</code>这个方法就会变成<code>decorator</code>返回的对象。在<code>decorator</code>的内部有两行代码，第一行是获取<code>endpoint</code>参数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">endpoint = options.pop(<span class="string">&quot;endpoint&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">self.add_url_rule(rule, endpoint, f, **options)</span><br></pre></td></tr></table></figure>
<p>接下来我们再看<code>add_url_rule</code>的方法， 我们还是先从<code>Flask</code>，类内部开始看，<code>Flask</code>类内部没有实现，我们再找<code>App</code>类，<code>App</code>类内部实现了这个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>(<span class="params">Scaffold</span>):</span></span><br><span class="line"></span><br><span class="line">    url_rule_class = Rule</span><br><span class="line">    url_map_class = Map</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 省略 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span>(<span class="params">...</span>):</span></span><br><span class="line">        <span class="comment"># 省略 ...</span></span><br><span class="line">    	self.url_map = self.url_map_class(host_matching=host_matching)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @setupmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        rule: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        endpoint: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        view_func: ft.RouteCallable | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        provide_automatic_options: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        **options: t.Any,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断endpoint， 如果为空，那么就吧视图函数的函数名当做 endpoint</span></span><br><span class="line">        <span class="keyword">if</span> endpoint <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            endpoint = _endpoint_from_view_func(view_func)  <span class="comment"># type: ignore</span></span><br><span class="line">        options[<span class="string">&quot;endpoint&quot;</span>] = endpoint</span><br><span class="line">        methods = options.pop(<span class="string">&quot;methods&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ============== 对请求方法进行处理 开始 ============== </span></span><br><span class="line">        <span class="keyword">if</span> methods <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            methods = <span class="built_in">getattr</span>(view_func, <span class="string">&quot;methods&quot;</span>, <span class="literal">None</span>) <span class="keyword">or</span> (<span class="string">&quot;GET&quot;</span>,)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(methods, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">&quot;Allowed methods must be a list of strings, for&quot;</span></span><br><span class="line">                <span class="string">&#x27; example: @app.route(..., methods=[&quot;POST&quot;])&#x27;</span></span><br><span class="line">            )</span><br><span class="line">        methods = &#123;item.upper() <span class="keyword">for</span> item <span class="keyword">in</span> methods&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Methods that should always be added</span></span><br><span class="line">        required_methods = <span class="built_in">set</span>(<span class="built_in">getattr</span>(view_func, <span class="string">&quot;required_methods&quot;</span>, ()))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># starting with Flask 0.8 the view_func object can disable and</span></span><br><span class="line">        <span class="comment"># force-enable the automatic options handling.</span></span><br><span class="line">        <span class="keyword">if</span> provide_automatic_options <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            provide_automatic_options = <span class="built_in">getattr</span>(</span><br><span class="line">                view_func, <span class="string">&quot;provide_automatic_options&quot;</span>, <span class="literal">None</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> provide_automatic_options <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;OPTIONS&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> methods:</span><br><span class="line">                provide_automatic_options = <span class="literal">True</span></span><br><span class="line">                required_methods.add(<span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                provide_automatic_options = <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">        methods |= required_methods</span><br><span class="line">        <span class="comment"># ============== 对请求方法进行处理 结束 ============== </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里实例化了一个Rule对象rule, 此处我们先不管 Rule 对象的内部实现。</span></span><br><span class="line">        rule = self.url_rule_class(rule, methods=methods, **options)</span><br><span class="line">        rule.provide_automatic_options = provide_automatic_options  <span class="comment"># type: ignore</span></span><br><span class="line">		 </span><br><span class="line">        <span class="comment"># 此处 url_map 是一个Map对象，包含了所有的rule对象。调用add方法将rule对象添加到Map中</span></span><br><span class="line">        self.url_map.add(rule)</span><br><span class="line">        <span class="keyword">if</span> view_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            old_func = self.view_functions.get(endpoint)</span><br><span class="line">            <span class="keyword">if</span> old_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> old_func != view_func:</span><br><span class="line">                <span class="keyword">raise</span> AssertionError(</span><br><span class="line">                    <span class="string">&quot;View function mapping is overwriting an existing&quot;</span></span><br><span class="line">                    <span class="string">f&quot; endpoint function: <span class="subst">&#123;endpoint&#125;</span>&quot;</span></span><br><span class="line">                )</span><br><span class="line">            <span class="comment"># 将 endpoint 和 view_func 对应起来。 添加到view_functions 中</span></span><br><span class="line">            self.view_functions[endpoint] = view_func</span><br></pre></td></tr></table></figure>


<p>所以再设置路由时，可以通过 <code>add_url_rule</code>设置或者是通过装饰器设置，装饰器在内部也是调用了 <code>add_url_rule</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器方式</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;首页&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add_url_rule 方式</span></span><br><span class="line">app.add_url_rule (rule=<span class="string">&#x27;/index&#x27;</span>, endpoint=<span class="string">&#x27;index&#x27;</span>, view_func=index)</span><br></pre></td></tr></table></figure>


<p>动态路由</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/item/&lt;int:id&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">item</span>():</span> ...</span><br></pre></td></tr></table></figure>
<p>当路由是动态路由时，在上文的<code>self.url_map.add(rule)</code>时，add方法中包含<code>rule.bind()</code>，在路由绑定时，会解析路由并获取装换器。默认的转换器有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DEFAULT_CONVERTERS: t.Mapping[<span class="built_in">str</span>, <span class="built_in">type</span>[BaseConverter]] = &#123;</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: UnicodeConverter,</span><br><span class="line">    <span class="string">&quot;string&quot;</span>: UnicodeConverter,</span><br><span class="line">    <span class="string">&quot;any&quot;</span>: AnyConverter,</span><br><span class="line">    <span class="string">&quot;path&quot;</span>: PathConverter,</span><br><span class="line">    <span class="string">&quot;int&quot;</span>: IntegerConverter,</span><br><span class="line">    <span class="string">&quot;float&quot;</span>: FloatConverter,</span><br><span class="line">    <span class="string">&quot;uuid&quot;</span>: UUIDConverter,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当我们需要自定义时，我们可以根据上述的转换器，进行自定义动态路由。</p>
<p><code>Flask</code>规定的一些转换器的格式都继承自：<code>BaseConverter</code>， 而且<code>Map</code>类所接受<code>converters</code>参数类型也是<code>BaseConverter</code>的子类，所以我们自定义时都要继承自<code>BaseConverter</code>。<img src="https://origin.chaizz.com/tc/image-20231108222521379.png" alt="image-20231108222521379"></p>
<p>自定义正则转换器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> typing <span class="keyword">as</span> t</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter, Map</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegexConverter</span>(<span class="params">BaseConverter</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义Converter</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">map</span>: Map, regex: t.Any</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="built_in">map</span>)</span><br><span class="line">        self.regex = regex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加转化器</span></span><br><span class="line">app.url_map.converters[<span class="string">&#x27;regex&#x27;</span>] = RegexConverter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/item/&lt;regex(&#x27;\w+&#x27;):item&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">item</span>(<span class="params">item: t.Any</span>) -&gt; str:</span></span><br><span class="line">    print(item)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;正则格式的路由&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>


<p>以上的路由操作都是使用装饰器<code>FBV</code>的方式，当我们使用<code>CBV</code>的方式去写路由视图时，具体的流程又是怎么走的呢？</p>
<h2 id="2-CBV-模式"><a href="#2-CBV-模式" class="headerlink" title="2. CBV 模式"></a>2. CBV 模式</h2><p>一个最小的<code>CBV</code>的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask.views <span class="keyword">import</span> MethodView</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span>(<span class="params">MethodView</span>):</span></span><br><span class="line">    methods = [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&quot;POST&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;get 请求&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;post 请求&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;post&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/item&#x27;</span>, view_func=ItemView.as_view(<span class="string">&#x27;item&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>我们进入<code>MethodView</code>的<code>as_view</code>源码， 他返回的时是一个<code>view</code>函数，即<code>view_func=view</code>，所以请求过来以后，执行<code>view</code>方法，在<code>view</code>的内部实例化了<code>view.view_class</code>，也就是当前类本身即<code>ItemView</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    cls, name: <span class="built_in">str</span>, *class_args: t.Any, **class_kwargs: t.Any</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) -&gt; ft.RouteCallable:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cls.init_every_request:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">**kwargs: t.Any</span>) -&gt; ft.ResponseReturnValue:</span></span><br><span class="line">            self = view.view_class(  <span class="comment"># type: ignore[attr-defined]</span></span><br><span class="line">                *class_args, **class_kwargs</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> current_app.ensure_sync(self.dispatch_request)(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self = cls(*class_args, **class_kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">**kwargs: t.Any</span>) -&gt; ft.ResponseReturnValue:</span></span><br><span class="line">            <span class="keyword">return</span> current_app.ensure_sync(self.dispatch_request)(**kwargs)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># CBV 的装饰器处理方式</span></span><br><span class="line">    <span class="keyword">if</span> cls.decorators:</span><br><span class="line">        view.__name__ = name</span><br><span class="line">        view.__module__ = cls.__module__</span><br><span class="line">        <span class="keyword">for</span> decorator <span class="keyword">in</span> cls.decorators:</span><br><span class="line">            view = decorator(view)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We attach the view class to the view function for two reasons:</span></span><br><span class="line">    <span class="comment"># first of all it allows us to easily figure out what class-based</span></span><br><span class="line">    <span class="comment"># view this thing came from, secondly it&#x27;s also used for instantiating</span></span><br><span class="line">    <span class="comment"># the view class so you can actually replace it with something else</span></span><br><span class="line">    <span class="comment"># for testing purposes and debugging.</span></span><br><span class="line">    view.view_class = cls  <span class="comment"># type: ignore</span></span><br><span class="line">    view.__name__ = name</span><br><span class="line">    view.__doc__ = cls.__doc__</span><br><span class="line">    view.__module__ = cls.__module__</span><br><span class="line">    view.methods = cls.methods  <span class="comment"># type: ignore</span></span><br><span class="line">    view.provide_automatic_options = cls.provide_automatic_options  <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回的是一个 view 函数</span></span><br><span class="line">    <span class="keyword">return</span> view</span><br></pre></td></tr></table></figure>


<p>然后我们再看， 在<code>view</code>中调用了<code>current_app.ensure_sync</code>， 我们暂且理解为处理异步代码的操作。它内部返回了接受的函数，而且后面跟了<code>(**kwargs)</code>，说明<code>dispatch_request</code>被执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ensure_sync</span>(<span class="params">self, func: t.Callable</span>) -&gt; t.Callable:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Ensure that the function is synchronous for WSGI workers.</span></span><br><span class="line"><span class="string">    Plain ``def`` functions are returned as-is. ``async def``</span></span><br><span class="line"><span class="string">    functions are wrapped to run and wait for the response.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Override this method to change how the app runs async views.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 2.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> iscoroutinefunction(func):</span><br><span class="line">        <span class="keyword">return</span> self.async_to_sync(func)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure>
<p>然后我们去查找<code>dispatch_request</code>方法， <code>ItemView</code>没有，再找<code>MethodView</code>， <code>MethodView</code>是有的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span>(<span class="params">self, **kwargs: t.Any</span>) -&gt; ft.ResponseReturnValue:</span></span><br><span class="line">    meth = <span class="built_in">getattr</span>(self, request.method.lower(), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the request method is HEAD and we don&#x27;t have a handler for it</span></span><br><span class="line">    <span class="comment"># retry with GET.</span></span><br><span class="line">    <span class="keyword">if</span> meth <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> request.method == <span class="string">&quot;HEAD&quot;</span>:</span><br><span class="line">        meth = <span class="built_in">getattr</span>(self, <span class="string">&quot;get&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> meth <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">f&quot;Unimplemented method <span class="subst">&#123;request.method!r&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> current_app.ensure_sync(meth)(**kwargs)</span><br></pre></td></tr></table></figure>
<p>我可能可以看到是和<code>Django</code>的<code>CBV</code>是一致的。</p>
<p>首先通过反射，获取当前实例下的请求方法对象的函数，如果没有或者是<code>HEAD</code>则自动设置为<code>GET</code>方法，然后直接调用该类下的方法<code>meth(**kwargs)</code>。</p>
<p>在<code>as_view</code>视图执行的时候， 我们可以看到这样一段代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cls.decorators:</span><br><span class="line">    view.__name__ = name</span><br><span class="line">    view.__module__ = cls.__module__</span><br><span class="line">    <span class="keyword">for</span> decorator <span class="keyword">in</span> cls.decorators:</span><br><span class="line">        view = decorator(view)</span><br></pre></td></tr></table></figure>
<p>此段代码正是处理<code>CBV</code>的请求装饰器的作用， 我们可以通过这种方式来给<code>CBV</code>请求添加装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask.views <span class="keyword">import</span> MethodView</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;开始...1&#x27;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">&#x27;开始...1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;开始...2&#x27;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">&#x27;开始...2&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemView</span>(<span class="params">MethodView</span>):</span></span><br><span class="line">    methods = [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&quot;POST&quot;</span>]</span><br><span class="line">    decorators = [wrapper, wrapper2]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;get 请求&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;post 请求&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;post&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/item&#x27;</span>, view_func=ItemView.as_view(<span class="string">&#x27;item&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p><code>wrapper</code>, <code>wrapper2</code>的执行顺序分别是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开始...2</span></span><br><span class="line"><span class="comment"># 开始...1</span></span><br><span class="line"><span class="comment"># get 请求</span></span><br><span class="line"><span class="comment"># 开始...1</span></span><br><span class="line"><span class="comment"># 开始...2</span></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>源码解析</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonista开发前的基础工作之浏览器篇</title>
    <url>/2023/09/29/Pythonista%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="Pythonista开发前的基础工作之浏览器篇"><a href="#Pythonista开发前的基础工作之浏览器篇" class="headerlink" title="Pythonista开发前的基础工作之浏览器篇"></a>Pythonista开发前的基础工作之浏览器篇</h1><h2 id="1-浏览器的选择"><a href="#1-浏览器的选择" class="headerlink" title="1 浏览器的选择"></a>1 浏览器的选择</h2><p>浏览器这个东西因人而异，每个人的使用习惯不一样，根据自己的习惯选择就好。</p>
<p>目前的主流浏览器有：<a href="https://www.google.com/chrome/">Chrome</a>、<a href="https://www.microsoft.com/edge">Edge</a>、<a href="https://www.apple.com/tw/safari/">Safari</a>、<a href="https://www.mozilla.org/firefox/new/">Firefox</a>。</p>
<p>之前还听说过一个浏览器叫做<a href="https://arc.net/">ARC</a>，使用习惯好像上面那些传统的浏览器不一致，比较新颖。不过目前好像不支持windows，也没用过，使用过的小伙伴可以说一下感受。</p>
<blockquote>
<p>我的选择：<strong>Chrome</strong>。</p>
</blockquote>
<p>之前参考过一篇<a href="https://tw93.fun/2023-08-20/edge.html">文章</a>，然后倒腾了下Edge dev版本, 使用的侧边栏的形式，也是使用了大概两周，但是在一些方面感觉还是不如<strong>Chrome</strong>用的顺手，就又换了回去。</p>
<h2 id="2-浏览器设置"><a href="#2-浏览器设置" class="headerlink" title="2 浏览器设置"></a>2 浏览器设置</h2><p>首先Google账号必须要设置的，不使用账号登录的话，同步功能无法很好的使用。</p>
<p>浏览器的一些具体配置，首先打开浏览器的设置界面：  </p>
<p>第一栏<code>您与Google</code>-&gt; <code>同步功能和 Google 服务</code>的<code>允许登录</code>和<code>改进搜索建议</code>是开启的，其他选项都是关闭的。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230929232249560.png"></p>
<p>第三栏<code>隐私与安全</code>-&gt;<code>隐私保护指南</code>里面<code>历史同步记录</code>是开的，保护级别为<code>标准保护</code>，第三方 Cookie 偏好设置为<code>在无痕模式下阻止第三方 Cookie</code>。</p>
<p><code>隐私与安全</code>-&gt;<code>广告隐私权设置</code>里面的所有能选择的按钮，我全是关的。最近Google出了这个推送广告服务，看来要和百度如出一辙了。</p>
<p>第四栏<code>性能</code>-&gt;<code>内存节省程序</code> 设置为开。</p>
<p>其他的就没有特别的设置了。</p>
<h2 id="3-扩展程序"><a href="#3-扩展程序" class="headerlink" title="3 扩展程序"></a>3 扩展程序</h2><p>扩展程序我安装的比较多，都是将一些常用的打开， 不常用的关闭， 等到需要用的时候，再打开使用，也能节省一点内存。</p>
<p>常用的一些扩展</p>
<ul>
<li><strong>AdGuard 广告拦截器</strong> - 拦截广告，感觉效果很好 - <a href="https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg">地址</a></li>
<li><strong>IDM Integration Module</strong> - 下载器，无敌好用 - <a href="https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek">地址</a></li>
<li><strong>PureTwitte</strong>r - 用来绿化X的，屏蔽一些黄推 - <a href="https://chrome.google.com/webstore/detail/puretwitter/nflidllhiamnebgbgoemadhhfdpbbpbi">地址</a></li>
<li><strong>Vue.js devtools</strong> - vuedebug工具 - <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">地址</a></li>
<li><strong>沉浸式翻译</strong> - 翻译工具 - <a href="https://chrome.google.com/webstore/detail/immersive-translate-web-p/bpoadfkcbjbfhfodiogcnhhhpibjhbnh">地址</a></li>
<li><strong>沙拉查词-聚合词典划词翻译</strong> - 划词翻译 - <a href="https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg">地址</a></li>
<li><strong>稀土掘金</strong> - 一般我会用来当做浏览器首页 - <a href="https://chrome.google.com/webstore/detail/%E7%A8%80%E5%9C%9F%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb">地址</a></li>
<li><strong>类似的网站</strong> - 查询类型的网站 - <a href="https://chrome.google.com/webstore/detail/similar-sites-discover-re/necpbmbhhdiplmfhmjicabdeighkndkn">地址</a></li>
<li><strong>篡改猴</strong> - 就是油猴，后续也会介绍一些常用的脚本 - <a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo">地址</a> </li>
<li><strong>购物党自动比价工具</strong> - 购物比价，不过现在都不在网页上购物了， 有时候会打开看看价格走势 - <a href="https://chrome.google.com/webstore/detail/%E8%B4%AD%E7%89%A9%E5%85%9A%E8%87%AA%E5%8A%A8%E6%AF%94%E4%BB%B7%E5%B7%A5%E5%85%B7/jgphnjokjhjlcnnajmfjlacjnjkhleah">地址</a></li>
</ul>
<p>不常用的扩展：</p>
<ul>
<li><strong>AI沉浸翻译和YouTube/Netflix双字幕</strong> - 这个东西可以在看外文视频网站时打开实时翻译，是一个很不错的学英语的工具 - <a href="https://chrome.google.com/webstore/detail/ai-translator-and-youtube/mjdbhokoopacimoekfgkcoogikbfgngb">地址</a></li>
<li><strong>Axure RP Extension for Chrome</strong> - 查看原型时使用 - <a href="https://chrome.google.com/webstore/detail/axure-rp-extension-for-ch/dogkpdfcklifaemcdfbildhcofnopogp">地址</a></li>
<li><strong>Dark Reader</strong> - 使没有夜间主题的网站手动变为夜间主题 - <a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh">地址</a></li>
<li><strong>GitZip for github</strong> - 可以单独下载github仓库的文件夹 - <a href="https://chrome.google.com/webstore/detail/gitzip-for-github/ffabmkklhbepgcgfonabamgnfafbdlkn">地址</a></li>
<li><strong>JSON格式化工具</strong> - 美化web端的json - <a href="https://chrome.google.com/webstore/detail/json%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/hldkiepdcdeibnadnpiekpbdgbgbalob">地址</a></li>
<li><strong>Minimal Theme for Twitter</strong> - x的美化主题 - <a href="https://chrome.google.com/webstore/detail/minimal-theme-for-twitter/pobhoodpcipjmedfenaigbeloiidbflp">地址</a></li>
<li><strong>Nimbus 截幕 &amp; 屏幕录像机</strong> - 使用这个工具一般用来网页录屏，截图都用Snipaste - <a href="https://chrome.google.com/webstore/detail/nimbus-screenshot-screen/bpconcjcammlapcogcnnelfmaeghhagj">地址</a></li>
<li><strong>Simple Allow Copy</strong> - 解除网站复制的，一些油猴脚本也可以实现 - <a href="https://chrome.google.com/webstore/detail/simple-allow-copy/aefehdhdciieocakfobpaaolhipkcpgc">地址</a></li>
<li><strong>Volume Master</strong> - 可以增大网页播放器音量 - <a href="https://chrome.google.com/webstore/detail/volume-master/jghecgabfgfdldnmbfkhmffcabddioke">地址</a></li>
<li><strong>XPath Helper</strong> - 爬虫必备 - <a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl">地址</a></li>
<li><strong>捕捉网页截图</strong> - 网页截图工具，保存为PDF - <a href="https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg">地址</a></li>
<li><strong>猫抓</strong> - 网页媒体休嗅探工具 - <a href="https://chrome.google.com/webstore/detail/%E7%8C%AB%E6%8A%93/jfedfbgedapdagkghmgibemcoggfppbb">地址</a></li>
</ul>
<h2 id="4-油猴脚本"><a href="#4-油猴脚本" class="headerlink" title="4 油猴脚本"></a>4 油猴脚本</h2><ul>
<li><strong>anti-redirect</strong> - 去除重定向 - <a href="https://greasyfork.org/zh-CN/scripts/11915-anti-redirect">地址</a></li>
<li><strong>HTML5视频播放器增强脚本</strong> - 很强大的H5播放器，平时看视频可以超高倍速 - <a href="https://greasyfork.org/zh-CN/scripts/381682-html5%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E5%A2%9E%E5%BC%BA%E8%84%9A%E6%9C%AC">地址</a></li>
<li><strong>Twitter Block Porn</strong> - 同样是屏蔽黄推的 -<a href="https://greasyfork.org/zh-CN/scripts/470359-twitter-block-porn">地址</a></li>
<li><strong>V2EX Polish</strong> - 美化V2ex - <a href="https://greasyfork.org/zh-CN/scripts/459848-v2ex-polish-%E4%BD%93%E9%AA%8C%E6%9B%B4%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84-v2ex">地址</a></li>
<li><strong>百度网盘千千下载助手</strong> - 百度网盘下载助手结合IDM可直接满速下载，**需要关注公众号 **- <a href="https://greasyfork.org/zh-CN/scripts/463171-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8D%83%E5%8D%83%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B">地址</a></li>
<li><strong>知乎修改器</strong> - 美化知乎 - <a href="https://greasyfork.org/zh-CN/scripts/423404-%E7%9F%A5%E4%B9%8E%E4%BF%AE%E6%94%B9%E5%99%A8-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%E5%8A%AA%E5%8A%9B%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E6%9C%80%E5%85%A8%E7%9A%84%E7%9F%A5%E4%B9%8E%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6">地址</a></li>
<li><strong>知乎隐藏标题</strong> - 在浏览知乎时隐藏知乎的标题 - <a href="https://greasyfork.org/zh-CN/scripts/476351-%E7%9F%A5%E4%B9%8E%E9%9A%90%E8%97%8F%E6%A0%87%E9%A2%98">地址</a></li>
<li><strong>网盘直链下载助手</strong> - 百度网盘下载助手结合IDM可直接满速下载，**需要关注公众号 ** - <a href="https://greasyfork.org/zh-CN/scripts/436446-%E7%BD%91%E7%9B%98%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B">地址</a></li>
<li><strong>CSDN广告完全过滤</strong> - 免登陆直接复制等 - <a href="https://greasyfork.org/zh-CN/scripts/378351-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-csdn%E5%B9%BF%E5%91%8A%E5%AE%8C%E5%85%A8%E8%BF%87%E6%BB%A4-%E4%BA%BA%E6%80%A7%E5%8C%96%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96-%E4%B8%8D%E7%94%A8%E5%86%8D%E7%99%BB%E5%BD%95%E4%BA%86-%E8%AE%A9%E4%BD%A0%E4%BD%93%E9%AA%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%96%9C%E7%9A%84%E5%B4%AD%E6%96%B0csdn">地址</a></li>
</ul>
<h2 id="5-配置同步"><a href="#5-配置同步" class="headerlink" title="5 配置同步"></a>5 配置同步</h2><p>Chrome的设置和扩展在Chrome的同步数据中都可以打开， 进行直接同步。</p>
<p>油猴脚本的同步需要打开脚本管理面板的同步设置：</p>
<p><code>点击油猴插件图标</code> -&gt; <code>点击管理面板</code> -&gt; <code>右上角点击设置按钮</code> -&gt; <code>第一栏通用-&gt;配置模式-&gt;选择初学者或者高级</code> -&gt; <code>下拉会发现 同步脚本 栏</code> -&gt; <code>开启启用脚本</code> -&gt; <code>可选择同步类型，默认浏览器就行</code> -&gt; <code>点击现在运行即可同步</code></p>
<p>建议在两个电脑之间同步脚本时，先将一个脚本列表清空在进行同步， 否则可能会导致冲突。</p>
]]></content>
      <categories>
        <category>开发环境配置</category>
        <category>浏览器配置</category>
      </categories>
      <tags>
        <tag>开发环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3组件相关知识</title>
    <url>/2023/09/17/Vue3%E7%BB%84%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Vue3组件相关知识"><a href="#Vue3组件相关知识" class="headerlink" title="Vue3组件相关知识"></a>Vue3组件相关知识</h1><p>当我们去开发一个项目时，出现频率比较高的一个组件我们可以把他抽离为一个==全局组件==，直接在其他的组件上使用。当我们在一个页面上模块非常多，我们可以把每个模块当做一个==局部组件==，在一个页面内引入使用。==递归组件==就是我们需要重复的在一个组件内复用自己，比如像是菜单或者是树形结构，就是通过递归得到的结构。</p>
<p>同时我们也可以在某个组件中动态的切换其他的组件，来达到v-if的效果。</p>
<h2 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h2><p>我们定义的每一个Vue文件就是一个组件， 在使用局部组件时直接引入就可以直接使用。</p>
<h2 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h2><p>注册全局组件的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.ts</span><br><span class="line"></span><br><span class="line">import Example from &#39;xxx&#x2F;xxx&#x2F;index.vue&#39; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个参数：组件名,可以任意定义，此处和组件实例同名</span><br><span class="line">&#x2F;&#x2F; 第二个参数：引入的组件实例</span><br><span class="line">app.component(&#39;Example&#39;, Example)</span><br><span class="line"></span><br><span class="line">app.mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>
<p>使用的方式：</p>
<p>直接在其他的任意组件中使用 <code>&lt;Example&gt;&lt;/Example&gt;</code></p>
<p>多个组件可以参考element-plus的 icon 组件的批量注册方式：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您正在使用CDN引入，请删除下面一行。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ElementPlusIconsVue <span class="keyword">from</span> <span class="string">&#x27;@element-plus/icons-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, component] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(ElementPlusIconsVue)) &#123;</span><br><span class="line">  app.component(key, component)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h2><p>在使用递归组件时第个一条件就是确定调用组件名称，第一种方式就是直接使用当前的文件名当做组件名。</p>
<p>父组件数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = ref([</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        check: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        check: <span class="literal">false</span>,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;2-1&quot;</span>,</span><br><span class="line">                check: <span class="literal">true</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        check: <span class="literal">false</span>,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                name: <span class="string">&quot;3-1&quot;</span>,</span><br><span class="line">                check: <span class="literal">true</span>,</span><br><span class="line">                children: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: <span class="string">&quot;3-1-1&quot;</span>,</span><br><span class="line">                        check: <span class="literal">true</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: <span class="string">&quot;3-1-2&quot;</span>,</span><br><span class="line">                        check: <span class="literal">false</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子组件递归调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;ts&gt;</span><br><span class="line">import &#123; ref &#125; from &#39;vue&#39;;</span><br><span class="line">defineProps([&#39;data&#39;])</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div v-for&#x3D;&quot;item in data&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;item.check&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;Tree v-if&#x3D;&quot;item?.children?.length&quot; :data&#x3D;&quot;item?.children&quot;&gt;&lt;&#x2F;Tree&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped  lang&#x3D;&#39;scss&#39;&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>


<p>如果不使用自身的文件名当做递归的组件名称， 还可以在重新开启一个新的script标签，但是不能写 setup。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;componentName&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>在组件中使用可以直接使用componentName， <code>&lt;componentName&gt;&lt;/componentName&gt;</code>。</p>
<p>弊端就是还需要再重新写一个script的标签， 很繁琐。</p>
<p>另一种方式就是需要安装一个插件：<code>unplugin-vue-define-options</code> 然后在需要一通设置。</p>
<p>在使用递归组件时，使用点击事件会有一个事件冒泡的问题，所以如果使用事件的话要添加<code>@click.stop=eventHandler</code>。 接受参数可以使用<code>$event</code></p>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>先说一下使用场景， 比如我们在做一些 tab页切换时，可以使用路由或者是v-if或者是<strong>动态组件</strong>。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230917204507008.png"></p>
<p>直接上示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;ts&gt;</span><br><span class="line">import &#123; ref, reactive &#125; from &#39;vue&#39;;</span><br><span class="line">import ACom from &#39;.&#x2F;components&#x2F;A.vue&#39;</span><br><span class="line">import BCom from &#39;.&#x2F;components&#x2F;B.vue&#39;</span><br><span class="line">import CCom from &#39;.&#x2F;components&#x2F;C.vue&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 待切换的组件数组</span><br><span class="line">const componentsArr &#x3D; reactive([</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;A&quot;,</span><br><span class="line">        com: ACom</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;B&quot;,</span><br><span class="line">        com: BCom</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;C&quot;,</span><br><span class="line">        com: CCom</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定的动态组件</span><br><span class="line">const activeCom &#x3D; ref(ACom)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; tab的选中样式类</span><br><span class="line">const activate &#x3D; ref(0)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切换事件</span><br><span class="line">const switchHandler &#x3D; (item, index) &#x3D;&gt; &#123;</span><br><span class="line">    activate.value &#x3D; index</span><br><span class="line">    activeCom.value &#x3D; item.com</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;tab&quot;&gt;</span><br><span class="line">            &lt;div @click&#x3D;&quot;switchHandler(item, index)&quot; class&#x3D;&quot;tab-item&quot; :class&#x3D;&quot;activate &#x3D;&#x3D; index ? &#39;activate&#39; : &#39;&#39;&quot;</span><br><span class="line">                v-for&#x3D;&quot;(item, index) in componentsArr&quot;&gt;</span><br><span class="line">                &lt;div&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;component :is&#x3D;&quot;activeCom&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped  lang&#x3D;&#39;scss&#39;&gt;</span><br><span class="line">.activate &#123;</span><br><span class="line">    color: white;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line"></span><br><span class="line">    .tab &#123;</span><br><span class="line">        display: flex;</span><br><span class="line"></span><br><span class="line">        .tab-item &#123;</span><br><span class="line">            cursor: pointer;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            margin-right: 10px;</span><br><span class="line">            border: 1px solid gray;</span><br><span class="line">            display: flex;</span><br><span class="line">            align-items: center;</span><br><span class="line">            justify-content: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>


<p><img src="https://origin.chaizz.com/tc/image-20230917213214203.png"></p>
<p>但是会有一个问题，vue会抛出一个警告：</p>
<p><img src="https://origin.chaizz.com/tc/image-20230917213640949.png"></p>
<p>大概是因为vue对切换的组件中的对象也做了一个代理，但是我们这个场景没有必要在做一层代理 所以可以使用 <code>markRaw</code>, <code>shallowRef</code> 来做一个性能优化， 来避免再次代理。</p>
<p>最终的代码为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;ts&gt;</span><br><span class="line">import &#123; ref, reactive, markRaw, shallowRef &#125; from &#39;vue&#39;;</span><br><span class="line">import ACom from &#39;.&#x2F;components&#x2F;A.vue&#39;</span><br><span class="line">import BCom from &#39;.&#x2F;components&#x2F;B.vue&#39;</span><br><span class="line">import CCom from &#39;.&#x2F;components&#x2F;C.vue&#39;</span><br><span class="line"></span><br><span class="line">const componentsArr &#x3D; reactive([</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;A&quot;,</span><br><span class="line">        com: markRaw(ACom)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;B&quot;,</span><br><span class="line">        com: markRaw(BCom)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;C&quot;,</span><br><span class="line">        com: markRaw(CCom)</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定的动态组件</span><br><span class="line">const activeCom &#x3D; shallowRef(ACom)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; tab的选中样式类</span><br><span class="line">const activate &#x3D; ref(0)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切换事件</span><br><span class="line">const switchHandler &#x3D; (item, index) &#x3D;&gt; &#123;</span><br><span class="line">    activate.value &#x3D; index</span><br><span class="line">    activeCom.value &#x3D; item.com</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;tab&quot;&gt;</span><br><span class="line">            &lt;div @click&#x3D;&quot;switchHandler(item, index)&quot; class&#x3D;&quot;tab-item&quot; :class&#x3D;&quot;activate &#x3D;&#x3D; index ? &#39;activate&#39; : &#39;&#39;&quot;</span><br><span class="line">                v-for&#x3D;&quot;(item, index) in componentsArr&quot;&gt;</span><br><span class="line">                &lt;div&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;component :is&#x3D;&quot;activeCom&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped  lang&#x3D;&#39;scss&#39;&gt;</span><br><span class="line">.activate &#123;</span><br><span class="line">    color: white;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line"></span><br><span class="line">    .tab &#123;</span><br><span class="line">        display: flex;</span><br><span class="line"></span><br><span class="line">        .tab-item &#123;</span><br><span class="line">            cursor: pointer;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            margin-right: 10px;</span><br><span class="line">            border: 1px solid gray;</span><br><span class="line">            display: flex;</span><br><span class="line">            align-items: center;</span><br><span class="line">            justify-content: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>具体的优化方式可以看下这个满神的<a href="https://www.bilibili.com/video/BV1dS4y1y7vd/?p=18&spm_id_from=pageDriver&vd_source=623a2a45ce286fe2d8644ddb7b5db1c6">这个视屏</a>。</p>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL架构</title>
    <url>/2023/09/17/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%9B%9B%E7%89%88(%E4%B8%80)MySQL%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><p>1、常规的C/S架构中的最外层：鉴权、连接处理</p>
<p>2、解析查询、优化 （优化器会向存储引擎询问执行操作的成本和表数据的统计信息）</p>
<p>3、存储引擎</p>
<p>==*== 在5.7.2 版本开始将查询缓存层标记为弃用，8.0版本中完全被移除。（为什么被弃用：随着并发性要求的增高，查询缓存层起不到太大的作用。）缓存重心迁移到Redis或者Memcached。</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>多个线程同时对数据进行读写就会遇到并发的问题。</p>
<p>处理上述的读写访问的系统，一种经典的解决方案是：实现一种共享锁/排他锁，也叫做读锁/写锁的锁系统。</p>
<p>读锁是共享的，不互相阻塞的，一个资源可以被多个客户端同时访问；写锁是排他的，也就是说一个写锁即会阻塞其他的写锁，也会阻塞读锁，防止一个客户端读取正在写入的资源。</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>如果要进一步的提高并发性，就要确保锁定的对象是具有选择性的，尽量只锁定需要修改的数据，而不是所有的资源。</p>
<h3 id="锁定策略"><a href="#锁定策略" class="headerlink" title="锁定策略"></a>锁定策略</h3><p>在执行锁的时候，也会产生开销，比如获取锁， 释放锁，检查锁是否空闲。对锁的管理和对数据的读写需要进行平衡。</p>
<h3 id="MySQL对锁做出的平衡"><a href="#MySQL对锁做出的平衡" class="headerlink" title="MySQL对锁做出的平衡"></a>MySQL对锁做出的平衡</h3><p>MySQL的不同的存储引擎给出了不同的锁策略和不同的锁粒度。锁粒度的控制可以优化某个场景的性能，但是针对其他的场景可能会导致负优化。</p>
<h3 id="MySQL中比较重要的两种锁策略"><a href="#MySQL中比较重要的两种锁策略" class="headerlink" title="MySQL中比较重要的两种锁策略"></a>MySQL中比较重要的两种锁策略</h3><p>表锁：table lock 是 MySQL 中最基本也是开销最小的锁策略。</p>
<p>行锁：rowlock 可以最大程度的支持并发，也带来了最大的锁开销，比如谁拥有了这些锁，拥有了多长时间，以及何时清理行级别锁。</p>
<p>行级锁是存储引擎实现的，不是服务器实现的，<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL Innodb 引擎锁介绍</a>。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是一组SQL语句作为工作单元以原子方式进行处理。</p>
<p>事务的特性：ACID  原子性：Atomicity、一致性：Consistency、隔离性：Isolation、持久性：Durability</p>
<p>原子性：Atomicity 一个事务中的SQL要么成功要么失败。</p>
<p>一致性：Consistency 从一个一致性状态转移到下一个一致性状态，如果事务没有被提交，一致性状态不应该改变。</p>
<p>隔离性：Isolation 通常来说一个事务未提交以前对其他的事务都是不可见的，这是隔离性带来的结果。但是会有不同的隔离级别，所以通常情况下是不可见的，有时候也会可见。</p>
<p>持久性：Durability 事务一旦提交所有的数据都会被保存到数据库中，不管程序奔溃或者系统奔溃数据也不会丢失。持久性也分为很多的级别，比如三地两中心等物理上的持久化。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>READ UNCOMMITTED（未提交读） 在事务中可以看到其他的事务未提交的更改，这个隔离级别会有很多的问题，即读取未提交的数据也叫做<strong>脏读</strong>，而且从性能上来说也不会比其他的隔离级别好太多，所以这种隔离级别不经常使用。</p>
<p>READ COMMITTED（提交读）这是大多数数据库的默认隔离级别，但是MySQL不是。一个事物可以看到其他事务已提交的数据，但是该事务在提交之前所做的操作对于其他的事务是不可见的，这个隔离级别仍然有着不可重复读的问题。<strong>这意味着同一事务中两次执行相同语句，可能会看到不同的数据结果。</strong></p>
<p>REPEATABLE READ（可重复读）是默认的隔离级别。 这种隔离级别解决了上一个隔离级别的不可重复读的问题，保证了在同一个事务中多次读取相同行数据的结果是一样的。但是理论上还是无法解决<strong>幻读</strong>的问题。所谓的幻读就是当前的事务在读取某个范围的数据时，其他的事务在该范围中<strong>插入</strong>了数据，导致该事务读取时出现了幻行。MySQL是通过<strong>多版本并发控制（MVCC）</strong>解决的幻读的问题。</p>
<p>SERIALIZABLE（可串行化）是最高的隔离级别，通过强制事务按照顺序执行，使事物之间不可能发生发生冲突，从而解决了前面说的幻读问题。原理就是在读取的每一行数据上面都加锁，但是也带来了大量的锁超时和性能问题，实际中很少使用。</p>
<p>以上的各个隔离级别带来的问题和解决的问题：</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复度</th>
<th align="center">幻读</th>
<th align="center">加锁读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">READ UNCOMMITTED（未提交读）</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="left">READ COMMITTED（提交读）</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="left">REPEATABLE READ（可重复读）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="left">SERIALIZABLE（可串行化）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>InnoDB引擎处理死锁的方式是将<strong>持有最少行级排他锁的事务回滚</strong>（这是一种最容易回滚的近似算法）。</p>
<p>锁的行为和顺序适合存储引擎相关的，同样的查询语句在不同的存储引擎上也会表现出不同的结果。产生死锁的双重原因；有些是真正的数据冲突，这种情况通常很难避免，有些则是存储引擎的实现方式导致的。</p>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>事务日志有助于提高事务的效率，存储引擎只需要修改内存中的数据副本，而不需要修改磁盘中的表的数据，然后再把更改的记录持久化到事务日志中，事务日志会被持久化到磁盘上，因为事务日志是追加写操作，在磁盘上是一块顺序IO，所以写入事务日志是相对快的，最后回一个后台进程将事务日志同步到磁盘中的表中。因此，大多数使用这种技术（write-ahead logging，预写式日志）的存储引擎修改数据最终需要写入磁盘两次。</p>
<h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><p>默认情况下，insert、update、delete 会隐士的包装在一个事务中，执行后立即提交，这种称为自动提交。</p>
<p>还有一种情况， 在一个事务执行过程中，当执行了其他的DDL语句或者发生了Lock Table，都会造成事务提前提交。</p>
<p>具体哪些会导致事务的提前提交：</p>
<ul>
<li>DDL 语句 </li>
<li>DCL 语句</li>
<li>在当前事务中开启一个新的事务</li>
<li>锁表或者解锁  lock tables、unlock tables</li>
<li>MySQL从机上执行的一些操作如 start slave、stop slave、reset slave 以及 change master to 等语句也会隐式提交事务。</li>
<li>其他的一下操作如刷新权限（flush privileges）、优化表（<a href="https://so.csdn.net/so/search?q=optimize&spm=1001.2101.3001.7020">optimize</a> table）、修复表（repair table）等操作，也会导致事务的隐式提交。</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MySQL 的事务型存储引擎使用的都是不是简单的行级别锁，而是结合MVCC技术，其他的数据库像Oracle和PostgreSQL也实现了MVCC，但是实现细节可能不相同，</p>
<p>MVCC的实现方式：</p>
<p>主要参与的成员有事务ID，Undo 日志 Redo 日志。</p>
<p>1、在开启事务时，存储引擎就会分配一个事务ID，该ID在事务首次读取任何数据时分配。</p>
<p>2、在该事务修改数据时，在 Undo 日志中写入一天如何恢复该更改的日志，并且事务的回滚指针指向刚刚写入undo日志中的记录。==（这就是事务如何在需要时执行回滚的方法）==。</p>
<p>3、当不同的会话读取聚集主键索引记录时，InnoDB会将该记录的事务ID和该会话的读取视图进行比较，如果当前状态下的记录不应可见（更改它的事务尚未提交），那么Undo日志记录将被跟踪并应用，直到会话达到一个符合可见条件的事务ID。这个过程可以一直循环到完全删除这一行的 Undo 记录，然后向读取视图发出这一行不存在的信号。</p>
<p>所有的 Undo 日志也会写入 Redo 日志。</p>
<p>在记录中保存这些额外的数据的结果就是，大部分查询都不需要在加锁。缺点就是存储引擎在每一行中存储更多的数据，</p>
<p>==MVCC仅适用于REPEATABLE READ和READ COMMITTED隔离级别。==</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>MySQL 提供了一个原生方式来讲写操作复制到其他的节点，源节点为每个副本节点提供一个线程，当写入发生时，线程就会被唤醒，将新的数据复制到副本节点。（通过二进制日志的方式 bin log）</p>
<h2 id="原子DDl"><a href="#原子DDl" class="headerlink" title="原子DDl"></a>原子DDl</h2><p>MySQL8引入了原子定义更改，意味着数据定义语句现在要么全部成功完成，要么全部失败回滚，是通过创建DDL特定的 Undo 和 Redo 日志来实现的。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>高性能MySQL(第四版)</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>创建高性能的索引</title>
    <url>/2023/09/17/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%9B%9B%E7%89%88(%E4%B8%83)%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h1><p>索引是一种快速找到记录的<strong>数据结构</strong></p>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>我们把它读作B+树索引，是一种特殊的树形结构。</p>
<p>自适应哈希索引</p>
<p>InnoDB 发现当某些索引值被频繁的访问时，会在原有的b+树索引上在构建一个哈希索引，使其也具备了哈希索引的优势。这些操作是InnoDB自动完成的，用户无法控制，不过可以通过参数关闭这个特性。</p>
<p>B+树索引的一些限制：</p>
<ul>
<li>不符合最左前缀。即a、b、c三个索引只使用b、c索引。</li>
<li>不能跳过索引中的列。</li>
<li>like 条件， 但是%在开头的情况下不会走索引（也没那么绝对）</li>
</ul>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>有时候为了提升索引的性能，同时也节省索引空间，可以只对字段的前一部分字符进行索引。但是也有缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY操作，也无法使用前缀索引做覆盖扫描。</p>
<h2 id="索引的选择性"><a href="#索引的选择性" class="headerlink" title="索引的选择性"></a>索引的选择性</h2><p>索引的选择性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（＃T）的比值，范围从1/＃T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>错误的多列索引是为每列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<p>MySQL引入了一种叫“索引合并”（index merge）的策略，它在一定程度上可以使用表中的多个单列索引来定位指定的行。在这种情况下，查询能够同时使用两个单列索引进行扫描，并将结果进行合并。</p>
<p>虽然索引合并有时候效果不错，但是也从侧面说明了索引建立的很糟糕：</p>
<ul>
<li>优化器对索引做相交操作时（通常发生在多个and条件），意味着使用多列索引可能会更好，而不是单个列的索引。</li>
<li>优化器对索引做联合操作时（通常发生在多个and条件），通常在算法的缓存、排序、合并上做大量的操作需要消耗cpu资源。</li>
<li>更加重要的时候优化器不会把这些计算到查询成本中，使得查询的成本被低估。</li>
</ul>
<blockquote>
<p>如果在EXPLAIN中看到有索引合并，那么就应该好好检查一下查询语句的写法和表的结构，看是不是已经是最优的。也可以通过参数optimizer_switch来关闭索引合并功能。</p>
</blockquote>
<p>如何选择合适的索引列顺序？</p>
<p>经验：</p>
<ul>
<li>通盘考虑，应该避免大量随机I/O和排序。如果不考虑排序和分组将选择性最高的列放在最前面是比较高性能的。</li>
<li>根据查询的值来判断，根据查询频率高的列或者根据列的值的分部来设置索引的排序。但是也不能根据某查询得出结果一概而论。</li>
</ul>
<h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>是一种存储数据的方式，将索引和数据存储在一起，拿到索引就相当于拿到了数据。在InnoDB中的聚集索引就是在同一个结构上保存了索引和数据结构。数据存储在索引的叶子结点上，所以一个表只能有一个聚集索引。不过覆盖索引可以模拟多个聚集索引的情况。</p>
<p>InnoDB根据主键聚集数据，所以一个表中没有定义主键的话，InnoDB会选择一个唯一的非空索引代替，如果没有符合的情况， InnoDB会自己创建一个唯一值作为主键索引。</p>
<p>聚集索引的好处：</p>
<ul>
<li>能够更快的读取数据，相比于非聚集索引能够更快的查询到数据。</li>
<li>使用覆盖索引查询时，可以直接使用节点中的主键值。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据都存储在索引中，索引在内存中缓存，极大地增加了IO密集型的性能，但是如果都在内存中。聚集索引也没有什么优势了。</li>
<li>插入的速度依赖插入的顺序。</li>
<li>更新聚集索引的代价很高，会对所有的索引节点进行重新排序。</li>
<li>二级索引可能会变得更大，因为二级索引的叶子节点包含了引用行的主键列。</li>
<li>主键被更新导致需要移动行的时候，可能面临页分裂（page split）的问题，导致磁盘占用变大。</li>
<li>二级索引访问需要两次索引查找，而不是一次。因为二级索引保存的是主键的值，还需要在重新在聚集索引中茶盏一次，才能拿到数据。自适应哈希索引能够减少这样的重复工作。</li>
</ul>
<h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p>其他非主键索引都叫二级索引或者是非聚集索引。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>创建索引一般会根据where条件来创建，设计优秀的索引应该考虑到整个查询，而不单是WHERE条件部分。如果床读取索引是能直接获取到列的数据，即索引的叶子结点已经包含要查询的数据。就没有必要在回表查询（即再根据主键索引查询实际的数据列）了。如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。需要注意是，只有B-tree索引可以用于覆盖索引。</p>
<p>好处：</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。</li>
<li>由于InnoDB的聚簇索引的特点，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了记录的主键值，所以如果二级索引能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<blockquote>
<p>当执行一个被索引覆盖的查询（也叫作索引覆盖查询）时，在EXPLAIN的Extra列可以看到“Using index”的信息。</p>
</blockquote>
<h2 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h2><p>未使用的索引建议完全删除，查找未使用的索引方法：<code>select * from sys.schema_unused_indexes</code></p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>高性能MySQL(第四版)</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>查询性能优化</title>
    <url>/2023/09/17/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%9B%9B%E7%89%88(%E5%85%AB)%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h1><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><p>1、是否在查询中包含了大量的不需要的行</p>
<p>2、服务器是否在分析大量的不需要的行。</p>
<p>针对第一点我们要规避的一些操作：</p>
<ul>
<li>查询了100行 只显示10行。</li>
<li>多表连接时返回全部列。</li>
<li>使用select * from …。</li>
<li>重复查询相同的数据。</li>
</ul>
<p>针对第二点如何确保MySQL是否在扫描一些额外的记录，我们可以通过三个指标进行衡量：响应时间、扫描行数、返回的行数。这是哪个指标们记录到MySQL的慢查询日志中。</p>
<h2 id="MySQL-执行计划的知识补充"><a href="#MySQL-执行计划的知识补充" class="headerlink" title="MySQL 执行计划的知识补充"></a>MySQL 执行计划的知识补充</h2><p>我们主要查看两个字段的含义：</p>
<p>type：代表我们的查询使用了哪种类型的查询分别有：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。 此值一般要超过range，最好是达到ref是比较合格的一个查询。</p>
<p>Extra: 解析查询的额外信息</p>
<p>Using index：使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。 </p>
<p>Using where：从数据表中返回数据，然后过滤不满足条件的记录。这在MySQL服务器层完成，MySQL需要先从数据表中读出记录然后过滤。</p>
<p>发现查询需要扫描大量的数据但只返回少数行，可以尝试下面的技巧去优化它：</p>
<ul>
<li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。</li>
<li>改变库表结构。例如，使用单独的汇总表（这是我们在第6章中讨论的办法）。</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>高性能MySQL(第四版)</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的服务器配置</title>
    <url>/2023/09/17/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%9B%9B%E7%89%88(%E4%BA%94)%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="MySQL的服务器配置"><a href="#MySQL的服务器配置" class="headerlink" title="MySQL的服务器配置"></a>MySQL的服务器配置</h1><h2 id="查询MySQL的配置"><a href="#查询MySQL的配置" class="headerlink" title="查询MySQL的配置"></a>查询MySQL的配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which mysqld</span><br></pre></td></tr></table></figure>
<p>根据找到的mysqld 在进行获取配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/sbin/mysqld --verbose --help | gerp -A 1 &#x27;Default options&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf </span><br></pre></td></tr></table></figure>
<h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><p>配置文件采用标准INI格式，被分为多个部分，每个部分都以一行包含在方括号中的该部分名称开头。客户端程序也会读取client部分，服务器通常读取mysqld部分。</p>
<p>配置使用小写字母表示，单词之间使用下划线或者短横分隔，两种表示方式都是有效的。（建议使用同一种风格）</p>
<p>除了在配置文件中进行设置外，很多变量（但不是全部）还可以在服务器运行时进行更改。MySQL将这些称为动态配置变量。但是在服务器重启之后更改项就会失效。</p>
<p>MySQL 8.0引入了一个名为持久化系统变量的新功能，语法为：<code>SET PERSIST</code>允许在运行时设置一次值，MySQL将把这个设置写入磁盘，以便在下次重启后继续使用该值。</p>
<blockquote>
<p>我们建议专注于优化峰值工作负载，然后在“足够好”的时候就可以停止优化。</p>
</blockquote>
<h2 id="最小示例文件"><a href="#最小示例文件" class="headerlink" title="最小示例文件"></a>最小示例文件</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 数据存放的位置</span></span><br><span class="line"><span class="attr">datadir</span>                   = /var/lib/mysql</span><br><span class="line"><span class="comment"># socket 配置，建议显示的配置此值，具体路径按需定义</span></span><br><span class="line"><span class="attr">socket</span>                    = /var/lib/mysql/mysql.sock </span><br><span class="line"><span class="comment"># pid 配置，建议显示的配置此值，具体路径按需定义</span></span><br><span class="line"><span class="attr">pid_file</span>                  = /var/lib/mysql/mysql.pid</span><br><span class="line"><span class="comment"># 确保用户存在，且有相关路径的操作权限</span></span><br><span class="line"><span class="attr">user</span>                      = mysql</span><br><span class="line"><span class="comment"># 端口，生产环境课适当的更改</span></span><br><span class="line"><span class="attr">port</span>                      = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在MySQL 8.0中引入了一些新的配置选项， 适用于云服务器环境中。</span></span><br><span class="line"><span class="comment"># InnnoDB</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span>   = &lt;value&gt;</span><br><span class="line"><span class="attr">innodb_log_file_size</span>      = &lt;value&gt;</span><br><span class="line"><span class="attr">innodb_file_per_table</span>     = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_flush_method</span>       = O_DIRECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span>    = <span class="number">8</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># logging</span></span><br><span class="line"><span class="attr">log_error</span>                 = /var/lib/mysql/mysql-error.log</span><br><span class="line"><span class="attr">log_slow_queries</span>          = /var/lib/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># other</span></span><br><span class="line"><span class="attr">tmp_table_size</span>            = <span class="number">32</span>M</span><br><span class="line"><span class="attr">max_heap_table_size</span>       = <span class="number">32</span>M</span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>           = &lt;value&gt;</span><br><span class="line"><span class="comment"># 线程缓冲大小</span></span><br><span class="line"><span class="attr">thread_cache_size</span>         = &lt;value&gt;</span><br><span class="line"><span class="attr">table_open_cache</span>          = &lt;value&gt;</span><br><span class="line"><span class="comment"># 在Linux系统中可以将值设置的尽可能的大，如果这个设置不够大，就会看到经典的24号错误，“too many open files”。</span></span><br><span class="line"><span class="attr">open_file_limit</span>           = <span class="number">65535</span></span><br><span class="line"><span class="section">[client]</span>                 </span><br><span class="line"><span class="attr">socket</span>                    = /var/lib/mysql/mysql.sock</span><br><span class="line"><span class="attr">port</span>                      = <span class="number">3306</span></span><br></pre></td></tr></table></figure>


<p>后续还会在补充</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>高性能MySQL(第四版)</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Schema设计与管理</title>
    <url>/2023/09/17/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%9B%9B%E7%89%88(%E5%85%AD)schema%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Schema设计与管理"><a href="#Schema设计与管理" class="headerlink" title="Schema设计与管理"></a>Schema设计与管理</h1><h2 id="schema-数据类型优化原则"><a href="#schema-数据类型优化原则" class="headerlink" title="schema 数据类型优化原则"></a>schema 数据类型优化原则</h2><ul>
<li>越小的约好<ul>
<li>占用的磁盘、内存、cpu缓存的空间少</li>
<li>但要确保不要低估值的范围</li>
</ul>
</li>
<li>简单的数据类型<ul>
<li>简单的数据类型的操作需要更少的cpu执行周期</li>
<li>整形笔字符串更好，是因为字符集和排序规则字符串更加的复杂</li>
<li>尽可能使用内置的日期类型</li>
<li>存储IP地址尽可能使用整形</li>
</ul>
</li>
<li>尽量避免存储NULl类型<ul>
<li>null是索引和索引统计以及值的比较都更加的复杂</li>
<li>但是设置为not null也不会带来很大的性能提升，具体根据业务情况设定列是否包含空置</li>
</ul>
</li>
</ul>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>有两种类型的数字：整数和实数（带有小数的数字）。</p>
<h3 id="整数类型-1"><a href="#整数类型-1" class="headerlink" title="整数类型"></a>整数类型</h3><p>存储整数的数据类型有 TINYINT、SMALLINT、MEDIUMINT、INT或BIGINT。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>位数</th>
<th>值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td>8</td>
<td>-2^(8-1)^ ~ 2^(8-1)^ - 1</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td>16</td>
<td>-2^(16-1)^ ~ 2^(16-1)^ - 1</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td>24</td>
<td>-2^(24-1)^ ~ 2^(24-1)^ - 1</td>
</tr>
<tr>
<td align="left">INT</td>
<td>32</td>
<td>-2^(32-1)^ ~ 2^(32-1)^ - 1</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td>64</td>
<td>-2^(64-1)^ ~ 2^(64-1)^ - 1</td>
</tr>
</tbody></table>
<p>整数类型还可以设置无符号选项 UNSIGNED ，可以使正书的大小上限提高一倍，例如，TINYINT UNSIGNED可以存储的值的范围是0～255，而TINYINT的值的存储范围是-128～127。无符号和有符号性能一致，可以根据具体业务来选择。</p>
<p>MySQL还可以为整形提供宽度，例如我们常看到的INT(11)，这种形式不会限制值的大小范围只是在一些交互工具中显示值的字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同的。</p>
<h3 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h3><p>实数是带小数的数字，FLOAT 和 DOUBLE 支持使用标准的浮点运行进行近似运算；FLOAT 占用4字节的存储空间，DOUBLE 占用8字节的存储空间。</p>
<p>如果需要对小数进准计算应使用 DECIMAL 来存储实数。例如货币信息等。</p>
<p>也可以使用BIGINT来代替大数据量的DECIMAL，例如根据货币的小数的位数乘以相应的倍数。假设要存储财务数据需要精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在BIGINT里，这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>VARCHAR存储可变长度的字符串，比使用固定长度类型的字符串更加的节省空间，需要注意的是他需要额外的1到2字节存储字符串的长度。VARCHAR 节省了空间性能也有所提升，但是可变长度的字符串当长度增长时，InnoDb需要分割页面来容纳新行。</p>
<p><strong>字符串长度定义的不是字节数，是字符数。多字节字符集可能需要多个字节来存储1个字符。</strong></p>
<p>使用VARCHAR的场景：</p>
<ul>
<li>字符串的最大长度远大于平均长度</li>
<li>列的更新很少</li>
<li>使用了UTF-8这样或更复杂的字符集</li>
</ul>
<p>CHAR是固定长度的，存储CHAR值时会删除尾部的空格，需要进行比较会使用空格填充。</p>
<p>使用CHAR的场景：</p>
<ul>
<li>存储非常短的字符，或者长度几乎相同的字符串。比如说MD5密码</li>
<li>经常修改的数据，因为固定长度不容易产生碎片。</li>
</ul>
<p>BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。它们分别属于两组不同的数据类型家族：</p>
<ul>
<li><p>字符类型：TINYTEXT、SMALLTEXT、TEXT、MEDIUMTEXT和LONGTEXT；</p>
</li>
<li><p>二进制类型：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。</p>
</li>
</ul>
<p>BLOB  是 SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。</p>
<p>MySQL把每个BLOB和TEXT值当作一个具有自己标识的对象来处理。存储引擎通常会专门存储它们。当BLOB和TEXT值太大时，InnoDB会使用独立的“外部”存储区域，此时每个值在行内需要1～4字节的存储空间，然后在外部存储区域需要足够的空间来存储实际的值。</p>
<p>BLOB和TEXT的唯一区别就是BLOB没有排序规则和字符集而TEXT有。</p>
<p>MySQL只对BLOB和TEXT列的最前max_sort_length字节而不是整个字符串做排序。也不能使用索引进行排序。</p>
<blockquote>
<p>以前经常将图像数据存储为BLOB，当数据量过大时，就会导致某方面性能下降，所以在存储图像时尽量将图像存储到专门的对象存储中去，只在数据库中存储对应的地址或者文件名。</p>
</blockquote>
<p>有时还可以使用枚举对象来代替字符串，MySQL会根据列表值的数量压缩到1或者2字节中。在内部会将每个值在列表中的位置保存为整数。所以存储枚举时应尽量使用字符串而不是数字字符串。另一个需要注意的是：枚举的值排序不是根据枚举字符串排序的，是根据内部的整数值排序的。</p>
<h2 id="DATETIME和TIMESTAMP-日期和时间类型"><a href="#DATETIME和TIMESTAMP-日期和时间类型" class="headerlink" title="DATETIME和TIMESTAMP 日期和时间类型"></a>DATETIME和TIMESTAMP 日期和时间类型</h2><p>DATETIME 可以存储很大的时间，从1000年到9999年，精度为一微秒。它以YYYYMMDDHHMMSS格式存储压缩成整数的日期和时间，且与时区无关。这需要8字节的存储空间。默认情况下，MySQL以可排序、无歧义的格式显示DATETIME值，例如，2023-08-18 15：39：08。</p>
<p>TIMESTAMP 类型存储自1970年1月1日格林尼治标准时间（GMT）午夜以来经过的秒数——与UNIX时间戳相同。TIMESTAMP只使用4字节的存储空间，所以它的范围比DATETIME小得多：只能表示从1970年到2038年1月19日。</p>
<p>MySQL提供FROM_UNIXTIME()函数来将UNIX时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数将日期转换为UNIX时间戳。</p>
<h2 id="位压缩数据类型"><a href="#位压缩数据类型" class="headerlink" title="位压缩数据类型"></a>位压缩数据类型</h2><p>这两种类型从技术上来说都是字符串类型。</p>
<p>BIT 可以存储一个或者多个true/false值，BIT(1)代表一位的字段，BIT(3)代表2为的字段，MySQL在处理时会将BIT视为字符串类型，而不是数字类型。当检索BIT（1）的值时，结果是一个包含二进制值0或1的字符串，而不是ASCII码的“0”或“1”。 最好避免使用这种类型。</p>
<p>SET 集合存储类型，可以将多列组合成一列，这在MySQL内部是以一组打包的位的集合来表示的。有对应的FIND_IN_SET()和FIELD()等函数，使其易于在查询中使用。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>在文章的测试中 sql模式的性能总是大于json模式的性能，当数据量更大时，差距会更加的明显。所以我们在选择使用json模式时，取决于在数据库中存储json的便捷性是否大于性能。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>当我们创建一个用户表时，我们通常会为每个用户分配一个唯一值或者唯一标识符，标识符列的类型选择更为重要。因为他通常扮演了与其他列进行比较、查找的索引、外键的功能。</p>
<p>关于为标识符选择类型的一些建议：</p>
<ul>
<li>整数类型：通常是最佳选择，因为速度快、可以递增，等等。</li>
<li>ENUM和SET类型：不建议。</li>
<li>字符串类型：也不建议，因为既消耗空间，速度也比较慢。<ul>
<li>像是 MD5()和UUID()生成的随机字符，也不建议，因为当使用这些字符串时索引的值会随机的插入到某个部分，使得查询很慢，也会导致页的分裂，磁盘随机访问，聚集索引产生聚集索引随机碎片。</li>
</ul>
</li>
<li>如果存储通用唯一标识符（UUID）值，则应该删除破折号，或者更好的做法是，使用UNHEX()函数将UUID值转换为16字节的数字，并将其存储在一个BINARY（16）列中。可以使用HEX()函数以十六进制格式检索值。</li>
</ul>
<h2 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h2><p>文章以IPv4进行了举例，IPv4实际上是32为无符号整数，而不是字符串。用小数点将地址分成四段的表示方法只是为了让人们阅读容易，所以应该将IP地址存储为无符号整数。MySQL提供了INET_ATON()和INET_NTOA()函数来在这两种表示形式之间进行转换。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>高性能MySQL(第四版)</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>前端样式的BEM架构基础实践</title>
    <url>/2023/09/16/%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E7%9A%84BEN%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>element-plus 的架构设计目的为解决当涉及到更大、更复杂的项目时，如何组织代码。</p>
<p>他的一套方法论是使用一套固定的结构和命名约定。</p>
</blockquote>
<p>BEM详细介绍地址：<a href="https://getbem.com/">Link</a></p>
<p>其中element-plus 就是采用了bem架构设计的一套样式规则。今天我们使用bem模式来实现一个常见的自适应容器布局。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230916213942355.png" alt="image-20230916213942355"></p>
<h2 id="1-了解BEM的前置知识"><a href="#1-了解BEM的前置知识" class="headerlink" title="1 了解BEM的前置知识"></a>1 了解BEM的前置知识</h2><h3 id="嵌套样式"><a href="#嵌套样式" class="headerlink" title="嵌套样式"></a>嵌套样式</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="selector-class">.b</span> &#123;</span><br><span class="line">        <span class="selector-class">.c</span> &#123;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="value-定义变量"><a href="#value-定义变量" class="headerlink" title="$value 定义变量"></a>$value 定义变量</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color</span>: blue;</span><br><span class="line"><span class="variable">$width</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.el</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="at-root-在嵌套的样式中，-跳出父级节点的类名即不在子类名之前再追加父级类名"><a href="#at-root-在嵌套的样式中，-跳出父级节点的类名即不在子类名之前再追加父级类名" class="headerlink" title="@at-root : 在嵌套的样式中， 跳出父级节点的类名即不在子类名之前再追加父级类名"></a>@at-root : 在嵌套的样式中， 跳出父级节点的类名即不在子类名之前再追加父级类名</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常的样式</span></span><br><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="selector-class">.child</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用@at-root 后的正常的样式</span></span><br><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="keyword">@at-root</span> .child &#123;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="mixin：混入-类似于批量处理-把比较通用的抽离出来，方便统一引用。"><a href="#mixin：混入-类似于批量处理-把比较通用的抽离出来，方便统一引用。" class="headerlink" title="@mixin：混入, 类似于批量处理,把比较通用的抽离出来，方便统一引用。"></a>@mixin：混入, 类似于批量处理,把比较通用的抽离出来，方便统一引用。</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> large-text &#123;</span><br><span class="line">    <span class="attribute">font</span>: &#123;</span><br><span class="line">        family: Arial;</span><br><span class="line">        size: <span class="number">20px</span>;</span><br><span class="line">        weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="selector-class">.el</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> large-text;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后样式即为：</span></span><br><span class="line"><span class="selector-class">.el</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混入也可以设置参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> sexy-boder(<span class="variable">$color</span>, <span class="variable">$width</span>) &#123;</span><br><span class="line">    <span class="attribute">border</span>: &#123;</span><br><span class="line">        color: <span class="variable">$color</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.el</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> sexy-boder(blue, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="插值表达式，-在选择器或者属性名称中使用变量"><a href="#插值表达式，-在选择器或者属性名称中使用变量" class="headerlink" title="插值表达式， 在选择器或者属性名称中使用变量"></a>插值表达式， 在选择器或者属性名称中使用变量</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span>: foo;</span><br><span class="line"><span class="variable">$attr</span>: border;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>.#&#123;<span class="variable">$name</span>&#125; &#123;</span><br><span class="line">	#&#123;<span class="variable">$attr</span>&#125;-<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="amp-：代表当前的父选择器"><a href="#amp-：代表当前的父选择器" class="headerlink" title="&amp;：代表当前的父选择器"></a>&amp;：代表当前的父选择器</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span><span class="selector-class">.bar</span> <span class="selector-class">.baz</span><span class="selector-class">.bang</span>,</span><br><span class="line"><span class="selector-class">.bip</span><span class="selector-class">.qux</span> &#123;</span><br><span class="line">        <span class="variable">$selector</span>: &amp;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &amp; 此时的父选择器为 .foo.bar .baz.bang 和 .bip.qu</span></span><br></pre></td></tr></table></figure>


<h2 id="2-在Vue中使用"><a href="#2-在Vue中使用" class="headerlink" title="2 在Vue中使用"></a>2 在Vue中使用</h2><h3 id="定义bem结构和命名规则"><a href="#定义bem结构和命名规则" class="headerlink" title="定义bem结构和命名规则"></a>定义bem结构和命名规则</h3><p>在项目根目录下新建：/src/styles/bem.scss</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个变量， 作为开头, 可以任意定义字符，此处以cz为例。 !default： 代表这个变量没有赋值过别的值。</span></span><br><span class="line"><span class="variable">$namespace</span>: <span class="string">&quot;cz&quot;</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block</span></span><br><span class="line"><span class="variable">$block-sel</span>: <span class="string">&quot;-&quot;</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Element</span></span><br><span class="line"><span class="variable">$elem-sel</span>: <span class="string">&quot;__&quot;</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modifier</span></span><br><span class="line"><span class="variable">$mod-sel</span>: <span class="string">&quot;--&quot;</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  开始构建block规则结构，例如： &lt;div class=&quot;cz-block&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">@mixin</span> b(<span class="variable">$block</span>) &#123;</span><br><span class="line">	<span class="comment">// 拼接规则</span></span><br><span class="line">	<span class="variable">$B</span>: #&#123;<span class="variable">$namespace</span> + <span class="variable">$block-sel</span> + <span class="variable">$block</span>&#125;;</span><br><span class="line">	<span class="comment">// 使用插值表达式</span></span><br><span class="line">	.#&#123;<span class="variable">$B</span>&#125; &#123;</span><br><span class="line">		<span class="comment">// @content 代表样式的具体内容，类似占位符的作用</span></span><br><span class="line">		<span class="keyword">@content</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始构建element规则结构，例如： &lt;div class=&quot;cz-block__button&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">@mixin</span> e(<span class="variable">$el</span>) &#123;</span><br><span class="line">	<span class="comment">// 拼接规则， 直接读取父级选择器</span></span><br><span class="line">	<span class="variable">$selector</span>: &amp;;</span><br><span class="line">	<span class="comment">// 不再需要父级的选择器</span></span><br><span class="line">	<span class="keyword">@at-root</span> &#123;</span><br><span class="line">		#&#123;<span class="variable">$selector</span> + <span class="variable">$elem-sel</span> + <span class="variable">$el</span>&#125; &#123;</span><br><span class="line">			<span class="keyword">@content</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始构建Modifier规则结构，例如： &lt;div class=&quot;cz-block--success&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">@mixin</span> m(<span class="variable">$m</span>) &#123;</span><br><span class="line">	<span class="comment">// 拼接规则， 直接读取父级选择器</span></span><br><span class="line">	<span class="variable">$selector</span>: &amp;;</span><br><span class="line">	<span class="comment">// 不再需要父级的选择器</span></span><br><span class="line">	<span class="keyword">@at-root</span> &#123;</span><br><span class="line">		#&#123;<span class="variable">$selector</span> + <span class="variable">$mod-sel</span> + <span class="variable">$m</span>&#125; &#123;</span><br><span class="line">			<span class="keyword">@content</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个通用规则</span></span><br><span class="line"><span class="keyword">@mixin</span> bfc &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="在vite-config-ts定义全局css预处理"><a href="#在vite-config-ts定义全局css预处理" class="headerlink" title="在vite.config.ts定义全局css预处理"></a>在vite.config.ts定义全局css预处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &quot;vite&quot;;</span><br><span class="line">import vue from &quot;@vitejs&#x2F;plugin-vue&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">	plugins: [vue()],</span><br><span class="line">	css: &#123;</span><br><span class="line">		preprocessorOptions: &#123;</span><br><span class="line">			scss: &#123;</span><br><span class="line">				additionalData: &#96;@import &quot;.&#x2F;src&#x2F;styles&#x2F;bem.scss&quot;;&#96;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="3-使用BEM模式实现一个容器样式"><a href="#3-使用BEM模式实现一个容器样式" class="headerlink" title="3 使用BEM模式实现一个容器样式"></a>3 使用BEM模式实现一个容器样式</h2><p>项目目录</p>
<p><img src="https://origin.chaizz.com/tc/image-20230916230612119.png" alt="image-20230916230612119"></p>
<p>src/styles/reset.scss</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">*,</span><br><span class="line">*<span class="selector-pseudo">:after</span>,</span><br><span class="line">*<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">	<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-tag">span</span>,</span><br><span class="line">applet,</span><br><span class="line"><span class="selector-tag">object</span>,</span><br><span class="line"><span class="selector-tag">iframe</span>,</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span>,</span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">pre</span>,</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">abbr</span>,</span><br><span class="line"><span class="selector-tag">acronym</span>,</span><br><span class="line"><span class="selector-tag">address</span>,</span><br><span class="line"><span class="selector-tag">big</span>,</span><br><span class="line"><span class="selector-tag">cite</span>,</span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">del</span>,</span><br><span class="line"><span class="selector-tag">dfn</span>,</span><br><span class="line"><span class="selector-tag">em</span>,</span><br><span class="line"><span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-tag">ins</span>,</span><br><span class="line"><span class="selector-tag">kbd</span>,</span><br><span class="line"><span class="selector-tag">q</span>,</span><br><span class="line">s,</span><br><span class="line"><span class="selector-tag">samp</span>,</span><br><span class="line"><span class="selector-tag">small</span>,</span><br><span class="line"><span class="selector-tag">strike</span>,</span><br><span class="line"><span class="selector-tag">strong</span>,</span><br><span class="line"><span class="selector-tag">sub</span>,</span><br><span class="line"><span class="selector-tag">sup</span>,</span><br><span class="line"><span class="selector-tag">tt</span>,</span><br><span class="line"><span class="selector-tag">var</span>,</span><br><span class="line"><span class="selector-tag">b</span>,</span><br><span class="line">u,</span><br><span class="line"><span class="selector-tag">i</span>,</span><br><span class="line">center,</span><br><span class="line"><span class="selector-tag">dl</span>,</span><br><span class="line"><span class="selector-tag">dt</span>,</span><br><span class="line"><span class="selector-tag">dd</span>,</span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">li</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span>,</span><br><span class="line"><span class="selector-tag">form</span>,</span><br><span class="line"><span class="selector-tag">label</span>,</span><br><span class="line"><span class="selector-tag">legend</span>,</span><br><span class="line"><span class="selector-tag">table</span>,</span><br><span class="line"><span class="selector-tag">caption</span>,</span><br><span class="line"><span class="selector-tag">tbody</span>,</span><br><span class="line"><span class="selector-tag">tfoot</span>,</span><br><span class="line"><span class="selector-tag">thead</span>,</span><br><span class="line"><span class="selector-tag">tr</span>,</span><br><span class="line"><span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-tag">td</span>,</span><br><span class="line"><span class="selector-tag">article</span>,</span><br><span class="line"><span class="selector-tag">aside</span>,</span><br><span class="line"><span class="selector-tag">canvas</span>,</span><br><span class="line"><span class="selector-tag">details</span>,</span><br><span class="line"><span class="selector-tag">embed</span>,</span><br><span class="line"><span class="selector-tag">figure</span>,</span><br><span class="line"><span class="selector-tag">figcaption</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">hgroup</span>,</span><br><span class="line">menu,</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">output</span>,</span><br><span class="line"><span class="selector-tag">ruby</span>,</span><br><span class="line"><span class="selector-tag">section</span>,</span><br><span class="line">summary,</span><br><span class="line"><span class="selector-tag">time</span>,</span><br><span class="line"><span class="selector-tag">mark</span>,</span><br><span class="line"><span class="selector-tag">audio</span>,</span><br><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">	<span class="attribute">font</span>: inherit;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">vertical-align</span>: baseline;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span>,</span><br><span class="line"><span class="selector-tag">aside</span>,</span><br><span class="line"><span class="selector-tag">details</span>,</span><br><span class="line"><span class="selector-tag">figcaption</span>,</span><br><span class="line"><span class="selector-tag">figure</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">hgroup</span>,</span><br><span class="line">menu,</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">	<span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">q</span> &#123;</span><br><span class="line">	<span class="attribute">quotes</span>: none;</span><br><span class="line"></span><br><span class="line">	&amp;<span class="selector-pseudo">:before</span>,</span><br><span class="line">	&amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">		<span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="attribute">content</span>: none;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sub</span>,</span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">75%</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">	<span class="attribute">top</span>: -<span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sub</span> &#123;</span><br><span class="line">	<span class="attribute">bottom</span>: -<span class="number">0.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">	<span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span>,</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">	<span class="attribute">font-family</span>: inhert;</span><br><span class="line">	<span class="attribute">font-size</span>: inherit;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">select</span> &#123;</span><br><span class="line">	<span class="attribute">text-indent</span>: <span class="number">0.01px</span>;</span><br><span class="line">	<span class="attribute">text-overflow</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	-webkit-appearance: none;</span><br><span class="line">	-moz-appearance: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">select</span>::-ms-expand &#123;</span><br><span class="line">	display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">pre</span> &#123;</span><br><span class="line">	<span class="attribute">font-family</span>: monospace, monospace;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/src/styles/index.scss</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入清除默认的样式</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./reset.scss&#x27;</span></span><br></pre></td></tr></table></figure>
<p>/src/styles/bem.scss</p>
<p>同第二步的scss</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles/index.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>/src/main.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Layout from &quot;.&#x2F;Layout&#x2F;index.vue&quot;;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Layout&gt;&lt;&#x2F;Layout&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">    @include bfc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>/src/App.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import Layout from &quot;.&#x2F;Layout&#x2F;index.vue&quot;;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Layout&gt;&lt;&#x2F;Layout&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">    @include bfc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>


<p>/src/Layout/index.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;ts&gt;</span><br><span class="line">import Header from &quot;.&#x2F;Header&#x2F;index.vue&quot;;</span><br><span class="line">import Content from &quot;.&#x2F;Content&#x2F;index.vue&quot;;</span><br><span class="line">import Menu from &quot;.&#x2F;Menu&#x2F;index.vue&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;cz-box&quot;&gt;</span><br><span class="line">        &lt;Menu&gt;&lt;&#x2F;Menu&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;cz-box__right&quot;&gt;</span><br><span class="line">            &lt;Header&gt;&lt;&#x2F;Header&gt;</span><br><span class="line">            &lt;Content&gt;&lt;&#x2F;Content&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped  lang&#x3D;&#39;scss&#39;&gt;</span><br><span class="line">@include b(box) &#123;</span><br><span class="line">    @include bfc;</span><br><span class="line">    display: flex;</span><br><span class="line"></span><br><span class="line">    @include e(right) &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>/src/Layout/Menu/index.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;ts&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;cz-menu&quot;&gt;</span><br><span class="line">        Menu</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped  lang&#x3D;&#39;scss&#39;&gt;</span><br><span class="line">@include b(menu) &#123;</span><br><span class="line">    min-width: 200px;</span><br><span class="line">    border-right: 1px solid rgb(57, 22, 184);</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>/src/Layout/Header/index.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;ts&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;cz-header&quot;&gt;</span><br><span class="line">        Header</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped  lang&#x3D;&#39;scss&#39;&gt;</span><br><span class="line">@include b(header) &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-bottom: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>/src/Layout/Content/index.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang&#x3D;ts&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;cz-content&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;cz-content__items&quot; v-for&#x3D;&quot;(item, index) in 100&quot;&gt; &#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped  lang&#x3D;&#39;scss&#39;&gt;</span><br><span class="line">@include b(content) &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    overflow: auto;</span><br><span class="line"></span><br><span class="line">    @include e(items) &#123;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        margin: 10px;</span><br><span class="line">        border: 1px solid #ccc;</span><br><span class="line">        border-radius: 4px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-效果"><a href="#4-效果" class="headerlink" title="4 效果"></a>4 效果</h2><p><img src="https://origin.chaizz.com/tc/Snipaste_2023-09-16_23-41-47.png" alt="Snipaste_2023-09-16_23-41-47"></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用butterfly主题设置文章的Format</title>
    <url>/2023/07/30/%E4%BD%BF%E7%94%A8butterfly%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E7%9A%84Format/</url>
    <content><![CDATA[<h1 id="文件头示例"><a href="#文件头示例" class="headerlink" title="文件头示例"></a>文件头示例</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">使用butterfly主题设置文章的Format</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Butterfly</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">教程</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">教程</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&quot;Hexo,主题配置&quot;</span></span><br><span class="line"><span class="attr">abbrlink:</span> </span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-7</span><span class="number">-30</span> <span class="number">19</span><span class="string">:22:45</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">butterfly主题文章format</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">https://origin.chaizz.com/undraw_online_art_re_f1pk.svg</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">https://origin.chaizz.com/undraw_online_art_re_f1pk.svg</span></span><br><span class="line"><span class="attr">copyright:</span></span><br><span class="line"><span class="attr">copyright_author:</span></span><br><span class="line"><span class="attr">copyright_author_href:</span></span><br><span class="line"><span class="attr">copyright_url:</span></span><br><span class="line"><span class="attr">copyright_info:</span>    </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>title</th>
<th>【必需】文章标题</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>【必需】文章创建日期</td>
</tr>
<tr>
<td>updated</td>
<td>【可选】文章更新日期</td>
</tr>
<tr>
<td>tags</td>
<td>【可选】文章标签</td>
</tr>
<tr>
<td>categories</td>
<td>【可选】文章分类</td>
</tr>
<tr>
<td>keywords</td>
<td>【可选】文章关键字</td>
</tr>
<tr>
<td>description</td>
<td>【可选】文章描述</td>
</tr>
<tr>
<td>top_img</td>
<td>【可选】文章顶部图片</td>
</tr>
<tr>
<td>cover</td>
<td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td>
</tr>
<tr>
<td>comments</td>
<td>【可选】显示文章评论模块(默认 true)</td>
</tr>
<tr>
<td>toc</td>
<td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td>
</tr>
<tr>
<td>toc_number</td>
<td>【可选】显示toc_number(默认为设置中toc的number配置)</td>
</tr>
<tr>
<td>copyright_author</td>
<td>【可选】文章版权模块的文章作者</td>
</tr>
<tr>
<td>copyright_author_href</td>
<td>【可选】文章版权模块的文章作者链接</td>
</tr>
<tr>
<td>copyright_url</td>
<td>【可选】文章版权模块的文章连结链接</td>
</tr>
<tr>
<td>copyright_info</td>
<td>【可选】文章版权模块的版权声明文字</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>建站</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytest入门</title>
    <url>/2023/07/29/Pytest%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>



<blockquote>
<p>Pytest 是一个基于 Python 的测试框架，它提供了一种简洁优雅的方式来编写测试代码。在软件开发中，测试是非常重要的环节，它有助于验证代码的正确性、稳定性和可靠性。Pytest 框架的出现使得编写和执行测试变得更加简单和高效。</p>
<p>为什么我们需要测试？在软件开发过程中，我们经常会遇到各种各样的需求变更、bug修复、功能扩展等情况，这些变动可能会对现有的代码产生意想不到的影响。而如果没有足够的测试覆盖，这些变动可能会导致代码的错误、功能失效或者性能下降。测试的作用就在于通过运行一系列的测试用例来验证代码的正确性，确保它能够按照预期的方式工作。测试能够帮助我们发现和解决问题，提高代码的质量和可维护性。</p>
<p>Pytest 框架相比其他测试框架有以下优势：</p>
<ol>
<li>简洁优雅：Pytest 使用简洁的语法和强大的断言库，使得编写测试代码更加易读、易维护。相比其他测试框架，Pytest 的测试用例更简洁、更清晰。</li>
<li>自动化发现测试：Pytest 可以自动发现项目中的测试函数和测试类，无需手动编写测试套件。只需要按照规定的命名规则来命名测试文件和测试函数，Pytest 就能自动识别并执行。</li>
<li>丰富的插件生态系统：Pytest 提供了丰富的插件机制，可以通过安装插件来扩展测试框架的功能。这些插件可以提供各种功能，如生成测试报告、代码覆盖率检查、性能测试等。</li>
<li>强大的断言库：Pytest 提供了易于使用的断言库，可以快速编写断言语句来验证代码的预期行为。断言库具有灵活的表达能力，可以进行多种类型的断言，包括比较值、判断异常等。</li>
</ol>
<p>总之，Pytest 是一个功能强大、易用且灵活的测试框架，能够帮助开发人员编写高质量的测试代码，提高软件的质量和可靠性。无论是单元测试、集成测试还是端到端测试，Pytest 都能够满足各种测试需求，并且减少测试代码的编写和维护工作量。</p>
</blockquote>
<p><em>以上序使用AI输出</em>。</p>
<h2 id="1-Pytest-测试用例的默认规则"><a href="#1-Pytest-测试用例的默认规则" class="headerlink" title="1 Pytest 测试用例的默认规则"></a>1 Pytest 测试用例的默认规则</h2><ul>
<li>模块名必须以<code>test_</code>开头或者<code>_test</code>结尾。</li>
<li>方法或者函数名必须以<code>test_</code>开头。</li>
<li>类名必须以<code>Test</code>开头。</li>
<li>测试类中不能有<code>__init__</code>方法。</li>
<li>不建议在类中设置一些类示例方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add</span>():</span></span><br><span class="line">    <span class="keyword">assert</span> add_func() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> sum_func() == <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add_func() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&#x27;-vs&#x27;</span>])</span><br></pre></td></tr></table></figure>


<h2 id="2-Pytest-的一些插件"><a href="#2-Pytest-的一些插件" class="headerlink" title="2 Pytest 的一些插件"></a>2 Pytest 的一些插件</h2><ul>
<li><p>pytest-html 使用–html=./report/report.html 生成html格式的自动化测试报告</p>
</li>
<li><p>pytest-xdist 分布式执行 使用-n=number指定线程数</p>
</li>
<li><p>pytest-ordering 改变测试用例的执行顺序</p>
</li>
<li><p>pytest-rerunfailures 失败重试，使用 –reruns=number 设置重试测试</p>
</li>
<li><p>allurre-pytest 更加美观的测试报告</p>
</li>
</ul>
<h2 id="3-Pytest-测试用例运行的方法"><a href="#3-Pytest-测试用例运行的方法" class="headerlink" title="3 Pytest 测试用例运行的方法"></a>3 Pytest 测试用例运行的方法</h2><h3 id="3-1-主函数模式"><a href="#3-1-主函数模式" class="headerlink" title="3.1 主函数模式"></a>3.1 主函数模式</h3><p>指定跟目录下所有的测试用例运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pytest.main([<span class="string">&#x27;-vs&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>指定运行某个文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pytest.main([<span class="string">&quot;-vs&quot;</span>], <span class="string">&quot;test_roles.py&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>指定某个文件夹下的所有测试用例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pytest.main([<span class="string">&quot;-vs&quot;</span>, <span class="string">&quot;./filepath&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>使用多线程运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pytest.main([<span class="string">&quot;-vs&quot;</span>, <span class="string">&quot;./filepath&quot;</span>, <span class="string">&quot;-n=2&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>每个用例失败重试两次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pytest.main([<span class="string">&quot;-vs&quot;</span>, <span class="string">&quot;./filepath&quot;</span>, <span class="string">&quot;--reruns=2&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>修改每个测试用例执行的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">1</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> sum_func() == <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add_func() == <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>参数解释：</p>
<ul>
<li><p>v：表述语输出调试信息， 包括打印的信息</p>
</li>
<li><p>s：显示更详细的信息</p>
</li>
<li><p>n：支持多线程或者分布式调用, 后面跟的数字代表开启的线程</p>
</li>
<li><p>reruns：失败重试</p>
</li>
<li><p>x：只要有一个错误，测试就停止</p>
</li>
<li><p>–html filepath.html 报告路径</p>
</li>
<li><p>-m “smoke or xx or xx…”  根据markers进行分组执行</p>
</li>
</ul>
<h3 id="3-2-命令行模式"><a href="#3-2-命令行模式" class="headerlink" title="3.2 命令行模式"></a>3.2 命令行模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pytest -vs ./filepath -n 2 --reruns 2</span><br></pre></td></tr></table></figure>


<h3 id="3-3-配置文件模式-（pytest-ini）"><a href="#3-3-配置文件模式-（pytest-ini）" class="headerlink" title="3.3 配置文件模式 （pytest.ini）"></a>3.3 <strong>配置文件模式 （pytest.ini）</strong></h3><p>在项目中一般使用这种方式运行，一般在项目的根目录，编码模式要保证为<code>ANSI</code>的模式，使用命令模式或者函数模式都会读取这个配置文件。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[pytest]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行的参数</span></span><br><span class="line"><span class="attr">addopts</span> = -vs  --alluredir=./tmp/my_allure_results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例的路径</span></span><br><span class="line"><span class="attr">testpaths</span> = ./testcase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块名的规则</span></span><br><span class="line"><span class="attr">python_files</span> = test_*.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试类名的规则</span></span><br><span class="line"><span class="attr">python_class</span> = Test*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法名的规则</span></span><br><span class="line"><span class="attr">python_functions</span> = test_*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例分组</span></span><br><span class="line">markers =</span><br><span class="line">    smoke: 冒烟测试</span><br><span class="line">    loginTest: 登录测试</span><br><span class="line">    userTest: 用户模块测试</span><br></pre></td></tr></table></figure>




<h3 id="3-4-测试用例分组的使用方法"><a href="#3-4-测试用例分组的使用方法" class="headerlink" title="3.4 测试用例分组的使用方法"></a>3.4 测试用例分组的使用方法</h3><p>使用<code>@pytest.mark.xx</code>， 这个<code>xx</code> 是指的是 <code>pytest.ini</code>中的markers中的选项，可以应用在函数上或者类上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">1</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> sum_func() == <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.smoke</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add_func() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add_func() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.loginTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCaseTwo</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @pytest.mark.run(<span class="params">order=<span class="number">1</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two_sum</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> sum_func() == <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add_func() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two_login</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> add_func() == <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>执行指令</p>
<p>使用 or 可以制定多个分组的测试用例 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pytest -m &quot;smoke or loginTest&quot;</span><br></pre></td></tr></table></figure>


<h3 id="3-5-跳过测试用例"><a href="#3-5-跳过测试用例" class="headerlink" title="3.5 跳过测试用例"></a>3.5 跳过测试用例</h3><h4 id="3-5-1-有条件跳过"><a href="#3-5-1-有条件跳过" class="headerlink" title="3.5.1 有条件跳过"></a>3.5.1 有条件跳过</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.skipif(<span class="params">age &gt;= <span class="number">18</span>, reason=<span class="string">&quot;年龄大于等于18岁&quot;</span></span>)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-无条件跳过"><a href="#3-5-2-无条件跳过" class="headerlink" title="3.5.2 无条件跳过"></a>3.5.2 无条件跳过</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.skip(<span class="params">reason=<span class="string">&quot;跳过原因&quot;</span></span>)</span></span><br></pre></td></tr></table></figure>


<h2 id="4-Pytest-参数化和读取yaml"><a href="#4-Pytest-参数化和读取yaml" class="headerlink" title="4 Pytest 参数化和读取yaml"></a>4 Pytest 参数化和读取yaml</h2><p>参数化的使用示例：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单参数</span></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;name&quot;</span>, [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_param</span>(<span class="params">name, age</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;当前的姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> name == <span class="string">&quot;李四&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多参数</span></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;name, age&quot;</span>, [[<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>], [<span class="string">&quot;李四&quot;</span>, <span class="number">25</span>], [<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>]]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_params</span>(<span class="params">name, age</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;当前的姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> name == <span class="string">&quot;张三&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main()</span><br></pre></td></tr></table></figure>


<p>读取yaml的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取yaml中数据&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单参数</span></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;name&quot;</span>, get_data(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_param</span>(<span class="params">name, age</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;当前的姓名：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> name == <span class="string">&quot;李四&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main()</span><br></pre></td></tr></table></figure>




<blockquote>
<p>此处仅展示最基本的使用方法。</p>
</blockquote>
<h2 id="5-测试前后的准备和善后工作"><a href="#5-测试前后的准备和善后工作" class="headerlink" title="5 测试前后的准备和善后工作"></a>5 测试前后的准备和善后工作</h2><h3 id="5-1-steup和teardown"><a href="#5-1-steup和teardown" class="headerlink" title="5.1 steup和teardown"></a>5.1 steup和teardown</h3><p>Pytest中的 steup 和 teardown 用法，分别有四种级别</p>
<table>
<thead>
<tr>
<th align="left">级别</th>
<th>表示方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">模块级别</td>
<td>setup_module<br>teardown_module</td>
<td>在Python的一个模块级别执行，开始于模块的始末，只执行一次。</td>
</tr>
<tr>
<td align="left">函数级别</td>
<td>setup_function<br>teardown_function</td>
<td>对每个函数用例生效, 每个测试用例函数执行前后执行。（不在类中）</td>
</tr>
<tr>
<td align="left">类级别</td>
<td>setup_class<br>teardown_class</td>
<td>只在测试类的前后运行一次。</td>
</tr>
<tr>
<td align="left">方法级别</td>
<td>setup_method<br>teardown_method</td>
<td>开始于累的方法始末。每个类中的测试用例都会执行。</td>
</tr>
</tbody></table>
<h4 id="5-1-1-模块级别示例"><a href="#5-1-1-模块级别示例" class="headerlink" title="5.1.1 模块级别示例"></a>5.1.1 模块级别示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_module</span>():</span></span><br><span class="line">    print(<span class="string">&quot;模块级别的前置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;测试1&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;测试2&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_module</span>():</span></span><br><span class="line">    print(<span class="string">&quot;模块级别的后置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main()</span><br></pre></td></tr></table></figure>


<h4 id="5-1-2-函数级别示例："><a href="#5-1-2-函数级别示例：" class="headerlink" title="5.1.2 函数级别示例："></a>5.1.2 函数级别示例：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;函数级别的前置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;测试1&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;测试2&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_function</span>():</span></span><br><span class="line">    print(<span class="string">&quot;函数级别的后置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&quot;-vs&quot;</span>])</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-类级别"><a href="#5-1-3-类级别" class="headerlink" title="5.1.3 类级别"></a>5.1.3 类级别</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_class</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;类级别的前置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;测试1&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;测试2&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown_class</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;类级别的后置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&quot;-vs&quot;</span>])</span><br></pre></td></tr></table></figure>


<h4 id="5-1-4-方法级别的实例"><a href="#5-1-4-方法级别的实例" class="headerlink" title="5.1.4 方法级别的实例"></a>5.1.4 方法级别的实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;方法级别的前置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;测试1&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;测试2&quot;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown_method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;方法级别的后置操作...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&quot;-vs&quot;</span>])</span><br></pre></td></tr></table></figure>


<h3 id="5-2-fixture"><a href="#5-2-fixture" class="headerlink" title="5.2 fixture"></a>5.2 fixture</h3><p>Fixture是一个特殊的函数，用于提供测试用例所需的数据、对象或者其他资源或者做一些清理的操作。Fixture可以被多个测试用例共享，并且可以在测试用例中通过参数传递的方式使用。</p>
<p>Fixture相比于setup和teardown的优势：命名更加灵活，我们可以随意的定义函数指定为fixture，或者作用于不同的域中，或者是数据共享，也可以动态生成数据，并且可以通过参数传递来使用。Fixture的优势在于提高了测试用例的可重用性和可维护性。</p>
<h4 id="5-2-1-定义方方式"><a href="#5-2-1-定义方方式" class="headerlink" title="5.2.1 定义方方式"></a>5.2.1 定义方方式</h4><p>在自定义个的一个方法上面添加装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;function&quot;</span>, autouse=<span class="literal">True</span>, name=<span class="string">&quot;my_fixture&quot;</span>, params=[<span class="number">1</span>, <span class="number">2</span>], ids=[]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_fixture</span>():</span></span><br><span class="line">    print(<span class="string">&quot;【前置操作】自定义的fixture操作...&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">&quot;【后置操作】...作操erutxif的义定自&quot;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="5-2-2-参数详解"><a href="#5-2-2-参数详解" class="headerlink" title="5.2.2 参数详解"></a>5.2.2 参数详解</h4><p>scope 参数详解：</p>
<ul>
<li><code>function</code>：默认范围，在函数测试用例前后执行。</li>
<li><code>class</code>：在类的测试用例前后执行。</li>
<li><code>module</code>：在模块的测试用例前后执行。</li>
<li><code>package</code>：在包的测试用例前后执行。</li>
<li><code>session</code>：在会话的测试用例前后执行。</li>
</ul>
<p>socpe 参数也是一个可调用的对象，来动态的设置域。</p>
<p>autouse 参数:</p>
<ul>
<li>默认为fasle, 所有的测试都不显示使用自定义的fixture，当为true时，所有的测试都自动使用该fixture。</li>
</ul>
<p>name 参数：默认为函数名，目的是给fixture起一个别名， 设置别名以后原来的函数名无法使用。</p>
<p>params 参数：支持可迭代对象，多个参数将会执行多次测试用例，如果fixture有return 也会被当做参数传递给对应的测试用例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;function&quot;</span>, name=<span class="string">&quot;my_fixture_alias&quot;</span>, params=[<span class="number">1</span>, <span class="number">2</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_fixture</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">&quot;【前置操作】自定义的fixture操作...&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> request.param</span><br><span class="line">    print(<span class="string">&quot;【后置操作】...作操erutxif的义定自&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_case</span>(<span class="params">my_fixture</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;我是一个测试用例，接受的参数：<span class="subst">&#123;my_fixture&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&quot;-vs&quot;</span>])</span><br></pre></td></tr></table></figure>


<p>ids 参数：为每个参数设置别名</p>
<h3 id="5-3-fixture-和-conftest-py-结合"><a href="#5-3-fixture-和-conftest-py-结合" class="headerlink" title="5.3 fixture 和 conftest.py 结合"></a>5.3 fixture 和 conftest.py 结合</h3><p>conftest.py 目的是和fixture结合使用实现==全局或者模块级别全局==的配置处理，比如项目的全局登录，模块的全局处理，conftest.py文件名是不能更改的，我们将fixture写在conftest.py中 就可以实现==不用导入==具体的fixture方法，来使用fixture。</p>
<h2 id="6-企业级测试报告-allure"><a href="#6-企业级测试报告-allure" class="headerlink" title="6 企业级测试报告 allure"></a>6 企业级测试报告 allure</h2><h3 id="6-1-windwos-安装-allure"><a href="#6-1-windwos-安装-allure" class="headerlink" title="6.1 windwos 安装 allure"></a>6.1 windwos 安装 allure</h3><ol>
<li><p>首先安装 <a href="https://scoop.sh/">Scoop</a> </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">irm</span> get.scoop.sh | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure></li>
<li><p>在安装 <a href="https://docs.qameta.io/allure/#_about">allure</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scoop install allure</span><br></pre></td></tr></table></figure></li>
<li><p>查看版本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">allure -<span class="literal">-version</span></span><br></pre></td></tr></table></figure>
<p>安装成功！</p>
</li>
</ol>
<h3 id="6-2-生成报告"><a href="#6-2-生成报告" class="headerlink" title="6.2 生成报告"></a>6.2 生成报告</h3><ol>
<li><p>生成报告临时文件，使用–allure 指定临时文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pytest -<span class="literal">-alluredir</span> ./tmp/my_allure_results</span><br></pre></td></tr></table></figure></li>
<li><p>在本地启动一个web服务展示报告</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">allure serve ./tmp/my_allure_results</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="6-3-allure-报告的详细参数"><a href="#6-3-allure-报告的详细参数" class="headerlink" title="6.3 allure 报告的详细参数"></a>6.3 allure 报告的详细参数</h3><table>
<thead>
<tr>
<th>装饰器</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>@allure.epic()</td>
<td>用例的一种分类级别，即一组相关功能需求的集合。</td>
</tr>
<tr>
<td>@allure.frature()</td>
<td>用例的一种分类级别，即一个功能的集合。</td>
</tr>
<tr>
<td>@allure.story()</td>
<td>用例的一种分类级别，即一个用户需求的集合。</td>
</tr>
<tr>
<td>@allure.title()</td>
<td>用于定义测试用例的标题。</td>
</tr>
<tr>
<td>allure.issue()</td>
<td>用于关联测试用例与缺陷/问题跟踪系统中的问题。</td>
</tr>
<tr>
<td>@allure.testcase()</td>
<td>用于指定测试用例的链接，将测试用例和测试步骤与外部的测试管理工具（如JIRA）中的具体测试用例进行关联。</td>
</tr>
<tr>
<td>@allure.description()</td>
<td>用于定义测试用例的描述信息。</td>
</tr>
<tr>
<td>@allure.step()</td>
<td>用于定义测试用例中的步骤信息，比如多个步骤1、2、3等。</td>
</tr>
<tr>
<td>@allure.severity()</td>
<td>用于定义测试用例的严重程度，可以是<code>BLOCKER</code>、<code>CRITICAL</code>、<code>NORMAL</code>、<code>MINOR</code>或<code>TRIVIAL</code>。</td>
</tr>
<tr>
<td>@allure.link()</td>
<td>用于定义测试用例的相关链接，例如需求文档、设计文档、缺陷跟踪工具等，方便查阅和跳转。</td>
</tr>
<tr>
<td>@allure.attach()</td>
<td>用于添加附件到测试报告中，例如截图、日志文件等。</td>
</tr>
</tbody></table>
<h4 id="6-3-1-allure-epic"><a href="#6-3-1-allure-epic" class="headerlink" title="6.3.1 @allure.epic"></a>6.3.1 @allure.epic</h4><ul>
<li>功能：<code>@allure.epic()</code>注解用于定义测试用例的史诗（Epic），即一组相关功能需求的集合。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.epic(&quot;epic_name&quot;)</code>注解，其中<code>epic_name</code>是史诗的名称。</li>
<li>作用：可以将一组相关功能需求的测试用例标记为同一个史诗，以提供更好的组织和管理。</li>
</ul>
<h4 id="6-3-2-allure-feature"><a href="#6-3-2-allure-feature" class="headerlink" title="6.3.2 @allure.feature"></a>6.3.2 @allure.feature</h4><ul>
<li>功能：<code>@allure.feature()</code>注解用于定义测试用例的功能模块（Feature），即一个功能的集合。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.feature(&quot;feature_name&quot;)</code>注解，其中<code>feature_name</code>是功能模块的名称。</li>
<li>作用：可以将属于同一个功能的测试用例标记为同一个功能模块，以提供更好的组织和管理。</li>
</ul>
<h4 id="6-3-3-allure-story"><a href="#6-3-3-allure-story" class="headerlink" title="6.3.3 @allure.story"></a>6.3.3 @allure.story</h4><ul>
<li>功能：<code>@allure.story()</code>注解用于定义测试用例的用户故事（Story），即一个用户需求的集合。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.story(&quot;story_name&quot;)</code>注解，其中<code>story_name</code>是用户故事的名称。</li>
<li>作用：可以将属于同一个用户故事的测试用例标记为同一个用户故事，以提供更好的组织和管理。</li>
</ul>
<h4 id="6-3-4-allure-title"><a href="#6-3-4-allure-title" class="headerlink" title="6.3.4 @allure.title"></a>6.3.4 @allure.title</h4><ul>
<li>功能：<code>@allure.title</code>注解用于定义测试用例的标题。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.title(&quot;title_name&quot;)</code>注解，其中<code>title_name</code>是测试用例的标题。</li>
<li>作用：可以将测试用例标记为具体的标题，以提供更明确的测试用例描述。</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><code>@allure.epic()</code>用于定义测试用例的史诗，标记一组相关功能需求的集合。</li>
<li><code>@allure.feature()</code>用于定义测试用例的功能模块，标记一个功能的集合。</li>
<li><code>@allure.story()</code>用于定义测试用例的用户故事，标记一个用户需求的集合。</li>
<li><code>@allure.title</code>用于定义测试用例的标题，即具体的测试用例描述。</li>
</ul>
<p><strong>使用建议：</strong></p>
<ul>
<li>使用<code>@allure.epic()</code>注解可以将一组相关功能需求的测试用例标记为同一个史诗，以提供更好的组织和管理。</li>
<li>使用<code>@allure.feature()</code>注解可以将属于同一个功能的测试用例标记为同一个功能模块，以提供更好的组织和管理。</li>
<li>使用<code>@allure.story()</code>注解可以将属于同一个用户故事的测试用例标记为同一个用户故事，以提供更好的组织和管理。这样可以更清晰地描述测试用例和需求之间的关系。</li>
<li>使用<code>@allure.title</code>注解将测试用例标记为具体的标题，以提供更明确的测试用例描述。这样可以更直观地了解测试用例的目的和预期结果。</li>
</ul>
<h4 id="6-3-5-allure-issue"><a href="#6-3-5-allure-issue" class="headerlink" title="6.3.5 @allure.issue"></a>6.3.5 @allure.issue</h4><ul>
<li>功能：<code>allure.issue</code>注解用于关联测试用例与缺陷/问题跟踪系统中的问题。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.issue(&quot;issue_key&quot;)</code>注解，其中<code>issue_key</code>是缺陷/问题跟踪系统中的问题的唯一标识符，如Bug的ID或链接。</li>
<li>作用：可以将测试用例与相关的缺陷/问题跟踪系统中的问题关联起来，以便更方便地追踪和查看问题的解决情况。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>使用<code>@allure.issue</code>注解在测试用例中关联相关的缺陷/问题跟踪系统中的问题。</li>
<li>在注解中提供问题的唯一标识符，如Bug的ID或链接，以确保可以准确定位并追踪相关的问题。</li>
<li>这样可以帮助开发团队跟踪和解决测试用例中发现的问题，提高问题的解决效率。</li>
</ul>
<h4 id="6-3-6-allure-description"><a href="#6-3-6-allure-description" class="headerlink" title="6.3.6  @allure.description"></a>6.3.6  @allure.description</h4><ul>
<li>功能：<code>@allure.description</code>注解用于定义测试用例的描述信息。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.description(&quot;description_text&quot;)</code>注解，其中<code>description_text</code>是测试用例的描述文本。</li>
<li>作用：可以将测试用例标记为具体的描述信息，以提供更详细的测试用例说明。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>使用<code>@allure.description</code>注解将测试用例标记为具体的描述信息，以提供更详细的测试用例说明。</li>
<li>在注解中添加测试用例的描述文本，可以包括测试目的、测试步骤、预期结果等信息。</li>
<li>这样可以使测试用例更易于理解和维护，也能帮助其他团队成员更好地理解和执行测试用例。</li>
</ul>
<h4 id="6-3-7-allure-step"><a href="#6-3-7-allure-step" class="headerlink" title="6.3.7 @allure.step"></a>6.3.7 @allure.step</h4><ul>
<li>功能：<code>@allure.step</code>注解用于定义测试用例中的步骤信息。</li>
<li>使用方式：在测试用例的代码中，使用<code>@allure.step(&quot;step_description&quot;)</code>注解来标记测试用例中的步骤，其中<code>step_description</code>是步骤的描述文本。</li>
<li>作用：可以将测试用例划分为多个步骤，并为每个步骤添加描述信息，使测试报告更加详细和可读。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>使用<code>@allure.step</code>注解将测试用例划分为多个步骤，并为每个步骤添加描述信息。</li>
<li>在注解中添加步骤的描述文本，可以包括具体的操作、输入数据、预期结果等信息。</li>
<li>每个步骤都会在测试报告中显示为一个独立的小区块，使测试执行过程更加清晰可见。</li>
<li>这样可以使测试报告更加详细和可读，方便测试人员和其他团队成员理解测试执行的流程、数据和结果。</li>
</ul>
<h4 id="6-3-8-allure-severity"><a href="#6-3-8-allure-severity" class="headerlink" title="6.3.8 @allure.severity"></a>6.3.8 @allure.severity</h4><ul>
<li>功能：<code>@allure.severity</code>注解用于定义测试用例的严重程度。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.severity(severity_level)</code>注解，其中<code>severity_level</code>是测试用例的严重程度，可以是<code>BLOCKER</code>、<code>CRITICAL</code>、<code>NORMAL</code>、<code>MINOR</code>或<code>TRIVIAL</code>。</li>
<li>作用：可以将测试用例标记为不同的严重程度，以便根据优先级进行测试执行和问题跟踪。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>使用<code>@allure.severity</code>注解将测试用例标记为不同的严重程度，以便根据优先级进行测试执行和问题跟踪。</li>
</ul>
<h4 id="6-3-9-allure-link"><a href="#6-3-9-allure-link" class="headerlink" title="6.3.9 @allure.link"></a>6.3.9 @allure.link</h4><ul>
<li>功能：<code>@allure.link</code>注解用于定义测试用例的相关链接。</li>
<li>使用方式：在测试用例的代码上方添加<code>@allure.link(url, name)</code>注解，其中<code>url</code>是相关链接的URL地址，<code>name</code>是链接的显示名称。</li>
<li>作用：可以为测试用例添加相关的链接，例如需求文档、设计文档、缺陷跟踪工具等，方便查阅和跳转。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>使用<code>@allure.link</code>注解为测试用例添加相关的链接，方便查阅和跳转到相关资料。</li>
</ul>
<h4 id="6-3-10-allure-attach"><a href="#6-3-10-allure-attach" class="headerlink" title="6.3.10  @allure.attach"></a>6.3.10  @allure.attach</h4><ul>
<li>功能：<code>@allure.attach</code>注解用于添加附件到测试报告中。</li>
<li>使用方式：在测试用例的代码中使用<code>@allure.attach(name, content_type)</code>注解来添加附件，其中<code>name</code>是附件的名称，<code>content_type</code>是附件的内容类型。</li>
<li>作用：可以将附件添加到测试报告中，例如截图、日志文件等，便于查看和分析测试执行过程中的细节。</li>
</ul>
<p>使用建议：</p>
<ul>
<li>使用<code>@allure.attach</code>注解将附件添加到测试报告中，方便查看和分析测试执行过程中的细节。</li>
</ul>
<h4 id="6-3-13-代码示例"><a href="#6-3-13-代码示例" class="headerlink" title="6.3.13 代码示例"></a>6.3.13 代码示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> allure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.step(<span class="params"><span class="string">&quot;第一步&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;-&quot;</span> * <span class="number">10</span> + <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.step(<span class="params"><span class="string">&quot;第二步&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_2</span>():</span></span><br><span class="line">    print(<span class="string">&quot;-&quot;</span> * <span class="number">10</span> + <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.epic(<span class="params"><span class="string">&quot;用户管理&quot;</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestUserManagement</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.feature(<span class="params"><span class="string">&quot;注册&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;用户注册&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;使用有效数据进行测试注册&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.testcase(<span class="params"><span class="string">&quot;https://example.com/docs/login&quot;</span>, name=<span class="string">&quot;对应测试系统中的测试用例&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.issue(<span class="params"><span class="string">&quot;https://example.com/docs/login&quot;</span>, name=<span class="string">&quot;对应测试系统中的缺陷&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.link(<span class="params"><span class="string">&quot;https://example.com/docs/login&quot;</span>, name=<span class="string">&quot;登录逻辑开发文档&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.description(<span class="params"><span class="string">&quot;验证用户是否可以使用有效凭据登录&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.severity(<span class="params">allure.severity_level.BLOCKER</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_registration_valid_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用有效数据进行注册的测试代码&quot;&quot;&quot;</span></span><br><span class="line">        allure.attach.file(<span class="string">&quot;./feihongnvwu.jpg&quot;</span>, attachment_type=allure.attachment_type.JPG)</span><br><span class="line">        step_1()</span><br><span class="line">        step_2()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.feature(<span class="params"><span class="string">&quot;注册&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;用户注册&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;使用无效数据进行测试注册“&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_registration_invalid_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用无效数据进行注册的测试代码&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.feature(<span class="params"><span class="string">&quot;登录&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;用户登录&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;使用有效凭据测试登录&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login_valid_credentials</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用有效凭证进行登录的测试代码&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.feature(<span class="params"><span class="string">&quot;登录&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;用户登录&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;使用无效凭据测试登录&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login_invalid_credentials</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用无效凭证进行登录的测试代码&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @allure.feature(<span class="params"><span class="string">&quot;密码管理&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.story(<span class="params"><span class="string">&quot;用户密码管理&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @allure.title(<span class="params"><span class="string">&quot;测试更改密码&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_password_change</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;修改密码的测试代码&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="6-3-12-报告显示"><a href="#6-3-12-报告显示" class="headerlink" title="6.3.12 报告显示"></a>6.3.12 报告显示</h4><p><img src="https://origin.chaizz.com/tc/image-20230802224820516.png" alt="image-20230802224820516"></p>
<h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>Allure-pytest 简化了测试报告的生成过程，通过添加一些装饰器和注解，可以很容易地在测试用例中添加附件、标签等。它的报告展示了各个测试用例的执行情况，以及对应的附件和日志信息，帮助我们更好地了解测试结果。</p>
<p>Allure-pytest 提供了丰富的插件和扩展，可以与其他测试框架（如pytest、unittest）和工具（如Selenium、Appium）集成使用。它支持多种语言和平台，可以用于不同的测试环境和项目。</p>
<p>Allure-pytest 还提供了命令行工具和 API，方便我们自定义测试报告的生成和使用。我们可以通过命令行工具直接生成测试报告，也可以通过 API 在自动化流水线中集成 Allure-pytest。</p>
<p>总之，Allure-pytest 是一个强大的测试报告生成工具，它提供了丰富的功能和灵活的扩展性，可以帮助我们更好地组织和展示测试结果，提高测试效率和可视化程度。它是一个值得推荐和使用的工具。</p>
<p><em>来自于AI</em></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Pytest</category>
      </categories>
      <tags>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonista开发前的基础工作之编辑器配置篇</title>
    <url>/2023/06/14/Pythonista%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C%E4%B9%8B%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="Pythonista开发前的基础工作之编辑器配置篇"><a href="#Pythonista开发前的基础工作之编辑器配置篇" class="headerlink" title="Pythonista开发前的基础工作之编辑器配置篇"></a>Pythonista开发前的基础工作之编辑器配置篇</h1><h2 id="1-编辑器基础配置"><a href="#1-编辑器基础配置" class="headerlink" title="1 编辑器基础配置"></a>1 编辑器基础配置</h2><h3 id="1-1-外观"><a href="#1-1-外观" class="headerlink" title="1.1 外观"></a>1.1 外观</h3><ul>
<li>字体：Fira Code Medium  大小：16</li>
</ul>
<h3 id="1-2-编辑器"><a href="#1-2-编辑器" class="headerlink" title="1.2 编辑器"></a>1.2 编辑器</h3><ul>
<li>字体：Fira Code  大小：18</li>
</ul>
<h3 id="1-3-Atom-Material-Icons-Setting"><a href="#1-3-Atom-Material-Icons-Setting" class="headerlink" title="1.3 Atom Material Icons Setting"></a>1.3 Atom Material Icons Setting</h3><p>​    <img src="https://origin.chaizz.com/tc/image-20230731181034618.png" alt="image-20230731181034618"></p>
<p><img src="https://origin.chaizz.com/tc/image-20230731181125760.png" alt="image-20230731181125760"></p>
<h2 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2 快捷键"></a>2 快捷键</h2><ul>
<li><p>禁用双击shift唤醒全局搜索框 [shift-shift] </p>
<p>设置 -&gt; 高级设置 -&gt; 用户界面</p>
<p><img src="https://origin.chaizz.com/tc/image-20230614153241084.png"></p>
</li>
</ul>
<h2 id="3-插件"><a href="#3-插件" class="headerlink" title="3 插件"></a>3 插件</h2><ul>
<li><p>.ignore  忽略文件</p>
</li>
<li><p>Translation 翻译插件， 需要自己设置翻译SDK的key </p>
</li>
<li><p>Atom Material Icons   一个好看的文件夹主题</p>
</li>
<li><p>GitToolBox    git 相关插件， 显示历史修改人等</p>
</li>
<li><p>One Dark Theme  黑色主题</p>
</li>
<li><p>Tabnine AI Code Completion AI开发助手</p>
</li>
<li><p>sourcery  基于AI的编码助手</p>
</li>
<li><p>LeetCode Editor leetcode 插件</p>
</li>
</ul>
<h2 id="4-代码模板"><a href="#4-代码模板" class="headerlink" title="4 代码模板"></a>4 代码模板</h2><ul>
<li><p>设置 -&gt; 编辑器 -&gt; 文件和代码模板 -&gt; Python Script </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">    File Name:   $&#123;NAME&#125;.py</span><br><span class="line">    Description: </span><br><span class="line">        </span><br><span class="line">    Author:      chaizz</span><br><span class="line">    Date:        $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">    Change Activity:</span><br><span class="line">          $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>开发环境配置</category>
        <category>Pycharm</category>
      </categories>
      <tags>
        <tag>开发环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Pythonista开发前的基础工作之系统环境篇</title>
    <url>/2023/04/06/Pythonista%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C%E4%B9%8B%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E7%AF%87/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="Pythonista开发前的基础工作之系统环境篇"><a href="#Pythonista开发前的基础工作之系统环境篇" class="headerlink" title="Pythonista开发前的基础工作之系统环境篇"></a>Pythonista开发前的基础工作之系统环境篇</h1><p>当我们进入到一个新的环境，或者是拿到一个新的操作系统，往往都需要我们配置自己的开发环境，系统软件环境等。</p>
<p>本次以Python开发者为例，介绍一个<strong>Pythonista</strong>需要做哪些准备工作。</p>
<p>个人常用的操作系统为Windows和Ubuntu, 所以以下的所有环境配置和软件都是基于Windows和Ubutu的。</p>
<h2 id="1-windwos系统软件"><a href="#1-windwos系统软件" class="headerlink" title="1 windwos系统软件"></a>1 windwos系统软件</h2><p>windows系统层面一般不需要太多的设置，只需要安装一些自己的开发软件。</p>
<p>首先作为开发者的必备的软件：</p>
<ul>
<li><p>Python 不装不行的软件</p>
</li>
<li><p>Git 代码版本控制系统</p>
</li>
<li><p>PyCharm - Pythonista Python编辑器利器 (针对Python项目)</p>
</li>
<li><p>Visual - Studio Code 同样是编辑器利器 （作为轻量化文本编辑器）</p>
</li>
<li><p>WebStorm - Pythoneer写个前端项目也不是不行</p>
</li>
<li><p>Navicat - 数据库可视化管理软件</p>
</li>
<li><p>Another Redis Desktop Manager - Redis可视化管理工具</p>
</li>
<li><p>ApiPost7 - 接口测试管理利器 同类型的有Apifox、Postman</p>
</li>
<li><p>WindTerm - 轻量开源的终端管理工具</p>
</li>
<li><p>chrome - 必备浏览器</p>
</li>
<li><p>Docker Desktop - windwos系统的中的docker</p>
</li>
<li><p>WSL - 本地Linux开发王炸</p>
</li>
<li><p>Windows Terminal - 比CMD好用一万倍的终端</p>
</li>
<li><p>Miniconda - Python多环境管理的佼佼者</p>
</li>
</ul>
<p>其他的一些软件（非开发者必备）：</p>
<ul>
<li>ToDesk - 远程桌面 (半夜远程修改BUG必备)</li>
<li>WizTree - 扫描磁盘空间文件利器</li>
<li>VMware Workstation - 虚拟机，保证测试环境的纯(测试用的较多)</li>
<li>IDM - 结合油猴脚本可以成为下载神器</li>
<li>Fiddler Classic - 抓包利器</li>
<li>Barrier - 跨平台共享使用鼠标和键盘利器。</li>
<li>Typora - Markdown写作工具</li>
<li>Snipaste - 桌面截图贴图利器。</li>
</ul>
<h2 id="2-Windows开发环境配置"><a href="#2-Windows开发环境配置" class="headerlink" title="2 Windows开发环境配置"></a>2 Windows开发环境配置</h2><h3 id="2-1-配置Miniconda"><a href="#2-1-配置Miniconda" class="headerlink" title="2.1 配置Miniconda"></a>2.1 配置Miniconda</h3><p><a href="https://docs.conda.io/en/latest/miniconda.html#windows-installers">官网</a>下载exe可执行文件，直接安装即可。然后需要做的就是切换miniconda的源。Miniconda 的基本配置:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消base环境的显示</span></span><br><span class="line">conda config -<span class="literal">-set</span> auto_activate_base False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置显示下载连接 </span></span><br><span class="line">conda config -<span class="literal">-set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换清华源：</span></span><br><span class="line">conda config -<span class="literal">-add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config -<span class="literal">-add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个conda环境</span></span><br><span class="line">conda remove <span class="literal">-n</span> 名称 -<span class="literal">-all</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更该conda的虚拟环境存储地址 （如果修改不成功，需要设置路径的权限）</span></span><br><span class="line">conda config -<span class="literal">-add</span> envs_dirs  具体的路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改conda的虚拟环境包的缓存地址 （如果修改不成功，需要设置路径的权限）</span></span><br><span class="line">conda config -<span class="literal">-add</span> pkgs_dirs  具体的路径</span><br></pre></td></tr></table></figure>
<p>可能遇到的问题：</p>
<p>1、在终端中输入conda 提示找不到conda命令；解决办法：</p>
<p>打开conda的安装目录，例如：D:\miniconda 将 然后找到 condabin目录 ，复制整个目录添加到环境变量中。 D:\miniconda\condabin</p>
<p>2、在windows中的powershell中无法显示miniconda的环境前缀；解决办法：在powershell中输入，重新打开powershell。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">conda init powershell</span><br></pre></td></tr></table></figure>


<p>如果要在Linux上开发，一般有好几种情况 (我一般使用第一种方式，使用WSL)：</p>
<ol>
<li><p>在Windows上安装WSL, 使用Ubuntu子系统</p>
</li>
<li><p>使用虚拟机，在虚拟机中安装系统各个发行版的Linux系统。 (本地构建分布式使用)</p>
</li>
<li><p>直接使用Linux系统 (基本很少使用，缺少常用的办公软件生态)</p>
</li>
</ol>
<h3 id="2-2-配置Windows-Terminal"><a href="#2-2-配置Windows-Terminal" class="headerlink" title="2.2 配置Windows Terminal"></a>2.2 配置Windows Terminal</h3><p>在微软商店即可直接下载，此软件也不需要什么配置，可以根据自己的使用习惯配置默认打开的配置文件，我这里使用的是PowerShell。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230406152440738.png" alt="image-20230406152440738"></p>
<h3 id="2-3-配置WSL"><a href="#2-3-配置WSL" class="headerlink" title="2.3 配置WSL"></a>2.3 配置WSL</h3><p>直接在微软应用商店，下载需要的Linux版本， 这里我常用的是Ubuntu, 一般选择最新版22.04或者是20.04。 存储以 Ubuntu-22.04 为例。</p>
<p>安装完毕后在windwos菜单中可以直接找到安装的ubuntu图标。可以直接打开使用。</p>
<p>打开系统后会提示让我们输入用户名密码， 我们可以直接关闭 Terminal，在重新打开默认就是root用户。</p>
<p>但是这里有一个点是默认安装的系统在C盘。我们可以手动更改为其他的盘符。</p>
<p>步骤如下：</p>
<ol>
<li><p>以管理员身份打开Windows Terminal 或者 PowerShell</p>
</li>
<li><p>查看当前WSL服务应用</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展示结果如下，Ubuntu-20.04是上一步安装的LInux子系统名称 （名称可能不一样） </span></span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* docker<span class="literal">-desktop</span><span class="literal">-data</span>    Stopped         <span class="number">2</span></span><br><span class="line">  Ubuntu<span class="literal">-22</span>.<span class="number">04</span>           Running         <span class="number">2</span></span><br><span class="line">  docker<span class="literal">-desktop</span>         Stopped         <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>我们直接将刚刚安装的Ubuntu-22.04导出到别的文件夹，此处导出到D盘下的WSL_Ubuntu</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl -<span class="literal">-export</span> Ubuntu<span class="literal">-22</span>.<span class="number">04</span> D:\WSL_Ubuntu\ubuntu.rar</span><br></pre></td></tr></table></figure></li>
<li><p>然后再将刚刚导出的ubuntu.rar， 在重新导入为wsl的应用，ubuntu为新的应用的名称，D:\WSL_Ubuntu 使我们要存放的此应用ubuntu的具体的路径，D:\WSL_Ubuntu\ubuntu.rar 是上一步存储的路径。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl -<span class="literal">-import</span> ubuntu D:\WSL_Ubuntu D:\WSL_Ubuntu\ubuntu.rar</span><br></pre></td></tr></table></figure></li>
<li><p>此时我们再查看wsl的应用, 就会多出来我们刚刚导入的应用。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl -<span class="literal">-list</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展示结果如下，Ubuntu-20.04是上一步安装的LInux子系统名称 （名称可能不一样） </span></span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* docker<span class="literal">-desktop</span><span class="literal">-data</span>    Stopped         <span class="number">2</span></span><br><span class="line">  ubuntu                 Stopped         <span class="number">2</span></span><br><span class="line">  Ubuntu<span class="literal">-22</span>.<span class="number">04</span>           Stopped         <span class="number">2</span></span><br><span class="line">  docker<span class="literal">-desktop</span>         Stopped         <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>注销原来的应用</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl -<span class="literal">-unregister</span> Ubuntu<span class="literal">-22</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure></li>
<li><p>此时我们再查看wsl的应用, 原始的应用就不存在了。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl -<span class="literal">-list</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展示结果如下，Ubuntu-20.04是上一步安装的LInux子系统名称 （名称可能不一样） </span></span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* docker<span class="literal">-desktop</span><span class="literal">-data</span>    Stopped         <span class="number">2</span></span><br><span class="line">  ubuntu                 Stopped         <span class="number">2</span></span><br><span class="line">  docker<span class="literal">-desktop</span>         Stopped         <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动/退出ubuntu 应用</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">-d</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：</p>
<p>我们也可以在执行开始时 关闭wsl在进行操作，命令：wsl –shutdown</p>
</blockquote>
</li>
</ol>
<p>经过上述配置后我们就可以得到一个在windwos下的Linux子系统，我们可以直接通过命令行进入该系统，就像操作Linux一样。之前在 microsoft Store 下载的也可以直接删除了。</p>
<h3 id="2-4-WSL-文件传输配置"><a href="#2-4-WSL-文件传输配置" class="headerlink" title="2.4 WSL 文件传输配置"></a>2.4 WSL 文件传输配置</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、打开Windows Terminal 或者 PowerShell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、进入Linux子系统，执行</span></span><br><span class="line">explorer.exe .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、此时终端会自动打开一个文件夹，就是在终端执行上一步命令的文件夹。</span></span><br><span class="line"><span class="comment"># 我们可以像操作本地文件一样操作Linux文件夹。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、如果不想每次都执行 explorer.exe . 可以将Linux的文件位置，添加到盘符中。</span></span><br><span class="line"><span class="comment"># 4.1、将第2步弹出的文件夹路径复制出来 ：例如 \\wsl$\Ubuntu\root</span></span><br><span class="line"><span class="comment"># 4.2、打开windwos 此电脑--&gt; 添加一个网络位置--&gt;下一页--&gt;指定网站的位置。</span></span><br><span class="line"><span class="comment"># 4.3、将4.2 复制的地址输入。此时在我的电脑网络位置中，就会出现刚刚设置的文件夹。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如下图所示：</p>
<p><img src="https://origin.chaizz.com/tc/image-20230406155044674.png" alt="image-20230406155044674"></p>
<h3 id="2-5-windows-配置pip"><a href="#2-5-windows-配置pip" class="headerlink" title="2.5 windows 配置pip"></a>2.5 windows 配置pip</h3><p>找到<code>C:\Users\xxx\pip\pip.ini</code>， 设置清华源，速度很快。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="attr">trusted-host</span> = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>


<h2 id="3-Linux开发环境配置"><a href="#3-Linux开发环境配置" class="headerlink" title="3 Linux开发环境配置"></a>3 Linux开发环境配置</h2><p>此处以WSL子系统为例。</p>
<h3 id="3-1-配置apt源"><a href="#3-1-配置apt源" class="headerlink" title="3.1 配置apt源"></a>3.1 配置apt源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份源文件</span></span><br><span class="line">sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  使用目录替换源地址</span></span><br><span class="line">sudo sed -i &quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">sudo sed -i &quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新 apt</span></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>


<p>此处列出几个镜像站</p>
<table>
<thead>
<tr>
<th>华为云</th>
<th><a href="https://mirrors.huaweicloud.com/home">https://mirrors.huaweicloud.com/home</a></th>
</tr>
</thead>
<tbody><tr>
<td>清华大学</td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></td>
</tr>
<tr>
<td>阿里云</td>
<td><a href="https://developer.aliyun.com/mirror/">https://developer.aliyun.com/mirror/</a></td>
</tr>
<tr>
<td>腾讯云</td>
<td><a href="https://mirrors.cloud.tencent.com/">https://mirrors.cloud.tencent.com/</a></td>
</tr>
<tr>
<td>网易网</td>
<td><a href="http://mirrors.163.com/">http://mirrors.163.com/</a></td>
</tr>
<tr>
<td>北大</td>
<td><a href="https://mirrors.pku.edu.cn/Mirrors">https://mirrors.pku.edu.cn/Mirrors</a></td>
</tr>
</tbody></table>
<h3 id="3-2-配置pip源"><a href="#3-2-配置pip源" class="headerlink" title="3.2 配置pip源"></a>3.2 配置pip源</h3><p>Linux 默认安装的python的pip源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者手动更改 pip.conf 配置文件 /root/.config/pip/pip.conf</span></span><br></pre></td></tr></table></figure>
<p>安装 minicaonda 和在windows上安装一致。</p>
<p>一些其他的源：</p>
<p>默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释。</p>
<p>中科大（贼快）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>


<p>清华源（还行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>


<p>阿里源（一般）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="meta">#</span><span class="bash"> deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发环境配置</category>
        <category>系统环境</category>
      </categories>
      <tags>
        <tag>开发环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之Generator(一)</title>
    <url>/2023/03/27/JS%E7%AC%94%E8%AE%B0%E4%B9%8BGenerator(%E4%B8%80)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之Generator-一"><a href="#JS笔记之Generator-一" class="headerlink" title="JS笔记之Generator(一)"></a>JS笔记之Generator(一)</h1><p>在JS中常规函数只会返回一个单一值，或者不返回值。而generator可以按需一个接一个的返回（yield）多个值。</p>
<h2 id="1-generator-函数"><a href="#1-generator-函数" class="headerlink" title="1 generator 函数"></a>1 generator 函数</h2><p>要创建一个generator，我们需要创建一个特殊的语法结构：function*，即所谓的“generator function”。它看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator 函数与常规函数的行为不同。在此类函数被调用时，它不会运行其代码。而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;generator function&quot; 创建了一个 &quot;generator object&quot;</span></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"><span class="built_in">console</span>.log(generator); <span class="comment">// [object Generator] &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>一个generator的主要的方法就是next()，当调用next()方法时，函数会执行到最近的一个yield，然后函数执行暂停，并将产出的（yielded）值返回到外部代码。</p>
<p><code>next()</code> 的结果始终是一个具有两个属性的对象：</p>
<ul>
<li><code>value</code>: 产出的（yielded）的值。</li>
<li><code>done</code>: 如果 generator 函数已执行完成则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>
<p>例如我们获取第一个值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"><span class="keyword">let</span> one = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(one)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以到现在函数只执行到了 <code>yield 1;</code>  如果再次调用就会返回{value: 2, done: false}, 继续调用 就会返回{value: 3, done: true}，代表函数执行完毕，如果在次调用next()，没有任何意义。只会返回{done: true}</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> one = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(one)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> two = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(two)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(t)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = generator.next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(f)); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>function* f(…)</code> 或 <code>function *f(…)</code>？</strong></p>
<p>这两种语法都是对的。</p>
<p>但是通常更倾向于第一种语法，因为星号 <code>*</code> 表示它是一个 generator 函数，它描述的是函数种类而不是名称，因此 <code>*</code> 应该和 <code>function</code> 关键字紧贴一起。</p>
</blockquote>
<h2 id="2-generator-是可迭代的"><a href="#2-generator-是可迭代的" class="headerlink" title="2 generator 是可迭代的"></a>2 generator 是可迭代的</h2><p>我们可以用for…of 循环遍历生成器的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator = generateSequence();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> generator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1，然后是 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>但是</strong>上面的例子不会返回3，这是因为当 done: true 时，for..of 循环会忽略最后一个 value。因此，如果我们想要通过 for..of 循环显示所有的结果，我们必须使用 yield 返回它们：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>因为 generator 是可迭代的，我们可以使用 iterator 的所有相关功能，例如：spread 语法 <code>...</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence = [<span class="number">0</span>, ...generateSequence()];</span><br><span class="line"></span><br><span class="line">alert(sequence); <span class="comment">// 0, 1, 2, 3</span></span><br></pre></td></tr></table></figure>


<h2 id="3-使用-generator-进行迭代"><a href="#3-使用-generator-进行迭代" class="headerlink" title="3 使用 generator 进行迭代"></a>3 使用 generator 进行迭代</h2><p>在之前的文章中，我们手动创建了一个可迭代对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">    to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for..of range 在一开始就调用一次这个方法</span></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="comment">// ...它返回 iterator object：</span></span><br><span class="line">        <span class="comment">// 后续的操作中，for..of 将只针对这个对象，并使用 next() 向它请求下一个值</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            current: <span class="built_in">this</span>.from,</span><br><span class="line">            last: <span class="built_in">this</span>.to,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// for..of 循环在每次迭代时都会调用 next()</span></span><br><span class="line">            <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 它应该以对象 &#123;done:.., value :...&#125; 的形式返回值</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代整个 range 对象，返回从 `range.from` 到 `range.to` 范围的所有数字</span></span><br><span class="line">alert([...range]); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以使用生成器来改造它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">    to: <span class="number">5</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;  <span class="comment">// [Symbol.iterator]: function*() 的简写形式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> value = <span class="built_in">this</span>.from; value &lt;= <span class="built_in">this</span>.to; value++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代整个 range 对象，返回从 `range.from` 到 `range.to` 范围的所有数字</span></span><br><span class="line"><span class="built_in">console</span>.log([...range]); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>


<h2 id="4-generator-组合"><a href="#4-generator-组合" class="headerlink" title="4 generator 组合"></a>4 generator 组合</h2><p>generator 组合（composition）是 generator 的一个特殊功能，它允许透明地（transparently）将 generator 彼此“嵌入（embed）”到一起。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateSequence</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatePasswordCodes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0..9</span></span><br><span class="line">    <span class="keyword">yield</span>* generateSequence(<span class="number">48</span>, <span class="number">57</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A..Z</span></span><br><span class="line">    <span class="keyword">yield</span>* generateSequence(<span class="number">65</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a..z</span></span><br><span class="line">    <span class="keyword">yield</span>* generateSequence(<span class="number">97</span>, <span class="number">122</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> code <span class="keyword">of</span> generatePasswordCodes()) &#123;</span><br><span class="line">    str += <span class="built_in">String</span>.fromCharCode(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 0..9A..Za..z</span></span><br></pre></td></tr></table></figure>
<p>在上述的代码中使用了yield*指令，<code>yield*</code> 指令将执行 <strong>委托</strong> 给另一个 generator。这个术语意味着 <code>yield* gen</code> 在 generator <code>gen</code> 上进行迭代，并将其产出（yield）的值透明地（transparently）转发到外部。就好像这些值就是由外部的 generator yield 的一样。</p>
<blockquote>
<p>generator 组合（composition）是将一个 generator 流插入到另一个 generator 流的自然的方式。它不需要使用额外的内存来存储中间结果。</p>
</blockquote>
<h2 id="5-yield-是一条双向路"><a href="#5-yield-是一条双向路" class="headerlink" title="5 yield 是一条双向路"></a>5 yield 是一条双向路</h2><p>generator和可迭代对象很相似，但是generator更加的强大和灵活。其中generator不仅可以向外部返回结果，也可以将外部的值传递给generator内。通过调用generator.next(arg)，就能给generator添加值。这个arg就会变成yield的结果，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向外部代码传递一个问题并等待答案</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> <span class="string">&quot;2 + 2 = ?&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"><span class="keyword">let</span> question = generator.next().value; <span class="comment">// &lt;-- yield 返回的 value, question= 2 + 2 = ?</span></span><br><span class="line"></span><br><span class="line">generator.next(<span class="number">4</span>); <span class="comment">// --&gt; 将结果传递到 generator 中</span></span><br></pre></td></tr></table></figure>


<h2 id="6-generator-throw"><a href="#6-generator-throw" class="headerlink" title="6 generator.throw"></a>6 generator.throw</h2><p>在generator中也有可能抛出一个异常，error本身也是一个结果。如果要向 <code>yield</code> 传递一个 error，我们应该调用 <code>generator.throw(err)</code>。</p>
<p>正常的错误像之前的错误一样，会调出generator, 使脚本停止。</p>
<h2 id="7-generator-return"><a href="#7-generator-return" class="headerlink" title="7 generator.return"></a>7 generator.return</h2><p><code>generator.return(value)</code> 完成 generator 的执行并返回给定的 <code>value</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.next());        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="string">&#x27;foo&#x27;</span>));; <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());;        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>


<p>如果我们在已完成的 generator 上再次使用 <code>generator.return()</code>，它将再次返回该值（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return">MDN</a>）。</p>
<p>通常我们不使用它，因为大多数时候我们想要获取所有的返回值，但是当我们想要在特定条件下停止 generator 时它会很有用。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><ul>
<li>generator 是通过 generator 函数 <code>function* f(…) &#123;…&#125;</code> 创建的。</li>
<li>在 generator（仅在）内部，存在 <code>yield</code> 操作。</li>
<li>外部代码和 generator 可能会通过 <code>next/yield</code> 调用交换结果。</li>
</ul>
<p>在现代 JavaScript 中，generator 很少被使用。但有时它们会派上用场，因为函数在执行过程中与调用代码交换数据的能力是非常独特的。而且，当然，它们非常适合创建可迭代对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Generator</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(三)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%B8%89)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-三"><a href="#js笔记之Promise-三" class="headerlink" title="js笔记之Promise(三)"></a>js笔记之Promise(三)</h1><h2 id="1-使用-promise-进行错误处理"><a href="#1-使用-promise-进行错误处理" class="headerlink" title="1 使用 promise 进行错误处理"></a>1 使用 promise 进行错误处理</h2><p>promise链在错误中处理中非常强大，当一个 promise 被 reject 时，控制权将移交至最近的 rejection 处理程序。这在实际开发中非常方便。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://no-such-server.blabla&#x27;</span>) <span class="comment">// reject</span></span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// TypeError: Failed to fetch（这里的文字可能有所不同）</span></span><br></pre></td></tr></table></figure>


<h2 id="2-隐式的try…catch"><a href="#2-隐式的try…catch" class="headerlink" title="2 隐式的try…catch"></a>2 隐式的try…catch</h2><p>在 executor 周围的“隐式 <code>try..catch</code>”自动捕获了 error，并将其变为 rejected promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>); <span class="comment">// reject 这个 promise</span></span><br><span class="line">&#125;).catch(alert); <span class="comment">// Error: Whoops!</span></span><br></pre></td></tr></table></figure>


<h2 id="2-再次抛出（Rethrowing）"><a href="#2-再次抛出（Rethrowing）" class="headerlink" title="2 再次抛出（Rethrowing）"></a>2 再次抛出（Rethrowing）</h2><p>在平常的try…catch中，在catch中遇到我们无法处理的错误我们可以再次的抛出异常，对于promise来 说也是可以的。</p>
<p>如果在promise的.catch中使用throw， 那么控制权就会移交到下一个error的处理程序，如果正常处理error并且正常完成，那么就会到最近的then处理程序。下面是一个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行流：catch -&gt; then</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;The error is handled, continue normally&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Next successful handler runs&quot;</span>));</span><br></pre></td></tr></table></figure>


<h2 id="3-未处理的-rejection"><a href="#3-未处理的-rejection" class="headerlink" title="3 未处理的 rejection"></a>3 未处理的 rejection</h2><p>如果一个error没有被处理，会发生什么？此时程序就会像正常开发中抛出了一个错误一样，脚本停止，然后生成一个全局的异常。</p>
<p>如果出现了一个 error，并且在这没有 .catch，那么 unhandledrejection 处理程序就会被触发，并获取具有 error 相关信息的 event 对象，所以我们就能做一些后续处理了。</p>
<p>通常此类 error 是无法恢复的，所以我们最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。</p>
<p>在 Node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。</p>
<h2 id="4-Promise-all"><a href="#4-Promise-all" class="headerlink" title="4 Promise.all"></a>4 Promise.all</h2><p>并行执行多个promise, 并等待所有的promise都准备就绪，例如并行下载几个url。</p>
<p>语法：<code>let promise = Promise.all(iterable);</code>，他接受一个可迭代对象，通常是一个项为promise的数组。并返回一个新的promise，当所有的promise 都 resolve时，新的promise才会resolve。并且其结果数组就是将成为新的promise的结果。</p>
<p>注意：结果数组中元素的顺序和在源promise中的顺序相同，不管每个promise执行时间的长短。</p>
<p>一个常见的技巧是：讲一个任务数组映射到一个promise, 然后将其包裹到promise.all。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/iliakan&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/remy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/jeresig&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个 url 映射（map）到 fetch 的 promise 中</span></span><br><span class="line"><span class="keyword">let</span> requests = urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.all 等待所有任务都 resolved</span></span><br><span class="line"><span class="built_in">Promise</span>.all(requests)</span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> responses.forEach(</span><br><span class="line">        response =&gt; alert(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>: <span class="subst">$&#123;response.status&#125;</span>`</span>)</span><br><span class="line">    ));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>又或者另外一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;iliakan&#x27;</span>, <span class="string">&#x27;remy&#x27;</span>, <span class="string">&#x27;jeresig&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requests = names.map(<span class="function"><span class="params">name</span> =&gt;</span> fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;name&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(requests)</span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 所有响应都被成功 resolved</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> response <span class="keyword">of</span> responses) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>: <span class="subst">$&#123;response.status&#125;</span>`</span>); <span class="comment">// 对应每个 url 都显示 200</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> responses;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 将响应数组映射（map）到 response.json() 数组中以读取它们的内容</span></span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> <span class="built_in">Promise</span>.all(responses.map(<span class="function"><span class="params">r</span> =&gt;</span> r.json())))</span><br><span class="line">    <span class="comment">// 所有 JSON 结果都被解析：&quot;users&quot; 是它们的数组</span></span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> users.forEach(<span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(user.name)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果任意一个 promise 被 reject，由 <code>Promise.all</code> 返回的 promise 就会立即 reject，并且带有的就是这个 error。</strong></p>
<p>且其他的promise也会被忽略，它们的结果也被忽略。</p>
</blockquote>
<h2 id="5-Promise-allSettled"><a href="#5-Promise-allSettled" class="headerlink" title="5 Promise.allSettled"></a>5 Promise.allSettled</h2><p>此API等待所有的 promise 都被 settle，无论结果如何，结果数组都具有一下：</p>
<ul>
<li><code>&#123;status:&quot;fulfilled&quot;, value:result&#125;</code> 对于成功的响应，</li>
<li><code>&#123;status:&quot;rejected&quot;, reason:error&#125;</code> 对于 error。</li>
</ul>
<p>一个例子：我们想要获取（fetch）多个用户的信息。即使其中一个请求失败，我们仍然对其他的感兴趣。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/iliakan&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://api.github.com/users/remy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://no-such-url&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(urls.map(<span class="function"><span class="params">url</span> =&gt;</span> fetch(url)))</span><br><span class="line">    .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123; <span class="comment">// (*)</span></span><br><span class="line">        results.forEach(<span class="function">(<span class="params">result, num</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.status == <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">                alert(<span class="string">`<span class="subst">$&#123;urls[num]&#125;</span>: <span class="subst">$&#123;result.value.status&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.status == <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">                alert(<span class="string">`<span class="subst">$&#123;urls[num]&#125;</span>: <span class="subst">$&#123;result.reason&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>对于以上的每个 promise，我们都得到了其状态（status）和 <code>value/reason</code>。</p>
<h2 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6 Promise.race"></a>6 Promise.race</h2><p>与 <code>Promise.all</code> 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">2000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">3</span>), <span class="number">3000</span>))</span><br><span class="line">]).then(alert); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>在这里第一个 promise 最快，所以它变成了结果。第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。</p>
<h2 id="7-Pomise-any"><a href="#7-Pomise-any" class="headerlink" title="7 Pomise.any"></a>7 Pomise.any</h2><p>与 Promise.race 类似，区别在于 Promise.any 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回。如果给出的 promise 都 rejected，那么返回的 promise 会带有 AggregateError —— 一个特殊的 error 对象，在其 errors 属性中存储着所有 promise error。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">1000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">2000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">3</span>), <span class="number">3000</span>))</span><br><span class="line">]).then(alert); <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的第一个 promise 是最快的，但 rejected 了，所以第二个 promise 则成为了结果。在第一个 fulfilled 的 promise “赢得比赛”后，所有进一步的结果都将被忽略。</p>
<h2 id="8-Promise-resolve"><a href="#8-Promise-resolve" class="headerlink" title="8 Promise.resolve"></a>8 Promise.resolve</h2><p>在现代的代码中，很少需要使用 Promise.resolve 和 Promise.reject 方法，因为 async/await 语法使它们变得有些过时了。</p>
<p><code>Promise.resolve(value)</code> 用结果 <code>value</code> 创建一个 resolved 的 promise。</p>
<p>语法：<code>let promise = new Promise(resolve =&gt; resolve(value));</code></p>
<p>大概的使用场景：当一个函数被期望返回一个 promise 时，这个方法用于兼容性。（译注：这里的兼容性是指，我们直接从缓存中获取了当前操作的结果 <code>value</code>，但是期望返回的是一个 promise，所以可以使用 <code>Promise.resolve(value)</code> 将 <code>value</code> “封装”进 promise，以满足期望返回一个 promise 的这个需求。）</p>
<h2 id="9-Promise-reject"><a href="#9-Promise-reject" class="headerlink" title="9 Promise.reject"></a>9 Promise.reject</h2><p><code>Promise.reject(error)</code> 用 <code>error</code> 创建一个 rejected 的 promise。</p>
<p>语法：<code>let promise = new Promise((resolve, reject) =&gt; reject(error));</code></p>
<p>实际上，这个方法几乎从未被使用过。</p>
<p>总结：</p>
<ul>
<li><code>catch</code> 处理 promise 中的各种 error：在 <code>reject()</code> 调用中的，或者在处理程序中抛出的 error。</li>
<li>如果给定 <code>.then</code> 的第二个参数（即 error 处理程序），那么 <code>.then</code> 也会以相同的方式捕获 error。</li>
<li>在任何情况下我们都应该有 <code>unhandledrejection</code> 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。</li>
</ul>
<p>​    </p>
<ul>
<li><code>Promise</code> 类有 6 种静态方法：<code>Promise.all</code> 可能是在实战中使用最多的。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(六)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E5%85%AD)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-六"><a href="#js笔记之Promise-六" class="headerlink" title="js笔记之Promise(六)"></a>js笔记之Promise(六)</h1><p>async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。</p>
<h2 id="1-async-function"><a href="#1-async-function" class="headerlink" title="1 async function"></a>1 async function</h2><p>语法：他可以被放置当在一个函数前面，他表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们显式的返回一个promise结果也是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="built_in">console</span>.log); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以说async确保了函数返回一个promise，也会将非 promise 的值包装进去。</p>
<h2 id="2-await"><a href="#2-await" class="headerlink" title="2 await"></a>2 await</h2><p>语法：只在 async 函数内工作, 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="keyword">await</span> promise;</span><br></pre></td></tr></table></figure>
<p>例如一个一秒后的resolve的promise:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done!&quot;</span>), <span class="number">1000</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> promise; <span class="comment">// 等待，直到 promise resolve (*)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &quot;done!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>


<p>上面的这个函数在执行的时候，“暂停”在了 <code>(*)</code> 那一行，并在 promise settle 时，拿到 <code>result</code> 作为结果继续往下执行。所以上面这段代码在一秒后显示 “done!”。</p>
<blockquote>
<p>Tips：<code>await</code> 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p>
</blockquote>
<p>相比于 <code>promise.then</code>，它只是获取 promise 的结果的一个更优雅的语法。并且也更易于读写。</p>
<blockquote>
<p>如果我们尝试在非 async 函数中使用 <code>await</code>，则会报语法错误。</p>
</blockquote>
<p>在现代浏览器中可以在一个modules，那么在顶层使用await也是可以的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">*<span class="comment">// 我们假设此代码在 module 中的顶层运行*</span></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/promise-chaining/user.json&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line"><span class="built_in">console</span>.log(user);</span><br></pre></td></tr></table></figure>


<p>如果我们没有使用 modules，或者必须兼容 旧版本浏览器 ，那么这儿还有一个通用的方法：包装到匿名的异步函数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/article/promise-chaining/user.json&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>


<blockquote>
<p>像 <code>promise.then</code> 那样，<code>await</code> 允许我们使用 thenable 对象（那些具有可调用的 <code>then</code> 方法的对象）。这里的想法是，第三方对象可能不是一个 promise，但却是 promise 兼容的：如果这些对象支持 <code>.then</code>，那么就可以对它们使用 <code>await</code>。</p>
</blockquote>
<h2 id="3-在类class中使用async方法"><a href="#3-在类class中使用async方法" class="headerlink" title="3 在类class中使用async方法"></a>3 在类class中使用async方法</h2><p>在类Class中使用async方法，只需在对应方法前面加上 <code>async</code> 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">wait</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Waiter()</span><br><span class="line">    .wait()</span><br><span class="line">    .then(alert); <span class="comment">// 1（alert 等同于 result =&gt; alert(result)）</span></span><br></pre></td></tr></table></figure>


<h2 id="4-Error-处理"><a href="#4-Error-处理" class="headerlink" title="4 Error 处理"></a>4 Error 处理</h2><p>如果一个 promise 正常 resolve，<code>await promise</code> 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 <code>throw</code> 语句那样。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面的是一样的</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在真实开发中，promise 可能需要一点时间后才 reject。在这种情况下，在 <code>await</code> 抛出（throw）一个 error 之前会有一个延时。</p>
<p>我们可以用 <code>try..catch</code> 来捕获上面提到的那个 error，与常规的 <code>throw</code> 使用的是一样的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://no-such-url&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err); <span class="comment">// TypeError: failed to fetch</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>如果有 error 发生，执行控制权马上就会被移交至 <code>catch</code> 块。我们也可以用 <code>try</code> 包装多行 <code>await</code> 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/no-user-here&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> user = <span class="keyword">await</span> response.json();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 捕获到 fetch 和 response.json 中的错误</span></span><br><span class="line">        alert(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>如果我们没有 <code>try..catch</code>，那么由异步函数 <code>f()</code> 的调用生成的 promise 将变为 rejected。我们可以在函数调用后面添加 <code>.catch</code> 来处理这个 error：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://no-such-url&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f() 变成了一个 rejected 的 promise</span></span><br><span class="line">f().catch(alert); <span class="comment">// TypeError: failed to fetch // (*)</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong><code>async/await</code> 和 <code>promise.then/catch</code></strong></p>
<p>当我们使用 <code>async/await</code> 时，几乎就不会用到 <code>.then</code> 了，因为 <code>await</code> 为我们处理了等待。并且我们使用常规的 <code>try..catch</code> 而不是 <code>.catch</code>。这通常（但不总是）更加方便。</p>
<p>但是当我们在代码的顶层时，也就是在所有 <code>async</code> 函数之外，我们在语法上就不能使用 <code>await</code> 了，所以这时候通常的做法是添加 <code>.then/catch</code> 来处理最终的结果（result）或掉出来的（falling-through）error，例如像上面那个例子中的 <code>(*)</code> 行那样。</p>
</blockquote>
<blockquote>
<p><strong><code>async/await</code> 可以和 <code>Promise.all</code> 一起使用</strong></p>
<p>当我们需要同时等待多个 promise 时，我们可以用 <code>Promise.all</code> 把它们包装起来，然后使用 <code>await</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待结果数组</span></span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">  fetch(url1),</span><br><span class="line">  fetch(url2),</span><br><span class="line">  ...</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>如果出现 error，也会正常传递，从失败了的 promise 传到 <code>Promise.all</code>，然后变成我们能通过使用 <code>try..catch</code> 在调用周围捕获到的异常（exception）。</p>
</blockquote>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>函数前面的关键字 <code>async</code> 有两个作用：</p>
<ol>
<li>让这个函数总是返回一个 promise。</li>
<li>允许在该函数内使用 <code>await</code>。</li>
</ol>
<p>Promise 前的关键字 <code>await</code> 使 JavaScript 引擎等待该 promise settle，然后：</p>
<ol>
<li>如果有 error，就会抛出异常 —— 就像那里调用了 <code>throw error</code> 一样。</li>
<li>否则，就返回结果。</li>
</ol>
<p>这两个关键字一起提供了一个很好的用来编写异步代码的框架，这种代码易于阅读也易于编写。</p>
<p>有了 <code>async/await</code> 之后，我们就几乎不需要使用 <code>promise.then/catch</code>，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法。并且，当我们需要同时等待需要任务时，<code>Promise.all</code> 是很好用的。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(五)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%BA%94)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-五"><a href="#js笔记之Promise-五" class="headerlink" title="js笔记之Promise(五)"></a>js笔记之Promise(五)</h1><h2 id="1-微任务"><a href="#1-微任务" class="headerlink" title="1 微任务"></a>1 微任务</h2><p>promise 的处理程序 <code>.then</code>、<code>.catch</code> 和 <code>.finally</code> 都是异步的。</p>
<p>即便一个 promise 立即被 resolve，<code>.then</code>、<code>.catch</code> 和 <code>.finally</code> <strong>下面</strong> 的代码也会在这些处理程序之前被执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;promise done!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;code finished&quot;</span>); <span class="comment">// 这个 console.log 先显示</span></span><br></pre></td></tr></table></figure>


<p>异步任务需要适当的管理，为此ECMA规定了一个内部队列，PromiseJobs，通常被称为“微任务队列（microtask queue）”（V8 术语）。</p>
<p>如 <a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">规范</a> 中所述：</p>
<ul>
<li>队列（queue）是先进先出的：首先进入队列的任务会首先运行。</li>
<li>只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务。</li>
</ul>
<p>简单的说就是当一个promise 准备就绪时，它的 <code>.then/catch/finally</code> 处理程序就会被放入队列中：但是它们不会立即被执行。当 JavaScript 引擎执行完当前的代码，它会从队列中获取任务并执行它。</p>
<p>如果有一个包含多个 <code>.then/catch/finally</code> 的链，那么它们中的每一个都是异步执行的。也就是说，它会首先进入队列，然后在当前代码执行完成并且先前排队的处理程序都完成时才会被执行。</p>
<p><strong>如果执行顺序对我们很重要该怎么办？我们怎么才能让 <code>code finished</code> 在 <code>promise done</code> 之后出现呢？</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> alert(<span class="string">&quot;promise done!&quot;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> alert(<span class="string">&quot;code finished&quot;</span>));</span><br></pre></td></tr></table></figure>


<h2 id="2-未处理的-rejection"><a href="#2-未处理的-rejection" class="headerlink" title="2 未处理的 rejection"></a>2 未处理的 rejection</h2><p>在js笔记之Promise(三)中说明了，如果一个 promise 的 error 未被在微任务队列的末尾进行处理，则会出现“未处理的 rejection”。现在我们知道<code>.then/catch/finally</code> 处理程序就会被放入队列中,</p>
<p>任务队列清空后，avaScript 引擎会触发下面这事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Promise Failed!&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise Failed!</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> alert(event.reason));</span><br></pre></td></tr></table></figure>
<p>当微任务队列中的任务都完成时，才会生成 <code>unhandledrejection</code>：引擎会检查 promise，如果 promise 中的任意一个出现 “rejected” 状态，<code>unhandledrejection</code> 事件就会被触发。</p>
<h2 id="3-总结："><a href="#3-总结：" class="headerlink" title="3 总结："></a>3 总结：</h2><p>Promise 处理始终是异步的，因为所有 promise 行为都会通过内部的 “promise jobs” 队列，也被称为“微任务队列”（V8 术语）。</p>
<p>因此，<code>.then/catch/finally</code> 处理程序总是在当前代码完成后才会被调用。</p>
<p>如果我们需要确保一段代码在 <code>.then/catch/finally</code> 之后被执行，我们可以将它添加到链式调用的 <code>.then</code> 中。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(四)</title>
    <url>/2023/03/27/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-四"><a href="#js笔记之Promise-四" class="headerlink" title="js笔记之Promise(四)"></a>js笔记之Promise(四)</h1><h2 id="1-Promisification"><a href="#1-Promisification" class="headerlink" title="1 Promisification"></a>1 Promisification</h2><p>Promisification 它指将一个接受回调的函数转换为一个返回 promise 的函数。由于许多的函数都是基于回调的，因此在实际的开发中经常会遇到这种转化。一个简单的例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    script.onload = <span class="function">() =&gt;</span> callback(<span class="literal">null</span>, script);</span><br><span class="line">    script.onerror = <span class="function">() =&gt;</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.append(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用法：</span></span><br><span class="line">  <span class="comment">// loadScript(&#x27;path/script.js&#x27;, (err, script) =&gt; &#123;...&#125;)</span></span><br></pre></td></tr></table></figure>
<p>上面的例子 通过给定的src加载脚本，然后再出现错误是调用callback(err)，或者在加载成功时，调用callback(null，script) 。</p>
<p>接下来我们将这个函数promise化。</p>
<p>我们要做的就是将这个函数返回一个promise,而不是使用回调。换句话就是我们只传入src, 然后再函数中return一个promise。加载成功时该 promise 将以 <code>script</code> 为结果 resolve，否则将以出现的 error 为结果 reject。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptPromise</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        loadScript(src, <span class="function">(<span class="params">err, script</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">            <span class="keyword">else</span> resolve(script)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，我们可能需要 promise 化很多函数，所以使用一个 helper（辅助函数）很有意义。</p>
<p>我们将其称为 <code>promisify(f)</code>：它接受一个需要被 promise 化的函数 <code>f</code>，并返回一个包装（wrapper）函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promisify(f, true) 来获取结果数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">f, manyArgs = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err, ...results</span>) </span>&#123; <span class="comment">// 我们自定义的 f 的回调</span></span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 manyArgs 被指定，则使用所有回调的结果 resolve</span></span><br><span class="line">                    resolve(manyArgs ? results : results[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            args.push(callback);</span><br><span class="line"></span><br><span class="line">            f.call(<span class="built_in">this</span>, ...args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line">f = promisify(f, <span class="literal">true</span>);</span><br><span class="line">f(...).then(<span class="function"><span class="params">arrayOfResults</span> =&gt;</span> ..., <span class="function"><span class="params">err</span> =&gt;</span> ...);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(二)</title>
    <url>/2023/03/25/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-二"><a href="#js笔记之Promise-二" class="headerlink" title="js笔记之Promise(二)"></a>js笔记之Promise(二)</h1><h2 id="1-Promise链"><a href="#1-Promise链" class="headerlink" title="1 Promise链"></a>1 Promise链</h2><p>Promise链的想法是通过.then处理程序链进行传递result。一个例子是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>); <span class="comment">// (*)</span></span><br><span class="line">    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">// (**)</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">// (***)</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>他的运行流程如下：</p>
<ol>
<li>初始程reomise在一秒后执行resolve。</li>
<li>然后.then处理程序被调用，然后又创建了一个新的promise.</li>
<li>下一个 <code>then</code> <code>(***)</code> 得到了前一个 <code>then</code> 的值，对该值进行处理（*2）并将其传递给下一个处理程序。</li>
<li>以此类推…</li>
</ol>
<p>这样之所以是可行的，是因为每个对 <code>.then</code> 的调用都会返回了一个新的 promise，因此我们可以在其之上调用下一个 <code>.then</code>。</p>
<p>当处理程序返回一个值时，它将成为该 promise 的 result，所以将使用它调用下一个 <code>.then</code>。</p>
<p><strong>新手常犯的一个经典错误：从技术上讲，我们也可以将多个 <code>.then</code> 添加到一个 promise 上。但这并不是 promise 链（chaining）。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    alert(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    alert(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    alert(result); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="2-返回Promise"><a href="#2-返回Promise" class="headerlink" title="2 返回Promise"></a>2 返回Promise</h2><p><code>.then(handler)</code> 中所使用的处理程序（handler）可以创建并返回一个 promise。</p>
<p>在这种情况下，其他的处理程序将等待它 settled 后再获得其结果。 </p>
<blockquote>
<p>确切地说，处理程序返回的不完全是一个 promise，而是返回的被称为 “thenable” 对象 —— 一个具有方法 <code>.then</code> 的任意对象。它会被当做一个 promise 来对待。</p>
<p>这个想法是，第三方库可以实现自己的“promise 兼容（promise-compatible）”对象。它们可以具有扩展的方法集，但也与原生的 promise 兼容，因为它们实现了 <code>.then</code> 方法。</p>
</blockquote>
<p>如果 <code>.then</code>（或 <code>catch/finally</code> 都可以）处理程序返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。当它被 settled 后，其 result（或 error）将被进一步传递下去。</p>
<h2 id="3-总结："><a href="#3-总结：" class="headerlink" title="3 总结："></a>3 总结：</h2><p><img src="https://origin.chaizz.com/tc/image-20230325231946264.png" alt="image-20230325231946264"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python环境管理Poetry的使用</title>
    <url>/2023/03/23/Python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86Poetry%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="Python环境管理Poetry的使用"><a href="#Python环境管理Poetry的使用" class="headerlink" title="Python环境管理Poetry的使用"></a>Python环境管理Poetry的使用</h1><blockquote>
<p>Poetry 是 Python 中依赖管理和打包的工具。他可以管理项目中的第三包的依赖（安装/更新）。T同时也提供了一个锁定文件以确保可重复安装，并且可以构建项目以供分发。</p>
</blockquote>
<p>poetry的Python版本要求为 3.7+，且是多平台的。</p>
<h2 id="1-安装-在windows平台下"><a href="#1-安装-在windows平台下" class="headerlink" title="1 安装 (在windows平台下)"></a>1 安装 (在windows平台下)</h2><h3 id="1-1-安装Poetry"><a href="#1-1-安装Poetry" class="headerlink" title="1.1 安装Poetry"></a>1.1 安装Poetry</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://install.python<span class="literal">-poetry</span>.org <span class="literal">-UseBasicParsing</span>).Content | python -</span><br></pre></td></tr></table></figure>
<p>根据官网安装的提示：如果是在Microsoft Store上安装的python，需要将上面的py替换为python，但是我直接安装，提示 <code>py : 无法将“py”项识别为 cmdlet、函数、脚本文件或可运行程序的名称</code>。必须要把py替换为python。</p>
<p>使用 <code>poetry --version</code> 检查版本， 如果提示版本号则安装成功。</p>
<h3 id="1-2-更新Poetry"><a href="#1-2-更新Poetry" class="headerlink" title="1.2 更新Poetry"></a>1.2 更新Poetry</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry self update</span><br></pre></td></tr></table></figure>
<h3 id="1-3-卸载Poetry"><a href="#1-3-卸载Poetry" class="headerlink" title="1.3 卸载Poetry"></a>1.3 卸载Poetry</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://install.python<span class="literal">-poetry</span>.org <span class="literal">-UseBasicParsing</span>).Content | python - -<span class="literal">-uninstall</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-配置poetry"><a href="#1-4-配置poetry" class="headerlink" title="1.4 配置poetry"></a>1.4 配置poetry</h3><p>poetry 安装后默认的缓存路径个虚拟环境路径在:</p>
<p><code>C:\Users\&lt;your name&gt;\AppData\Local\pypoetry\Cache</code> 为了不占用C盘空间，修改默认的虚拟环境的目录。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此处直接修改 cache-dir 就会修改 cache-dir 和 virtualenvs.path 的路径</span></span><br><span class="line">poetry config cache<span class="literal">-dir</span> D:\\poetry_enev </span><br></pre></td></tr></table></figure>
<p>通过 <code>poetry config --list</code> 查看已经修改成功</p>
<p><img src="https://origin.chaizz.com/33b9dcacca2011ed8b330242ac190002.png"></p>
<blockquote>
<p>取消之前的修改：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry config cache<span class="literal">-dir</span> -<span class="literal">-unset</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-使用poetry创建一个新项目"><a href="#2-使用poetry创建一个新项目" class="headerlink" title="2 使用poetry创建一个新项目"></a>2 使用poetry创建一个新项目</h2><h3 id="2-1-直接使用poetry-创建项目"><a href="#2-1-直接使用poetry-创建项目" class="headerlink" title="2.1 直接使用poetry 创建项目"></a>2.1 直接使用poetry 创建项目</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry new project_name </span><br></pre></td></tr></table></figure>
<p>自动创建一个project_name的文件件，项目名称也叫做project_name。</p>
<h3 id="2-2-添加python依赖"><a href="#2-2-添加python依赖" class="headerlink" title="2.2 添加python依赖"></a>2.2 添加python依赖</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在pyproject.toml 同目录下</span></span><br><span class="line">poetry add numpy </span><br></pre></td></tr></table></figure>
<p>安装的包和版本都会在  pyproject.toml 中</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.9&quot;</span></span><br><span class="line"><span class="attr">numpy</span> = <span class="string">&quot;^1.24.2&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-运行项目或者文件"><a href="#2-3-运行项目或者文件" class="headerlink" title="2.3 运行项目或者文件"></a>2.3 运行项目或者文件</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry run python run.py </span><br></pre></td></tr></table></figure>


<h2 id="3-在现有项目中使用poetry"><a href="#3-在现有项目中使用poetry" class="headerlink" title="3 在现有项目中使用poetry"></a>3 在现有项目中使用poetry</h2><h3 id="3-1-在某个目录下-使用poetry-init"><a href="#3-1-在某个目录下-使用poetry-init" class="headerlink" title="3.1 在某个目录下 使用poetry init"></a>3.1 在某个目录下 使用poetry init</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry init</span><br></pre></td></tr></table></figure>
<p>使用这种交互式的方式创建项目，根据选项设置完成之后，在对应的目录下同样会生成 pyproject.toml 文件。</p>
<h3 id="3-2-添加依赖和运行项目和-使用poetry创建一个新项目-与一致。"><a href="#3-2-添加依赖和运行项目和-使用poetry创建一个新项目-与一致。" class="headerlink" title="3.2 添加依赖和运行项目和==使用poetry创建一个新项目==与一致。"></a>3.2 添加依赖和运行项目和==使用poetry创建一个新项目==与一致。</h3><h2 id="4-拿到一个使用poetry管理依赖的新项目"><a href="#4-拿到一个使用poetry管理依赖的新项目" class="headerlink" title="4 拿到一个使用poetry管理依赖的新项目"></a>4 拿到一个使用poetry管理依赖的新项目</h2><h3 id="4-1-在pyproject-toml同目录下"><a href="#4-1-在pyproject-toml同目录下" class="headerlink" title="4.1 在pyproject.toml同目录下"></a>4.1 在pyproject.toml同目录下</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry install</span><br></pre></td></tr></table></figure>
<h3 id="4-2-如果要将依赖跟新到最新版本"><a href="#4-2-如果要将依赖跟新到最新版本" class="headerlink" title="4.2 如果要将依赖跟新到最新版本"></a>4.2 如果要将依赖跟新到最新版本</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry update</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips: 使用poetry时会生成 poetry.lock，此文件推荐上传到git版本控制中，</p>
</blockquote>
<h2 id="5-手动管理依赖"><a href="#5-手动管理依赖" class="headerlink" title="5 手动管理依赖"></a>5 手动管理依赖</h2><h3 id="5-1-在-pyproject-toml文件同目录下，进入虚拟环境"><a href="#5-1-在-pyproject-toml文件同目录下，进入虚拟环境" class="headerlink" title="5.1 在 pyproject.toml文件同目录下，进入虚拟环境"></a>5.1 在 pyproject.toml文件同目录下，进入虚拟环境</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></table></figure>
<p>使用此命令，进入当前的项目虚拟环境，接下来就像平常使用python一样了。</p>
<h3 id="5-2-退出"><a href="#5-2-退出" class="headerlink" title="5.2 退出"></a>5.2 退出</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">deactivate </span><br><span class="line"><span class="comment"># 或者直接退出 这个是shell</span></span><br></pre></td></tr></table></figure>


<h2 id="6-管理环境"><a href="#6-管理环境" class="headerlink" title="6 管理环境"></a>6 管理环境</h2><h3 id="6-1-获取当前的虚拟环境的基本信息"><a href="#6-1-获取当前的虚拟环境的基本信息" class="headerlink" title="6.1 获取当前的虚拟环境的基本信息"></a>6.1 获取当前的虚拟环境的基本信息</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry env info</span><br></pre></td></tr></table></figure>
<h3 id="6-2-切换虚拟环境"><a href="#6-2-切换虚拟环境" class="headerlink" title="6.2 切换虚拟环境"></a>6.2 切换虚拟环境</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry env use 具体的环境的python可执行文件路径</span><br></pre></td></tr></table></figure>
<h3 id="6-3-删除环境"><a href="#6-3-删除环境" class="headerlink" title="6.3 删除环境"></a>6.3 删除环境</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry env remove </span><br></pre></td></tr></table></figure>




<h2 id="7-在Pycharm中配置poetry环境"><a href="#7-在Pycharm中配置poetry环境" class="headerlink" title="7 在Pycharm中配置poetry环境"></a>7 在Pycharm中配置poetry环境</h2><p>一般拿到一个含有poetry环境的项目，使用pycharm打开，会自动识别poetry解释器。如果没有识别 需要手动添加，如下所示：</p>
<ul>
<li><p>基础解释器：选择对应虚拟环境的Python可执行文件。</p>
</li>
<li><p>Poetry可执行文件，选择安装在本地的Poetry可执行文件。</p>
</li>
</ul>
<p><img src="https://origin.chaizz.com/tc/image-20230327103659866.png"></p>
<p>配置完毕，打开pycharm底部导航栏控制台，即可显示当前虚拟环境前缀，接下来就可以操作就按照正常的流程执行了。</p>
<h2 id="8-更改poetry的pypi源"><a href="#8-更改poetry的pypi源" class="headerlink" title="8 更改poetry的pypi源"></a>8 更改poetry的pypi源</h2><p>通常国内下载一些包比较慢，这时我们可以更新poetry的源来使用国内的镜像。默认的情况下poetry使用的是pypi来下载包.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --default 设置为默认源</span></span><br><span class="line"><span class="comment"># 阿里源：</span></span><br><span class="line"><span class="comment"># poetry source add ali https://mirrors.aliyun.com/pypi/simple/ --default</span></span><br><span class="line"><span class="comment"># -- default 已经弃用，建议使用以下方式</span></span><br><span class="line"><span class="comment"># --priority=default 将源设置为默认源</span></span><br><span class="line">poetry source add -<span class="literal">-priority</span>=default tsinghua https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 腾讯源：</span></span><br><span class="line">poetry source add tencent https://mirrors.cloud.tencent.com/pypi/simple/ </span><br><span class="line"><span class="comment"># 清华源：</span></span><br><span class="line">poetry source add  tsinghua  https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/</span><br></pre></td></tr></table></figure>
<p>设置源以后，在<code>pyproject.toml</code>会有如下显示：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[tool.poetry.source]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;tsinghua&quot;</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/&quot;</span></span><br><span class="line"><span class="attr">priority</span> = <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure>
<p>删除源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">poetry source remove 源的名字</span><br></pre></td></tr></table></figure>


<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>一般情况下我们使用poetry管理项目，无非就是两种情况：新建项目，可以使用<code>poetry new 项目名称</code>, 或者是在旧的项目上使用poetry，那么就是用<code>poetry init </code> 使用交互式初始化一个项目。</p>
<p>平常安装依赖或者是更新依赖 就使用 <code>poetry add/update 依赖名</code>。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>包管理器</category>
      </categories>
      <tags>
        <tag>Poetry</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Promise(一)</title>
    <url>/2023/03/22/js%E7%AC%94%E8%AE%B0%E4%B9%8BPromise(%E4%B8%80)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="js笔记之Promise-一"><a href="#js笔记之Promise-一" class="headerlink" title="js笔记之Promise(一)"></a>js笔记之Promise(一)</h1><h2 id="1-Promise-对象的构造器语法"><a href="#1-Promise-对象的构造器语法" class="headerlink" title="1 Promise 对象的构造器语法"></a>1 Promise 对象的构造器语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor（生产者代码，“歌手”）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>传递给Promise的函数被称为 executor，当 new Promise 被创建时，executor 会自动运行，它包含最终应产生结果的生产者代码。</p>
<p>函数的参数 resolve，reject 是由JS自身提供的回调，我们的代码仅在executor的内部，当executor得到的结果，无论早晚，他应该调用一下的回调之一：</p>
<ul>
<li><code>resolve(value)</code> —— 如果任务成功完成并带有结果 <code>value</code>。</li>
<li><code>reject(error)</code> —— 如果出现了 error，<code>error</code> 即为 error 对象。</li>
</ul>
<p>所以总结一下就是executor会自动运行并尝试执行一项工作，尝试结束后，如果成功则调用resolve，如果出现error则调用reject。</p>
<p>由new Promise 构造器返回的promise对象具有以下的属性：</p>
<ul>
<li>state 最初是padding 然后再 resolve被调用时，变为fulfilled, 或者在reject被调用时变为rejected。</li>
<li>result 最初是 undefined 然后在resolve(value)  被调用时变为value，或者在 reject(error) 被调用时变为 error。</li>
</ul>
<p>所以executor最终将promise移至一下状态之一：</p>
<p><img src="https://origin.chaizz.com/tc/image-20230322204449440.png" alt="image-20230322204449440"></p>
<p>一个简单的例子：</p>
<p>下面的new Promise 构造器和一个简单的函数，该executor具有包含事件的生产者代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 promise 被构造完成时，自动执行此函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 秒后发出工作已经被完成的信号，并带有结果 &quot;done&quot;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>executor 只能调用一个 <code>resolve</code> 或一个 <code>reject</code>。任何状态的更改都是最终的。所有其他的再对 resolve 和 reject 的调用都会被忽略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;…&quot;</span>)); <span class="comment">// 被忽略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一个被 executor 完成的工作只能有一个结果或一个 error。并且，<code>resolve/reject</code> 只需要一个参数（或不包含任何参数），并且将忽略额外的参数。</p>
<p>reject接受的参数，可已接收任何类型， 但是建议使用Error对象或者继承Error的对象，因为这样做也是正常的做法。</p>
<p>实际上executor是异步执行的某些操作，并且在一段事件之后调用resolve/reject，但是这不是必须的，我们还可以立即调用他们，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不花时间去做这项工作</span></span><br><span class="line">    resolve(<span class="number">123</span>); <span class="comment">// 立即给出结果：123</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="2-then"><a href="#2-then" class="headerlink" title="2 then"></a>2 then</h2><p>Promise对象的state和result属性都是内部的，我们无法直接访问他们，但是我们可以对他们使用.then/ .catch/ .finally </p>
<p>Promise的executor接受结果可以通过 .then .catch 方法注册消费函数。</p>
<p>then </p>
<p>首先最重要最基础的就是.then，语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123; <span class="comment">/* handle a successful result */</span> &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">/* handle an error */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>.then</code> 的第一个参数是一个函数，该函数将在 promise resolved 且接收到结果后执行。</p>
<p><code>.then</code> 的第二个参数也是一个函数，该函数将在 promise rejected 且接收到 error 信息后执行。</p>
<p>例如在成功的情况下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;done!&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 运行 .then 中的第一个函数</span></span><br><span class="line">promise.then(</span><br><span class="line">    result =&gt; alert(result), <span class="comment">// 1 秒后显示 &quot;done!&quot;</span></span><br><span class="line">    error =&gt; alert(error) <span class="comment">// 不运行</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者在失败的情况下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 运行 .then 中的第二个函数</span></span><br><span class="line">promise.then(</span><br><span class="line">    result =&gt; alert(result), <span class="comment">// 不运行</span></span><br><span class="line">    error =&gt; alert(error) <span class="comment">// 1 秒后显示 &quot;Error: Whoops!&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="3-catch"><a href="#3-catch" class="headerlink" title="3 catch"></a>3 catch</h2><p>如果我们只对error感兴趣，那么我们可以使用null作为第一个参数：.then(null, errorHandlingFunction)，或者我们也可以使用.catch(errorHandlingFunction)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Whoops!&quot;</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .catch(f) 与 promise.then(null, f) 一样</span></span><br><span class="line">promise.catch(alert); <span class="comment">// 1 秒后显示 &quot;Error: Whoops!&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="4-finally-清理"><a href="#4-finally-清理" class="headerlink" title="4 finally 清理"></a>4 finally 清理</h2><p>想常规的try…catch…finally 一样， promise中也有finally，调用.finally类似于.then(f, f) 因为当 promise settled 时 f 就会执行：无论 promise 被 resolve 还是 reject。<code>finally</code> 的功能是设置一个处理程序在前面的操作完成后，执行清理/终结。例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 做一些需要时间的事，之后调用可能会 resolve 也可能会 reject */</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 在 promise 为 settled 时运行，无论成功与否</span></span><br><span class="line">    .finally(<span class="function">() =&gt;</span> stop loading indicator)</span><br><span class="line">    <span class="comment">// 所以，加载指示器（loading indicator）始终会在我们继续之前停止</span></span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> show result, <span class="function"><span class="params">err</span> =&gt;</span> show error)</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>finally(f)</code> 并不完全是 <code>then(f,f)</code> 的别名。</p>
<ol>
<li><p>finally处理程序没有参数，在finnally中我们不知道promise是否成功，没关系，因为我们的任务通常是执行常规的完成程序。就比如上面的例子，<code>finally</code> 处理程序没有参数，promise 的结果由下一个处理程序处理。</p>
</li>
<li><p>finally处理程序将结果或者是error传递给下一个合适的处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;value&quot;</span>), <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">    .finally(<span class="function">() =&gt;</span> alert(<span class="string">&quot;Promise ready&quot;</span>)) <span class="comment">// 先触发</span></span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> alert(result)); <span class="comment">// &lt;-- .then 显示 &quot;value&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，promise返回的value通过finally传递给了then。当然也有失败的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .finally(<span class="function">() =&gt;</span> alert(<span class="string">&quot;Promise ready&quot;</span>)) <span class="comment">// 先触发</span></span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> alert(err));  <span class="comment">// &lt;-- .catch 显示这个 error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>finally 处理程序也不应该返回任何的内容，如果他返回了 返回的值也会被忽略。唯一例外的是当finally抛出error时， 这个error会被转到下一个处理程序。</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li><code>finally</code> 处理程序没有得到前一个处理程序的结果（它没有参数）。而这个结果被传递给了下一个合适的处理程序。</li>
<li>如果 <code>finally</code> 处理程序返回了一些内容，那么这些内容会被忽略。</li>
<li>当 <code>finally</code> 抛出 error 时，执行将转到最近的 error 的处理程序。</li>
</ul>
</blockquote>
<p>Promise 可以随时添加处理程序（handler）：如果结果已经在了，它们就会执行。</p>
<p>例如Promise编写异步代码的更多的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.src = src;</span><br><span class="line"></span><br><span class="line">        script.onload = <span class="function">() =&gt;</span> resolve(script);</span><br><span class="line">        script.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error for <span class="subst">$&#123;src&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.head.append(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以这样使用这个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    script =&gt; alert(<span class="string">`<span class="subst">$&#123;script.src&#125;</span> is loaded!`</span>),</span><br><span class="line">    error =&gt; alert(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">script</span> =&gt;</span> alert(<span class="string">&#x27;Another handler...&#x27;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS错误处理(二).md</title>
    <url>/2023/03/21/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS错误处理-二"><a href="#JS笔记之JS错误处理-二" class="headerlink" title="JS笔记之JS错误处理(二)"></a>JS笔记之JS错误处理(二)</h1><p>在我们开发的时候 经常需要我们自己定义的类来反应我们在程序中遇到的错误。比如在网络请求中我们是用HttpError，在操作数据库中我么使用DbError等等。</p>
<p>我们一般都会创建自己的自定义异常，他们都支持最基本的Error属性，例如 message、name、并且最好有stack。但是他们也有自己的属性，例如HttpError队形可能有一个statusCode属性。</p>
<p>JavaScript 允许将 throw 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 Error 中继承。但是，如果我们继承，那么就可以使用 obj instanceof Error 来识别 error 对象。因此，最好继承它。</p>
<p>随着项目的增大，我们定义的异常，可能会越来越细分， 形成一个层次结构，例如：HttpTimeoutError 可能继承自 HttpError，等等。</p>
<h2 id="1-扩展Error"><a href="#1-扩展Error" class="headerlink" title="1 扩展Error"></a>1 扩展Error</h2><p>例如当我们读一个一个用户的信息的json数据，有时候即使JSON的数据格式是正确的，但是数据却不一定是是我们想要的得到的数据，可能会缺少些必要的数据。</p>
<p>我们可以定义一个函数，来解析数据并且验证数据，如果没有得到我们要求的数据，那么就会抛出一个error，但是这个error不是 语法错误等，而是类似 ValidationError的错误对象。且是一个类，他可能继承自Error，且包含具体的错误信息等。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了父类的 constructor。JavaScript 要求我们在子类的 constructor 中调用 super，所以这是必须的。</span></span><br><span class="line">    <span class="comment">// 父类的 constructor 设置了 message 属性。</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message); <span class="comment">// (1)</span></span><br><span class="line">        <span class="comment">// 父类的 constructor 还将 name 属性的值设置为了 &quot;Error&quot;，</span></span><br><span class="line">        <span class="comment">// 所以在这一行中，我们将其重置为了ValidationError</span></span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;ValidationError&quot;</span>; <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在解析json中使用它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readUser</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.age) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ValidationError(<span class="string">&quot;No field: age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ValidationError(<span class="string">&quot;No field: name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try..catch 的工作示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = readUser(<span class="string">&#x27;&#123; &quot;age&quot;: 25 &#125;&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> ValidationError) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Invalid data: &quot;</span> + err.message); <span class="comment">// Invalid data: No field: name</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123; <span class="comment">// (*)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;JSON Syntax Error: &quot;</span> + err.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err; <span class="comment">// 未知的 error，再次抛出 (**)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的try…cacth中既捕获了json解析的错误。也能捕获我们自定义的异常。在最后一中，，我们再次抛出了err。</p>
<h2 id="2-深入继承"><a href="#2-深入继承" class="headerlink" title="2 深入继承"></a>2 深入继承</h2><p>在数据中很多数据都有可能出错，我们可以为错误创建根据的异常对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;ValidationError&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;PropertyRequiredError&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.property = property;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readUser</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.age) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try..catch 的工作示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = readUser(<span class="string">&#x27;&#123; &quot;age&quot;: 25 &#125;&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> ValidationError) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Invalid data: &quot;</span> + err.message); <span class="comment">// Invalid data: No property: name</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.name); <span class="comment">// PropertyRequiredError</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.property); <span class="comment">// name</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;JSON Syntax Error: &quot;</span> + err.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err; <span class="comment">// 未知 error，将其再次抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类 PropertyRequiredError 使用起开很简单，我们只需要传递属性名， new PropertyRequiredError(property)， 人类刻度的message是 constructor 生成的。</p>
<blockquote>
<p>​    Tips：在 PropertyRequiredError constructor 中的 this.name 是通过手动重新赋值的。这可能会变得有些乏味 —— 在每个自定义 error 类中都要进行 this.name = <class name> 赋值操作。可以通过创建自己的“基础错误（basic error）”类来避免这种情况，在基础错误类上进行 <code>this.name = this.constructor.name</code> 赋值，然后让我们的所有的异常类 都继承自这个基础错误类。</class></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="built_in">this</span>.constructor.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">MyError</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;No property: &quot;</span> + property);</span><br><span class="line">        <span class="built_in">this</span>.property = property;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name 是对的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;field&quot;</span>).name); <span class="comment">// PropertyRequiredError</span></span><br></pre></td></tr></table></figure>


<h2 id="3-包装异常"><a href="#3-包装异常" class="headerlink" title="3 包装异常"></a>3 包装异常</h2><p>我们扩展了ValidationError，PropertyRequiredError 未来可能会有其他的更多的类，try…catch.. 中使用了多个if else语句进行检查，这种方法并不是很优雅，那么有没有哟中比较高级的方法。答案是有的， 这种方法叫做包装异常。例如将上面的读取数据的例子进行包装：</p>
<ol>
<li>创建一个新的类ReadError，来表示一般的数据读取Error。</li>
<li>函数readUser 将捕获内部发生的数据读取 error，例如 ValidationError 和 SyntaxError，并生成一个 ReadError 来进行替代。</li>
<li>对象ReadError 会把原始的error 的引用，保存在其cause中。</li>
</ol>
<p>经过上面的包装之后，再次调用 上面的 readUser 只需要检查 ReadError，而不必检查每种数据读取 error。并且，如果需要更多 error 细节，那么可以检查 readUser 的 cause 属性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">message, cause</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.cause = cause;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;ReadError&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidationError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRequiredError</span> <span class="keyword">extends</span> <span class="title">ValidationError</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!user.age) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PropertyRequiredError(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readUser</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ReadError(<span class="string">&quot;Syntax Error&quot;</span>, err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        validateUser(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err <span class="keyword">instanceof</span> ValidationError) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ReadError(<span class="string">&quot;Validation Error&quot;</span>, err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    readUser(<span class="string">&#x27;&#123;bad json&#125;&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ReadError) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        <span class="comment">// Original error: SyntaxError: Unexpected token b in JSON at position 1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Original error: &quot;</span> + e.cause);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><ol>
<li>我们可以从Error和其他的内建error中进行继承，我们只需要注意name属性，以及调用super。</li>
<li>我们可以使用 instanceof 来检查特定的 error。但有时我们有来自第三方库的 error 对象，并且在这儿没有简单的方法来获取它的类。那么可以将 name 属性用于这一类的检查。</li>
<li>包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数。在上面的示例中，低级别异常有时会成为该对象的属性，例如 err.cause，但这不是严格要求的。</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS错误处理(一).md</title>
    <url>/2023/03/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86(%E4%B8%80)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS错误处理-一"><a href="#JS笔记之JS错误处理-一" class="headerlink" title="JS笔记之JS错误处理(一)"></a>JS笔记之JS错误处理(一)</h1><p>在编程中很难能够一次性写出完美的代码，错误确实经常性的，在JS中可以使用try…catch能够使我们捕获错误。</p>
<h2 id="1-try…catch语法"><a href="#1-try…catch语法" class="headerlink" title="1 try…catch语法"></a>1 try…catch语法</h2><p>try…catch 结构由两部分组成：try 和 catch：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误捕获</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的执行步骤是：</p>
<ol>
<li>首先执行try…的代码。</li>
<li>如果第一步没有错误，则忽略catch(err)…的代码，跳过catch…的代码，执行try的末尾继续执行。</li>
<li>如果第一步错误，则try…停止执行，代码则跳转带catch(err)的开头，变量err(可以是任何名称)将包含一个error对象，该对象包含了所发生事件的详细信息。</li>
</ol>
<p>所以 try…catch(err)… try后面的代码不会导致程序停止。一些例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有 error 的例子：显示 alert (1) 和 (2)：</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始执行 try 中的内容&#x27;</span>);  <span class="comment">// (1) &lt;--</span></span><br><span class="line">    <span class="comment">// ...这里没有 error</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;try 中的内容执行完毕&#x27;</span>);   <span class="comment">// (2) &lt;--</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch 被忽略，因为没有 error&#x27;</span>); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含 error 的例子：显示 (1) 和 (3) 行的 alert 中的内容：</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始执行 try 中的内容&#x27;</span>);  <span class="comment">// (1) &lt;--</span></span><br><span class="line">    lalala; <span class="comment">// error，变量未定义！</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;try 的末尾（未执行到此处）&#x27;</span>);  <span class="comment">// (2)</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`出现了 error！`</span>); <span class="comment">// (3) &lt;--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：try…catch… 仅仅对运行时的error有效，也就是说要想try…catch能够工作，代码必须是可执行的，如果包含语法错误，那么try..catch将无法工作。</p>
<p>JS引擎首先会读取代码，然后运行它，在读取阶段发生的错误，被称为解析时间（parse-time）错误，并且无法修复，因为引擎无法理解代码。</p>
</blockquote>
<p>所以try…catch只能处理有效代码中出现的错误，这列错误成为运行时的错误(runtime errors)，也被称为异常。</p>
<p>如果在”计划的”代码中发生异常，例如在setTimeout中，则try…catch不会捕获到异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        noSuchVariable; <span class="comment">// 脚本将在这里停止运行</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;不工作&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 try…catch 包裹了计划要执行的函数，该函数本身要稍后才执行，这时引擎已经离开了try…catch 结构。</p>
<p>如果要捕获到计划的函数的异常，那么try…catch 必须在这个函数内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        noSuchVariable; <span class="comment">// try...catch 处理 error 了！</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error 被在这里捕获了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-Error对象"><a href="#2-Error对象" class="headerlink" title="2 Error对象"></a>2 Error对象</h2><p>发生错误时JS会生成一个包含此error的详细信息的对象，然后将该对象作为参数传递给catch，对于所有的内建的 error对象有两个主要的属性: name、message。 </p>
<p>name:error的名称，例如对于一个未定义的变量，名称是“ReferenceError”。</p>
<p>message: 关于error的详细文字描述。</p>
<p>还有其他的非标准的属性，在大多数环境下可用，其中被广泛使用和支持的是：</p>
<p>stack: 代表当前的调用栈，用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lalala; <span class="comment">// error, variable is not defined!</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.name); <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">console</span>.log(err.message); <span class="comment">// lalala is not defined</span></span><br><span class="line">    <span class="built_in">console</span>.log(err.stack); <span class="comment">// ReferenceError: lalala is not defined at (...call stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以将一个 error 作为整体显示出来</span></span><br><span class="line">    <span class="comment">// error 信息被转换为像 &quot;name: message&quot; 这样的字符串</span></span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError: lalala is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可选的catch绑定</p>
<p>这是一个新的特性，如果我们不需要error的信息，catch也可以忽略他。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; <span class="comment">// &lt;-- 没有 (err)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-try…catch的真实用例"><a href="#3-try…catch的真实用例" class="headerlink" title="3 try…catch的真实用例"></a>3 try…catch的真实用例</h2><p>当我们接受来自网络、服务器或是其他来源的json数据，我们会使用 JSON.parse(str)来讲字符串解析为JS对象。</p>
<p>但是如果json字符串无法解析，那么就会生成一个error，所以这个时候就需要try…catch来尝试解析这个json字符串，即使发生了错误我们也能主动的捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&quot;&#123; bad json &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json); <span class="comment">// &lt;-- 当出现 error 时...</span></span><br><span class="line">    <span class="built_in">console</span>.log(user.name); <span class="comment">// 不工作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// ...执行会跳转到这里并继续执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;很抱歉，数据有错误，我们会尝试再请求一次。&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err.name);</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里我们将错误输出了，我们可以做更多的事情，例如新发送一个网络请求，或者将日志发送到记录日志的设备。</p>
<h2 id="4-输出自定义的错误"><a href="#4-输出自定义的错误" class="headerlink" title="4 输出自定义的错误"></a>4 输出自定义的错误</h2><p>有时候我们可能知道这里容易出问题，那么如何输出我们自定义的错误呢？</p>
<p>使用 throw 操作符， 语法：<code>throw &lt;object error&gt;</code>技术上我们可以将任何东西用作于error，甚至可以是一个原型类型数据，又或者是字符串或数字，但是最好使用对象，最好具有name和message属性的对象。 某种程度上和内建的Error对象保持兼容。</p>
<p>JS中有很多内建的标准 error 的构造器：Error，SyntaxError，ReferenceError，TypeError 等。我们也可以使用它们来创建 error 对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(message);</span><br><span class="line"><span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(message);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>内建的error对象， name属性刚刚好就是构造器的名字，message 就是构造器的参数。</p>
<p>例如我们使用内建的错误对象，构造一个我们自己的错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>; <span class="comment">// 不完整的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json); <span class="comment">// &lt;-- 没有 error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">&quot;数据不全：没有 name&quot;</span>); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(user.name);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;JSON Error: &quot;</span> + err.message); <span class="comment">// JSON Error: 数据不全：没有 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-再次抛出error"><a href="#5-再次抛出error" class="headerlink" title="5 再次抛出error"></a>5 再次抛出error</h2><p>在上述的例子中 try…catch 用于捕获 数据不正确的error, 但是 try…代码块可能会继续抛出其他的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>; <span class="comment">// 不完整的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    user = <span class="built_in">JSON</span>.parse(json); <span class="comment">// &lt;-- 忘记在 user 前放置 &quot;let&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;JSON Error: &quot;</span> + err); <span class="comment">// JSON Error: ReferenceError: user is not defined</span></span><br><span class="line">    <span class="comment">// (实际上并没有 JSON Error)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，catch会捕获到所有来自于try…代码块的error，上面的代码中 错误已经不再是 json error 了， 是其他的错误，但是错误信息还是 JSON Error。</p>
<p>为了避免此类的问题，我们采用“重新抛出技术”，规则很简单：</p>
<p>catch 只处理他知道的error，并抛出其他的error。</p>
<p>再次抛出的技术可以理解为：</p>
<ol>
<li>catch 捕获所有的error。</li>
<li>在catch(err){…} 块中，我们对error对象err进行分析。</li>
<li>如果我们不知道如何处理它，那么我们就throw err。</li>
</ol>
<p>通常我们可以使用instanceif 操作符判断错误类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    user = &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">ReferenceError</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;ReferenceError&#x27;</span>); <span class="comment">// 访问一个未定义（undefined）的变量产生了 &quot;ReferenceError&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以从err.name 属性中获取错误类型的类名，所有的原生的错误都有这个类型，另一种方式是读取err.constructor.name。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">&#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;</span>; <span class="comment">// 不完整的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user.name) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">&quot;数据不全：没有 name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blabla(); <span class="comment">// 预料之外的 error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(user.name);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="comment">//     if (err.constructor.name == &quot;SyntaxError&quot;) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;JSON Error: &quot;</span> + err.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err; <span class="comment">// 再次抛出 (*)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-try…catch…finally"><a href="#6-try…catch…finally" class="headerlink" title="6 try…catch…finally"></a>6 try…catch…finally</h2><p>try…catch 还有一个代码结构， finally的代码所有的情况都会被执行，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ... 尝试执行的代码 ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">   ... 处理 error ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   ... 总是会执行的代码 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = +prompt(<span class="string">&quot;输入一个正整数？&quot;</span>, <span class="number">35</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> diff, result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || <span class="built_in">Math</span>.trunc(n) != n) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;不能是负数，并且必须是整数。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? n : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = fib(num);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    diff = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result || <span class="string">&quot;出现了 error&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`执行花费了 <span class="subst">$&#123;diff&#125;</span>ms`</span>);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips: 变量和 try…catch…finally 中的局部变量</p>
<p>请注意，上面代码中的 result 和 diff 变量都是在 try…catch 之前 声明的。</p>
<p>否则，如果我们使用 let 在 try 块中声明变量，那么该变量将只在 try 块中可见。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// 先执行 finally 中的 console.log，然后执行这个 console.log</span></span><br></pre></td></tr></table></figure>


<p>没有catch…finally 结构也很有用，当我们不想在这处理error，但是需要确保我们启动的处理需要被完成。</p>
<h2 id="7-全局的catch"><a href="#7-全局的catch" class="headerlink" title="7 全局的catch"></a>7 全局的catch</h2><p>在浏览器中我们可以讲一个函数赋值给特殊的 window.onerror 属性，该函数在发生未捕获的error时执行。</p>
<p>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, col, error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// message: error 信息。</span></span><br><span class="line"><span class="comment">// url :发生 error 的脚本的 URL。</span></span><br><span class="line"><span class="comment">// line，col: 发生 error 处的代码的行号和列号。</span></span><br><span class="line"><span class="comment">//  error:error 对象。</span></span><br></pre></td></tr></table></figure>


<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, col, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">`<span class="subst">$&#123;message&#125;</span>\n At <span class="subst">$&#123;line&#125;</span>:<span class="subst">$&#123;col&#125;</span> of <span class="subst">$&#123;url&#125;</span>`</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        badFunc(); <span class="comment">// 啊，出问题了！</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readData();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>全局错误处理程序的作用通常不是回复程序的方法，而是在程序发生错误的时候，将错误消息发送给开发者。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>try…catch 结构允许我们处理执行过程中出现的error, 从字面上拉看他允许尝试运行代码，并捕获其中可能发生的error。</p>
<p>error 对象包括以下属性：</p>
<ol>
<li>name error名称的字符串。</li>
<li>message 人类可读的错误信息。</li>
<li>stack error发生时的调用栈。</li>
</ol>
<p>如果需要error对象，也可以直接使用 try{…}catch {…}。</p>
<p>我们可以使用throw 抛出自己根据内建对象定义的错误对象。</p>
<p>再次抛出  throwing 是一种错误处理的常用模式。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(六)</title>
    <url>/2023/03/18/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E5%85%AD)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-六"><a href="#JS笔记之JS类-六" class="headerlink" title="JS笔记之JS类(六)"></a>JS笔记之JS类(六)</h1><p>在JS中类只能扩展一个类， 每个对象只能有一个[[prototype]],但是有些时候，会让人感到限制，例如我们有一个User类和一个EventEmitter类来实现事件生成，并且想将EventEmitter的功能添加到User类中，以便用户可以触发事件。</p>
<p>有一个概念可以帮我们， 叫做 mixins， 在维基百科中 mixin是一个可以被其他的类使用，而无需继承的方法的类。</p>
<p>换句话说就是 mixin 提供了一些特殊的方法，但是我们不单独使用它，而是用它来将这些行为添加到其他的类中，</p>
<h2 id="1-一个Mixin实例"><a href="#1-一个Mixin实例" class="headerlink" title="1 一个Mixin实例"></a>1 一个Mixin实例</h2><p>在JS中构造一个mixin最简单的方法就是构造一个拥有使用方法的对象，以便我们可以轻松的将这些实用的方法合并到任何类的原型中。例如这个名为sayHiMixin的mixin用于给User添加一些语言功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mixin</span></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>(<span class="string">`Hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>(<span class="string">`Bye <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 User 可以打招呼了</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&quot;Dude&quot;</span>).sayHi(); <span class="comment">// Hello Dude!</span></span><br></pre></td></tr></table></figure>
<p>在这里没有使用继承，而只是一个简单的拷贝，所以User可以从另一个类继承，还可以包括mixin来”mix-in”其他的方法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br></pre></td></tr></table></figure>
<p>Mixin可以在自己的内部进行继承，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayMixin = &#123;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params">phrase</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>(phrase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHiMixin = &#123;</span><br><span class="line">    __proto__: sayMixin, <span class="comment">// (或者，我们可以在这儿使用 Object.setPrototypeOf 来设置原型)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.say(<span class="string">`Hello <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>); <span class="comment">// (*)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sayBye</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.say(<span class="string">`Bye <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, sayHiMixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 User 可以打招呼了</span></span><br><span class="line"><span class="keyword">new</span> User(<span class="string">&quot;Dude&quot;</span>).sayHi(); <span class="comment">// Hello Dude!</span></span><br></pre></td></tr></table></figure>


<p>在sayHiMixin内部对父类的方法，super.say()的调用会在mixin的原型中查找方法，而不是在class中查找。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230318164932986.png" alt="image-20230318164932986"></p>
<p>这是因为方法sayHi和sayBye最初是在sayHiMixin中创建的，因此即使复制了他们，但是他们的[[homeObject]]内部属性扔引用的sayHiMixin。</p>
<p>当 super 在 [[HomeObject]].[[Prototype]] 中寻找父方法时，意味着它搜索的是 sayHiMixin.[[Prototype]]，而不是 User.[[Prototype]]。</p>
<h2 id="2-EventMixin"><a href="#2-EventMixin" class="headerlink" title="2 EventMixin"></a>2 EventMixin</h2><p>许多浏览器对象的一个重要功能就是可以生成事件，事件是向任何有需要的人“广播信息”的好方法。</p>
<p>我们将构造一个对象，能够轻松的将与事件相关的函数添加到任意的calss或者是object中。</p>
<ol>
<li>Mixin提供.trigger(name,[…data])方法，以在发生重要的事情时，生成一个事件。name参数（arguments）是事件的名称，[…data] 是可选的带有事件数据的其他参数。</li>
<li>此外还有.on(name,handler)方法，他为具有给定名称的事件添加了handler函数作为监听器，（listener）当具有给定name的事件触发时将调用该方法，并从.trigger调用中参数（arguments）。</li>
<li>还有.off(name, handler)方法，他会删除handler监听器（listener）。</li>
</ol>
<p>田家湾mixin后，对象user能够在访客登录时，生成事件login, 另一个对象，例如calender可能希望监听此类事件以便为登录的人添加日历。</p>
<p>或者当一个菜单选项被选中时，menu可以生成select事件，其他对象可以分配处理程序以对该事件作出反应。诸如此类。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> eventMixin = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件，用法：</span></span><br><span class="line"><span class="comment">     *  menu.on(&#x27;select&#x27;, function(item) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers) <span class="built_in">this</span>._eventHandlers = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers[eventName]) &#123;</span><br><span class="line">            <span class="built_in">this</span>._eventHandlers[eventName] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._eventHandlers[eventName].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅，用法：</span></span><br><span class="line"><span class="comment">     *  menu.off(&#x27;select&#x27;, handler)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">off</span>(<span class="params">eventName, handler</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> handlers = <span class="built_in">this</span>._eventHandlers?.[eventName];</span><br><span class="line">        <span class="keyword">if</span> (!handlers) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handlers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlers[i] === handler) &#123;</span><br><span class="line">                handlers.splice(i--, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成具有给定名称和数据的事件</span></span><br><span class="line"><span class="comment">     *  this.trigger(&#x27;select&#x27;, data1, data2);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">trigger</span>(<span class="params">eventName, ...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._eventHandlers?.[eventName]) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 该事件名称没有对应的事件处理程序（handler）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用事件处理程序（handler）</span></span><br><span class="line">        <span class="built_in">this</span>._eventHandlers[eventName].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> handler.apply(<span class="built_in">this</span>, args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">choose</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.trigger(<span class="string">&quot;select&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加带有事件相关方法的 mixin</span></span><br><span class="line"><span class="built_in">Object</span>.assign(Menu.prototype, eventMixin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> menu = <span class="keyword">new</span> Menu();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个事件处理程序（handler），在被选择时被调用：</span></span><br><span class="line">menu.on(<span class="string">&quot;select&quot;</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Value selected: <span class="subst">$&#123;value&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件 =&gt; 运行上述的事件处理程序（handler）并显示：</span></span><br><span class="line"><span class="comment">// 被选中的值：123</span></span><br><span class="line">menu.choose(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>




<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>Mixin是一个通用的面向对象的变成术语，一个包含其他类的方法的类。</p>
<p>JS不支持多继承，但是可以通过将方法拷贝到原型中来实现，mixin。我们可以使用mixin作为一种通过添加多种行为来扩充类的方法。</p>
<p>如果 Mixins 意外覆盖了现有类的方法，那么它们可能会成为一个冲突点。因此，通常应该仔细考虑 mixin 的命名方法，以最大程度地降低发生这种冲突的可能性。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(五)</title>
    <url>/2023/03/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%BA%94)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-五"><a href="#JS笔记之JS类-五" class="headerlink" title="JS笔记之JS类(五)"></a>JS笔记之JS类(五)</h1><h2 id="1-类检查-instanceof"><a href="#1-类检查-instanceof" class="headerlink" title="1 类检查 instanceof"></a>1 类检查 instanceof</h2><p>instanceof 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承。</p>
<p>在许多情况下，可能都需要进行此类检查。例如，它可以被用来构建一个 <strong>多态性（polymorphic）</strong> 的函数，该函数根据参数的类型对参数进行不同的处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> Class</span><br><span class="line"><span class="comment">//如果 obj 隶属于 Class 类（或 Class 类的衍生类），则返回 true。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// rabbit 是 Rabbit class 的对象吗？</span></span><br><span class="line"><span class="built_in">console</span>.log( rabbit <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>还可以与构造函数一起使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是构造函数，而不是 class</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> Rabbit() <span class="keyword">instanceof</span> Rabbit ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>与内建的类一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">alert( arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> ); <span class="comment">// true</span></span><br><span class="line">alert( arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常，<code>instanceof</code> 在检查中会将原型链考虑在内。此外，我们还可以在静态方法 <code>Symbol.hasInstance</code> 中设置自定义逻辑。</p>
</blockquote>
<h2 id="2-obj-instanceof-Class-的-算法逻辑如下："><a href="#2-obj-instanceof-Class-的-算法逻辑如下：" class="headerlink" title="2 obj instanceof Class 的 算法逻辑如下："></a>2 obj instanceof Class 的 算法逻辑如下：</h2><ol>
<li><p>如果Class 有静态方法：Symbol.hasInstance，那么就直接调用这个方法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 instanceOf 检查</span></span><br><span class="line"><span class="comment">// 并假设具有 canEat 属性的都是 animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.canEat) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">canEat</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Animal); <span class="comment">// true：Animal[Symbol.hasInstance](obj) 被调用</span></span><br></pre></td></tr></table></figure></li>
<li><p>大多数 class 没有 Symbol.hasInstance。在这种情况下，标准的逻辑是：使用 obj instanceOf Class 检查 Class.prototype 是否等于 obj 的原型链中的原型之一。也就是在Class 的原型链上一步一步的比较。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.__proto__ === Class.prototype?</span><br><span class="line">obj.__proto__.__proto__ === Class.prototype?</span><br><span class="line">obj.__proto__.__proto__.__proto__ === Class.prototype?</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果任意一个的答案为 true，则返回 true</span></span><br><span class="line"><span class="comment">// 否则，如果我们已经检查到了原型链的尾端，则返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承中的比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"><span class="built_in">console</span>.log(rabbit <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rabbit.__proto__ === Animal.prototype（无匹配）</span></span><br><span class="line"><span class="comment">// rabbit.__proto__.__proto__ === Animal.prototype（匹配！）</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
<p>这里还要提到一个方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf">objA.isPrototypeOf(objB)</a>，如果 <code>objA</code> 处在 <code>objB</code> 的原型链中，则返回 <code>true</code>。所以，可以将 <code>obj instanceof Class</code> 检查改为 <code>Class.prototype.isPrototypeOf(obj)</code>。</p>
<p>这很有趣，但是 <code>Class</code> 的 constructor 自身是不参与检查的！检查过程只和原型链以及 <code>Class.prototype</code> 有关。</p>
<p>创建对象后如果更改对象的 prototype 属性，那么示例就不再是类的示例了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改了 prototype</span></span><br><span class="line">Rabbit.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...再也不是 rabbit 了！</span></span><br><span class="line"><span class="built_in">console</span>.log(rabbit <span class="keyword">instanceof</span> Rabbit); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h2 id="3-使用-Object-prototype-toString-方法来揭示类型"><a href="#3-使用-Object-prototype-toString-方法来揭示类型" class="headerlink" title="3 使用 Object.prototype.toString 方法来揭示类型"></a>3 使用 Object.prototype.toString 方法来揭示类型</h2><p>一个普通的对象被转化为字符串时得到的结果是：[Object Object]，这是通过toString方法实现的，但是此处有一个隐藏功能，可以使toString变得更加强大，可以将其作为 typeof 的增强版或者 instanceof 的替代方法来使用。</p>
<p>按照 规范 所讲，内建的 toString 方法可以被从对象中提取出来，并在任何其他值的上下文中执行。其结果取决于该值。</p>
<ul>
<li>对于 number 类型，结果是 <code>[object Number]</code></li>
<li>对于 boolean 类型，结果是 <code>[object Boolean]</code></li>
<li>对于 <code>null</code>：<code>[object Null]</code></li>
<li>对于 <code>undefined</code>：<code>[object Undefined]</code></li>
<li>对于数组：<code>[object Array]</code></li>
<li>……等（可自定义）</li>
</ul>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方便起见，将 toString 方法复制到一个变量中</span></span><br><span class="line"><span class="keyword">let</span> objectToString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它是什么类型的？</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内部，toString 的算法会检查 this，并返回相应的结果</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(arr) ); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(<span class="number">123</span>) ); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(<span class="literal">null</span>) ); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log( objectToString.call(<span class="built_in">console</span>.log) ); <span class="comment">// [object Function]</span></span><br></pre></td></tr></table></figure>


<p>可以使用特殊的对象属性，Symbol.toStringTag 自定义对象的 toString 方法的行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&quot;User&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.toString.call(user)); <span class="comment">// [object User]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特定于环境的对象和类的 toStringTag：</span></span><br><span class="line">alert( <span class="built_in">window</span>[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// Window</span></span><br><span class="line">alert( XMLHttpRequest.prototype[<span class="built_in">Symbol</span>.toStringTag] ); <span class="comment">// XMLHttpRequest</span></span><br><span class="line"></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="built_in">window</span>) ); <span class="comment">// [object Window]</span></span><br><span class="line">alert( &#123;&#125;.toString.call(<span class="keyword">new</span> XMLHttpRequest()) ); <span class="comment">// [object XMLHttpRequest]</span></span><br></pre></td></tr></table></figure>
<p>正如我们所看到的，输出结果恰好是 <code>Symbol.toStringTag</code>（如果存在），只不过被包裹进了 <code>[object ...]</code> 里。所以，如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 <code>&#123;&#125;.toString.call</code> 替代 <code>instanceof</code>。</p>
<p>类型检查方法：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">用于</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>typeof</code></td>
<td align="left">原始数据类型</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left"><code>&#123;&#125;.toString</code></td>
<td align="left">原始数据类型，内建对象，包含 <code>Symbol.toStringTag</code> 属性的对象</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left"><code>instanceof</code></td>
<td align="left">对象</td>
<td align="left">true/false</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(四)</title>
    <url>/2023/03/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-四"><a href="#JS笔记之JS类-四" class="headerlink" title="JS笔记之JS类(四)"></a>JS笔记之JS类(四)</h1><h2 id="1-私有的和受保护的属性和方法"><a href="#1-私有的和受保护的属性和方法" class="headerlink" title="1 私有的和受保护的属性和方法"></a>1 私有的和受保护的属性和方法</h2><p>面向对象编程最重要的原则之一 —— 将内部接口与外部接口分隔开来。</p>
<p>在 JavaScript 中，有两种类型的对象字段（属性和方法）：</p>
<ul>
<li>公共的：可从任何地方访问。它们构成了外部接口。到目前为止，我们只使用了公共的属性和方法。</li>
<li>私有的：只能从类的内部访问。这些用于内部接口。</li>
</ul>
<p>首先创建一个咖啡机类:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    waterAmount = <span class="number">0</span>; <span class="comment">// 内部的水量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">power</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.power = power;</span><br><span class="line">        alert(<span class="string">`Created a coffee-machine, power: <span class="subst">$&#123;power&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加水</span></span><br><span class="line">coffeeMachine.waterAmount = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p>现在咖啡机的 waterAmount 和  power 是公共的属性，我们可以从外部轻易的修改，我们将 <code>waterAmount</code> 属性更改为受保护的属性，以对其进行更多控制。</p>
<h2 id="2-受保护的属性"><a href="#2-受保护的属性" class="headerlink" title="2 受保护的属性"></a>2 受保护的属性</h2><p><strong>受保护的属性通常以下划线 <code>_</code> 作为前缀。</strong>这并不是强制的，但是是程序的约个约定俗称的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    _waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._waterAmount = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">waterAmount</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._waterAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">power</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加水</span></span><br><span class="line">coffeeMachine.waterAmount = -<span class="number">10</span>; <span class="comment">// _waterAmount 将变为 0，而不是 -10</span></span><br></pre></td></tr></table></figure>
<p>现在访问已受到控制，因此将水量的值设置为小于零的数变得不可能。</p>
<p>设置只读属性，将咖啡机的 power属性设置为在开始创建之后就不可更改。我们值需要设施getter属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">power</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._power = power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">power</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._power;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建咖啡机</span></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">`Power is: <span class="subst">$&#123;coffeeMachine.power&#125;</span>W`</span>); <span class="comment">// 功率是：100W</span></span><br><span class="line"></span><br><span class="line">coffeeMachine.power = <span class="number">25</span>; <span class="comment">// Error（没有 setter）</span></span><br></pre></td></tr></table></figure>
<p>在上述的代码中我们使用了 getter和setter语法，但是我们大多数使用get…/set… 这中函数：因为函数更灵活。它们可以接受多个参数，但是并没有严格约定使用那种方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    _waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setWaterAmount</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>._waterAmount = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getWaterAmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._waterAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> CoffeeMachine().setWaterAmount(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>受保护的字段是可以被继承的</strong></p>
<p>如果我们继承 <code>class MegaMachine extends CoffeeMachine</code>，那么什么都无法阻止我们从新的类中的方法访问 <code>this._waterAmount</code> 或 <code>this._power</code>。</p>
<p>所以受保护的字段是自然可被继承的。</p>
</blockquote>
<h2 id="3-私有的属性"><a href="#3-私有的属性" class="headerlink" title="3 私有的属性"></a>3 私有的属性</h2><p><strong>私有属性和方法应该以 <code>#</code> 开头。它们只在类的内部可被访问。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    #waterLimit = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    #<span class="function"><span class="title">fixWaterAmount</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="built_in">this</span>.#waterLimit) <span class="keyword">return</span> <span class="built_in">this</span>.#waterLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setWaterAmount</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.#waterLimit = <span class="built_in">this</span>.#fixWaterAmount(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.#waterLimit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coffeeMachine = <span class="keyword">new</span> CoffeeMachine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能从类的外部访问类的私有属性和方法</span></span><br><span class="line"><span class="comment">// Private field &#x27;#fixWaterAmount&#x27; must be declared in an enclosing class</span></span><br><span class="line">coffeeMachine.#fixWaterAmount(<span class="number">123</span>); <span class="comment">// Error</span></span><br><span class="line">coffeeMachine.#waterLimit = <span class="number">1000</span>; <span class="comment">// Error</span></span><br><span class="line">coffeeMachine.print()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在语言级别，<code>#</code> 是该字段为私有的特殊标志。我们无法从外部或从继承的类中访问它。</p>
<p>私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 <code>#waterAmount</code> 和公共的 <code>waterAmount</code> 字段。例如 让waterAmount成为#waterAmount 的访问器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    #waterAmount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">waterAmount</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.#waterAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">waterAmount</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.#waterAmount = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> machine = <span class="keyword">new</span> CoffeeMachine();</span><br><span class="line"></span><br><span class="line">machine.waterAmount = <span class="number">100</span>;</span><br><span class="line">alert(machine.#waterAmount); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>与受保护的字段不同，私有字段由语言本身强制执行。当我们需要继承CoffeeMachine时， 私有字段不会被继承，需要依赖属性访问器<code>waterAmount</code> getter/setter。</p>
<p>许多种情况下，我们经常会扩展某个有私有属性的类，这种私有属性太限制，所以我们还是常常使用受保护的属性，即使它们不受语言语法的支持。</p>
<blockquote>
<p><strong>私有字段不能通过 this[name] 访问</strong></p>
<p>私有字段很特别。</p>
<p>正如我们所知道的，通常我们可以使用 <code>this[name]</code> 访问字段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fieldName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>[fieldName]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于私有字段来说，这是不可能的：<code>this[&#39;#name&#39;]</code> 不起作用。这是确保私有性的语法限制。</p>
</blockquote>
<h2 id="4-扩展内建类"><a href="#4-扩展内建类" class="headerlink" title="4 扩展内建类"></a>4 扩展内建类</h2><p>内建的 Array, Map 对象也是可以扩展的。例如我们扩展了一个内建的Array 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> PowerArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.isEmpty()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(filteredArr); <span class="comment">// 10, 50</span></span><br><span class="line"><span class="built_in">console</span>.log(filteredArr.isEmpty()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<p>在上述代码中， 我们发现 PowerArray 的 arr 实例，具有Array的方法 filter, 由filter 得到的新数组具有PowerArray 的 isEmpty 方法。所以我们得知 arr.filter它内部使用的是arr.constructor， 来创建新的数组，因此我们才可以在结果数组上继续使用isEmpty方法。</p>
<p>我们可以给这个类添加一个特殊的静态访问器方法，Symbol.species，如果存在，则返回JS 在内部用来在 <code>map</code> 和 <code>filter</code> 等方法中创建新实体的 <code>constructor</code>。如果我们希望像 <code>map</code> 或 <code>filter</code> 这样的内建方法返回常规数组，我们可以在 <code>Symbol.species</code> 中返回 <code>Array</code>，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内建方法将使用这个作为 constructor</span></span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> PowerArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.isEmpty()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter 使用 arr.constructor[Symbol.species] 作为 constructor 创建新数组</span></span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &gt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// filteredArr 不是 PowerArray，而是 Array</span></span><br><span class="line"><span class="built_in">console</span>.log(filteredArr.isEmpty()); <span class="comment">// Error: filteredArr.isEmpty is not a function</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>其他集合，例如 <code>Map</code> 和 <code>Set</code> 的工作方式类似。它们也使用 <code>Symbol.species</code>。</p>
</blockquote>
<h2 id="5-内建类没有静态方法继承"><a href="#5-内建类没有静态方法继承" class="headerlink" title="5 内建类没有静态方法继承"></a>5 内建类没有静态方法继承</h2><p>内建对象有它们自己的静态方法，例如 <code>Object.keys</code>，<code>Array.isArray</code> 等。</p>
<p>如我们所知道的，原生的类互相扩展。例如，<code>Array</code> 扩展自 <code>Object</code>。</p>
<p>通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承。这已经在 <a href="https://zh.javascript.info/static-properties-methods#statics-and-inheritance">静态属性和静态方法</a> 中详细地解释过了。</p>
<p>但内建类却是一个例外。它们相互间不继承静态方法。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>就面向对象编程（OOP）而言，内部接口与外部接口的划分被称为 <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">封装</a>。</p>
<p>它具有以下优点：</p>
<ul>
<li><p>保护用户，使他们不会误伤自己</p>
<p>想象一下，有一群开发人员在使用一个咖啡机。这个咖啡机是由“最好的咖啡机”公司制造的，工作正常，但是保护罩被拿掉了。因此内部接口暴露了出来。所有的开发人员都是文明的 —— 他们按照预期使用咖啡机。但其中的一个人，约翰，他认为自己是最聪明的人，并对咖啡机的内部做了一些调整。然而，咖啡机两天后就坏了。这肯定不是约翰的错，而是那个取下保护罩并让约翰进行操作的人的错。编程也一样。如果一个 class 的使用者想要改变那些本不打算被从外部更改的东西 —— 后果是不可预测的。</p>
</li>
<li><p>可支持性</p>
<p>编程的情况比现实生活中的咖啡机要复杂得多，因为我们不只是购买一次。我们还需要不断开发和改进代码。<strong>如果我们严格界定内部接口，那么这个 class 的开发人员可以自由地更改其内部属性和方法，甚至无需通知用户。</strong>如果你是这样的 class 的开发者，那么你会很高兴知道可以安全地重命名私有变量，可以更改甚至删除其参数，因为没有外部代码依赖于它们。对于用户来说，当新版本问世时，应用的内部可能被进行了全面检修，但如果外部接口相同，则仍然很容易升级。</p>
</li>
<li><p>隐藏复杂性</p>
<p>人们喜欢使用简单的东西。至少从外部来看是这样。内部的东西则是另外一回事了。程序员也不例外。<strong>当实施细节被隐藏，并提供了简单且有据可查的外部接口时，总是很方便的。</strong></p>
</li>
</ul>
<p>为了隐藏内部接口，我们使用受保护的或私有的属性：</p>
<ul>
<li>受保护的字段以 <code>_</code> 开头。这是一个众所周知的约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以 <code>_</code> 开头的字段。</li>
<li>私有字段以 <code>#</code> 开头。JavaScript 确保我们只能从类的内部访问它们。</li>
</ul>
<p>目前，各个浏览器对私有字段的支持不是很好，但可以用 polyfill 解决。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(三)</title>
    <url>/2023/03/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%B8%89)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-三"><a href="#JS笔记之JS类-三" class="headerlink" title="JS笔记之JS类(三)"></a>JS笔记之JS类(三)</h1><h2 id="1-静态属性和方法"><a href="#1-静态属性和方法" class="headerlink" title="1 静态属性和方法"></a>1 静态属性和方法</h2><p>使用字面量创建一个 静态方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === User);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是我直接给类的属性复制一个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">User.staticMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === User);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常，静态方法用于实现属于 整个类，但不属于该类任何特定对象的函数。</p>
<p>例如，我们创建一个article类，然后我们创建一个方法来比较这个article，通常的方案就是添加一个静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">title, date</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">compare</span>(<span class="params">articleA, articleB</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> articleA.date - articleB.date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法：</span></span><br></pre></td></tr></table></figure>
<p>或者使用静态类创建一个工厂方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">title, date</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">createTodays</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 记住 this = Article</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>(<span class="string">&quot;Today&#x27;s digest&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> article = Article.createTodays();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(article.title); <span class="comment">// Today&#x27;s digest</span></span><br></pre></td></tr></table></figure>
<p>静态方法也被用于与数据库相关的公共类，可以用于搜索/保存/删除数据库中的条目， 就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定 Article 是一个用来管理文章的特殊类</span></span><br><span class="line"><span class="comment">// 通过 id 来移除文章的静态方法：</span></span><br><span class="line">Article.remove(&#123;<span class="attr">id</span>: <span class="number">12345</span>&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态方法不是类的对象的方法，二是类本身的方法。</p>
<p>他可以再类上调用， 但是不能在对象上调用。</p>
</blockquote>
<h2 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h2><p>JS比较新的特性。他看起来就像常规的类的属性，但是前面回家一个 static ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> publisher = <span class="string">&quot;Levi Ding&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( Article.publisher ); <span class="comment">// Levi Ding</span></span><br></pre></td></tr></table></figure>
<p>这种定义的方式， 等同于直接给Article赋值。<code>Article.publisher = &quot;Levi Ding&quot;;</code></p>
<p>继承静态属性和方法</p>
<p>类的静态属性和方法同样可以继承，也是通过原型链进行查找。extends 让 Rabbit 的 [[Prototype]] 指向了 Animal。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230313151407307.png" alt="image-20230313151407307"></p>
<p>所以，<code>Rabbit extends Animal</code> 创建了两个 <code>[[Prototype]]</code> 引用：</p>
<ol>
<li><code>Rabbit</code> 函数原型继承自 <code>Animal</code> 函数。</li>
<li><code>Rabbit.prototype</code> 原型继承自 <code>Animal.prototype</code></li>
</ol>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>原型的静态方法被应用于整个类的功能， 和具体的实例没有关系，在类声明中，它们都被用关键字 static 进行了标记。</p>
<p>静态属性被用于当我们想要存储类级别的数据时，而不是绑定到实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> property = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从技术上讲，静态声明与直接给类相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyClass.property = ...</span><br><span class="line">MyClass.method = ...</span><br></pre></td></tr></table></figure>
<p>静态属性和方法是可被继承的。</p>
<p>对于 <code>class B extends A</code>，类 <code>B</code> 的 prototype 指向了 <code>A</code>：<code>B.[[Prototype]] = A</code>。因此，如果一个字段在 <code>B</code> 中没有找到，会继续在 <code>A</code> 中查找。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(二)</title>
    <url>/2023/03/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-二"><a href="#JS笔记之JS类-二" class="headerlink" title="JS笔记之JS类(二)"></a>JS笔记之JS类(二)</h1><h2 id="1-类的继承-使用“extends”-关键字"><a href="#1-类的继承-使用“extends”-关键字" class="headerlink" title="1 类的继承, 使用“extends” 关键字"></a>1 类的继承, 使用“extends” 关键字</h2><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">someMethods</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;继承&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建一个动物类，有动物的一些方法属性，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params">speed</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = speed;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> runs with speed <span class="subst">$&#123;<span class="built_in">this</span>.speed&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.speed = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> stands still.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">&quot;My animal&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.run(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.hide(); <span class="comment">// White Rabbit hides!</span></span><br></pre></td></tr></table></figure>


<p>在内部，关键字 extends 使用了原型的机制工作，他将<code>Rabbit.prototype.[[prototype]]</code>设置为了<code>Animal.prototype</code>，所以在Rabbit中找不到的方法，会自动去他的原型链上去寻找。</p>
<p>extends 后面可以根任意的表达式，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; alert(phrase); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User extends f(&quot;Hello&quot;) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>根据许多条件使用函数生成类，并继承它们时来说可能很有用。</p>
<h2 id="2-重写类的方法"><a href="#2-重写类的方法" class="headerlink" title="2 重写类的方法"></a>2 重写类的方法</h2><p>完全重新类的方法， 直接在子类中定义名称相同的方法名即可，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ……现在这个将会被用作 rabbit.stop()</span></span><br><span class="line">        <span class="comment">// 而不是来自于 class Animal 的 stop()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们通常都只是想扩展一下， 父类的方法。JS提供了 super 关键字。使用 super.method() 来调用一个父类。使用 super()一个父类的constructor。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> hides!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.stop(); <span class="comment">// 调用父类的 stop</span></span><br><span class="line">        <span class="built_in">this</span>.hide(); <span class="comment">// 然后 hide</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">&quot;White Rabbit&quot;</span>);</span><br><span class="line"></span><br><span class="line">rabbit.run(<span class="number">5</span>); <span class="comment">// White Rabbit runs with speed 5.</span></span><br><span class="line">rabbit.stop(); <span class="comment">// White Rabbit stands still. White Rabbit hides!</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>箭头函数没有super，如果被访问他从外部获取，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">super</span>.stop(), <span class="number">1000</span>); <span class="comment">// 1 秒后调用父类的 stop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-重写-constructor"><a href="#3-重写-constructor" class="headerlink" title="3 重写 constructor"></a>3 重写 constructor</h2><p>如果一个类继承了一个父类，但是没有重写constructor，那么他的constructor，默认是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为没有自己的 constructor 的扩展类生成的</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们设置自己子类的constructor，但是有一定的要求：</p>
<ul>
<li>继承类的constructor， 必须调用 super()。</li>
<li>并且一定要在this 之前调用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, earLength</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.earLength = earLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-重写类字段"><a href="#4-重写类字段" class="headerlink" title="4 重写类字段"></a>4 重写类字段</h2><p>一般错误的实现方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;rabbit&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(); <span class="comment">// animal</span></span><br><span class="line"><span class="keyword">new</span> Rabbit(); <span class="comment">// animal</span></span><br></pre></td></tr></table></figure>
<p><strong>是因为，父类构造器总是会使用它自己字段的值，而不是被重写的那一个。</strong></p>
<p>实际上，原因在于字段初始化的顺序。类字段是这样初始化的：</p>
<ul>
<li>对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</li>
<li>对于子类，在 super() 后立刻初始化</li>
</ul>
<p>在上面的例子中，Rabbit是子类, 他没有实现constructor，所以是一个空的 super(…args)的构造器。</p>
<p>所以，new Rabbit() 调用了 super()，因此它执行了父类构造器，并且只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候，Rabbit 还没有自己的类字段，这就是为什么 Animal 类字段被使用了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>想要扩展一个类：<code>class Child extends Parent</code>。</p>
<p>这意味着 <code>Child.prototype.__proto__</code> 将是 <code>Parent.prototype</code>，所以方法会被继承。</p>
<p>重写一个 constructor：在使用 <code>this</code> 之前，我们必须在 <code>Child</code> 的 constructor 中将父 constructor 调用为 <code>super()</code>。</p>
<p>重写一个方法：我们可以在一个 <code>Child</code> 方法中使用 <code>super.method()</code> 来调用 <code>Parent</code> 方法。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS类(一)</title>
    <url>/2023/03/08/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E7%B1%BB(%E4%B8%80)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS类-一"><a href="#JS笔记之JS类-一" class="headerlink" title="JS笔记之JS类(一)"></a>JS笔记之JS类(一)</h1><p>在日常的开发中，京城需要构建许多类型相同的对象，例如 Users, Goods ，我们可以使用构造器来完成这样的操作，但是在现代JS中可以是使用类这种方式来创建相同类型的对象。</p>
<h2 id="1-类基本语法"><a href="#1-类基本语法" class="headerlink" title="1 类基本语法"></a>1 类基本语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class 方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="title">method1</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="title">method2</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="title">method3</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User()</span><br></pre></td></tr></table></figure>
<p>new 会自动调用<code>constructor</code>方法，因此可以在<code>constructor</code>方法中初始化对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure>
<p>在python中创建类的方式也大同小异。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">f&quot;我的名字是：<span class="subst">&#123;self.name&#125;</span>，Hi~&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    user = User(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">    user.say_hi()</span><br></pre></td></tr></table></figure>
<p>在JS中当 new User(“john”)被调用时，代表一个新的对象被创建，constructor 使用给定的参数运行，并且将其赋值给this.name。</p>
<blockquote>
<p>Tips：</p>
<p>类的方法之间没有逗号。</p>
</blockquote>
<h2 id="2-所以class到底是什么？"><a href="#2-所以class到底是什么？" class="headerlink" title="2 所以class到底是什么？"></a>2 所以class到底是什么？</h2><p>在JS中类是一种函数，class User(…) 实际上做了如下的事情：</p>
<ol>
<li>创建一个名为User的函数，该函数称为类声明的结果，该函数的代码来自于constructor方法（如果不编写这个方法，那么就为空）。</li>
<li>存储类中的方法，例如 User.prototype.sayHi</li>
</ol>
<h2 id="3-class-不仅仅是语法糖"><a href="#3-class-不仅仅是语法糖" class="headerlink" title="3 class 不仅仅是语法糖"></a>3 class 不仅仅是语法糖</h2><p>声明上述的User对象不使用类也可以声明一个同样的对象：`</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用纯函数重写 class User</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建构造器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数的原型（prototype）默认具有 &quot;constructor&quot; 属性，</span></span><br><span class="line"><span class="comment">// 所以，我们不需要创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将方法添加到原型</span></span><br><span class="line">User.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">user.sayHi();</span><br></pre></td></tr></table></figure>
<p>虽然得到的结果基本相同，但是他们之间仍然存着巨大的差异。</p>
<ol>
<li><p>通过class创建的函数具有特殊的内部属性标记。[[IsClassConstructor]]:true。</p>
<p>必须使用 new 来创建它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> User); <span class="comment">// function</span></span><br><span class="line">User();  <span class="comment">// Class constructor User cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>类方法不可枚举，类定义将 prototype 中的所有的方法的描述符enumerable设置为fasle。</p>
</li>
<li><p>类总是使用 user strict , 在类构造中的代码都自动进入严格模式。</p>
</li>
</ol>
<h2 id="4-类表达式"><a href="#4-类表达式" class="headerlink" title="4 类表达式"></a>4 类表达式</h2><p>类会像函数一样可以在另外一个表达式中被定义，被传递，返回，赋值等。如果类表达式有名字，那么该名字仅在类内部可见。且可以动态的创建类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> User = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// “命名类表达式（Named Class Expression）”</span></span><br><span class="line"><span class="comment">// (规范中没有这样的术语，但是它和命名函数表达式类似)</span></span><br><span class="line"><span class="keyword">let</span> User = <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(MyClass); <span class="comment">// MyClass 这个名字仅在类内部可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// 正常运行，显示 MyClass 中定义的内容</span></span><br><span class="line"></span><br><span class="line">alert(MyClass); <span class="comment">// error，MyClass 在外部不可见</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态的创建类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClass</span>(<span class="params">phrase</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个类并返回它</span></span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            alert(phrase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的类</span></span><br><span class="line"><span class="keyword">let</span> User = makeClass(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi(); <span class="comment">// Hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="5-getters-setters"><a href="#5-getters-setters" class="headerlink" title="5 getters/setters"></a>5 getters/setters</h2><p>类同样可能包括getters/setters，以及计算属性 （computed properties）等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 setter</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;Name is too short.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> User(<span class="string">&quot;&quot;</span>); <span class="comment">// Name is too short.</span></span><br></pre></td></tr></table></figure>


<h2 id="6-计算属性"><a href="#6-计算属性" class="headerlink" title="6 计算属性"></a>6 计算属性</h2><p>计算属性的方法名称使用中括号声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="string">&#x27;say&#x27;</span> + <span class="string">&#x27;Hi&#x27;</span>]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> User().sayHi();</span><br></pre></td></tr></table></figure>


<h2 id="7-类字段"><a href="#7-类字段" class="headerlink" title="7 类字段"></a>7 类字段</h2><p>类字段是一种允许添加任何属性的语法，类字段的重要的不同之处在于他们会在每个对立对象中被设置好，而不是在User.prototype：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// John</span></span><br><span class="line"><span class="built_in">console</span>.log(User.prototype.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>


<h2 id="8-使用类字段实现绑定方法"><a href="#8-使用类字段实现绑定方法" class="headerlink" title="8 使用类字段实现绑定方法"></a>8 使用类字段实现绑定方法</h2><p>在JS中具有动态的this，它取决于调用上下文，如果一个对象方法被传递到某处，或者在另一个上下文中被调用，则this不在是起对象的引用。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> Button(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(button.click, <span class="number">1000</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>


<p>在函数进阶中的函数绑定中说明过这个情况，解决的方法有两种，一是使用包装器，二是将方法绑定到对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 他是基于每一个对象创建的，在这里每一个button都有一个独立的方法，内部都有一个指向此对象的this,可以把button.click()传递到任何都一个对象。</span></span><br><span class="line">    click = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> Button(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(button.click, <span class="number">1000</span>); <span class="comment">// hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在浏览器环境中，它对于进行事件监听尤为有用。</p>
</blockquote>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>类的基本语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    prop = value; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...</span>)</span> &#123; <span class="comment">// 构造器</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">method</span>(<span class="params">...</span>)</span> &#123; &#125; <span class="comment">// method</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">something</span>(<span class="params">...</span>) &#123; &#125; <span class="comment">// getter 方法</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title">something</span>(<span class="params">...</span>) &#123; &#125; <span class="comment">// setter 方法</span></span><br><span class="line"></span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; &#125; <span class="comment">// 有计算名称（computed name）的方法（此处为 symbol）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>技术上来说，<code>MyClass</code> 是一个函数（我们提供作为 <code>constructor</code> 的那个），而 methods、getters 和 setters 都被写入了 <code>MyClass.prototype</code>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>类</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(六)</title>
    <url>/2023/03/02/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E5%85%AD)%20/</url>
    <content><![CDATA[<p>​        </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-六"><a href="#JS笔记之JS函数进阶-六" class="headerlink" title="JS笔记之JS函数进阶(六)"></a>JS笔记之JS函数进阶(六)</h1><h2 id="1-函数绑定"><a href="#1-函数绑定" class="headerlink" title="1 函数绑定"></a>1 函数绑定</h2><p>将对象方法作为回调进行绑定，例如传递给<code>setTimeout</code>会存在丢失this的问题。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(user.sayHi, <span class="number">1000</span>); <span class="comment">// Hello, undefined!</span></span><br></pre></td></tr></table></figure>
<p>这是因为<code>setTimeout</code> 获取到的函数 <code>user.sayHi</code> 和对象 <code>user</code> 分离了，无法在获取<code>user</code> 对象的上下文。</p>
<p>这是一种比较典型的问题：我们想将一个对象的方法，传递到别的地方调用，如何确保对象中的方法的上下文呢？</p>
<h2 id="2-解决方案一：包装器"><a href="#2-解决方案一：包装器" class="headerlink" title="2 解决方案一：包装器"></a>2 解决方案一：包装器</h2><p>通过包装器从外部的此法环境，能够获取user，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    user.sayHi(); <span class="comment">// Hello, John!</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用箭头函数函数m 更简洁的语法</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> user.sayHi(), timeout);</span><br></pre></td></tr></table></figure>


<p>上述的方法有一个问题就是函数执行有一秒的延迟，但是在这一秒之内，原来的对象被修改了，name将会执行被修改后的对象的方法，或者直接抛出异常。</p>
<h2 id="3-解决方案二：bind"><a href="#3-解决方案二：bind" class="headerlink" title="3 解决方案二：bind"></a>3 解决方案二：bind</h2><p>函数提供了一个内建方法，他可以绑定this，基本的语法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.bind(context);</span><br></pre></td></tr></table></figure>
<p>简单来说就是把<code>this</code>，提供给<code>func</code>，和之前的<code>func.call(contenxt, arg1,...)</code>和<code>func.apply(contenxt, ...args)</code>类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.firstName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> funcUser = func.bind(user);</span><br><span class="line">funcUser(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>


<p>现在来尝试解决解决方案一出现的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params">phrase</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;phrase&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = user.sayHi.bind(user); <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在没有对象（译注：与对象分离）的情况下运行它</span></span><br><span class="line">sayHi(<span class="string">&quot;李四&quot;</span>); <span class="comment">// 李四, John!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(sayHi, <span class="number">1000</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 张三, John!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使 user 的值在不到 1 秒内发生了改变</span></span><br><span class="line"><span class="comment">// sayHi 还是会使用预先绑定（pre-bound）的值，该值是对旧的 user 对象的引用</span></span><br></pre></td></tr></table></figure>


<p>现在使用<code>bind</code>来操作函数，并且函数能够保持在对象改变的情况下，保持对原来对象的引用。同样可以正常运行。<code>let sayHi = user.sayHi.bind(user);</code> 我们将<code>user</code>对象的方法绑定给<code>sayHi</code>，他可以被单独调用，也可以传递到<code>setTimeout</code>中。</p>
<p>如果一个对象有很多方法， 可以在循环中进行绑定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> user[key] == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        user[key] = user[key].bind(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-部分应用函数-（Partial-functions）"><a href="#4-部分应用函数-（Partial-functions）" class="headerlink" title="4 部分应用函数 （Partial functions）"></a>4 部分应用函数 （Partial functions）</h2><p>JS中不仅可以绑定函数，还可以绑定参数，在python中也有同样的概念，Python中partial的基本使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">sum_1 = partial(<span class="built_in">sum</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(sum_1(<span class="number">2</span>)) </span><br></pre></td></tr></table></figure>


<p>JS partial的基本语法：<code>let bound = func.bind(context, [arg1], [arg2], ...);</code>他可以将上下文绑定为<code>this</code>，且绑定部分参数。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> double = mul.bind(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">3</span>)); <span class="comment">// = mul(2, 3) = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">4</span>)); <span class="comment">// = mul(2, 4) = 8</span></span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">5</span>)); <span class="comment">// = mul(2, 5) = 10</span></span><br></pre></td></tr></table></figure>


<p>值得一提的是，当没有上下文<code>this</code>需要绑定的时候， 要显示的将上下文设置为<code>null</code>。或者可以理解为将<code>null</code>绑定为了上下文。但是不能省略。</p>
<p>可用的场景大概是：①：我们再原来的函数的基础上创建一个可独享较高的独立函数，且不必每次都提供一个参数，因为参数是被绑定了的。②：或者是当我们有一个很灵活的函数，希望有一个不那么领灵活的变形时，可以使用这个方法。</p>
<h2 id="5-没有上下文的部分应用函数-（Partial-functions）"><a href="#5-没有上下文的部分应用函数-（Partial-functions）" class="headerlink" title="5 没有上下文的部分应用函数 （Partial functions）"></a>5 没有上下文的部分应用函数 （Partial functions）</h2><p>当我们只想为一些函数绑定参数，但是没有上下文，原生的<code>bind</code>不支持这样。这是我们可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">func, ...argsBound</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(<span class="built_in">this</span>, ...argsBound, ...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>function partial(func, ...argsBound)</code>调用的结果是一个包装器，这个包装器调用<code>func</code>，并且与他获得的函数具有相同的<code>this</code>，<code>...argsBound</code>是<code>function partial(func, ...argsBound)</code>的参数，<code>...args</code>是给包装器的参数。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params">time, phrase</span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">`[<span class="subst">$&#123;time&#125;</span>] <span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span>: <span class="subst">$&#123;phrase&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个带有绑定时间的 partial 方法</span></span><br><span class="line"><span class="comment">// new Date().getHours() + &#x27;:&#x27; + new Date().getMinutes() 是包装器的参数，就是...argsBound</span></span><br><span class="line">user.sayNow = partial(user.say, <span class="keyword">new</span> <span class="built_in">Date</span>().getHours() + <span class="string">&#x27;:&#x27;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getMinutes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello 是包装器的参数。</span></span><br><span class="line">user.sayNow(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的结果： [22:41] John: Hello!</span></span><br></pre></td></tr></table></figure>


<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><ul>
<li>方法<code>func.bind(context, ...args)</code>返回函数<code>func</code>的“绑定变体”，它绑定了上下文 this 和第一个参数（如果给定了）。我们一般使用<code>bind</code>绑定<code>this</code>传递到其他地方用，例如传递给<code>setTimeout</code>。</li>
<li>当绑定现有函数的一些参数后，绑定的函数被称为 partially  applied或者偏函数（自创）。</li>
<li>bind 绑定的结果是一个新的对象，他没有原来函数的属性。</li>
<li>一个函数不能被重绑定（re-bound）。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS弹性盒模型Flex知识巩固</title>
    <url>/2023/02/27/CSS%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8BFlex%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<p>​               </p>
<a id="more"></a>          



<p>所谓弹性盒模型就是首先要有一个盒子，即弹性盒，在盒子中的所有的元素都是弹性元素，我们可以控制里面的元素的排列组合。</p>
<p>例如盒子中有两个元素水平排列时，他们自动等宽排列。我们同样可以使其（弹性元素）竖直排列。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230227202922436.png" alt="image-20230227202922436"></p>
<p>当增加了一个盒子，会自动变为三个元素水平等宽排列。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230227203140920.png" alt="image-20230227203140920"></p>
<h2 id="1-声明弹性盒子"><a href="#1-声明弹性盒子" class="headerlink" title="1 声明弹性盒子"></a>1 声明弹性盒子</h2><p>例如当前我们有这样一个结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> * &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://origin.chaizz.com/tc/image-20230227204707086.png" alt="image-20230227204707086"></p>
<h2 id="2-弹性元素排列"><a href="#2-弹性元素排列" class="headerlink" title="2 弹性元素排列"></a>2 弹性元素排列</h2><p>默认的HTML的文档流排列方法为从上到下， 1,2,3 三个<code>div</code>以此排列。</p>
<p>当我们在<code>article</code>上添加 <code>display:flex</code> 时，此时三个<code>div</code>将编程如下的排列方式:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="comment">/* 将article转化为弹性盒 */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://origin.chaizz.com/tc/image-20230227205029209.png" alt="image-20230227205029209"></p>
<p>弹性盒中的弹性元素默认为水平排列，当元素的个数发生变化，元素宽度会自适应伸缩。我们仍然可以使用<code>flex-direction</code>来改变弹性元素的排列方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-direction：控制弹性元素的排列方式。</span></span><br><span class="line"><span class="comment">        row：默认的排列方式。水平排列</span></span><br><span class="line"><span class="comment">        row-reverse：水平排列，但是弹性元素进行翻转</span></span><br><span class="line"><span class="comment">        column：竖向方向排列</span></span><br><span class="line"><span class="comment">        column-reverse：竖向排列，但是弹性元素进行翻转</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-direction</span>: row;  </span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-弹性元素换行"><a href="#3-弹性元素换行" class="headerlink" title="3 弹性元素换行"></a>3 弹性元素换行</h2><p>在上文中， 弹性元素都没有弹性盒子的宽度宽，有时候我们会有很多的弹性元素，默认是自适应伸缩的，但是我们想让他们超过弹性盒子宽度时进行换行要怎么实现呢？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    flex-wrap：控制元素在溢出的时候是否换行 </span></span><br><span class="line"><span class="comment">        npwrap：不换行</span></span><br><span class="line"><span class="comment">        wrap：换行</span></span><br><span class="line"><span class="comment">        wrap-reverse：反向换行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>根据<code>flex-wrap</code>的属性和<code>flex-direction</code>的属性，我们可以控制元素的水平、列排布以及在元素溢出的时候的换行排布。css针对上述属性提供了一个快捷的属性<code>flex-flow</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    flex-flow 可以同时设置排列和换行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-flow</span>: column wrap;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-弹性盒排列的方式"><a href="#4-弹性盒排列的方式" class="headerlink" title="4 弹性盒排列的方式"></a>4 弹性盒排列的方式</h2><p>在弹性元素水平竖直排列时候，会有一个轴的概念。弹性盒主要根据轴来区分弹性元素排列的方向。弹性盒内部会有一个主轴副轴之分，如果是默认排列方式：<code>flex-flow:row nowarp</code> 此时水平方向的轴为弹性盒的主轴。当元素换行的时候元素就会根据副轴（即竖直方向的轴）进行排列。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230227212850381.png" alt="image-20230227212850381"></p>
<p>如果是排列方式为：<code>flex-flow:column nowarp</code> 此时竖直方向的轴为弹性盒的主轴。当元素换行的时候元素就会根据副轴（即水平方向的轴）进行排列。</p>
<p><img src="https://origin.chaizz.com/tc/image-20230227213340600.png" alt="image-20230227213340600"></p>
<p>所以根据上面的图例，可以说明在弹性盒模型中，主轴并不一定是水平方向或者是垂直方向，是要根据弹性盒模型的<code>flex-direction</code>属性决定的。</p>
<h2 id="5-主轴的排列方式（单行）"><a href="#5-主轴的排列方式（单行）" class="headerlink" title="5 主轴的排列方式（单行）"></a>5 主轴的排列方式（单行）</h2><p>使用<code>justify-content</code>来控制主轴的排列方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">article &#123;</span><br><span class="line">	display: flex;</span><br><span class="line">	flex-flow: row wrap;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">    justify-content：控制弹性元素在主轴的对齐方式</span></span><br><span class="line"><span class="comment">        1、当 flex-direction 为 row 时，主轴为水平方向。</span></span><br><span class="line"><span class="comment">            flex-start：从主轴开始对齐， 默认。从左到右。</span></span><br><span class="line"><span class="comment">            flex-end：从主轴结束对齐，从右到左。</span></span><br><span class="line"><span class="comment">            如果 flex-direction 进行翻转：row-reverse，以上两种对齐方式则也会翻转</span></span><br><span class="line"><span class="comment">        2、当 flex-direction 为 column 时，主轴为竖直方向。</span></span><br><span class="line"><span class="comment">            flex-start：从主轴开始对齐， 默认。从上到下。</span></span><br><span class="line"><span class="comment">            flex-end：从主轴结束对齐，从下到上。</span></span><br><span class="line"><span class="comment">            如果 flex-direction 进行翻转：column-reverse，以上两种对齐方式则也会翻转</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3、根据主轴居中</span></span><br><span class="line"><span class="comment">            center：所有元素在主轴之间进行居中显示</span></span><br><span class="line"><span class="comment">        4、平均分布</span></span><br><span class="line"><span class="comment">            4.1  space-evenly：完全的平局分布</span></span><br><span class="line"><span class="comment">            4.2  space-around：元素左右两侧会有相等的间距。</span></span><br><span class="line"><span class="comment">            4.3  space-between：左右两边的元素完全靠边，中间的元素平均分布</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	justify-content: space-around;</span><br><span class="line">	border: 2px solid rgb(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	width: 600px;</span><br><span class="line">	height: 600px;</span><br><span class="line">	margin: 50px auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://origin.chaizz.com/tc/image-20230227221805554.png" alt="image-20230227221805554"></p>
<p>当主轴为竖直方向也是相同的排列规则。</p>
<h2 id="6-副轴（交叉轴）的排列方式（单行）"><a href="#6-副轴（交叉轴）的排列方式（单行）" class="headerlink" title="6 副轴（交叉轴）的排列方式（单行）"></a>6 副轴（交叉轴）的排列方式（单行）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">	<span class="attribute">justify-content</span>: space-around;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    align-items 控制弹性元素在副轴（交叉轴）的对齐方式</span></span><br><span class="line"><span class="comment">        1、当主轴为水平方向时：</span></span><br><span class="line"><span class="comment">            flex-start：从副轴开始对齐，从上到下。</span></span><br><span class="line"><span class="comment">            flex-end：从副轴开始对齐，从下到上。</span></span><br><span class="line"><span class="comment">        2、center</span></span><br><span class="line"><span class="comment">            交叉轴的中心对齐。</span></span><br><span class="line"><span class="comment">        3、stretch</span></span><br><span class="line"><span class="comment">            元素拉伸，前提是元素没有高度，否则会进行覆盖。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        当主轴为垂直方向时 与水平方向原理一致。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">align-items</span>: stretch;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> * &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="comment">/* height: 100px; */</span></span><br><span class="line">	<span class="attribute">background-color</span>: red;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>案例：单行元素在弹性盒模型中水平垂直居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="comment">/* 1、将盒子设置为弹性盒模型。 */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* 2、设置主轴方向上的居中。 */</span></span><br><span class="line">	<span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="comment">/* 3、设置副轴（交叉轴）方向上的居中。 */</span></span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgb</span>(<span class="number">15</span>, <span class="number">25</span>, <span class="number">171</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> * &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: red;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>步骤：</p>
<ol>
<li>将盒子设置为弹性盒模型。</li>
<li>设置主轴方向上的居中：<code>justify-content: center</code>。</li>
<li>设置副轴（交叉轴）方向上的居中：<code> align-items: center</code>。</li>
</ol>
<h2 id="7-多行元素在交叉轴的排列"><a href="#7-多行元素在交叉轴的排列" class="headerlink" title="7 多行元素在交叉轴的排列"></a>7 多行元素在交叉轴的排列</h2><p>如果交叉轴的元素有<code>margin</code>属性是<code>auto</code>，则会忽略<code>align-self</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">        对单个元素的交叉轴进行控制</span></span><br><span class="line"><span class="comment">        flex-end：反向排列</span></span><br><span class="line"><span class="comment">        flex-start：默认排列</span></span><br><span class="line"><span class="comment">        center：居中对齐排列</span></span><br><span class="line"><span class="comment">        stretch：将元素拉伸 （没有高度或者自动的高度）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="attribute">align-self</span>: baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="8-弹性元素在弹性盒可用空间的分配"><a href="#8-弹性元素在弹性盒可用空间的分配" class="headerlink" title="8 弹性元素在弹性盒可用空间的分配"></a>8 弹性元素在弹性盒可用空间的分配</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">	<span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    lex-grow：按比例在弹性盒中分配，</span></span><br><span class="line"><span class="comment">        当只为一个元素设置lex-grow 属性时，他的值可以是任意值，其他的元素没有设置，代表其余的模型宽度不变。</span></span><br><span class="line"><span class="comment">        当前设置的元素占据剩下盒子宽度的所有。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    lex-grow 当其他的元素也设置 lex-grow 属性时， 就会按照弹性盒的宽度记性等分。</span></span><br><span class="line"><span class="comment">    例如第二个元素设置了1， 第一个元素也设置了1，那么弹性盒除去未设置的元素的大小 100px,</span></span><br><span class="line"><span class="comment">    剩下的500px 将 元素1 和 元素2 等分，都是250px，因为他们的flex-grow 都是1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果第二个元素设置为2，那么弹性盒除去未设置的元素的大小100px,剩下的500px 设置为三等分，第二个元素占用</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="9-关于第八点的案例"><a href="#9-关于第八点的案例" class="headerlink" title="9 关于第八点的案例"></a>9 关于第八点的案例</h2><p>在手机应用中，常常会有顶部导航栏，底部菜单栏，中间全部时内容区域。切会根据不同的手机分辨率，自适用伸缩。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置 高度和视口高度一致 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="comment">/* 设置body为弹性盒模型 */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* 设置为列对齐， 主轴为竖直方向 */</span></span><br><span class="line">	<span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="comment">/* 设置上下元素贴边，中间居中 */</span></span><br><span class="line">	<span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置该弹性盒模型的元素占用剩余弹性盒的所有区域 */</span></span><br><span class="line">	<span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: blueviolet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: forestgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="10-元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）"><a href="#10-元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）" class="headerlink" title="10 元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）"></a>10 元素在单行的缩小关系（弹性盒空间不够，但是元素不换行）</h2><p><code>flex-shrink</code>：控制元素在弹性盒空间不足以容纳弹性元素且不换行时的弹性元素的伸缩比例。</p>
<p>当<code>flex-shirk</code>为0时，弹性元素不进行缩放，如果设置某个元素的缩放比例。</p>
<p>元素缩小比例的计算规则：(可以缩小的总宽度/((A元素<em>flex-shrink的值) + (B元素</em>flex-shrink的值) + …) * 对应flex-shrink的值) * 元素的本身的宽度。这个属性用的比较少。。。。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="comment">/* 控制某个弹性元素的缩放比例 */</span></span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="11-主轴的基准尺寸"><a href="#11-主轴的基准尺寸" class="headerlink" title="11 主轴的基准尺寸"></a>11 主轴的基准尺寸</h2><p><code>flex-basis</code> 的主轴的基准尺寸，来设置元素的宽度或者高度，当主轴为水平轴时，基准尺寸为元素的宽度，如果是竖直排列，基准尺寸为元素的高度。</p>
<p>基准尺寸会覆盖元素的宽度。但是当元素有<code>max-width</code>或者<code>min-width</code>时，他的优先级要比基准尺寸要高。所以优先级为：<code>max/min-width</code>&gt;<code>flex-basis</code>&gt;<code>width</code>。</p>
<h2 id="12-结合弹性元素的放大、缩放、主轴组合定义"><a href="#12-结合弹性元素的放大、缩放、主轴组合定义" class="headerlink" title="12 结合弹性元素的放大、缩放、主轴组合定义"></a>12 结合弹性元素的放大、缩放、主轴组合定义</h2><p><code>flex: 放大 缩放 主轴基准</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">artile</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="comment">/* 以上的三种属性可以直接在flex上直接定义，依次是 flex-grow flex-shrink flex-basis */</span></span><br><span class="line">    <span class="comment">/* 更推荐这种写法 */</span></span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-控制弹性盒模型的弹性元素顺序"><a href="#13-控制弹性盒模型的弹性元素顺序" class="headerlink" title="13 控制弹性盒模型的弹性元素顺序"></a>13 控制弹性盒模型的弹性元素顺序</h2><p><code>order</code>属性的值为整数，代表按照顺序排列元素， 按照该整数（最低的值）首先按照视觉顺序放置项目。如果多个项目具有相同的整数值，则在该组中按照源顺序对项目进行布局。</p>
<p>值越低顺序越在前，越高越往后。</p>
<h2 id="14-弹性盒模型中的文本"><a href="#14-弹性盒模型中的文本" class="headerlink" title="14 弹性盒模型中的文本"></a>14 弹性盒模型中的文本</h2><p>文本同样适用于弹性盒模型。</p>
<h2 id="15-定位元素在弹性布局中的效果"><a href="#15-定位元素在弹性布局中的效果" class="headerlink" title="15 定位元素在弹性布局中的效果"></a>15 定位元素在弹性布局中的效果</h2><ol>
<li>绝对定位<ol>
<li>和普通的绝对定位一致，直接浮动于其他的元素之上，其他的元素无法感知到他的位置。可以使用top left 等进行控制。</li>
</ol>
</li>
<li>相对定位<ol>
<li>相对定位，原来的空间位是保存的，其他的元素能够感知到他，不会占据他的空间，也可以top left 等进行控制。</li>
</ol>
</li>
</ol>
<h2 id="16-案例-一"><a href="#16-案例-一" class="headerlink" title="16 案例(一)"></a>16 案例(一)</h2><p>移动端的弹出菜单栏</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">			* &#123;</span><br><span class="line">				margin: 0;</span><br><span class="line">				padding: 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			body &#123;</span><br><span class="line">				height: 100vh;</span><br><span class="line">				display: flex;</span><br><span class="line">				flex-direction: column;</span><br><span class="line">                font-size: 30px;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			main &#123;</span><br><span class="line">				flex: 1;</span><br><span class="line"><span class="css">				<span class="selector-tag">background-color</span>: <span class="selector-id">#f3f3f3</span>;</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			footer &#123;</span><br><span class="line">				height: 100px;</span><br><span class="line">				display: flex;</span><br><span class="line"><span class="css">				<span class="selector-tag">border-top</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">				justify-content: space-between;</span><br><span class="line">				background-color: rgb(145, 145, 149);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			footer section &#123;</span><br><span class="line">				flex: 1;</span><br><span class="line">				background-color: rgb(174, 171, 171);</span><br><span class="line">				border-right: 1px solid seagreen;</span><br><span class="line"></span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column-reverse;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            footer section  h4 &#123;</span><br><span class="line">                flex: 0 0 100px;</span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column;</span><br><span class="line">                justify-content: center;</span><br><span class="line">                text-align: center;</span><br><span class="line">                font-size: 2rem;</span><br><span class="line">                cursor: pointer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            footer section  ul &#123;</span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">                text-align: center;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            footer section  ul  li &#123;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">                flex:  1 0 70px;</span><br><span class="line">                display: flex;</span><br><span class="line">                flex-direction: column;</span><br><span class="line">                justify-content: center;</span><br><span class="line">                cursor: pointer;</span><br><span class="line">            &#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>后端<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Django<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Flask<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>AI<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Pytorch<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>TensorFlow<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>大前端<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>React<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>效果：</p>
<p><img src="https://origin.chaizz.com/tc/image-20230228235044543.png" alt="image-20230228235044543"></p>
<h2 id="17-案例-二"><a href="#17-案例-二" class="headerlink" title="17 案例(二)"></a>17 案例(二)</h2><p>导航栏的左右靠边</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">			* &#123;</span><br><span class="line">				margin: 0;</span><br><span class="line">				padding: 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			nav &#123;</span><br><span class="line">				width: 1200px;</span><br><span class="line">				height: 60px;</span><br><span class="line"><span class="css">				<span class="selector-tag">background-color</span>: <span class="selector-id">#f3f3f3</span>;</span></span><br><span class="line">				margin: 0 auto;</span><br><span class="line">				display: flex;</span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line">			ul &#123;</span><br><span class="line">				list-style: none;</span><br><span class="line">				display: flex;</span><br><span class="line"><span class="css">				<span class="comment">/* 交叉轴居中 */</span></span></span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">			<span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">				/*</span><br><span class="line">            使用flex：1 代表让第一个ul占满弹性盒， </span><br><span class="line">            剩下的元素按照他自身的宽度占据弹性盒的宽度</span><br><span class="line"><span class="css">            <span class="selector-tag">margin-right</span>：<span class="selector-tag">auto</span>也可以达到 <span class="selector-tag">flex</span><span class="selector-pseudo">:1</span> 同样的效果</span></span><br><span class="line">            */</span><br><span class="line">				flex: 1;</span><br><span class="line"><span class="css">				<span class="comment">/* margin-right: auto; */</span></span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">			<span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">				margin: 0 20px;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">			<span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(2)</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">				width: 50px;</span><br><span class="line">				height: 50px;</span><br><span class="line">				margin-right: 20px;</span><br><span class="line">				background: chartreuse;</span><br><span class="line">				border-radius: 100% 100%;</span><br><span class="line">				justify-content: center;</span><br><span class="line">				display: flex;</span><br><span class="line">				justify-content: center;</span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Go<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>JavScript<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>JS<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>效果：</p>
<p><img src="https://origin.chaizz.com/tc/image-20230302214940526.png" alt="image-20230302214940526"></p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(三)</title>
    <url>/2023/02/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%B8%89)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-三"><a href="#JS笔记之JS函数进阶-三" class="headerlink" title="JS笔记之JS函数进阶(三)"></a>JS笔记之JS函数进阶(三)</h1><p>在JS中 函数也是一种值，函数的类型就是Object，函数本身也包含自己的属性。</p>
<h2 id="1-name-属性"><a href="#1-name-属性" class="headerlink" title="1 name 属性"></a>1 name 属性</h2><p>在创建一个函数时，我们可以根据函数名获取对应函数的name属性，直接创建一个具名函数或者使用命名表达式，来创建函数，函数名和命名表达式的变量名就是函数的name属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayHi.name); <span class="comment">// sayHi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sayHi.name); <span class="comment">// sayHi（有名字！）</span></span><br></pre></td></tr></table></figure>
<p>在对象中的函数同样也是具有该属性，当无法获取该属性时， name的值为空字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数是在数组中创建的</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log( arr[<span class="number">0</span>].name ); <span class="comment">// &lt;空字符串&gt;</span></span><br><span class="line"><span class="comment">// 引擎无法设置正确的名字，所以没有值</span></span><br></pre></td></tr></table></figure>


<h2 id="2-length-属性"><a href="#2-length-属性" class="headerlink" title="2 length 属性"></a>2 length 属性</h2><p>该属性返回的是函数入参的个数，但是不包含…rest的参数，属性 length 有时在操作其它函数的函数中用于做 内省/运行时检查（introspection）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">many</span>(<span class="params">a, b, ...more</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">alert(f1.length); <span class="comment">// 1</span></span><br><span class="line">alert(f2.length); <span class="comment">// 2</span></span><br><span class="line">alert(many.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>


<h2 id="3-自定义属性"><a href="#3-自定义属性" class="headerlink" title="3 自定义属性"></a>3 自定义属性</h2><p>在函数内部还可以直接自定义属性，直接使用函数名.属性名， 这里的属性名和函数内部的变量名，是两个概念，他们之间没有关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算调用次数</span></span><br><span class="line">    sayHi.counter++;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi.counter = <span class="number">0</span>; <span class="comment">// 初始值</span></span><br><span class="line">  </span><br><span class="line">  sayHi(); <span class="comment">// Hi</span></span><br><span class="line">  sayHi(); <span class="comment">// Hi</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">`Called <span class="subst">$&#123;sayHi.counter&#125;</span> times`</span> ); <span class="comment">// Called 2 times</span></span><br></pre></td></tr></table></figure>


<p>函数的属性有时候会代替闭包，因为函数属性，可以在函数作用域内，保存局部的变量信息。</p>
<h2 id="4-函数命名表达式"><a href="#4-函数命名表达式" class="headerlink" title="4 函数命名表达式"></a>4 函数命名表达式</h2><p>带有函数 (NFE，Named Function Expression) 指带有名字的表达式的术语。</p>
<p>一个普通的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funcName = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给这个函数加一个名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funcName = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时加名字和不加名字的区别就是：</p>
<ul>
<li>加名字可以在函数的内部调用，</li>
<li>在函数的外部是不可见的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">et sayHi = <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (who) &#123;</span><br><span class="line">    alert(<span class="string">`Hello, <span class="subst">$&#123;who&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func(<span class="string">&quot;Guest&quot;</span>); <span class="comment">// 使用 func 再次调用函数自身</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// Hello, Guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但这不工作：</span></span><br><span class="line">func(); <span class="comment">// Error, func is not defined（在函数外不可见）</span></span><br></pre></td></tr></table></figure>


<h2 id="5-使用-new-Function-来创建函数"><a href="#5-使用-new-Function-来创建函数" class="headerlink" title="5 使用 new Function 来创建函数"></a>5 使用 new Function 来创建函数</h2><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数是通过给定的 arg1 arg2 参数 和 functionBody 创建的</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span> ([arg1, arg2, ...argN], functionBody);</span><br></pre></td></tr></table></figure>
<p>实际的例字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含参数和函数体</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;return a + b&#x27;</span>);</span><br><span class="line">alert( sum(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 只有函数体</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;alert(&quot;Hello&quot;)&#x27;</span>);</span><br><span class="line">sayHi(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>使用的场景：比如我们需要动态的从服务器获取一段代码来运行。</p>
<h2 id="6-闭包"><a href="#6-闭包" class="headerlink" title="6 闭包"></a>6 闭包</h2><p>闭包是指使用一个特殊的属性，来记录函数自身得创建时的环境的函数，他具体执行了函数创建时的此法环境，但是我们使用 new Function 创建的函数，他并不指向当前的词法环境，而是全局环境。</p>
<p>new Function 这种特性在实际中非常使用，想象一下我们必须通过一个字符串来创建一个函数。在编写脚本时我们不会知道该函数的代码（这也就是为什么我们不用常规方法创建函数），但在执行过程中会知道了。我们可能会从服务器或其他来源获取它。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><ul>
<li><p>new Function 语法：<code>let func = new Function ([arg1, arg2, ...argN], functionBody);</code></p>
</li>
<li><p>使用 new Function 创建的函数，的词法环境执行全局的环境。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(五)</title>
    <url>/2023/02/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%BA%94)/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-五"><a href="#JS笔记之JS函数进阶-五" class="headerlink" title="JS笔记之JS函数进阶(五)"></a>JS笔记之JS函数进阶(五)</h1><h2 id="1-JS函数应用缓存之透明缓存"><a href="#1-JS函数应用缓存之透明缓存" class="headerlink" title="1 JS函数应用缓存之透明缓存"></a>1 JS函数应用缓存之透明缓存</h2><p>当我们有一个函数运行非常慢且每次结果都一致的时候，可以用到包装器函数，用来保存他的运行结果。我们可以使用一个Map 对象，来保存函数第一次运行的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可能会有重负载的 CPU 密集型工作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Called with <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.has(x)) &#123;    <span class="comment">// 如果缓存中有对应的结果</span></span><br><span class="line">            <span class="keyword">return</span> cache.get(x); <span class="comment">// 从缓存中读取结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result = func(x);  <span class="comment">// 否则就调用 func</span></span><br><span class="line"></span><br><span class="line">        cache.set(x, result);  <span class="comment">// 然后将结果缓存（记住）下来</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slow = cachingDecorator(slow);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(slow(<span class="number">1</span>)); <span class="comment">// slow(1) 被缓存下来了，并返回结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Again: &quot;</span> + slow(<span class="number">1</span>)); <span class="comment">// 返回缓存中的 slow(1) 的结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(slow(<span class="number">2</span>)); <span class="comment">// slow(2) 被缓存下来了，并返回结果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Again: &quot;</span> + slow(<span class="number">2</span>)); <span class="comment">// 返回缓存中的 slow(2) 的结果</span></span><br></pre></td></tr></table></figure>
<p>上述代码段中：<code>cachingDecorator</code>方法中定义了一个map对象，然后返回了一个方法。Map对象的作用就是判断耗时的函数是否已经被调用过。返回的函数接受一个参数值，该值就是耗时函数的值，在函数中首先判断Map中是否有当前参数的一个对象，如果有则直接返回Map对象的值，如果没有则继续执行耗时函数，并把结果添加到Map对象中。</p>
<p>我们可以将<code>cachingDecorator</code>称为装饰器，装饰器是一个特殊的函数，他接收一个函数，并返回一个函数。</p>
<p>装饰器有几个好处：</p>
<ul>
<li>装饰器<code>cachingDecorator</code>是可重用的，我们可以将它应用于另外一个函数。</li>
<li>缓存的逻辑是独立的，我们并没有修改耗时函数的复杂性。</li>
<li>装饰器可以进行多个组合。</li>
</ul>
<p>在使用上面的装饰器时，有时我们可能会遇到一个问题，当这个耗时方法在对象中是，且在函数中使用<code>this</code>调用了对像中的其他的属性，例如一个方法 <code>someMethod</code>，我们要对这个对象的方法属性应用装饰器，那么就会出现如下的问题：</p>
<p><code>TypeError: this.someMethod is not a function</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">    <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">slow</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 可怕的 CPU 过载任务</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Called with &quot;</span> + x);</span><br><span class="line">        <span class="keyword">return</span> x * <span class="built_in">this</span>.someMethod(); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和之前例子中的代码相同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.has(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> result = func(x); <span class="comment">// (**)</span></span><br><span class="line">        cache.set(x, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">1</span>)); <span class="comment">// 原始方法有效</span></span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow); <span class="comment">// 现在对其进行缓存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">2</span>)); <span class="comment">// TypeError: this.someMethod is not a function</span></span><br></pre></td></tr></table></figure>
<p>出现上面的问题，是因为此时好使函数中的<code>this</code>已经不再是原来的<code>worker</code>对象了，他指向了<code>global</code>，在全局对象中，自然没有<code>someMethod </code>这个方法。</p>
<p>当我们将<code>worker.slow</code>赋值给一个变量时，也会出现上面的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = worker.slow;</span><br><span class="line">func(<span class="number">2</span>); <span class="comment">// TypeError: this.someMethod is not a function</span></span><br></pre></td></tr></table></figure>


<h2 id="2-使用-“func-call”-设定上下文"><a href="#2-使用-“func-call”-设定上下文" class="headerlink" title="2 使用 “func.call” 设定上下文"></a>2 使用 “func.call” 设定上下文</h2><p>他允许调用一个显示设置this的函数，运行func，提供第一参数作为该函数的this对象，后端面的作为参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line">  <span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 call 将不同的对象传递为 &quot;this&quot;</span></span><br><span class="line">  sayHi.call( user ); <span class="comment">// John</span></span><br><span class="line">  sayHi.call( admin ); <span class="comment">// Admin</span></span><br></pre></td></tr></table></figure>
<p>在上述的包装器中使用<code>func.call()</code> 来解决<code>TypeError: this.someMethod is not a function</code> 的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">    <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">slow</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Called with &quot;</span> + x);</span><br><span class="line">        <span class="keyword">return</span> x * <span class="built_in">this</span>.someMethod(); <span class="comment">// (*)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.has(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> result = func.call(<span class="built_in">this</span>, x); <span class="comment">// 现在 &quot;this&quot; 被正确地传递了</span></span><br><span class="line">        cache.set(x, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow); <span class="comment">// 现在对其进行缓存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">2</span>)); <span class="comment">// 工作正常</span></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">2</span>)); <span class="comment">// 工作正常，没有调用原始函数（使用的缓存）</span></span><br></pre></td></tr></table></figure>
<p>上述<code>func.call()</code>的调佣详细过程：</p>
<ol>
<li><code>cachingDecorator</code> 装饰器函数接受的方法是 <code>worker.slow</code>。</li>
<li>此时， 装饰器中的 <code>function(x)</code> 就是<code>worker.slow</code>。</li>
<li>当执行<code>worker.slow(2)</code>，<code>this</code> 就是的方法前的对象，也就是<code>.</code>之前的对象<code>worker</code>。</li>
</ol>
<h2 id="3-传递多个参数"><a href="#3-传递多个参数" class="headerlink" title="3 传递多个参数"></a>3 传递多个参数</h2><p>上述中的装饰器只接受一个参数，我们使用一个参数作为Map对象的key，但是当有多个参数时如何存储缓存呢？</p>
<ol>
<li>自定义一个可以使用多个参数作为key的Map对象。</li>
<li>使用嵌套Map，即一个 cache.get(x) 是另一个Map的key cache.get(x).get(b)。</li>
<li>将两个值合并为一个，并将其hash。</li>
</ol>
<p>第三种实现方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = &#123;</span><br><span class="line">    <span class="function"><span class="title">slow</span>(<span class="params">min, max</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Called with <span class="subst">$&#123;min&#125;</span>,<span class="subst">$&#123;max&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> min + max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cachingDecorator</span>(<span class="params">func, hash</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> key = hash(<span class="built_in">arguments</span>); <span class="comment">// (*)</span></span><br><span class="line">        <span class="keyword">if</span> (cache.has(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result = func.call(<span class="built_in">this</span>, ...arguments); <span class="comment">// (**)</span></span><br><span class="line"></span><br><span class="line">        cache.set(key, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>] + <span class="string">&#x27;,&#x27;</span> + args[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.slow = cachingDecorator(worker.slow, hash);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(worker.slow(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// works</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Again &quot;</span> + worker.slow(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// same (cached)</span></span><br></pre></td></tr></table></figure>


<h2 id="4-func-apply"><a href="#4-func-apply" class="headerlink" title="4 func.apply"></a>4 func.apply</h2><p>使用<code>func.apply()</code> 同样可以实现<code>func.call()</code>的方法，使用的方法为：<code>func.apply(this, arguments)</code> 代替 <code>func.call(this, ...arguments</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(context, ...args);</span><br><span class="line">func.apply(context, args);</span><br></pre></td></tr></table></figure>
<p><code>apply </code>和 <code>call</code> 只有一个关于 <code>args</code> 的细微的差别：</p>
<ul>
<li>Spread 语法 <code>...</code> 允许将 <strong>可迭代对象</strong> <code>args</code> 作为列表传递给 <code>call</code>。</li>
<li><code>apply</code> 只接受 <strong>类数组</strong> <code>args</code>。</li>
</ul>
<p>对于一个即可迭代又是类数组的对象，例如一个真正的数组，我是用apply可能会更快，因为大多数JS引擎内部对其进行了优化。</p>
<h2 id="5-呼叫转移"><a href="#5-呼叫转移" class="headerlink" title="5 呼叫转移"></a>5 呼叫转移</h2><p>将所有的参数连同上下文一起传递给另一个函数被称为”呼叫转移（call fowarding）”</p>
<p>最简单的语法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="6-借用一种方法"><a href="#6-借用一种方法" class="headerlink" title="6 借用一种方法"></a>6 借用一种方法</h2><p>针对上文中的<code>hash</code>函数做一个改进，他只接受两个参数，如果是任意数量的参数如何处理呢？</p>
<p>一般数组对象转化为字符串时可以使用<code>arr.join()</code>方法，但是在这合理无法使用，因为参数<code>args</code>并不是一个真正的数组。但是我们可以一个技巧来借用数组的<code>join()</code>方法：<code>[].join().call(args)</code>，这种方法叫做方法借用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hash</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].join.call(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个技巧主要是从数组<code>[].join</code>借取<code>join</code>方法，并使用 <code>[].join.call</code> 在 <code>args</code> 的上下文中运行它。</p>
<h2 id="7-装饰器和函数属性"><a href="#7-装饰器和函数属性" class="headerlink" title="7 装饰器和函数属性"></a>7 装饰器和函数属性</h2><p>在使用装饰器的时候，注意一点如果原始函数有属性，则装饰后的函数不在提供这些属性。如果需要保留原始函数的属性等信息，需要使用特殊的<code>Proxy</code>对象来包装函数。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>装饰器是一个围绕改变函数行为的包装器，主要工作还是由函数来完成。</p>
<p><code>func.call(context, arg1, arg2)</code> 用给定的上下文和参数调用函数。</p>
<p><code>func.apply(context, arg1, arg2)</code> 调用 <code>func</code> 将 <code>context</code> 作为 <code>this</code> 和类数组的 <code>args</code> 传递给参数列表。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(四)</title>
    <url>/2023/02/20/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​         </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-四"><a href="#JS笔记之JS函数进阶-四" class="headerlink" title="JS笔记之JS函数进阶(四)"></a>JS笔记之JS函数进阶(四)</h1><h2 id="1-setTimeout-和-setInterval"><a href="#1-setTimeout-和-setInterval" class="headerlink" title="1 setTimeout 和 setInterval"></a>1 setTimeout 和 setInterval</h2><p>语法格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout 第一个参数：一个函数或者是字符串代码(这个不常用)，第二个参数：时间间隔，代表多少秒后直行，剩下的参数：代表函数的参数。</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;&#125;, timeout [, arg1, arg2]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和setTimeout 参数一致，只不过代表的含义为重复执行该函数，interval 是重复的间隔。</span></span><br><span class="line"><span class="keyword">let</span> timer2 = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;&#125;, interval [, arg1, arg2]);</span><br></pre></td></tr></table></figure>
<p>停止计时器使用clearTimeout(timer) 和 clearInterval(timer2)。</p>
<p>使用 clearInterval 函数的调用间隔实际会代码设置的调用间隔要短，因为是在函数开始时就开始计算时间，这个间隔时间包括函数执行的时间，如果函数执行的比较慢，name就会等待函数执行完成，如果函数的执行时间小于执行间隔，那么实际的执行间隔就是：函数的执行时间+剩余的时间= Interval。</p>
<p>使用clearTimeout 则不会出现这个问题，他是等待函数执行完毕，在进行下一次的函数调用。</p>
<blockquote>
<p>当一个函数传入 setInterval/setTimeout 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。</p>
</blockquote>
<h2 id="2-嵌套setTimeout"><a href="#2-嵌套setTimeout" class="headerlink" title="2 嵌套setTimeout"></a>2 嵌套setTimeout</h2><p>使用clearInterval 调用函数每次间隔都是一致的，如果想要更加的灵活的设置函数执行之间的间隔，可以将clearInterval 进行嵌套调用。一个常用的场景就是，我们调用接口获取失败后重试，可以设置不同的访问间隔，避免造成服务器压力过大。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delay = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;发送请求！&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果请求失败，下一次执行的间隔是当前的 2 倍</span></span><br><span class="line">        delay *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = <span class="built_in">setTimeout</span>(request, delay);</span><br><span class="line">&#125;, delay);</span><br></pre></td></tr></table></figure>


<h2 id="3-零延时的setTimeout"><a href="#3-零延时的setTimeout" class="headerlink" title="3 零延时的setTimeout"></a>3 零延时的setTimeout</h2><p>setTimeout(func, 0) 或者是 setTimeout(func)，这种特性，叫做零延时调度，但是他需要在哦脚本执行完毕后执行。例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> alert(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">alert(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上的代码显示输出 Hello， 在输出 World。 </p>
<blockquote>
<p>但是在浏览器环境中，零延时并不为零，嵌套定时器的运行频率是受限制的。根据 HTML5 标准 所讲：“经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒”。</p>
</blockquote>
<p><strong>任何 setTimeout 都只会在当前代码执行完毕之后才会执行。</strong></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><ul>
<li>setTimeout(func, delay, …args) 和 setInterval(func, delay, …args) 方法允许我们在 delay 毫秒之后运行 func 一次或以 delay 毫秒为时间间隔周期性运行 func。要取消函数的执行，我们应该调用 clearInterval/clearTimeout，并将 setInterval/setTimeout 返回的值作为入参传入。</li>
<li>嵌套的 setTimeout 比 setInterval 用起来更加灵活，允许我们更精确地设置两次执行之间的时间。<br>零延时调度 setTimeout(func, 0)（与 setTimeout(func) 相同）用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。</li>
<li>浏览器会将 setTimeout 或 setInterval 的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。</li>
<li>请注意，所有的调度方法都不能 保证 确切的延时<ul>
<li>例如，浏览器内的计时器可能由于许多原因而变慢：</li>
<li>CPU 过载。</li>
<li>浏览器页签处于后台模式。</li>
<li>笔记本电脑用的是省电模式。</li>
<li>所有这些因素，可能会将定时器的最小计时器分辨率（最小延迟）增加到 300ms 甚至 1000ms，具体以浏览器及其设置为准。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(一)</title>
    <url>/2023/02/15/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%B8%80)/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-一"><a href="#JS笔记之JS函数进阶-一" class="headerlink" title="JS笔记之JS函数进阶(一)"></a>JS笔记之JS函数进阶(一)</h1><h2 id="1-函数rest参数"><a href="#1-函数rest参数" class="headerlink" title="1 函数rest参数"></a>1 函数rest参数</h2><p>在JS中很多内建的参数都支持传入无限个数的参数。</p>
<p>当我们自己定义一个函数时， 也可以转入无限个数的参数，但是只能根据形参的个数来获取真正的参数，如何实现接收无限个参数或者接收数组形式的参数？</p>
<p>可以在函数定义时声明一个数组来收集参数，语法格式为：<code>...变量名</code>， 这会声明一个数组，并指定一个名称为变量名，其中存有剩余的参数。三个点的含义就是将剩余的参数存储到指定的数组中。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">...args</span>) </span>&#123; <span class="comment">// 数组名为 args</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> args) sum += arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>...args</code> 称为Rest 参数，他可以和其他的正常的函数同时使用，因为<code>...args</code> 会收集所有剩余的参数，因此，这种语法格式只能放在函数的末尾。</p>
<p>在Python函数支持位置参数和关键字参数，同样可以使用<code>*args</code> 来接收不限个数的位置参数或者是使用<code>**kwargs</code>来接收不限制个数的关键字参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_all</span>(<span class="params">*args: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">sum</span> += x</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(sum_all(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p>在JS中还有一个特殊的参数对象areguments，可以在函数中被访问，该对象以参数在参数列中的索引作为键，存储所有的参数。areguments是一个类数组，也是一个可迭代对象，他不支持数组方法，而且他始终包含所有的参数，无法向数组那样直接对参数截取。因此当接受很多参数时最好使用Rest参数。</p>
<blockquote>
<p>另外箭头函数是没有areguments的。如果在剪头函数中访问 areguments 得到的是箭头函数的外部的普通函数的areguments。</p>
<p>即箭头函数没有本身的this以及 areguments。</p>
</blockquote>
<h2 id="2-函数Spread语法"><a href="#2-函数Spread语法" class="headerlink" title="2 函数Spread语法"></a>2 函数Spread语法</h2><p>在上文中Rest参数是从多个参数中得到一个类数组对象，而Spread则与之相反，当我们有一个数组，如何将它作为多个参数的函数中去？</p>
<p>Spread的语法和Rest参数语法很像，也是使用<code>...</code>，但是用途确实相反，当在函数中调用<code>...arr</code>时，他会把可迭代对象展开到参数列表中去，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...arr) ); <span class="comment">// 5（spread 语法把数组转换为参数列表）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样可以传入多个可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>, <span class="number">3</span>, -<span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...arr1, ...arr2) ); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与常规的参数使用</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>, <span class="number">3</span>, -<span class="number">8</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(<span class="number">1</span>, ...arr1, <span class="number">2</span>, ...arr2, <span class="number">25</span>) ); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>Spread 可以迭代任意的可迭代对象，例如字符串，Spread内部使用迭代器来收集元素，和for…of 的方式相同，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( [...str1] ); <span class="comment">// H,e,l,l,o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 将可迭代对象转换为数组</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.from(str2) ); <span class="comment">// H,e,l,l,o</span></span><br></pre></td></tr></table></figure>
<p>上述的例字中Array.from 和[…str] 得到的结果一致，但是他们之间还有一个细微的差别：</p>
<ul>
<li>Array.from(str) 适用于类数组对象也适用于可迭代对象。</li>
<li>Spread 语法只适用于可迭代对象。</li>
</ul>
<p>使用Spread也可以进行浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrCopy = [...arr]; <span class="comment">// 将数组 spread 到参数列表中，然后将结果放到一个新数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(arr) === <span class="built_in">JSON</span>.stringify(arrCopy)); <span class="comment">// 结果是一致的</span></span><br><span class="line"><span class="built_in">console</span>.log(arr === arrCopy);  <span class="comment">// 引用是不一致的</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrCopy);</span><br></pre></td></tr></table></figure>
<p>使用同样的方式也可以复制一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objCopy = &#123; ...obj &#125;; <span class="comment">// 将对象 spread 到参数列表中</span></span><br><span class="line">                          <span class="comment">// 然后将结果返回到一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个对象中的内容相同吗？</span></span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(obj) === <span class="built_in">JSON</span>.stringify(objCopy)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个对象相等吗？</span></span><br><span class="line">alert(obj === objCopy); <span class="comment">// false (not same reference)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改我们初始的对象不会修改副本：</span></span><br><span class="line">obj.d = <span class="number">4</span>;</span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4&#125;</span></span><br><span class="line">alert(<span class="built_in">JSON</span>.stringify(objCopy)); <span class="comment">// &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种方式比使用 let arrCopy = Object.assign([], arr) 复制数组，或使用 let objCopy = Object.assign({}, obj) 复制对象来说更为简便。因此，只要情况允许，我们倾向于使用它</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>Rest 参数语法和Spread 语法的一个区别就是若<code>...</code>出现在函数参数列表的最后，那么他就是Rest参数，如果出现在函数调用或者类似的表达式中，那么就是Spread语法。</p>
<p>可以使用这两种语法轻松的转换参数列表和参数数组。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS函数进阶(一)</title>
    <url>/2023/02/15/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​             </p>
<a id="more"></a>

<h1 id="JS笔记之JS函数进阶-一"><a href="#JS笔记之JS函数进阶-一" class="headerlink" title="JS笔记之JS函数进阶(一)"></a>JS笔记之JS函数进阶(一)</h1><h2 id="1-let-和-var-的区别"><a href="#1-let-和-var-的区别" class="headerlink" title="1 let 和 var 的区别"></a>1 let 和 var 的区别</h2><p>let 属于现代JS的声明变量的方式，而var则是老旧的方式。所以现在尽可能使用let。</p>
<p>一般情况下可以使用 let 代替var，或者使用var 代替 let，但是在某些方面存在着巨大的差异。</p>
<h3 id="1-1-var没有块级作用域"><a href="#1-1-var没有块级作用域" class="headerlink" title="1.1 var没有块级作用域"></a>1.1 var没有块级作用域</h3><p>例如：在 if 或者 while 中使用 var 声明的变量，可以在其他的地方获取到。是因为早期的JS中，块没有词法环境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;var&quot; 而不是 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// true，变量在 if 结束后仍存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> test = <span class="literal">true</span>; <span class="comment">// 使用 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// ReferenceError: test is not defined</span></span><br></pre></td></tr></table></figure>


<h3 id="1-2-var-允许重新声明"><a href="#1-2-var-允许重新声明" class="headerlink" title="1.2 var 允许重新声明"></a>1.2 var 允许重新声明</h3><p>使用var可以多次声明同一个变量，最新声明的变量就会无效，因为上面已经声明过了。</p>
<p>使用let在同一个作用域下声明两次会提示已经被声明的错误，var 则不会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user;</span><br><span class="line"><span class="keyword">let</span> user; <span class="comment">// SyntaxError: &#x27;user&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;Pete&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;John&quot;</span>; <span class="comment">// 这个 &quot;var&quot; 无效（因为变量已经声明过了）</span></span><br><span class="line"><span class="comment">// ……不会触发错误</span></span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-var-声明的变量-可以再声明之前使用。"><a href="#1-3-var-声明的变量-可以再声明之前使用。" class="headerlink" title="1.3 var 声明的变量 可以再声明之前使用。"></a>1.3 var 声明的变量 可以再声明之前使用。</h3><p>这种情况叫做提升，相当于使用var声明的变量 会被提升到一个函数或者脚本的最上面。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(phrase);</span><br><span class="line">    <span class="keyword">var</span> phrase = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的函数就相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> phrase</span><br><span class="line">    <span class="built_in">console</span>.log(phrase);</span><br><span class="line">    phrase = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但是有一点值的注意，虽然声明会提升到函数的开始，但是赋值并不会被提升，所以输出的结果就是一个未被赋值的变量，即：undefined。</p>
<h3 id="1-4-IIFE"><a href="#1-4-IIFE" class="headerlink" title="1.4 IIFE"></a>1.4 IIFE</h3><p>在很久以前，JS中只有var这一种声明变量的方式，且没有快捷作用域，所以程序员就发明了一种模仿块级作用域的方法，这种方法叫做立即调用函数表达式（immediately-invoked function expressions，IIFE）例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;立即调用函数表达式&#x27;</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在我们已经没有理由需要这样的方法了。</p>
</blockquote>
<h3 id="1-5-全局对象"><a href="#1-5-全局对象" class="headerlink" title="1.5 全局对象"></a>1.5 全局对象</h3><p>全局对象提供可在任何地方调用的变量和函数。在浏览器中他的名字叫做 window 在nodejs中他的名字叫做global。不同的环境可能会有不同的名字， 所以JS 提出了一个标准名称叫做 globalThis。</p>
<p>使用var 定义的变量，会成为全局对象的属性，函数声明也是同样的，但是不建议直接使用<code>window.xx</code> 调用。</p>
<blockquote>
<p>一般不建议使用全局变量，全局变量应该尽可能的少的使用。</p>
</blockquote>
<h3 id="1-6-使用-polyfills"><a href="#1-6-使用-polyfills" class="headerlink" title="1.6 使用 polyfills"></a>1.6 使用 polyfills</h3><p>有时候我们可以使用全局对象来做兼容性的工作，例如查看全局对象中是否含有 Promise对象，如果没有的话我们可以创建 polyfills，来添加环境中不支持但在现代浏览器标准中存在的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.Promise) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;当前正使用旧的浏览器!&quot;</span>);</span><br><span class="line">    <span class="comment">// 定制实现现代语言功能</span></span><br><span class="line">    <span class="built_in">window</span>.Promise = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h2><p>var 和 let 的主要的两个区别：</p>
<ul>
<li>var 生明没有块级作用域，仅在当前函数内部可见，或者全局可见。</li>
<li>var 变量的声明在函数开头就会被处理。</li>
</ul>
<p>在现代JS中尽可能的使用 const 或者 let。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(七)</title>
    <url>/2023/02/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%83)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-七"><a href="#JS笔记之JS数据类型-七" class="headerlink" title="JS笔记之JS数据类型(七)"></a>JS笔记之JS数据类型(七)</h1><h2 id="1-日期和时间"><a href="#1-日期和时间" class="headerlink" title="1 日期和时间"></a>1 日期和时间</h2><h3 id="1-1-创建日期"><a href="#1-1-创建日期" class="headerlink" title="1.1 创建日期"></a>1.1 创建日期</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Date-接收参数类型"><a href="#1-2-Date-接收参数类型" class="headerlink" title="1.2 Date() 接收参数类型"></a>1.2 Date() 接收参数类型</h3><ul>
<li><p>int类型：代表距离 1970 年 1 月 1 日 UTC+0 之后经过的毫秒数，可以为负数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 表示 01.01.1970 UTC+0</span></span><br><span class="line"><span class="keyword">let</span> Jan01_1970 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">alert( Jan01_1970 );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在增加 24 小时，得到 02.01.1970 UTC+0</span></span><br><span class="line"><span class="keyword">let</span> Jan02_1970 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">alert( Jan02_1970 );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 31 Dec 1969</span></span><br><span class="line"><span class="keyword">let</span> Dec31_1969 = <span class="keyword">new</span> <span class="built_in">Date</span>(-<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">alert( Dec31_1969 );</span><br></pre></td></tr></table></figure></li>
<li><p>str类型：将会自动解析为 时间字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-01-26&quot;</span>);</span><br><span class="line">alert(date);</span><br><span class="line"><span class="comment">// 未指定具体时间，所以假定时间为格林尼治标准时间（GMT）的午夜零点</span></span><br><span class="line"><span class="comment">// 并根据运行代码时的用户的时区进行调整</span></span><br><span class="line"><span class="comment">// 因此，结果可能是</span></span><br><span class="line"><span class="comment">// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="comment">// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)</span></span><br></pre></td></tr></table></figure></li>
<li><p>year, month, date, hours, minutes, seconds, ms：使用当前时区的给定组件创建日期，只有前两个参数是必须的，</p>
<ul>
<li>year 应该是四位数，为了兼容也接受两位数，例如：98 应该等于1998，强烈建议使用四位数。</li>
<li>month 计数从 0（一月）开始，到 11（十二月）结束。</li>
<li>date 是当月的具体某一天，如果缺失，默认为1。</li>
<li>hours, minutes, seconds, ms 如果缺失默认为0.</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 1 Jan 2011, 00:00:00</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 同样，时分秒等均为默认值 0</span></span><br><span class="line"><span class="comment">// 时间度量精确到1毫秒</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">567</span>);</span><br><span class="line">alert( date ); <span class="comment">// 1.01.2011, 02:03:04.567</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1-3-获取日期组件"><a href="#1-3-获取日期组件" class="headerlink" title="1.3 获取日期组件"></a>1.3 获取日期组件</h3><ul>
<li>getFullYear：从Date对象中获取年（四位数）。</li>
<li>getMonth()：获取月份，从0 到11。</li>
<li>getDate() 获取具体的日期。1 到 31。</li>
<li>getHouers() 获取当天的小时。</li>
<li>getMinutes() 获取分钟。</li>
<li>getSeconds() 获取秒</li>
<li>getMilliseconds() 获取毫秒。</li>
<li>getDay() 获取一周中的第几天， 星期几，从0 到 6， 星期天是0。</li>
<li>getTime() 返回自1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。</li>
<li>getTimezoneOffset() 返回UTC时间与本地时间的误差，以分钟为单位。</li>
</ul>
<h3 id="1-4-设置日期组件"><a href="#1-4-设置日期组件" class="headerlink" title="1.4 设置日期组件"></a>1.4 设置日期组件</h3><ul>
<li>setFullYear(year, [month], [date])</li>
<li>setMonth(month, [date])</li>
<li>setDate(date)</li>
<li>setHours(hour, [min], [sec], [ms])</li>
<li>setMinutes(min, [sec], [ms])</li>
<li>setSeconds(sec, [ms])</li>
<li>setMilliseconds(ms)</li>
<li>setTime(milliseconds)（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）</li>
</ul>
<p>以上方法除了 setTime() 方法，都有UTC变体，例如：setUTCHours()。</p>
<p>其中有的方法接受多个参数，不过不填的话，默认按照当前的时间。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">today.setHours(<span class="number">0</span>);</span><br><span class="line">alert(today); <span class="comment">// 日期依然是今天，但是小时数被改为了 0  2023-02-09T16:53:33.757Z</span></span><br><span class="line"></span><br><span class="line">today.setHours(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">alert(today); <span class="comment">// 日期依然是今天，时间为 00:00:00。 2023-02-09T16:00:00.000Z</span></span><br></pre></td></tr></table></figure>


<h3 id="1-5-自动校准"><a href="#1-5-自动校准" class="headerlink" title="1.5 自动校准"></a>1.5 自动校准</h3><p>Date 的参数超过范围，它本身会自动校准。</p>
<p>假设我们要在日期 “28 Feb 2016” 上加 2 天。结果可能是 “2 Mar” 或 “1 Mar”，因为存在闰年。但是我们不需要考虑这些，只需要直接加 2 天，剩下的 Date 对象会帮我们处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">28</span>);</span><br><span class="line">date.setDate(date.getDate() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">alert( date ); <span class="comment">// 1 Mar 2016</span></span><br></pre></td></tr></table></figure>
<p>这个特性经常获取给定时间段后的时间。</p>
<h3 id="1-6-日期转化为数字，日期差值。"><a href="#1-6-日期转化为数字，日期差值。" class="headerlink" title="1.6 日期转化为数字，日期差值。"></a>1.6 日期转化为数字，日期差值。</h3><p>当Date被转化为数字时， 获取的是时间戳，与getTime()相同，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 使用一元运算符 将Date对象转化为数字 </span></span><br><span class="line">alert(+date);</span><br></pre></td></tr></table></figure>


<p>日期可以相减，结果是以毫秒为单位的时间差，可以用作测试代码的执行速度。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 开始测量时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do the job</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> doSomething = i * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 结束测量时间</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">`The loop took <span class="subst">$&#123;end - start&#125;</span> ms`</span> );</span><br></pre></td></tr></table></figure>


<h3 id="1-7-Date-new"><a href="#1-7-Date-new" class="headerlink" title="1.7 Date.new()"></a>1.7 Date.new()</h3><p>在上文中，创建了两个Date对象，用来计算时间间隔，在JS中还有一个方法Date.new()，他会返回当前时间戳，相等于 new Date().getTime() 但是不会创建中间的Date对象，因此更快，不会对垃圾回收造成额外的压力，所以在使用JS编写游戏或者其他有性能要求的场景会使用到。</p>
<p>因此上文中的 计算代码执行速度这种方式最好：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now(); <span class="comment">// 从 1 Jan 1970 至今的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do the job</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> doSomething = i * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> end = <span class="built_in">Date</span>.now(); <span class="comment">// 完成</span></span><br><span class="line"></span><br><span class="line">alert( <span class="string">`The loop took <span class="subst">$&#123;end - start&#125;</span> ms`</span> ); <span class="comment">// 相减的是时间戳，而不是日期</span></span><br></pre></td></tr></table></figure>


<h3 id="1-8-对字符串调用Date-parse"><a href="#1-8-对字符串调用Date-parse" class="headerlink" title="1.8 对字符串调用Date.parse"></a>1.8 对字符串调用Date.parse</h3><p>根据时间字符串获取对应的时间戳，字符串的格式为：YYYY-MM-DDTHH:mm:ss.sssZ，其中：T 是分隔符，Z 为 +- hh:mm 格式的时区，单个字符代表 UTC+0 时区，简短的形式也可以：YYYY，或者是 YYYY-MM-DD 或者YYYY-MM。</p>
<p>Date.parse 返回的结果是时间戳，从 1970-01-01 00:00:00 起所经过的毫秒数，如果给点的字符串不正确，则返回NaN。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(八)</title>
    <url>/2023/02/10/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AB)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-八"><a href="#JS笔记之JS数据类型-八" class="headerlink" title="JS笔记之JS数据类型(八)"></a>JS笔记之JS数据类型(八)</h1><h2 id="1-JSON-stringify-obj"><a href="#1-JSON-stringify-obj" class="headerlink" title="1 JSON.stringify(obj)"></a>1 JSON.stringify(obj)</h2><p>JSON编码的对象与JS对象的字面量有一些区别：</p>
<ul>
<li>字符串使用双引号，没有单引号或者反引号。</li>
<li>对象的属性名称也是双引号的，是强制性的。</li>
</ul>
<p>JSON支持以下的数据类型：</p>
<ul>
<li>Objects {…}</li>
<li>Arrays […]</li>
<li>Strings ‘ ‘</li>
<li>numbers 1</li>
<li>boolean  true false</li>
<li>null</li>
</ul>
<p>JSON是语言无关的数据规范，所以一些属于JS的对象属性将会被忽略掉，例如：</p>
<ul>
<li>函数</li>
<li>Symbol</li>
<li>undefined</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 被忽略</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>)]: <span class="number">123</span>, <span class="comment">// 被忽略</span></span><br><span class="line">    something: <span class="literal">undefined</span> <span class="comment">// 被忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(user) ); <span class="comment">// &#123;&#125;（空对象）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips：在使用JSON.stringify(obj) 时（仅包含单个参数），对象中不能有循环引用。</strong></p>
</blockquote>
<h2 id="2-排除和转换-replacer"><a href="#2-排除和转换-replacer" class="headerlink" title="2 排除和转换 replacer"></a>2 排除和转换 replacer</h2><p>JSON.stringify 的完整语法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="built_in">JSON</span>.stringify(value[, replacer, space])</span><br><span class="line"></span><br><span class="line"><span class="comment">// value：要编码的值</span></span><br><span class="line"><span class="comment">// reolacer：要编码的属性数组，或者映射函数。 function(key, value)</span></span><br><span class="line"><span class="comment">// sapce：要格式化的空格数量</span></span><br></pre></td></tr></table></figure>
<p>如果要过滤掉循环引用， 可以使用JSON.stringify的第二个参数：replacer，如果我们传递一个属性数组给他，name只有这些属性会被编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">    place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup, [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;participants&#x27;</span>]) );</span><br><span class="line"><span class="comment">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&#125;,&#123;&#125;]&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上文的例字中，因为只设置了 participants和title， 所以输出内容中的 participants的下一级为空。</p>
<p>可以使用一个函数来保证转换的数据不包括循环引用的所有属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">    place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.occupiedBy = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="string">&#x27;occupiedBy&#x27;</span>) ? <span class="literal">undefined</span> : value;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// : [object Object]</span></span><br><span class="line"><span class="comment">// title: Conference                                                                       </span></span><br><span class="line"><span class="comment">// participants: [object Object],[object Object]                                           </span></span><br><span class="line"><span class="comment">// 0: [object Object]                                                                     </span></span><br><span class="line"><span class="comment">// name: John                                                                             </span></span><br><span class="line"><span class="comment">// 1: [object Object]                                                                    </span></span><br><span class="line"><span class="comment">// name: Alice                                                                             </span></span><br><span class="line"><span class="comment">// place: [object Object]                                                                 </span></span><br><span class="line"><span class="comment">// number: 23                                                                             </span></span><br><span class="line"><span class="comment">// occupiedBy: [object Object]                                                             </span></span><br><span class="line"><span class="comment">// &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],&quot;place&quot;:&#123;&quot;number&quot;:23&#125;&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="3-格式化-space"><a href="#3-格式化-space" class="headerlink" title="3 格式化 space"></a>3 格式化 space</h2><p>JSON.stringif 的第三个参数是优化格式的空格数量。也可以是字符串，字符串用于缩进而不是空格的数量。spaces 参数仅用于日志记录和美化输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    participants: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">    place: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(meetup, <span class="literal">null</span>, <span class="string">&quot;====&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// ====&quot;title&quot;: &quot;Conference&quot;,</span></span><br><span class="line"><span class="comment">// ====&quot;participants&quot;: [</span></span><br><span class="line"><span class="comment">// ========&#123;</span></span><br><span class="line"><span class="comment">// ============&quot;name&quot;: &quot;John&quot;</span></span><br><span class="line"><span class="comment">// ========&#125;,</span></span><br><span class="line"><span class="comment">// ========&#123;</span></span><br><span class="line"><span class="comment">// ============&quot;name&quot;: &quot;Alice&quot;</span></span><br><span class="line"><span class="comment">//     ========&#125;</span></span><br><span class="line"><span class="comment">// ====],</span></span><br><span class="line"><span class="comment">// ====&quot;place&quot;: &#123;</span></span><br><span class="line"><span class="comment">// ========&quot;number&quot;: 23</span></span><br><span class="line"><span class="comment">// ====&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="4-自定义-toJson"><a href="#4-自定义-toJson" class="headerlink" title="4 自定义 toJson"></a>4 自定义 toJson</h2><p>toString 可以进行字符串转化， 对象也可以自定义toJson来进行JSON转换，如果可用，JSON.stringify 则会自动调用它。 在Python 输出类的字符串形式， 使用魔术方法<code>__str__</code>和<code>__repr__</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">    number: <span class="number">23</span>,</span><br><span class="line">    <span class="function"><span class="title">toJSON</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">    title: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">    room</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(room) ); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(meetup) );</span><br></pre></td></tr></table></figure>
<p>toJson 既可以用于直接调用JSON.stringify， 也可以在嵌套在另一个对象时，被调用。</p>
<h2 id="5-JSON-parse"><a href="#5-JSON-parse" class="headerlink" title="5 JSON.parse"></a>5 JSON.parse</h2><p>将JSON字符串要解码JS对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="built_in">JSON</span>.parse(str, [reviver]);</span><br><span class="line"><span class="comment">// str：要解析的字符串</span></span><br><span class="line"><span class="comment">// reviver：可选的函数参数，函数将每个（key, value）对调用，并可以对值进行转换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userData = <span class="string">&#x27;&#123; &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] &#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> user = <span class="built_in">JSON</span>.parse(userData);</span><br><span class="line"><span class="built_in">console</span>.log( user.friends[<span class="number">1</span>] ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>


<p>当要解析的字符串包括日期字符串时，JSON.parse 就无法解析，这是我们可以通过第二个参数，定义一个函数来判断key。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> schedule = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">  &quot;meetups&quot;: [</span></span><br><span class="line"><span class="string">    &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&quot;title&quot;:&quot;Birthday&quot;,&quot;date&quot;:&quot;2017-04-18T12:00:00.000Z&quot;&#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line">schedule = <span class="built_in">JSON</span>.parse(schedule, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">&#x27;date&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( schedule.meetups[<span class="number">1</span>].date.getDate() ); <span class="comment">// 正常运行了！</span></span><br></pre></td></tr></table></figure>
<p>函数在嵌套中同样适用。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><ul>
<li>JSON 支持 object，array，string，number，boolean 和 null。</li>
<li>如果独享具有toJson方法，那么会被 JSON.stringify 调用。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(六)</title>
    <url>/2023/02/06/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AD)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-六"><a href="#JS笔记之JS数据类型-六" class="headerlink" title="JS笔记之JS数据类型(六)"></a>JS笔记之JS数据类型(六)</h1><p>解构赋值是一种特殊的语法，他使可迭代对象拆包值一系列变量中，而只需要其中的一部分（与python的拆包类似）。</p>
<h2 id="1-在数组中的解构"><a href="#1-在数组中的解构" class="headerlink" title="1 在数组中的解构"></a>1 在数组中的解构</h2><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [var1, var2] = arr;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们有一个存放了名字和姓氏的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Smith&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="comment">// 设置 firstName = arr[0]</span></span><br><span class="line"><span class="comment">// 以及 surname = arr[1]</span></span><br><span class="line"><span class="keyword">let</span> [firstName, surname] = arr;</span><br><span class="line"></span><br><span class="line">alert(firstName); <span class="comment">// John</span></span><br><span class="line">alert(surname);  <span class="comment">// Smith</span></span><br></pre></td></tr></table></figure>
<p>当结构语法配合spilt更加优雅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, surname] = <span class="string">&quot;John Smith&quot;</span>.split(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>结构并不意味着破坏，原有的数据对象自身没有被修改。</strong></p>
<h3 id="1-2-忽略使用逗号的元素"><a href="#1-2-忽略使用逗号的元素" class="headerlink" title="1.2 忽略使用逗号的元素"></a>1.2 忽略使用逗号的元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要第二个元素， 剩下的元素也被跳过了。</span></span><br><span class="line"><span class="keyword">let</span> [firstName, , title] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br></pre></td></tr></table></figure>


<h3 id="1-3-解构的元素可以赋值给任何对象"><a href="#1-3-解构的元素可以赋值给任何对象" class="headerlink" title="1.3 解构的元素可以赋值给任何对象"></a>1.3 解构的元素可以赋值给任何对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line">[user.name, user.surname] = <span class="string">&quot;John Smith&quot;</span>.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br><span class="line">alert(user.surname); <span class="comment">// Smith</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：使用解构交换两个变量的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> guest = <span class="string">&quot;Jane&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> admin = <span class="string">&quot;Pete&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让我们来交换变量的值：使得 guest = Pete，admin = Jane</span></span><br><span class="line">[guest, admin] = [admin, guest];</span><br><span class="line"></span><br><span class="line">alert(<span class="string">`<span class="subst">$&#123;guest&#125;</span> <span class="subst">$&#123;admin&#125;</span>`</span>); <span class="comment">// Pete Jane（成功交换！）</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-4-使用-…-解构"><a href="#1-4-使用-…-解构" class="headerlink" title="1.4 使用 … 解构"></a>1.4 使用 … 解构</h3><p>在解构时遇到很多元素，当左边没有右边长时，部分元素作为一个整体进行结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [name1, name2, ...rest] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 是包含从第三项开始的其余数组项的数组</span></span><br><span class="line">alert(rest[<span class="number">0</span>]); <span class="comment">// Consul</span></span><br><span class="line">alert(rest[<span class="number">1</span>]); <span class="comment">// of the Roman Republic</span></span><br><span class="line">alert(rest.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在Python中 是使用<code>*</code>代替<code>...</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name1, name2, *rest = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line">// rest 是包含从第三项开始的其余数组项的数组</span><br><span class="line">print(rest[<span class="number">0</span>]); // Consul</span><br><span class="line">print(rest[<span class="number">1</span>]); // of the Roman Republic</span><br><span class="line">print(<span class="built_in">len</span>(rest)); // <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>当左边比右边长时， 多出的变量名默认为：undefined，也可以手动指定变量的默认值， 默认值可以是更复杂的表达式，或者是一个函数。这些表达式或者函数只有在变量未被赋值的时候在会执行计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstName, surname] = [];</span><br><span class="line">alert(firstName); <span class="comment">// undefined</span></span><br><span class="line">alert(surname); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定默认值</span></span><br><span class="line"><span class="keyword">let</span> [name = <span class="string">&quot;Guest&quot;</span>, surname = <span class="string">&quot;Anonymous&quot;</span>] = [<span class="string">&quot;Julius&quot;</span>];</span><br><span class="line">alert(name);    <span class="comment">// Julius（来自数组的值）</span></span><br><span class="line">alert(surname); <span class="comment">// Anonymous（默认值被使用了</span></span><br></pre></td></tr></table></figure>


<h2 id="2-在对象中的解构"><a href="#2-在对象中的解构" class="headerlink" title="2 在对象中的解构"></a>2 在对象中的解构</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;var1, var2&#125; = &#123;<span class="attr">var1</span>:…, <span class="attr">var2</span>:…&#125;</span><br><span class="line"><span class="comment">// 在等号右侧是一个已经存在的对象。</span></span><br><span class="line"><span class="comment">// 等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 &#123;...&#125; 中的变量名列表。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;title, width, height&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(width);  <span class="comment">// 100</span></span><br><span class="line">alert(height); <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的属性值 options.title options.width  options.theightitle  被赋值给 title width height</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-在等号左侧的-pattern-可以更加的复杂：指定属性和变量间的关系。"><a href="#2-2-在等号左侧的-pattern-可以更加的复杂：指定属性和变量间的关系。" class="headerlink" title="2.2 在等号左侧的 pattern 可以更加的复杂：指定属性和变量间的关系。"></a>2.2 在等号左侧的 pattern 可以更加的复杂：指定属性和变量间的关系。</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果我们想把一个属性赋值给另一个名字的变量，比如把 options.width 属性赋值给名为 w 的变量，那么我们可以使用冒号来设置变量名称：</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; sourceProperty: targetVariable &#125;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">widthk</span>: w = <span class="string">&#x27;222&#x27;</span>, <span class="attr">height</span>: h, title&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// width -&gt; w</span></span><br><span class="line"><span class="comment">// height -&gt; h</span></span><br><span class="line"><span class="comment">// title -&gt; title</span></span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(w);      <span class="comment">// 100</span></span><br><span class="line">alert(h);      <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<p>其中冒号的语法是：<code>对象中的某个属性名：具体的变量名</code>，如果<code>对象中的某个属性名</code> 不在要解构的对象中，赋值得到的结果是：undefined。 同样也可以设置默认值，默认值是任意表达式或者函数。</p>
<h3 id="2-3-对象结构对于多余的属性同样可以使用：…"><a href="#2-3-对象结构对于多余的属性同样可以使用：…" class="headerlink" title="2.3 对象结构对于多余的属性同样可以使用：…"></a>2.3 对象结构对于多余的属性同样可以使用：…</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  height: <span class="number">200</span>,</span><br><span class="line">  width: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// title = 名为 title 的属性</span></span><br><span class="line"><span class="comment">// rest = 存有剩余属性的对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;title, ...rest&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 title=&quot;Menu&quot;, rest=&#123;height: 200, width: 100&#125;</span></span><br><span class="line">alert(rest.height);  <span class="comment">// 200</span></span><br><span class="line">alert(rest.width);   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


<p>在解构中如果预先定义了变量， 可能会遇到一些错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一行发生了错误</span></span><br><span class="line">&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>主要的问题是 JS 把主代码流，中的 {…} 当做一个代码块，为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 <code>(...)</code> 包起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在就可以了</span></span><br><span class="line">(&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br><span class="line"></span><br><span class="line">alert( title ); <span class="comment">// Menu</span></span><br></pre></td></tr></table></figure>


<h2 id="3-嵌套解构"><a href="#3-嵌套解构" class="headerlink" title="3 嵌套解构"></a>3 嵌套解构</h2><p>如果一个独享或者数组中包括其他的对象或者数组，可以使用更负责的嵌套解构进行赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  size: &#123;</span><br><span class="line">    width: <span class="number">100</span>,</span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  items: [<span class="string">&quot;Cake&quot;</span>, <span class="string">&quot;Donut&quot;</span>],</span><br><span class="line">  extra: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了清晰起见，解构赋值语句被写成多行的形式</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  size: &#123; <span class="comment">// 把 size 赋值到这里</span></span><br><span class="line">    width,</span><br><span class="line">    height</span><br><span class="line">  &#125;,</span><br><span class="line">  items: [item1, item2], <span class="comment">// 把 items 赋值到这里</span></span><br><span class="line">  title = <span class="string">&quot;Menu&quot;</span> <span class="comment">// 在对象中不存在（使用默认值）</span></span><br><span class="line">&#125; = options;</span><br><span class="line"></span><br><span class="line">alert(title);  <span class="comment">// Menu</span></span><br><span class="line">alert(width);  <span class="comment">// 100</span></span><br><span class="line">alert(height); <span class="comment">// 200</span></span><br><span class="line">alert(item1);  <span class="comment">// Cake</span></span><br><span class="line">alert(item2);  <span class="comment">// Donu</span></span><br></pre></td></tr></table></figure>


<h2 id="4-智能参数函数"><a href="#4-智能参数函数" class="headerlink" title="4 智能参数函数"></a>4 智能参数函数</h2><p>有时候一个函数有很多的参数，大部分是可选的，我们可以使用一个对象来传递所有的参数，而函数负责把这个对象进行解构为对应的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  title: <span class="string">&quot;My menu&quot;</span>,</span><br><span class="line">  items: [<span class="string">&quot;Item1&quot;</span>, <span class="string">&quot;Item2&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMenu</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  title = <span class="string">&quot;Untitled&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  width: w = <span class="number">100</span>,  <span class="regexp">//</span> width goes to w</span></span></span><br><span class="line"><span class="function"><span class="params">  height: h = <span class="number">200</span>, <span class="regexp">//</span> height goes to h</span></span></span><br><span class="line"><span class="function"><span class="params">  items: [item1, item2] <span class="regexp">//</span> items first element goes to item1, second to item2</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;w&#125;</span> <span class="subst">$&#123;h&#125;</span>`</span> ); <span class="comment">// My Menu 100 200</span></span><br><span class="line">  alert( item1 ); <span class="comment">// Item1</span></span><br><span class="line">  alert( item2 ); <span class="comment">// Item2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMenu(options);</span><br></pre></td></tr></table></figure>
<p>上面输入的参数对象是确定了存在参数，如果想让所有的参数都是用默认值，那么在函数中直接传递一个空对象即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showMenu(&#123;&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMenu</span>(<span class="params">&#123; title = <span class="string">&quot;Menu&quot;</span>, width = <span class="number">100</span>, height = <span class="number">200</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;width&#125;</span> <span class="subst">$&#123;height&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMenu(); <span class="comment">// Menu 100 200</span></span><br></pre></td></tr></table></figure>


<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>解构可以将一个对象或者数组（只要是可迭代对象）拆开赋值到多个变量上。</p>
<p>解构对象的完成语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span> : varName = <span class="keyword">default</span>, ...rest&#125; = object</span><br><span class="line"><span class="comment">// prop：代表对象的key</span></span><br><span class="line"><span class="comment">// varName：要复制的变量名</span></span><br><span class="line"><span class="comment">// default：变量的默认值</span></span><br><span class="line"><span class="comment">// ...rest：其余的属性组成的对象</span></span><br></pre></td></tr></table></figure>
<p>解构数组的完整语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [item1 = <span class="keyword">default</span>, item2, ...rest] = array</span><br><span class="line"></span><br><span class="line"><span class="comment">// item1：数组的第一个元素</span></span><br><span class="line"><span class="comment">// default：默认值</span></span><br><span class="line"><span class="comment">// item2：数组的第二个元素</span></span><br><span class="line"><span class="comment">// ...rest：其余的元素组成的数组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(五)</title>
    <url>/2023/02/06/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%94)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-五"><a href="#JS笔记之JS数据类型-五" class="headerlink" title="JS笔记之JS数据类型(五)"></a>JS笔记之JS数据类型(五)</h1><h2 id="1-Map"><a href="#1-Map" class="headerlink" title="1 Map"></a>1 Map</h2><p>map 是一个带键的数据项的集合，他和object很像， 但是map允许任意类型的键，而对象的键只能是 字符串和symbol，不管用什么当做对象的key（除了symbol），都会被js转化为字符串。</p>
<h3 id="1-1-方法"><a href="#1-1-方法" class="headerlink" title="1.1 方法"></a>1.1 方法</h3><ul>
<li>new Map() ：创建一个map。</li>
<li>map.set(key, value)：根据键设置值。map在创建时保留了值插入的顺序。</li>
<li>map.get(key)：根据键来返回值，如果不存在key，则返回undefined。</li>
<li>map.has(key)：如果key存在返回true，不存在返回false。</li>
<li>map.delete(key)：删除指定的key。</li>
<li>map.clear()：清空map。</li>
<li>map.size：返回当前元素的个数。</li>
</ul>
<p>在使用map获取key的值或者设置值时 应该使用 map.get() 或者 map.set() 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;str1&#x27;</span>);   <span class="comment">// 字符串键</span></span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">&#x27;num1&#x27;</span>);     <span class="comment">// 数字键</span></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>); <span class="comment">// 布尔值键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 则会保留键的类型，所以下面这两个结果不同：</span></span><br><span class="line">alert( map.get(<span class="number">1</span>)   ); <span class="comment">// &#x27;num1&#x27;</span></span><br><span class="line">alert( map.get(<span class="string">&#x27;1&#x27;</span>) ); <span class="comment">// &#x27;str1&#x27;</span></span><br><span class="line"></span><br><span class="line">alert( map.size ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map 使用对象作为key</span></span><br><span class="line"><span class="keyword">let</span> username = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;john&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> visitsCountMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">visitsCountMap.set(<span class="string">&#x27;john&#x27;</span>, <span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>map比较键的方法：使用sameValueZero算法来比较键是否相等，他和严格等于 === 差不多，但区别是 NaN是等于NaN的，所以NaN也可以被用作键。</p>
<p>map 在设置key的时候返回的是他自身，所以可以被链式调用，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapObj = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">mapObj.set(<span class="string">&#x27;name&#x27;</span>, ‘张三).set(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>).set(<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Map-迭代"><a href="#1-2-Map-迭代" class="headerlink" title="1.2 Map 迭代"></a>1.2 Map 迭代</h3><p>在map里面循环可以使用下面的三个方法：</p>
<ul>
<li><p>map.keys() 遍历并返回一个包含所有键的可迭代对象。</p>
</li>
<li><p>map.values() 遍历并返回一个包含所有值的可迭代对象。</p>
</li>
<li><p>map.entries() 遍历并返回一个包含所有实体 [key, value] 的可迭代对象，for…of 在默认情况下才 就是使用的此方法。</p>
</li>
<li><p>map.forEach()  和数组一样，对每个键值对执行一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对每个键值对 (key, value) 运行 forEach 函数</span></span><br><span class="line">recipeMap.forEach( <span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// cucumber: 500 etc</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="1-3-将对象转化为Map-gt-Object-entries"><a href="#1-3-将对象转化为Map-gt-Object-entries" class="headerlink" title="1.3 将对象转化为Map -&gt; Object.entries"></a>1.3 将对象转化为Map -&gt; Object.entries</h3><p>当new 一个Map() 对象时，我们可以使用一个带键值对的数组（或者其他的可迭代对象）进行初始化，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键值对 [key, value] 数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>,  <span class="string">&#x27;str1&#x27;</span>],</span><br><span class="line">  [<span class="number">1</span>,    <span class="string">&#x27;num1&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">alert( map.get(<span class="string">&#x27;1&#x27;</span>) ); <span class="comment">// str1</span></span><br></pre></td></tr></table></figure>
<p>如果使用普通的对象来创建map，我们可以使用内建方法 Object.entries(obj)，该方法返回对象的键值对数组。</p>
<h3 id="1-4-将Map转化为建对象-Object-fromEntries-obj"><a href="#1-4-将Map转化为建对象-Object-fromEntries-obj" class="headerlink" title="1.4 将Map转化为建对象 Object.fromEntries(obj)"></a>1.4 将Map转化为建对象 Object.fromEntries(obj)</h3><p>它与 Object.entries(obj)是相反的，给定一个具有[key, value] 的数组，他会根据数组创建一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> prices = <span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 prices = &#123; banana: 1, orange: 2, meat: 4 &#125;</span></span><br><span class="line">alert(prices.orange); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>例如 将一个map的数组转化为一个普通对象传输给第三方的接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map)</span><br></pre></td></tr></table></figure>
<h2 id="2-set"><a href="#2-set" class="headerlink" title="2 set"></a>2 set</h2><p>set 是一个特殊的类型集合 – 值的集合，他没有键，而且他的值只能出现一次。</p>
<h3 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h3><ul>
<li>new Set(iterable)：  创建一个set，如果提供了一个可迭代对象（通常是数组），将会从数组里面复制到set中。有重复的值，自动删除。</li>
<li>set.add(value)：添加一个值返回set 本身，可以像map那样链式调用。</li>
<li>set.delete(value)： 删除值，存在返回true，不存在返回false。</li>
<li>set.has(value)：如果value在set中，返回true，不在返回false。</li>
<li>set.clear()：清空set。</li>
<li>set.size：返回当前元素的个数。</li>
</ul>
<h3 id="2-2-set-迭代"><a href="#2-2-set-迭代" class="headerlink" title="2.2 set 迭代"></a>2.2 set 迭代</h3><p>可以使用for…of 或者 forEach 来迭代set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;oranges&quot;</span>, <span class="string">&quot;apples&quot;</span>, <span class="string">&quot;bananas&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set) alert(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 forEach 相同：</span></span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, valueAgain, set</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在forEach的回调函数中有三个参数， 一个是value，另一个也是 value，最后是目标对象。</p>
<p><strong>在map中的迭代方法在set中同样适用。</strong></p>
<h2 id="3-WeakMap"><a href="#3-WeakMap" class="headerlink" title="3 WeakMap"></a>3 WeakMap</h2><p>在JS中 数组或者对象中的key 或者value，他们都是认为是可达的，如果一个对象被传入数组中，那么我们认为如果这个数组存在，那么这个对象也一定是可达的。在 map 中的 key或者是value 也是同样的道理。</p>
<p>JS垃圾回收中JS引擎在值可达和被可能引用的时候，会将值保存在内存中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象能被访问，john 是它的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖引用</span></span><br><span class="line">john = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象将会被从内存中清除</span></span><br></pre></td></tr></table></figure>
<p>当某个对象作为map的键的时候， 我们也认为改对象是可达的，他会占用内存，且不会被垃圾回收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(john, <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>; <span class="comment">// 覆盖引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// john 被存储在了 map 中，</span></span><br><span class="line"><span class="comment">// 我们可以使用 map.keys() 来获取它，所以他不会被垃圾回收</span></span><br></pre></td></tr></table></figure>
<p>WeakMap 和 Map 的区别</p>
<ul>
<li>在键上的区别<ul>
<li>WeakMap  的键必须是对象，不能是原始值。</li>
</ul>
</li>
<li>方法上的区别<ul>
<li>只支持 has()  get () set() delete() 方法， 不支持 keys() values() entries()</li>
<li>不能迭代。</li>
</ul>
</li>
</ul>
<p>WeakMap  的使用场景主要的使用场景：</p>
<p><strong>额外数据的存储</strong>。</p>
<blockquote>
<p>假如要处理另一些代码的数据，或者是第三方库的数据并且要存储一些相关的数据，那么这时候这些数据就应该和这个对象共存亡。将这些数据存储到WeakMap 中，并使用该对象作为这些数据的键，当改对象对垃圾回收后，这些数据也会被回收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">// 如果 john</span></span><br><span class="line">weakMap.set(john, <span class="string">&#x27;some data&#x27;</span>);</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>做数据缓存</strong></p>
<blockquote>
<p> 可以缓存函数返回的结果，一遍多次电泳不需要重新计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并记结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="comment">/* calculate the result for */</span> obj;</span><br><span class="line">    cache.set(obj, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache.get(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 📁 main.js</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="comment">/* some object */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = process(obj);</span><br><span class="line"><span class="keyword">let</span> result2 = process(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……稍后，我们不再需要这个对象时：</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法获取 cache.size，因为它是一个 WeakMap，</span></span><br><span class="line"><span class="comment">// 要么是 0，或即将变为 0</span></span><br><span class="line"><span class="comment">// 当 obj 被垃圾回收，缓存的数据也会被清除</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="4-WeakSet"><a href="#4-WeakSet" class="headerlink" title="4 WeakSet"></a>4 WeakSet</h2><p>WeakSet 和 Set 的区别</p>
<ul>
<li>WeakSet 的元素只能是对象。</li>
<li>对象只有在其他某个地方能被访问的时候，再能六在 WeakSet中。</li>
<li>只支持add() has() delete() 不支持size和 keys() ，并且不可迭代。</li>
</ul>
<p>weakSet也可以作为额外的空间，但是只能是针对<strong>是/否</strong>的事实。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> visitedSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">visitedSet.add(john); <span class="comment">// John 访问了我们</span></span><br><span class="line">visitedSet.add(pete); <span class="comment">// 然后是 Pete</span></span><br><span class="line">visitedSet.add(john); <span class="comment">// John 再次访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 现在有两个用户了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 John 是否来访过？</span></span><br><span class="line">alert(visitedSet.has(john)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Mary 是否来访过？</span></span><br><span class="line">alert(visitedSet.has(mary)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 将被自动清理(即自动清除其中已失效的值 john)</span></span><br></pre></td></tr></table></figure>


<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><ul>
<li><p>map 是一个带有键的数据的集合。与普通的对象不同的是，他的键可以是任意数据类型。有不同结构的方法，例如：map.size</p>
</li>
<li><p>set 是一组唯一值的集合。</p>
</li>
<li><p>在map和set 迭代总是按照插入的顺序，所以不能说他们的元素是无序的，但也不能对元素重新排序，也不能按照编号来取数据。</p>
</li>
<li><p>WeakMap 类似于Map ，但是只能设置键为对象，并且这些对象一旦在其他地方无法访问，则这个对象就会被垃圾回收，且WeakMap 对应的值也会被删除回收。</p>
</li>
<li><p>WeakSet 类似于Set，但是只能存储对象，并且这些对象一旦在其他地方无法访问，那么也会在WeakSet中删除回收。</p>
</li>
<li><p>WeakMap WeakSet 被用作主要对象存储之外的辅助数据结构。例如缓存的使用场景。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(四)</title>
    <url>/2023/02/06/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>



<h1 id="JS笔记之JS数据类型-四"><a href="#JS笔记之JS数据类型-四" class="headerlink" title="JS笔记之JS数据类型(四)"></a>JS笔记之JS数据类型(四)</h1><h2 id="1-可迭代对象定义"><a href="#1-可迭代对象定义" class="headerlink" title="1 可迭代对象定义"></a>1 可迭代对象定义</h2><p>可迭代对象是数组的泛化，任何对象都可以被定制为在 for…of循环使用的对象。</p>
<p>在JS中可迭代的内建对象有很多，例如数组，字符串等。</p>
<h3 id="1-1-创建可迭代对象"><a href="#1-1-创建可迭代对象" class="headerlink" title="1.1 创建可迭代对象"></a>1.1 创建可迭代对象</h3><p>例如我们要让下面的对象，能够使用for…of循环得到下面的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">    to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望得到的结果</span></span><br><span class="line"><span class="comment">// for (let num of range) ... num = 1，2, 3,4，5</span></span><br></pre></td></tr></table></figure>


<p>使用内建方法：Symbol.iterator （一个专门使对象可迭代的内建Symbol） </p>
<ol>
<li>给range对象添加一个属性， 即这个方法Symbol.iterator ，这个方法返回一个迭代器：一个有next方法的对象。</li>
<li>for…of 适用于这个被返回的对象。</li>
<li>当for…of循环，希望取得下一个值的时候，就会调用这个和next方法。</li>
<li>next方法返回的结构必须是{done:Boolean, value:any} 当done为true时，循环结束， 否则value是下一个值。</li>
</ol>
<h3 id="1-2-具体的实现方法："><a href="#1-2-具体的实现方法：" class="headerlink" title="1.2 具体的实现方法："></a>1.2 具体的实现方法：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. for..of 调用首先会调用这个：</span></span><br><span class="line">range[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……它返回迭代器对象（iterator object）：</span></span><br><span class="line">  <span class="comment">// 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    current: <span class="built_in">this</span>.from,</span><br><span class="line">    last: <span class="built_in">this</span>.to,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. next() 在 for..of 的每一轮循环迭代中被调用</span></span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 4. 它将会返回 &#123;done:.., value :...&#125; 格式的对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.last) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在它可以运行了！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>range 本身没有next方法。而是通过symbol.iterator 创建了另一个对象，即迭代器对象，并且他的next会为迭代生成值。</p>
</blockquote>
<p><strong>迭代器和要进行迭代的对象是分开的，技术上也可以进行合并。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="number">1</span>,</span><br><span class="line">  to: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">this</span>.from;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= <span class="built_in">this</span>.to) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.current++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  alert(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 range的Symbol.iterator 属性，返回的是自身，即range有一个next方法属性。</p>
<h3 id="1-3-字符串也是可迭代的"><a href="#1-3-字符串也是可迭代的" class="headerlink" title="1.3 字符串也是可迭代的"></a>1.3 字符串也是可迭代的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&quot;test&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// 触发 4 次，每个字符一次</span></span><br><span class="line">  alert( char ); <span class="comment">// t, then e, then s, then t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-显示的调用迭代器"><a href="#1-4-显示的调用迭代器" class="headerlink" title="1.4 显示的调用迭代器"></a>1.4 显示的调用迭代器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 for..of 做相同的事</span></span><br><span class="line"><span class="comment">// for (let char of str) alert(char);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = str[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = iterator.next();</span><br><span class="line">  <span class="keyword">if</span> (result.done) <span class="keyword">break</span>;</span><br><span class="line">  alert(result.value); <span class="comment">// 一个接一个地输出字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中很少这样做，但是这样做自由度更高，我们可以在任意迭代的过程中，暂停，并做一些其他的处理。</p>
<h3 id="1-5-可迭代和类数组-（array-like）"><a href="#1-5-可迭代和类数组-（array-like）" class="headerlink" title="1.5 可迭代和类数组 （array-like）"></a>1.5 可迭代和类数组 （array-like）</h3><p>可迭代：实现了上述 symbol.iterator 方法的对象。</p>
<p>array-like：是有索引和length属性的对象，所以他们看起来像数组。</p>
<p>可迭代对象通常都不是数组，他们没有push和pop方法，如果要将一个可迭代对象转化为数组，要怎么实现？</p>
<h3 id="1-6-array-from"><a href="#1-6-array-from" class="headerlink" title="1.6 array.from"></a>1.6 array.from</h3><p>array.from 接收一个可迭代和类数组的值，并从中获取一个真正的数组，然后对齐调用数组的方法。</p>
<p>array.from 也接收一个可选的函数作为参数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 thisArg 允许我们为该函数设置 this。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 range 来自上文例子中</span></span><br><span class="line"><span class="comment">// 求每个数的平方</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line">alert(arr); <span class="comment">// 1,4,9,16,25</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 str 拆分为字符数组</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> chars = <span class="built_in">Array</span>.from(str);</span><br><span class="line">alert(chars[<span class="number">0</span>]); <span class="comment">// 𝒳</span></span><br><span class="line">alert(chars[<span class="number">1</span>]); <span class="comment">// 😂</span></span><br><span class="line">alert(chars.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>array.from 相对于str.split() 要精简许多。</p>
<h2 id="2-总结："><a href="#2-总结：" class="headerlink" title="2 总结："></a>2 总结：</h2><p>可迭代对象必须实现symbol.iterator方法。他的结果是一个对象，被称为迭代器，由这个对象的next属性进一步处理迭代过程。</p>
<p>symbol.iterator 由for…of自动调用，但是我们也可以手动调用。</p>
<p>有索引和length属性的兑现我们称之为类数组对象，这种对象可能有其他的方法，但是没有数组的内建方法。</p>
<p>array.from(obj[,mapFn, thisAsg]) 将可迭代对象或者类数组对象转化为真正的数组, 然后我们就可以使用对应的数组方法。可选参数 mapFn 和 thisArg 允许我们将函数应用到每个元素。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(三)</title>
    <url>/2023/01/31/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%89)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-三"><a href="#JS笔记之JS数据类型-三" class="headerlink" title="JS笔记之JS数据类型(三)"></a>JS笔记之JS数据类型(三)</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h2><p>在JS中数组被定义为：[], 可以存放任意数据类型的元素。</p>
<h3 id="1-1-at"><a href="#1-1-at" class="headerlink" title="1.1 at"></a>1.1 at</h3><p>获取数组最后一个元素，在Python语言中可以使用 list1[-1]，但是JS不可以这样使用，他提供了一个专门的方法：at， 这个方法在旧的浏览器上存在兼容问题。</p>
<p>如果 <code>i &gt;= 0</code> 那么 <code>arr[i]</code> 和 <code>arr.at(i) </code>结果一致。 如果i为负数，<code>arr.at(i)</code> 则从后往前数。</p>
<h3 id="1-2-pop-push-shift-unshift-方法"><a href="#1-2-pop-push-shift-unshift-方法" class="headerlink" title="1.2 pop/push, shift/unshift 方法"></a>1.2 pop/push, shift/unshift 方法</h3><h4 id="1-2-1-作用于数组末端的方法："><a href="#1-2-1-作用于数组末端的方法：" class="headerlink" title="1.2.1 作用于数组末端的方法："></a>1.2.1 作用于数组末端的方法：</h4><p>pop：取出并返回数组的最后一个元素， 和上面的 array.at(-1) 结果一致， 但是，pop()会把最后一个元素删除，原数组被修改。空数组返回undefined。</p>
<p>push：在数组的末端添加元素，与 array[array.length] = “” 结果一致</p>
<h4 id="1-2-2-作用于数组首端的方法："><a href="#1-2-2-作用于数组首端的方法：" class="headerlink" title="1.2.2 作用于数组首端的方法："></a>1.2.2 作用于数组首端的方法：</h4><p>shift：取出数组的第一个元素并返回它。</p>
<p>unshift：在数组的首端添加元素。</p>
<p>unshift 和 push 都可以添加多个元素： <code>unshift(&#39;a&#39;,&#39;b&#39;)</code>、<code>push(&#39;a&#39;,&#39;b&#39;)</code>。</p>
<p>数组的访问方式：array[0], 实际上是来自于对象的语法，它扩展了对象，并提供了特殊的方法，来处理有序结合以及length属性，但是本质上讲数组仍然是一个对象。</p>
<p>例如数组的复制，是通过引用来实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Banana&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = fruits; <span class="comment">// 通过引用复制 (两个变量引用的是相同的数组)</span></span><br><span class="line"></span><br><span class="line">alert( arr === fruits ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="string">&quot;Pear&quot;</span>); <span class="comment">// 通过引用修改数组</span></span><br><span class="line"></span><br><span class="line">alert( fruits ); <span class="comment">// Banana, Pear — 现在有 2 项了</span></span><br></pre></td></tr></table></figure>


<p>但是数组的内部实现是将数组的元素一个一个的存储在连续的内存区域，且针对其优化，使其效率更高。</p>
<p>但是我们在使用数组想使用对象那样的话，数组的优化就不存在了。如下==错误==的使用方法：</p>
<ul>
<li>添加一个非数字的属性：array.test = 3。</li>
<li>制造空洞，比如添加array[0], 然后在添加array[9999]。</li>
<li>以倒叙填充数组 比如：arr[1000], arr[999]。</li>
</ul>
<p>所以在使用数组的时候，将数组作用于有序数组的特殊结构，JS引擎内部经过特殊优化过，如果需要任意值，可能普通对象更合适。</p>
<h3 id="1-3-性能"><a href="#1-3-性能" class="headerlink" title="1.3 性能"></a>1.3 性能</h3><p>pop和push 方法运行的比较快，而shift unshift 运行的比较慢。首先查看四个方法在执行期间都执行了什么？</p>
<p>shift</p>
<ol>
<li><p>第一步从首端取出第一个元素，所以移除了array[0]的元素，</p>
</li>
<li><p>还需要将后面的所有的元素的索引进行重新编号。1 改成0 2 改成 1。</p>
</li>
<li><p>更新数组的属性：length</p>
</li>
</ol>
<p>unshift 也和shift 一样 在array[0] 新增一个元素，修改所有元素的索引值，修改length属性。元素越多，性能越慢。</p>
<p>pop:</p>
<ol>
<li>删除最后一个元素。</li>
</ol>
<p>pop 和 push 一样，不需要移动元素，</p>
<h3 id="1-4-循环"><a href="#1-4-循环" class="headerlink" title="1.4 循环"></a>1.4 循环</h3><p>普通的计数循环可以使用 <code>for (let i=0; i&lt;array.length; i++) &#123;...&#125;</code>，在数组中可以使用<code>for (let x of array) &#123;...&#125;</code>。使用 for…of 不能获取元素得索引 只能获取元素。</p>
<p>还有一种方法：<code>for(let key in array)&#123;...&#125;</code> 虽有效果也是一样的，但是会存在问题：</p>
<ol>
<li>循环会遍历所有属性，不仅仅是数字属性。在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</li>
<li><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。</li>
</ol>
<p><strong>索引遍历数组不推荐使用for…in。</strong></p>
<h3 id="1-5-数组的length"><a href="#1-5-数组的length" class="headerlink" title="1.5 数组的length"></a>1.5 数组的length</h3><p>准确地说数组的length，并不是数组元素得个数，二是数组最大索引加一。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [];</span><br><span class="line">fruits[<span class="number">123</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( fruits.length ); <span class="comment">// 124 输出的结果就输索引值 + 1</span></span><br></pre></td></tr></table></figure>
<p>length的又一特性为 length <strong>是可写的</strong>，但是修改了length以后的数组是不可逆的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">2</span>; <span class="comment">// 截断到只剩 2 个元素</span></span><br><span class="line">alert( arr ); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">5</span>; <span class="comment">// 又把 length 加回来</span></span><br><span class="line">alert( arr[<span class="number">3</span>] ); <span class="comment">// undefined：被截断的那些数值并没有回来</span></span><br></pre></td></tr></table></figure>


<h3 id="1-6-多维数组"><a href="#1-6-多维数组" class="headerlink" title="1.6 多维数组"></a>1.6 多维数组</h3><p>数组里面的项也可以是数组，我们称之为多维数组，可以用来存储矩阵。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> matrix = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>


<h3 id="1-7-toString"><a href="#1-7-toString" class="headerlink" title="1.7 toString"></a>1.7 toString</h3><p>数组的toString会返回以逗号隔开的元素列表。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( [] + <span class="number">1</span> ); <span class="comment">// &quot;1&quot;</span></span><br><span class="line">alert( [<span class="number">1</span>] + <span class="number">1</span> ); <span class="comment">// &quot;11&quot;</span></span><br><span class="line">alert( [<span class="number">1</span>,<span class="number">2</span>] + <span class="number">1</span> ); <span class="comment">// &quot;1,21&quot;</span></span><br><span class="line"><span class="comment">// 这里 [] 就变成了一个空字符串，[1] 变成了 &quot;1&quot;，[1,2] 变成了 &quot;1,2&quot;。</span></span><br></pre></td></tr></table></figure>


<h3 id="1-8-不要使用-比较数组"><a href="#1-8-不要使用-比较数组" class="headerlink" title="1.8 不要使用 == 比较数组"></a>1.8 不要使用 == 比较数组</h3><p>如果我们使用 <code>==</code> 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。</p>
<h2 id="2-数组方法"><a href="#2-数组方法" class="headerlink" title="2 数组方法"></a>2 数组方法</h2><p>前面介绍了 shift/unshift/pop/push等在数组开头结尾添加删除数组方法，还有一些其他的方法</p>
<h3 id="2-1-splice-拼接"><a href="#2-1-splice-拼接" class="headerlink" title="2.1 splice [拼接]"></a>2.1 splice [拼接]</h3><p>splice 可以添加、删除、插入元素</p>
<p>使用 <code>del array[1]</code>的问题是：虽然数组的元素被删除掉了，但是根据array.length 获取数组的长度， 还是原来的长度，使用splice不出出现这个问题。</p>
<p>splice的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// start：从数组的索引 start 开始，删除 deleteCount 个元素，并在当前位置插入 elem1, ..., elemN 最后返回被删除的元素组成的数组。</span></span><br><span class="line">array.splice(start [, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从索引 1 开始删除 1 个元素</span></span><br><span class="line">alert( arr ); <span class="comment">// [&quot;I&quot;, &quot;JavaScript&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;now&quot;</span>];</span><br><span class="line"><span class="comment">// 删除数组的前三项，并使用其他内容代替它们</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Let&#x27;s&quot;</span>, <span class="string">&quot;dance&quot;</span>);</span><br><span class="line">alert( arr ) <span class="comment">// 现在 [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"><span class="comment">// 从索引 2 开始</span></span><br><span class="line"><span class="comment">// 删除 0 个元素</span></span><br><span class="line"><span class="comment">// 然后插入 &quot;complex&quot; 和 &quot;language&quot;</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;complex&quot;</span>, <span class="string">&quot;language&quot;</span>);</span><br><span class="line">alert( arr ); <span class="comment">// &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许负向索引</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 从索引 -1（尾端前一位）</span></span><br><span class="line"><span class="comment">// 删除 0 个元素，</span></span><br><span class="line"><span class="comment">// 然后插入 3 和 4</span></span><br><span class="line">arr.splice(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">alert( arr ); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-slice-切片"><a href="#2-2-slice-切片" class="headerlink" title="2.2 slice [切片]"></a>2.2 slice [切片]</h3><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它返回一个新数组，从索引 start 开始到 end [取头不取尾]  start 和 end 都可以是负数， 和字符串的slice方法一致。</span></span><br><span class="line">arr.slice([start], [end])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>];</span><br><span class="line">alert( arr.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// e,s（复制从位置 1 到位置 3 的元素）</span></span><br><span class="line">alert( arr.slice(-<span class="number">2</span>) ); <span class="comment">// s,t（复制从位置 -2 到尾端的元素）</span></span><br><span class="line"></span><br><span class="line">arr.slice()  <span class="comment">// 创建一个arr副本，以进行不影响原始数组的进一步转换。</span></span><br></pre></td></tr></table></figure>


<h3 id="2-3-concat"><a href="#2-3-concat" class="headerlink" title="2.3 concat"></a>2.3 concat</h3><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收任意数量的参数， 数组或者是值都可以，结果是包含arr和添加的值的数组，如果argN 是数组，那么会复制argN。</span></span><br><span class="line">arr.concat(arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 arr 和 [3,4] 创建一个新数组</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>]) ); <span class="comment">// 1,2,3,4</span></span><br><span class="line"><span class="comment">// 从 arr、[3,4] 和 [5,6] 创建一个新数组</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]) ); <span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line"><span class="comment">// 从 arr、[3,4]、5 和 6 创建一个新数组</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>) ); <span class="comment">// 1,2,3,4,5,6</span></span><br></pre></td></tr></table></figure>


<p>如果某个对象，具有Symbol.isConcatSpreadable属性， 那么concat会把这个对象当做数组一样来处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;else&quot;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat(arrayLike) ); <span class="comment">// 1,2,something,else</span></span><br></pre></td></tr></table></figure>


<h3 id="2-4-forEach-遍历"><a href="#2-4-forEach-遍历" class="headerlink" title="2.4 forEach 遍历"></a>2.4 forEach 遍历</h3><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许数组的每个元素，都运行一个函数, 有结果的话会被忽略。</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do something with item</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对每个元素调用 alert</span></span><br><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].forEach(alert);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 介绍了它们在目标数组中的位置：</span></span><br><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;item&#125;</span> is at index <span class="subst">$&#123;index&#125;</span> in <span class="subst">$&#123;array&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h3 id="2-5-indexOf-lastIndexOf-includes"><a href="#2-5-indexOf-lastIndexOf-includes" class="headerlink" title="2.5 indexOf/lastIndexOf/includes"></a>2.5 indexOf/lastIndexOf/includes</h3><p>在数组中进行搜索</p>
<p>arr.indexOf(item, from)：从索引from开始搜索item, 找到返回索引，找不到返回-1。</p>
<p>arr.includes(item, from)：从索引from开始搜索item, 找到返回true，找不到返回false。</p>
<p>arr.lastIndexOf(item, from)与 indexOf 一样， 但是是从右到左查找。</p>
<p>一般只会传入item, 从头搜索。在搜索进行比较的时候使用的是 严格比较’===’。</p>
<p><strong>indexOf 和 includes 在查找 NaN 的时候 是有区别的，indexOf无法找到NaN，而includes 可以找到。</strong></p>
<p>在数组中查找具有特定条件的对象</p>
<h3 id="2-6-find-findIndex-findLastIndex"><a href="#2-6-find-findIndex-findLastIndex" class="headerlink" title="2.6 find/findIndex/findLastIndex"></a>2.6 find/findIndex/findLastIndex</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// item 是数组中的元素，index 是元素得索引， array 是数组本身</span></span><br><span class="line"><span class="keyword">let</span> ret = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果返回 true，则返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（falsy）的情况，则返回 undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如，我们有一个存储用户的数组，每个用户都有 id 和 name 字段。让我们找到 id == 1 的那个用户：</span></span><br><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>findIndex 和find 有相同的的语法，只不过当找到时，返回的元素的索引。如果没找到返回-1。</p>
<p>findLastIndex 方法类似于 findIndex，但从右向左搜索，类似于 lastIndexOf。</p>
<h3 id="2-7-filter"><a href="#2-7-filter" class="headerlink" title="2.7 filter"></a>2.7 filter</h3><p>find 是查找数组中的符合条件返回true的第一个元素，如果需要匹配的有很多，使用fileter。</p>
<p>语法与find相同，但是filter返回的是匹配元素组成的数组，没找到返回空数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前两个用户的数组</span></span><br><span class="line"><span class="keyword">let</span> someUsers = users.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">alert(someUsers.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>


<h3 id="2-8-map-有用且经常使用"><a href="#2-8-map-有用且经常使用" class="headerlink" title="2.8 map (有用且经常使用)"></a>2.8 map (有用且经常使用)</h3><p>map 他对每个数组都调用函数，并返回结果数组。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lengths = [<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].map(<span class="function"><span class="params">item</span> =&gt;</span> item.length);</span><br><span class="line"><span class="built_in">console</span>.log(lengths); <span class="comment">// 5,7,6</span></span><br></pre></td></tr></table></figure>


<h3 id="2-9-sort-fn"><a href="#2-9-sort-fn" class="headerlink" title="2.9 sort(fn)"></a>2.9 sort(fn)</h3><p>对数组进行原位排序， 在数组内部，而不是生成一个新的数组， 返回排序后的数组。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"><span class="comment">// 该方法重新排列 arr 的内容</span></span><br><span class="line">arr.sort();</span><br><span class="line">alert( arr );  <span class="comment">// 1, 15, 2</span></span><br></pre></td></tr></table></figure>
<p><strong>上面的排序结果是默认进行字符串进行排序的。</strong></p>
<p>比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于数字的比较</span></span><br><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line">arr.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于字符串的比较</span></span><br><span class="line"><span class="keyword">let</span> countries = [<span class="string">&#x27;Österreich&#x27;</span>, <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Vietnam&#x27;</span>];</span><br><span class="line">countries.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b) ) </span><br></pre></td></tr></table></figure>


<h3 id="2-10-reverse"><a href="#2-10-reverse" class="headerlink" title="2.10 reverse"></a>2.10 reverse</h3><p>颠倒数组的元素， 返回颠倒后的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line">alert( arr ); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>


<h3 id="2-11-split和join"><a href="#2-11-split和join" class="headerlink" title="2.11 split和join"></a>2.11 split和join</h3><p>split：将字符串根据特定的字符串分割，并返回组成的数组，split方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拆分字母</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">alert( str.split(<span class="string">&#x27;&#x27;</span>) ); <span class="comment">// t,e,s,t</span></span><br></pre></td></tr></table></figure>
<p>join：与split相反，根据特定的字符将数组的元素组成一个字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Bilbo&#x27;</span>, <span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;Nazgul&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.join(<span class="string">&#x27;;&#x27;</span>); <span class="comment">// 使用分号 ; 将数组粘合成字符串</span></span><br><span class="line">alert( str ); <span class="comment">// Bilbo;Gandalf;Nazgul</span></span><br></pre></td></tr></table></figure>


<h3 id="2-12-reduce-reduceRight"><a href="#2-12-reduce-reduceRight" class="headerlink" title="2.12 reduce/reduceRight"></a>2.12 reduce/reduceRight</h3><p>当我们需要遍历一个数组时，我们可以使用 for/forof/forEach，需要遍历并返回每个元素的数据时，可以使用map， arr.reduce和arr.reduceRught更复杂，用于根据数组计算单个值。</p>
<p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。</span></span><br><span class="line"><span class="comment">// item —— 当前的数组元素。</span></span><br><span class="line"><span class="comment">// index —— 当前索引。</span></span><br><span class="line"><span class="comment">// arr —— 数组本身。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, [initial]);</span><br></pre></td></tr></table></figure>
<p>应用函数时，上一个函数的调用结果，将作为参数传递给下一个函数。如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。<strong>建议始终指定初始值。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line">alert(result); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、在第一次运行时，sum 的值为初始值 initial（reduce 的最后一个参数），等于 0，current 是第一个数组元素，等于 1。所以函数运行的结果是 1。</span></span><br><span class="line"><span class="comment">// 2、在第二次运行时，sum = 1，我们将第二个数组元素（2）与其相加并返回。</span></span><br><span class="line"><span class="comment">// 3、在第三次运行中，sum = 3，我们继续把下一个元素与其相加，以此类推……</span></span><br></pre></td></tr></table></figure>
<p>reduceRight 和 reduce 一样，只是总右到左。</p>
<h3 id="2-13-Array-isArray"><a href="#2-13-Array-isArray" class="headerlink" title="2.13 Array.isArray"></a>2.13 Array.isArray</h3><p>数组是基于对象的，所以不能使用 typeOf 准确地判断类型。因此有一种特殊的方法，用来判断数组是一个数组：Array.isArray(value)。如果value是数组则返回true，否则返回false。</p>
<h3 id="2-14-thisArg"><a href="#2-14-thisArg" class="headerlink" title="2.14 thisArg"></a>2.14 thisArg</h3><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.find(func, thisArg);</span><br><span class="line">arr.filter(func, thisArg);</span><br><span class="line">arr.map(func, thisArg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// thisArg 是可选的最后一个参数</span></span><br></pre></td></tr></table></figure>


<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><h3 id="3-1-添加删除元素"><a href="#3-1-添加删除元素" class="headerlink" title="3.1 添加删除元素"></a>3.1 添加删除元素</h3><p>push(…items)  向尾端添加 items </p>
<p>pop()   从尾端删除元素</p>
<p>shift()   在首部删除元素</p>
<p>unshift(…items)  在首部添加 items</p>
<p>splice(pos, deleteCount, …items) 从pos删除deleteCount并插入items</p>
<p>slice(start, end)  返回一个新数组，返回从start开始到end结束的数组，但不包括end。</p>
<p>concat(…items) 返回一个新数组，参数如果是数组，则将数组拷贝过来，如果不是数组，直接添加。</p>
<h3 id="3-2-搜索元素"><a href="#3-2-搜索元素" class="headerlink" title="3.2 搜索元素"></a>3.2 搜索元素</h3><p>indexOf/lastIndoxOf(items, pos)  从pos索引位置开始判断数组中是否含有items, 有返回items索引，没有返回-1。</p>
<p>includes(value) 如果数组有value，则返回true，否则返回 false。</p>
<p>find/fliter(func) 通过方法过滤元素。返回使 func 返回 true 的第一个值/所有值。。</p>
<p>findIndex 返回索引值。</p>
<h3 id="3-3-遍历元素"><a href="#3-3-遍历元素" class="headerlink" title="3.3 遍历元素"></a>3.3 遍历元素</h3><p>forEach(func)  对每个元素都调用func。</p>
<h3 id="3-4-转换数组"><a href="#3-4-转换数组" class="headerlink" title="3.4 转换数组"></a>3.4 转换数组</h3><p>map(func)  根据每个元素调用func的返回的结果创建一个新数组。</p>
<p>sort(func) 对数组进行原位排序， 然后返回他。</p>
<p>reverse() 原位（in-place）反转数组，然后返回它。</p>
<p>split/join  将字符串转换为数组并返回/ 将数组转化为字符串并返回。</p>
<p>reduce/reduceRight(func, initial)   对每个元素执行方法，并将前一个元素作为函数的参数。</p>
<h3 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h3><p>Array.isArray(value) 判断value是否为数组， 是返回true不是返回false</p>
<p>sort、reverse、splice 都是对数组本身操作，不会产生新的数组。</p>
<p>some(func)/every(func) 对数组的每个元素调用func,如果为任何/所有结果true，返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较数组是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraysEqual</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.length === arr2.length &amp;&amp; arr1.every(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value === arr2[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( arraysEqual([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>fill(value， start, end)  从索引start到end用重复的value 填充数组。</p>
<p>copyWithin(target, start, end) 将从位置 start 到 end 的所有元素复制到 自身 的 target 位置（覆盖现有元素）。</p>
<p>arr.flat(depth)/arr.flatMap(fn) 从多维数组创建一个新的扁平数组。</p>
<p>of(element0[,element1[,elementN]]) 基于可变数量的参数创建一个新的 Array 实例，而不需要考虑参数的数量或类型。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python第三方包Dynaconf</title>
    <url>/2023/01/30/Python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85Dynaconf/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<h1 id="Python第三方包Dynaconf的使用"><a href="#Python第三方包Dynaconf的使用" class="headerlink" title="Python第三方包Dynaconf的使用"></a>Python第三方包Dynaconf的使用</h1><p>不管开发什么项目，我们总会遇到不同的环境下有着不同的配置信息，对于这些配置有应用相关的信息，同时也会有一些比较隐私的配置，比如MySQL或者Redis的账号密码等等。</p>
<h2 id="1-项目中常用的配置方式"><a href="#1-项目中常用的配置方式" class="headerlink" title="1 项目中常用的配置方式"></a>1 项目中常用的配置方式</h2><ul>
<li><p>类似flask中的app.config可以加载类的模式读取配置信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">    LOG_LEVEL = logging.DEBUG</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProdConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    LOG_LEVEL = logging.INFO</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>或者使用python-dotenv， 从.env 中加载配置信息，且是遵循了<a href="https://12factor.net/config">12-factor application</a>原则。具体配置不在赘述。</p>
</li>
<li><p>使用Dynaconf， Dynaconf同样是受到了<a href="https://12factor.net/config">12-factor application</a>的启发，但是相对于dotenv 提供了多种不同的配置方式。并且可以兼容python-dotenv。</p>
</li>
</ul>
<h2 id="2-Dynaconf的基础用法"><a href="#2-Dynaconf的基础用法" class="headerlink" title="2 Dynaconf的基础用法"></a>2 Dynaconf的基础用法</h2><p><a href="https://www.dynaconf.com/">Dynaconf</a>的Slogan就是**<em>Configuration Management for Python.**</em></p>
<h3 id="2-1-Dynaconf的基本特征-内容来自官网-："><a href="#2-1-Dynaconf的基本特征-内容来自官网-：" class="headerlink" title="2.1 Dynaconf的基本特征(内容来自官网)："></a>2.1 Dynaconf的基本特征(内容来自官网)：</h3><ul>
<li>受到了<a href="https://12factor.net/config">12-factor application</a>的启发。</li>
<li>设置管理（默认值、验证、解析、模板）。</li>
<li>多种文件格式（toml、yaml、json、ini、py）。</li>
<li>支持环境变量覆盖，支持dotenv。</li>
<li>可以用于多环境。（default, development, testing, production）。</li>
<li>内置支持 Hashicorp Vault 和 Redis 作为设置和秘密存储。</li>
<li><strong>Django</strong>和<strong>Flask</strong>网络框架的内置扩展。</li>
<li>常见操作的 CLI，例如<code>init, list, write, validate, export</code>。</li>
</ul>
<h3 id="2-2-Dynaconf安装"><a href="#2-2-Dynaconf安装" class="headerlink" title="2.2 Dynaconf安装"></a>2.2 Dynaconf安装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install dynaconf</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Dynaconf初始化"><a href="#2-3-Dynaconf初始化" class="headerlink" title="2.3 Dynaconf初始化"></a>2.3 Dynaconf初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移动到项目根目录下</span></span><br><span class="line">cd your/project/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化dynaconf相关配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dynaconf 支持多种文件，默认使用toml格式，也可以指定其他的格式（在Django）项目中建议使用yaml格式。</span></span><br><span class="line">dynaconf init -f toml</span><br></pre></td></tr></table></figure>
<p>正常输出如下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">⚙️  Configuring your Dynaconf environment</span><br><span class="line">------------------------------------------</span><br><span class="line">🐍 The file `config.py` was generated.</span><br><span class="line">  on your code now use `from config import settings`.</span><br><span class="line">  (you must have `config` importable in your PYTHONPATH).</span><br><span class="line"></span><br><span class="line">🎛️  settings.toml created to hold your settings.</span><br><span class="line"></span><br><span class="line">🔑 .secrets.toml created to hold your secrets.</span><br><span class="line"></span><br><span class="line">🙈 the .secrets.toml is also included in `.gitignore`</span><br><span class="line">  beware to not push your secrets to a public repo</span><br><span class="line">  or use dynaconf builtin support for Vault Servers.</span><br><span class="line"></span><br><span class="line">🎉 Dynaconf is configured! read more on https://dynaconf.com</span><br><span class="line">   Use `dynaconf -i config.settings list` to see your settings</span><br></pre></td></tr></table></figure>
<p>在项目文件夹中生成了如下四个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    目录: D:\Chaizz\Project\Python\dyna</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/1/30     15:12                __pycache__</span><br><span class="line">-a----         2023/1/30     15:12             46 .gitignore</span><br><span class="line">-a----         2023/1/30     15:12              0 .secrets.toml</span><br><span class="line">-a----         2023/1/30     15:12            270 config.py</span><br><span class="line">-a----         2023/1/30     15:12              0 settings.toml</span><br></pre></td></tr></table></figure>
<p>.gitignore      ：上传到代码仓库标记需要忽略的文件</p>
<p>.secrets.toml   ：存放隐私配置</p>
<p>config.py       ：实例化Dynaconf 对象</p>
<p>settings.toml   ：项目的常规配置</p>
<h3 id="2-4-在python中使用示例"><a href="#2-4-在python中使用示例" class="headerlink" title="2.4 在python中使用示例"></a>2.4 在python中使用示例</h3><p>config.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> Dynaconf, Validator</span><br><span class="line"></span><br><span class="line">settings = Dynaconf(</span><br><span class="line">    <span class="comment"># 取消 Dynaconf 的前缀</span></span><br><span class="line">    envvar_prefix=<span class="literal">False</span>,</span><br><span class="line">    <span class="comment"># 指定包含配置的文件</span></span><br><span class="line">    settings_files=[<span class="string">&#x27;settings.toml&#x27;</span>, <span class="string">&#x27;.secrets.toml&#x27;</span>],</span><br><span class="line">    <span class="comment"># 启用分层环境，即下文中的 dev、test、prod</span></span><br><span class="line">    environments=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># 自定义验证器</span></span><br><span class="line">    validators=[</span><br><span class="line">        <span class="comment"># 确保某些参数存在（必需）</span></span><br><span class="line">        Validator(<span class="string">&#x27;VERSION&#x27;</span>, must_exist=<span class="literal">True</span>),</span><br><span class="line">        <span class="comment"># 确保变量的类型， 为特定的类型</span></span><br><span class="line">        Validator(<span class="string">&#x27;MYSQL_PORT&#x27;</span>, is_type_of=<span class="built_in">int</span>),</span><br><span class="line">        <span class="comment"># 确保某些参数不存在</span></span><br><span class="line">        Validator(<span class="string">&#x27;PASSWORD&#x27;</span>, must_exist=<span class="literal">False</span>),</span><br><span class="line">        <span class="comment"># 保证参数满足一些条件</span></span><br><span class="line">        <span class="comment"># conditions: (eq, ne, lt, gt, lte, gte, identity, is_type_of, is_in, is_not_in)</span></span><br><span class="line">        Validator(<span class="string">&#x27;AGE&#x27;</span>, lte=<span class="number">30</span>, gte=<span class="number">10</span>),</span><br><span class="line">        <span class="comment"># 在某个环境中确保一些参数等于某个值</span></span><br><span class="line">        Validator(<span class="string">&#x27;PROJECT&#x27;</span>, eq=<span class="string">&#x27;hello_world&#x27;</span>, env=<span class="string">&#x27;prod&#x27;</span>),</span><br><span class="line">        <span class="comment"># 保证参数（字符串）满足一些条件</span></span><br><span class="line">        <span class="comment"># conditions: (len_eq, len_ne, len_min, len_max, cont)</span></span><br><span class="line">        <span class="comment"># 确定值的最小最大长度</span></span><br><span class="line">        Validator(<span class="string">&quot;NAME&quot;</span>, len_min=<span class="number">3</span>, len_max=<span class="number">125</span>),</span><br><span class="line">        <span class="comment"># 确保，字符串在集合中存在</span></span><br><span class="line">        Validator(<span class="string">&quot;DEV_SERVERS&quot;</span>, cont=<span class="string">&#x27;localhost&#x27;</span>),</span><br><span class="line">        <span class="comment"># 确保参数的长度和定义的长度相等</span></span><br><span class="line">        Validator(<span class="string">&quot;PORT&quot;</span>, len_eq=<span class="number">4</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>settings.toml</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="comment"># 当 Dynaconf的属性：environments 为True，default 为默认属性。</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">15</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[dev]</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">190</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[test]</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">150</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[prod]</span></span><br><span class="line"><span class="attr">VERSION</span> = <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="attr">AGE</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">PROJECT</span> = <span class="string">&quot;hello_world&quot;</span></span><br><span class="line"><span class="attr">NAME</span> = <span class="string">&quot;admin&quot;</span></span><br></pre></td></tr></table></figure>
<p>.secrets.toml</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="comment"># 当 Dynaconf的属性：environments 为True，default 为默认属性。</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[dev]</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;1.1.1.1&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;PASSWORD&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;database&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[test]</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;22222222&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;database&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[prod]</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">&quot;333333333333&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">&quot;prod&quot;</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">&quot;database&quot;</span></span><br></pre></td></tr></table></figure>


<p>在上面的toml文件中：dev、test、prod 代表不同的开发环境下的不同的配置信息，需要在系统环境变量中设置 <code>export ENV_FOR_DYNACONF = dev|test|prod</code> 。</p>
<p>default是当Dynaconf的属性environments为True时, 设置的默认值。</p>
<p><strong>在不同的开发环境之间切换只需要在环境变量中设置<code>ENV_FOR_DYNACONF</code>的值即可。</strong></p>
<h2 id="3-Dynaconf的高级用法"><a href="#3-Dynaconf的高级用法" class="headerlink" title="3 Dynaconf的高级用法"></a>3 Dynaconf的高级用法</h2><h3 id="3-1-hooks：需要根据先前加载的设置，有条件地加载数据。"><a href="#3-1-hooks：需要根据先前加载的设置，有条件地加载数据。" class="headerlink" title="3.1 hooks：需要根据先前加载的设置，有条件地加载数据。"></a>3.1 hooks：需要根据先前加载的设置，有条件地加载数据。</h3><h3 id="3-2-PrefixFilter：根据前缀过滤"><a href="#3-2-PrefixFilter：根据前缀过滤" class="headerlink" title="3.2 PrefixFilter：根据前缀过滤"></a>3.2 PrefixFilter：根据前缀过滤</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> Dynaconf</span><br><span class="line"><span class="keyword">from</span> dynaconf.strategies.filtering <span class="keyword">import</span> PrefixFilter</span><br><span class="line"></span><br><span class="line">settings = Dynaconf(</span><br><span class="line">    settings_file=<span class="string">&quot;settings.toml&quot;</span>,</span><br><span class="line">    environments=<span class="literal">False</span></span><br><span class="line">    <span class="comment"># 初始化Dynaconf时，添加过滤条件，仅加载前缀为prefix_开头的配置。</span></span><br><span class="line">    filter_strategy=PrefixFilter(<span class="string">&quot;prefix&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="3-3-切换工作环境"><a href="#3-3-切换工作环境" class="headerlink" title="3.3 切换工作环境"></a>3.3 切换工作环境</h3><h4 id="3-3-1-from-env：返回指定环境的配置"><a href="#3-3-1-from-env：返回指定环境的配置" class="headerlink" title="3.3.1 from_env：返回指定环境的配置"></a>3.3.1 from_env：返回指定环境的配置</h4><p>在配置文件 srttings.toml 中有如下配置。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[development]</span></span><br><span class="line"><span class="attr">message</span> = <span class="string">&#x27;This is in dev&#x27;</span></span><br><span class="line"><span class="attr">foo</span> = <span class="number">1</span></span><br><span class="line"><span class="section">[other]</span></span><br><span class="line"><span class="attr">message</span> = <span class="string">&#x27;this is in other env&#x27;</span></span><br><span class="line"><span class="attr">bar</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在正常使用时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.MESSAGE)</span><br><span class="line"><span class="string">&#x27;This is in dev&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.FOO)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.BAR)</span><br><span class="line">AttributeError: settings <span class="built_in">object</span> has no attribute <span class="string">&#x27;BAR&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后你可以使用<code>from_env</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.from_env(<span class="string">&#x27;other&#x27;</span>).MESSAGE)</span><br><span class="line"><span class="string">&#x27;This is in other env&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.from_env(<span class="string">&#x27;other&#x27;</span>).BAR)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(settings.from_env(<span class="string">&#x27;other&#x27;</span>).FOO)</span><br><span class="line">AttributeError: settings <span class="built_in">object</span> has no attribute <span class="string">&#x27;FOO&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也可以分别获取不同的环境下配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">development_settings = settings.from_env(<span class="string">&#x27;development&#x27;</span>)</span><br><span class="line">other_settings = settings.from_env(<span class="string">&#x27;other&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="3-3-2-setenv：在原地更改配置。"><a href="#3-3-2-setenv：在原地更改配置。" class="headerlink" title="3.3.2 setenv：在原地更改配置。"></a>3.3.2 setenv：在原地更改配置。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">settings.setenv(<span class="string">&#x27;other&#x27;</span>)</span><br><span class="line"><span class="comment"># 将当前的环境更改为 other 环境</span></span><br><span class="line"><span class="keyword">assert</span> settings.MESSAGE == <span class="string">&#x27;This is in other env&#x27;</span></span><br><span class="line"></span><br><span class="line">settings.setenv()</span><br><span class="line"><span class="comment"># 将当前环境返回到先前的环境</span></span><br></pre></td></tr></table></figure>


<h4 id="3-3-3-using-env：使用上下文管理器切换环境"><a href="#3-3-3-using-env：使用上下文管理器切换环境" class="headerlink" title="3.3.3 using_env：使用上下文管理器切换环境"></a>3.3.3 using_env：使用上下文管理器切换环境</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> settings.using_env(<span class="string">&#x27;other&#x27;</span>):</span><br><span class="line">    <span class="comment"># 在上下文管理器之内，切换为选择的环境</span></span><br><span class="line">    <span class="keyword">assert</span> settings.MESSAGE == <span class="string">&#x27;This is in other env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在上下文管理器之外，还是默认的环境</span></span><br><span class="line"><span class="keyword">assert</span> settings.MESSAGE == <span class="string">&#x27;This is in dev&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="3-4-导出配置信息"><a href="#3-4-导出配置信息" class="headerlink" title="3.4 导出配置信息"></a>3.4 导出配置信息</h3><ol>
<li><p>使用命令导出 <code>dynaconf list -o /path/to/file.yaml|toml|ini|json|py</code></p>
</li>
<li><p>使用代码导出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> loaders</span><br><span class="line"><span class="keyword">from</span> dynaconf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> dynaconf.utils.boxing <span class="keyword">import</span> DynaBox</span><br><span class="line"></span><br><span class="line"><span class="comment"># generates a dict with all the keys for `development` env</span></span><br><span class="line">data = settings.as_dict(env=<span class="string">&#x27;development&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># writes to a file, the format is inferred by extension</span></span><br><span class="line"><span class="comment"># can be .yaml, .toml, .ini, .json, .py</span></span><br><span class="line">loaders.write(<span class="string">&#x27;../file.json&#x27;</span>, DynaBox(data).to_dict(), env=<span class="string">&#x27;development&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-Dynaconf的详细配置"><a href="#4-Dynaconf的详细配置" class="headerlink" title="4 Dynaconf的详细配置"></a>4 Dynaconf的详细配置</h2></li>
</ol>
<p><a href="https://www.dynaconf.com/configuration/">Dynaconfg详细配置</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Package</category>
      </categories>
      <tags>
        <tag>Dynaconf</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(二)</title>
    <url>/2023/01/29/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>



<p>JS笔记之JS数据类型(二)</p>
<p>字符串</p>
<p>在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。 字符串是不可变的。</p>
<p>字符串的内部格式始终是 <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>，它不依赖于页面编码。</p>
<p>引号</p>
<p>在字符串中有三种引号，单引号和双引号基本相同。但是，反引号允许我们通过 <code>$&#123;…&#125;</code> 将任何表达式嵌入到字符串中。 使用反引号允许字符串跨行。</p>
<p>反引号还允许我们在第一个反引号之前指定一个“模版函数”。语法是：<code>func</code>string``。函数 <code>func</code> 被自动调用，接收字符串和嵌入式表达式，并处理它们。你可以在 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals">docs</a> 中阅读更多关于它们的信息。这叫做 “tagged templates”。此功能可以更轻松地将字符串包装到自定义模版或其他函数中，但这很少使用。</p>
<p>特殊字符</p>
<p>在上述的反引号能够换行，特殊字符也可以达到目的。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\n</code></td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">在 Windows 文本文件中，两个字符 <code>\r\n</code> 的组合代表一个换行。而在非 Windows 操作系统上，它就是 <code>\n</code>。这是历史原因造成的，大多数的 Windows 软件也理解 <code>\n</code>。</td>
</tr>
<tr>
<td align="left"><code>\&#39;</code>, <code>\&quot;</code></td>
<td align="left">引号</td>
</tr>
<tr>
<td align="left"><code>\\</code></td>
<td align="left">反斜线</td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left"><code>\b</code>, <code>\f</code>, <code>\v</code></td>
<td align="left">退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。</td>
</tr>
<tr>
<td align="left"><code>\xXX</code></td>
<td align="left">具有给定十六进制 Unicode <code>XX</code> 的 Unicode 字符，例如：<code>&#39;\x7A&#39;</code> 和 <code>&#39;z&#39;</code> 相同。</td>
</tr>
<tr>
<td align="left"><code>\uXXXX</code></td>
<td align="left">以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 Unicode 字符，例如 <code>\u00A9</code> —— 是版权符号 <code>©</code> 的 Unicode。它必须正好是 4 个十六进制数字。</td>
</tr>
<tr>
<td align="left"><code>\u&#123;X…XXXXXX&#125;</code>（1 到 6 个十六进制字符）</td>
<td align="left">具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&quot;\u00A9&quot;</span> ); <span class="comment">// ©</span></span><br><span class="line">alert( <span class="string">&quot;\u&#123;20331&#125;&quot;</span> ); <span class="comment">// 佫，罕见的中国象形文字（长 Unicode）</span></span><br><span class="line">alert( <span class="string">&quot;\u&#123;1F60D&#125;&quot;</span> ); <span class="comment">// 😍，笑脸符号（另一个长 Unicode）</span></span><br></pre></td></tr></table></figure>
<p>反斜杠 <code>\</code> 在 JavaScript 中用于正确读取字符串，然后消失。内存中的字符串没有 <code>\</code>。</p>
<p>length 字符串长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="string">`My\n`</span>.length ); <span class="comment">// 3  \n 是一个单独的“特殊”字符，所以长度确实是 3。</span></span><br></pre></td></tr></table></figure>
<p>length 是一个属性。</p>
<p>访问字符</p>
<p>要获取在pos位置的一个字符，可以使用<code>[]</code> 或者调用<code>str.charAt(pos)</code>，第一个字符串位置从0开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Hello`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个字符</span></span><br><span class="line">alert( str[<span class="number">0</span>] ); <span class="comment">// H</span></span><br><span class="line">alert( str.charAt(<span class="number">0</span>) ); <span class="comment">// H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个字符</span></span><br><span class="line">alert( str[str.length - <span class="number">1</span>] ); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>方括号是获取字符的一种现代化方法，而 <code>charAt</code> 是历史原因才存在的。</p>
<p>它们之间的唯一区别是，如果没有找到字符，<code>[]</code>返回 <code>undefined</code>，而 <code>charAt</code> 返回一个空字符串 ‘’</p>
<p>也可以使用for..of 遍历字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">  alert(char); <span class="comment">// H,e,l,l,o（char 变为 &quot;H&quot;，然后是 &quot;e&quot;，然后是 &quot;l&quot; 等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>字符串常用方法：</p>
<ul>
<li><p><strong>改变大小写</strong>：<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase">toLowerCase()</a> 和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">toUpperCase()</a>。</p>
</li>
<li><p><strong>查找子字符串</strong>：<a href="https://zh.javascript.info/string#strindexof">str.indexOf(substr, pos)</a>，它从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code>，如果没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。 pos 允许我们从指定位置查找。**str.lastIndexOf(substr, pos)**：它从字符串的末尾开始搜索到开头，它会以相反的顺序列出这些事件。</p>
<p>在if 中使用 indexOf ， 应该判断是否不等于 -1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Widget with id&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str.indexOf(<span class="string">&quot;Widget&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">    alert(<span class="string">&quot;We found it&quot;</span>); <span class="comment">// 现在工作了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><a href="https://zh.javascript.info/string#an-wei-bitwisenot-ji-qiao">按位（bitwise）NOT 技巧</a></p>
<p>这里使用的一个老技巧是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">bitwise NOT</a> <code>~</code> 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。</p>
<p>实际上，这意味着一件很简单的事儿：对于 32-bit 整数，<code>~n</code> 等于 <code>-(n+1)</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( ~<span class="number">2</span> ); <span class="comment">// -3，和 -(2+1) 相同</span></span><br><span class="line">alert( ~<span class="number">1</span> ); <span class="comment">// -2，和 -(1+1) 相同</span></span><br><span class="line">alert( ~<span class="number">0</span> ); <span class="comment">// -1，和 -(0+1) 相同</span></span><br><span class="line">alert( ~-<span class="number">1</span> ); <span class="comment">// 0，和 -(-1+1) 相同</span></span><br></pre></td></tr></table></figure>
<p>正如我们看到这样，只有当 <code>n == -1</code> 时，<code>~n</code> 才为零（适用于任何 32-bit 带符号的整数 <code>n</code>）。</p>
<p>因此，仅当 <code>indexOf</code> 的结果不是 <code>-1</code> 时，检查 <code>if ( ~str.indexOf(&quot;...&quot;) )</code> 才为真。换句话说，当有匹配时。</p>
<p>人们用它来简写 <code>indexOf</code> 检查：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Widget&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (~str.indexOf(<span class="string">&quot;Widget&quot;</span>)) &#123;</span><br><span class="line">  alert( <span class="string">&#x27;Found it!&#x27;</span> ); <span class="comment">// 正常运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要记住：<code>if (~str.indexOf(...))</code> 读作 “if found”。</p>
<p>确切地说，由于 <code>~</code> 运算符将大数字截断为 32 位，因此存在给出 <code>0</code> 的其他数字，最小的数字是 <code>~4294967295=0</code>。这使得这种检查只有在字符串没有那么长的情况下才是正确的。</p>
<p>现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 <code>.includes</code> 方法（见下文）。</p>
<p>includes，startsWith，endsWith</p>
<p>str.includes(substr, pos) 根据str 中是否包含 substr 来返回true或者false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测匹配，但不需要它的位置</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Widget with id&quot;</span>.includes(<span class="string">&quot;Widget&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Hello&quot;</span>.includes(<span class="string">&quot;Bye&quot;</span>) ); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 第二个参数也是查询的起始位置</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Widget&quot;</span>.includes(<span class="string">&quot;id&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Widget&quot;</span>.includes(<span class="string">&quot;id&quot;</span>, <span class="number">3</span>) ); <span class="comment">// false, 从位置 3 开始没有 &quot;id&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&quot;Widget&quot;</span>.startsWith(<span class="string">&quot;Wid&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span></span><br><span class="line">alert( <span class="string">&quot;Widget&quot;</span>.endsWith(<span class="string">&quot;get&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span></span><br></pre></td></tr></table></figure>


<p>获取子字符串</p>
<p>JS中有三种获取子字符串的方法， substring、substr、slice</p>
<p>str.slice(start [, end])：返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。如果没有第二个参数，<code>slice</code> 会一直运行到字符串末尾。<code>start/end</code> 也有可能是负值。它们的意思是起始位置从字符串结尾计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右边的第四个位置开始，在右边的第一个位置结束</span></span><br><span class="line">alert( str.slice(-<span class="number">4</span>, -<span class="number">1</span>) ); <span class="comment">// &#x27;gif&#x27;</span></span><br></pre></td></tr></table></figure>
<p>str.substring(start [, end])：返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。这与 <code>slice</code> 几乎相同，但它允许 <code>start</code> 大于 <code>end</code>。不支持负参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些对于 substring 是相同的</span></span><br><span class="line">alert( str.substring(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line">alert( str.substring(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……但对 slice 是不同的：</span></span><br><span class="line">alert( str.slice(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;（一样）</span></span><br><span class="line">alert( str.slice(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;&quot;（空字符串）</span></span><br></pre></td></tr></table></figure>
<p>str.substr(start [, length])：返回字符串从 <code>start</code> 开始的给定 <code>length</code> 的部分。</p>
<p>与以前的方法相比，这个允许我们指定 <code>length</code> 而不是**==结束位置==**：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line">alert( str.substr(<span class="number">2</span>, <span class="number">4</span>) ); <span class="comment">// &#x27;ring&#x27;，从位置 2 开始，获取 4 个字符</span></span><br></pre></td></tr></table></figure>
<p>具体使用哪一个？ </p>
<blockquote>
<p>   它们都可用于获取子字符串。正式一点来讲，<code>substr</code> 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中。附录 B 的内容主要是描述因历史原因而遗留下来的仅浏览器特性。因此，理论上非浏览器环境可能无法支持 <code>substr</code>，但实际上它在别的地方也都能用。</p>
<p>相较于其他两个变体，<code>slice</code> 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 <code>slice</code> 就足够了。</p>
</blockquote>
<p>比较字符串</p>
<p>字符串的比较按照字母的顺序逐字比较，但是有特殊情况：</p>
<ol>
<li><p>小写字母总是大于大写字母。<code>console.log( &#39;a&#39; &gt; &#39;Z&#39; ); // true</code></p>
</li>
<li><p>带变音符号的字母存在“乱序”的情况。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">&#x27;Österreich&#x27;</span> &gt; <span class="string">&#x27;Zealand&#x27;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>为什么会出现乱序？</p>
<p>在JS中所有的字符串都使用 <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。str.codePointAt(pos) 返回在 <code>pos</code> 位置的字符代码 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同的字母有不同的代码</span></span><br><span class="line">alert( <span class="string">&quot;z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 122</span></span><br><span class="line">alert( <span class="string">&quot;Z&quot;</span>.codePointAt(<span class="number">0</span>) ); <span class="comment">// 90</span></span><br></pre></td></tr></table></figure>








































]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS数据类型(一)</title>
    <url>/2023/01/19/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%80)/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="JS笔记之JS数据类型-一"><a href="#JS笔记之JS数据类型-一" class="headerlink" title="JS笔记之JS数据类型(一)"></a>JS笔记之JS数据类型(一)</h1><p>原始类型的方法</p>
<p>在JS中允许我们像使用对象一样使用原始类型（数字。字符串等）。</p>
<h2 id="1-字符串与对象的基本区别"><a href="#1-字符串与对象的基本区别" class="headerlink" title="1 字符串与对象的基本区别"></a>1 字符串与对象的基本区别</h2><p>一个原始值：</p>
<ul>
<li>是原始类型中的一种值。</li>
<li>在 JavaScript 中有 7 种原始类型：<code>string</code>，<code>number</code>，<code>bigint</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 和 <code>undefined</code>。</li>
</ul>
<p>一个对象：</p>
<ul>
<li>能够存储多个值作为属性。</li>
<li>可以使用大括号 <code>&#123;&#125;</code> 创建对象，例如：<code>&#123;name: &quot;John&quot;, age: 30&#125;</code>。JavaScript 中还有其他种类的对象，例如函数就是对象</li>
</ul>
<h3 id="1-1-如何解决使原始类型拥有和对象类似的方法？"><a href="#1-1-如何解决使原始类型拥有和对象类似的方法？" class="headerlink" title="1.1 如何解决使原始类型拥有和对象类似的方法？"></a>1.1 如何解决使原始类型拥有和对象类似的方法？</h3><ol>
<li>原始类型仍然是原始的。与预期相同，提供单个值。</li>
<li>JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。</li>
<li>为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。</li>
</ol>
<p>所以原始类型可以提供方法，但它们依然是轻量级的。</p>
<p>JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。</p>
<blockquote>
<p><strong>null/undefined 没有任何方法</strong></p>
<p>特殊的原始类型 <code>null</code> 和 <code>undefined</code> 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。</p>
<p>尝试访问这种值的属性会导致错误：<code>alert(null.test); // error</code></p>
</blockquote>
<h2 id="2-数字类型"><a href="#2-数字类型" class="headerlink" title="2 数字类型"></a>2 数字类型</h2><p>在现代的JS中数字有两种类型：</p>
<ul>
<li>JS中常规的数字以64为的格式存储，也称为双精度浮点数，是我们大多数使用时数字。但是不能安全地超过 <code>(253-1)</code> 或小于 <code>-(253-1)</code>。</li>
<li>BigInt 表示任意长度的整数，仅在少数特殊领域才会用到 BigInt。</li>
</ul>
<h3 id="2-1-编写数字的方式"><a href="#2-1-编写数字的方式" class="headerlink" title="2.1 编写数字的方式"></a>2.1 编写数字的方式</h3><p>你如要写一个10亿的数字：<code>let billion = 1000000000</code> 也可以使用下划线作为分隔符 <code>let billiion = 1_000_000_000</code>。</p>
<p>这里的下划线 <code>_</code> 扮演了“<a href="https://en.wikipedia.org/wiki/Syntactic_sugar">语法糖</a>”的角色，使得数字具有更强的可读性。JS引擎会直接忽略数字之间的 <code>_</code>，所以 上面两个例子其实是一样的。</p>
<p>在 JS 中，我们可以通过在数字后面附加字母 <code>&quot;e&quot;</code> 并指定零的个数来缩短数字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> billion = <span class="number">1e9</span>;  <span class="comment">// 10 亿，字面意思：数字 1 后面跟 9 个 0</span></span><br><span class="line"></span><br><span class="line">alert( <span class="number">7.3e9</span> );  <span class="comment">// 73 亿（与 7300000000 和 7_300_000_000 相同）</span></span><br></pre></td></tr></table></figure>
<p>换句话说，<code>e</code> 把数字乘以 <code>1</code> 后面跟着给定数量的 0 的数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1e3</span> === <span class="number">1</span> * <span class="number">1000</span>; <span class="comment">// e3 表示 *1000</span></span><br><span class="line"><span class="number">1.23e6</span> === <span class="number">1.23</span> * <span class="number">1000000</span>; <span class="comment">// e6 表示 *1000000</span></span><br></pre></td></tr></table></figure>
<p>现在让我们写一些非常小的数字。例如，1 微秒（百万分之一秒）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mcs = <span class="number">0.000001</span>;</span><br></pre></td></tr></table></figure>
<p>就像以前一样，可以使用 <code>&quot;e&quot;</code> 来完成。如果我们想避免显式地写零，我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mcs = <span class="number">1e-6</span>; <span class="comment">// 1 的左边有 6 个 0</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-十六进制、八进制和二进制数字"><a href="#2-2-十六进制、八进制和二进制数字" class="headerlink" title="2.2 十六进制、八进制和二进制数字"></a>2.2 十六进制、八进制和二进制数字</h3><p>十六进制 在JS中总是表示颜色，使用<code>0x</code> 表示，二进制使用<code>0b</code>表示，八进制使用<code>0o</code>表示。只有这三种进制支持这种写法，其他的进制使用 parseInt 表示。</p>
<h3 id="2-3-toString-base"><a href="#2-3-toString-base" class="headerlink" title="2.3 toString(base)"></a>2.3 toString(base)</h3><p>方法toString(base)方法，返回在给定base进制数字系统（base的范围可以从2到36。默认情况下是10）中num的字符串表示形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num= <span class="number">255</span>;</span><br><span class="line"><span class="built_in">console</span>.log&#123;num.toString(<span class="number">16</span>)&#125; <span class="comment">// ff</span></span><br><span class="line"><span class="built_in">console</span>.log&#123;num.tostring(<span class="number">2</span>)&#125; <span class="comment">// 11111111</span></span><br></pre></td></tr></table></figure>
<p>常用的进制范例：</p>
<ol>
<li>base=16 用户十六进制颜色，字符编码等，数字可以是0..9 或者是A..F。</li>
<li>base=2 主要用于调试按位操作。数字是0和1。</li>
<li>base=36 是最大进制，数字可以是0..9或者A..Z，所有的字母都被用于表示数字，对于36进制来说、一个；例字设计：将一个较长的数字标识符转化较短的时候，比如短连接，可以使用基数为36的数字系统表示。<code>console.log( 123456..toString(36) ); // 2n9c</code></li>
</ol>
<blockquote>
<p>在范例第三点中 <code>123456..toString(36)</code> 两个点不是错误。如果想直接在一个数字上，调用一个方法，比如上面的例字中的toString，那么需要在数字后面加上两个点 .. 。</p>
<p>如果放置一个点，<code>123456.toString(36)</code>那么就会出现一个error，因为JS语法隐含了第一个点后面的部分是小数部分，如果再放一个点，那么JS就知道小数部分为空。</p>
<p>也可以写成<code>(123346).toString(36)</code></p>
</blockquote>
<h3 id="2-4-舍入"><a href="#2-4-舍入" class="headerlink" title="2.4 舍入"></a>2.4 舍入</h3><p>舍入是对数字比较常用的操作之一。一下是几个对数字进行舍入操作的内建函数。</p>
<p>Math.floor：向下舍入， 3.1 变成 3，-1.1 变成 -2。</p>
<p>Math.ceil：向下舍入，3.1 变成 4，-1.1 变成 -1。</p>
<p>Math.round：像最近的整数舍入。3.1 变成 3，3.6 变成 4，3.5 变成 4。</p>
<p>Math.trunc：（IE浏览器不支持）移除小数点后的内容而不舍入。3.1 变成 3，-1.1 变成 -1。</p>
<h3 id="2-5-保留小数位数"><a href="#2-5-保留小数位数" class="headerlink" title="2.5 保留小数位数"></a>2.5 保留小数位数</h3><p>toFixed(n) 将数字输入到下小数的后n位，以字符串的形式返回结果。会向上或者向下的舍入到近似的值，类似Math.round()。如果小数部分比需要的短，则在末尾加0。 可以使用一元符号或者Number()将其转化为数字。例如：<code>+num.toFixed(5)</code></p>
<h3 id="2-6-不精确的计算"><a href="#2-6-不精确的计算" class="headerlink" title="2.6 不精确的计算"></a>2.6 不精确的计算</h3><p>数字内部是以64为存储数字的，所以：其中52位被用于存储这些数字，11为被存储与小数点的位置，一位用于符号，如果一个数字很大，可能会溢出64位存储，变成一个特殊的值：infinty。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1e500</span>);</span><br></pre></td></tr></table></figure>
<p>在大多数语言中都会有精度的问题，<code>console.log( 0.1 + 0.2 ); // 0.30000000000000004</code>,</p>
<p>出现的原因：数字是以二进制存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 <code>0.1</code>，<code>0.2</code> 这样的小数，实际上在二进制形式中是无限循环小数。</p>
<p>其中的解决办法有：</p>
<ul>
<li><p>通过将数字舍入到最接近的可能数字来解决此问题，使用toFixed <code>+(0.1 + 0.2 ).toFixed(2)</code></p>
</li>
<li><p>使用乘法或者除法来减少误差。但是乘法除法只能减少误差，不能消除误差。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( (<span class="number">0.1</span> * <span class="number">10</span> + <span class="number">0.2</span> * <span class="number">10</span>) / <span class="number">10</span> ); <span class="comment">// 0.3</span></span><br><span class="line">alert( (<span class="number">0.28</span> * <span class="number">100</span> + <span class="number">0.14</span> * <span class="number">100</span>) / <span class="number">100</span>); <span class="comment">// 0.4200000000000001</span></span><br></pre></td></tr></table></figure>
<p>实际上完全处理小数是不可能的，但是我们可以在满足条件的情况下，减掉尾巴，来进行四舍五入即可。</p>
</li>
</ul>
<h3 id="2-7-isFinite和isNaN"><a href="#2-7-isFinite和isNaN" class="headerlink" title="2.7 isFinite和isNaN"></a>2.7 isFinite和isNaN</h3><p>infinity和-infinity以及NaN 都属于Number类型，但不是普通的数字。</p>
<ul>
<li><p>isNaN() 将参数转化为数字，并判断其是否为NaN。</p>
<p>为什么不用 <code>xx === NaN</code>？因为在JS中，NaN是独一无二的，即使是<code>NaN === NaN</code> 进行比较也是false。</p>
</li>
<li><p>isFinity() 将参数转为数字， 判断是否为常规数字。如果是常规数字而不是NaN、infinity,-infinity 返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">isFinite</span>(<span class="string">&quot;15&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">isFinite</span>(<span class="string">&quot;str&quot;</span>) ); <span class="comment">// false，因为是一个特殊的值：Na</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) ); <span class="comment">// false，因为是一个特殊的值：Infinity</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>与Object.is 进行比较。它类似于 === 一样对值进行比较，但是他对于两种边缘庆魁昂更可靠。</p>
<p>1.它适用于NaN：<code>Object.is(NaN, NaN) === true</code>。</p>
<p>2.值0和-0是不同的，<code>Object.is(0, -0) === False</code>，从技术上讲是对的，因为在内部数字的符号位可能会不同，即使其他的均为0。</p>
<p>在所有情况下， <code>Objet.is(a, b) 与 a === b</code> 相同。</p>
</blockquote>
<h3 id="2-8-parseInt-和-parsrFloat"><a href="#2-8-parseInt-和-parsrFloat" class="headerlink" title="2.8 parseInt 和 parsrFloat"></a>2.8 parseInt 和 parsrFloat</h3><p>使用一元运算符将字符串转化为数字时，是严格的，当转化的字符串不是一个数字时就会失败。(除了字符开头结尾的空格)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;sss&quot;</span>)  <span class="comment">// NaN	</span></span><br></pre></td></tr></table></figure>
<p>在现实中我们会经常遇到带有单位的字符串， 100px, 100pt，19€（欧元）。</p>
<p>parseInt 和 parsrFloat 他们可以从字符串中提取数字，，直到无法读取为止，如果发生error则返回收集到的数字，函数parseInt 返回一个整数，parseFloat 返回一个浮点数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseInt</span>(<span class="string">&#x27;100px&#x27;</span>) ); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseFloat</span>(<span class="string">&#x27;12.5em&#x27;</span>) ); <span class="comment">// 12.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseInt</span>(<span class="string">&#x27;12.3&#x27;</span>) ); <span class="comment">// 12，只有整数部分被返回了</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">parseFloat</span>(<span class="string">&#x27;12.3.4&#x27;</span>) ); <span class="comment">// 12.3，在第二个点出停止了读取</span></span><br></pre></td></tr></table></figure>
<p>parseInt 和 parsrFloat 的局限性：只能是数字开头的字符串，如果第一个字符就不是数字则无法读取，返回NaN。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;xxx111&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>parseInt(str，radix) radix:技术的意思， 第二个参数制定了数字系统的基数，因此parseInt 还可以解析十六进制，八进制，二进制等字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert( <span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>) ); <span class="comment">// 255</span></span><br><span class="line">alert( <span class="built_in">parseInt</span>(<span class="string">&#x27;ff&#x27;</span>, <span class="number">16</span>) ); <span class="comment">// 255，没有 0x 仍然有效</span></span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">parseInt</span>(<span class="string">&#x27;2n9c&#x27;</span>, <span class="number">36</span>) ); <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure>


<h3 id="2-9-其他的数学函数"><a href="#2-9-其他的数学函数" class="headerlink" title="2.9 其他的数学函数"></a>2.9 其他的数学函数</h3><p>Math 对象包含了一个小型的数学函数和常量库。</p>
<ul>
<li>Math.random() 返回一个从 0 到 1 的随机数（不包括 1）。</li>
<li>Math.max(a, b, c…) 和 Math.min(a, b, c…) 从任意数量的参数中返回最大值和最小值。</li>
<li>Math.pow(n, power) 返回 <code>n</code> 的给定（power）次幂。</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>要写很多0的数字</p>
<ul>
<li>有很多0的整数，将e和0的个数写到数字的后面。 <code>123e5 === 12300000</code>。</li>
<li>有很多0的小数，将e和0的个数写到数字的后面，0的个数前加上负号-，<code>1.33e-5 === 0.0000133</code> </li>
</ul>
<h3 id="3-2-不同的数字系统"><a href="#3-2-不同的数字系统" class="headerlink" title="3.2 不同的数字系统"></a>3.2 不同的数字系统</h3><ul>
<li>可以在十六进制，八进制，二进制 数字系统中写入数字。</li>
<li>parseInt(str, base) 将字符串 str 解析为在给定的 <code>base</code> 数字系统中的整数，<code>2 ≤ base ≤ 36</code>。</li>
<li>num.toString(base) 将数字转化为给定的base数字系统中的字符串。</li>
</ul>
<h3 id="3-3-对于常规的数字检测"><a href="#3-3-对于常规的数字检测" class="headerlink" title="3.3 对于常规的数字检测"></a>3.3 对于常规的数字检测</h3><ul>
<li>isNaN(value) 将参数转为为数字，并判断是否为NaN。</li>
<li>isFinite(value) 将其参数转换为数字，如果它是常规数字，则返回 true，而不是 `NaN/Infinity/-Infinity</li>
</ul>
<h3 id="3-4-将字符串转为数字"><a href="#3-4-将字符串转为数字" class="headerlink" title="3.4 将字符串转为数字"></a>3.4 将字符串转为数字</h3><ul>
<li>使用一元符号，但是是严格模式。</li>
<li>使用parseInt/parseFloat进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。</li>
</ul>
<h3 id="3-5-小数"><a href="#3-5-小数" class="headerlink" title="3.5 小数"></a>3.5 小数</h3><ul>
<li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入。</li>
<li>使用小数时损失精度。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(八)</title>
    <url>/2023/01/19/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AB)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-八"><a href="#JS笔记之JS对象基础知识-八" class="headerlink" title="JS笔记之JS对象基础知识(八)"></a>JS笔记之JS对象基础知识(八)</h1><h2 id="1-对象原始值的转换"><a href="#1-对象原始值的转换" class="headerlink" title="1 对象原始值的转换"></a>1 对象原始值的转换</h2><p>当对象相加或者相减时，使用 alert(obj) 打印会输出什么？</p>
<p>JS不允许自定义运算符对对象的处理方式，我们无法实现特殊的对象处理方法来处理加法或者是其他的运算。</p>
<p>在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值，这是一个重要的限制：因为 <code>obj1 + obj2</code>（或者其他数学运算）的结果不能是另一个对象！</p>
<p>例如我们无法使用对象来表示向量或者是矩阵，或者是成就或者其他。</p>
<p>因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。</p>
<p>对象如何转换为原始值，以及如何对其进行自定义。</p>
<h3 id="1-1-转换规则"><a href="#1-1-转换规则" class="headerlink" title="1.1 转换规则"></a>1.1 转换规则</h3><ul>
<li>没有转换为布尔值，所有的对象在布尔值上下文中均为<code>true</code>，只有字符串和数字转换。</li>
<li>数字转换发生在对象相减或应用数学函数时，例如Date对象可以相减，date1-date2 的结果是两个日期之间的差值。</li>
<li>对于字符串转换，通常发生在我们像alert(obj)这样输出一个对象和类似的上下文中。</li>
</ul>
<p>我们可以使用特殊的对象方法，实现字符串和数字的转换。</p>
<h3 id="1-2-hint定义"><a href="#1-2-hint定义" class="headerlink" title="1.2 hint定义"></a>1.2 hint定义</h3><p>类型转换在各种情况下有三种变体，他们被称为hint.</p>
<h4 id="1-2-1-String"><a href="#1-2-1-String" class="headerlink" title="1.2.1 String"></a>1.2.1 String</h4><p>对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 “alert”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">alert(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象作为属性键</span></span><br><span class="line">anotherObj[obj] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


<h4 id="1-2-2-Number"><a href="#1-2-2-Number" class="headerlink" title="1.2.2 Number"></a>1.2.2 Number</h4><p>对象到数字的转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式转换</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Number</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学运算（除了二元加法）</span></span><br><span class="line"><span class="keyword">let</span> n = +obj; <span class="comment">// 一元加法</span></span><br><span class="line"><span class="keyword">let</span> delta = date1 - date2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于/大于的比较</span></span><br><span class="line"><span class="keyword">let</span> greater = user1 &gt; user2;</span><br></pre></td></tr></table></figure>
<p>大多数内建的数学函数也包括这种转换。</p>
<h4 id="1-2-3-default"><a href="#1-2-3-default" class="headerlink" title="1.2.3 default"></a>1.2.3 default</h4><p>当运算符 “不确定” 期望值的类型时。在极少数情况下发生。</p>
<p>例如二元加法 <code>+</code> 可用于字符串的拼接，也可用于数字的相加，因此当二元加法得到对象类型的参数时，他将依据 <code>default</code> hint 来对其进行转换。</p>
<p>此外如果对象被用于与字符串、数字、或者symbol进行<code>==</code>比较，这时候他进行那种类型转换也不熟很明确，因此使用 <code>default</code> hint。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二元加法使用默认 hint</span></span><br><span class="line"><span class="keyword">let</span> total = obj1 + obj2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj == number 使用默认 hint</span></span><br><span class="line"><span class="keyword">if</span> (user == <span class="number">1</span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-转换方法"><a href="#1-3-转换方法" class="headerlink" title="1.3 转换方法"></a>1.3 转换方法</h3><p><strong>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</strong></p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> —— 带有 symbol 键 <code>Symbol.toPrimitive</code>（系统 symbol）的方法，如果这个方法存在的话，</li>
<li>否则，如果 hint 是 <code>&quot;string&quot;</code> —— 尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li>
<li>否则，如果 hint 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> —— 尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li>
</ol>
<h4 id="1-3-1-Symbol-toPrimitive"><a href="#1-3-1-Symbol-toPrimitive" class="headerlink" title="1.3.1 Symbol.toPrimitive"></a>1.3.1 Symbol.toPrimitive</h4><p>他是被用来给转换方法命名。如果它存在则他会被用于所有的hint。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是将此对象转换为原始值的代码</span></span><br><span class="line">  <span class="comment">// 它必须返回一个原始值</span></span><br><span class="line">  <span class="comment">// hint = &quot;string&quot;、&quot;number&quot; 或 &quot;default&quot; 中的一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-3-2-toString-valueOf"><a href="#1-3-2-toString-valueOf" class="headerlink" title="1.3.2 toString/valueOf"></a>1.3.2 toString/valueOf</h4><p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试寻找 <code>toString</code> 和 <code>valueOf</code> 方法：</p>
<ul>
<li>对于 <code>&quot;string&quot;</code> hint：调用 <code>toString</code> 方法，如果它不存在，则调用 <code>valueOf</code> 方法（因此，对于字符串转换，优先调用 <code>toString</code>）。</li>
<li>对于其他 hint：调用 <code>valueOf</code> 方法，如果它不存在，则调用 <code>toString</code> 方法（因此，对于数学运算，优先调用 <code>valueOf</code> 方法）。</li>
</ul>
<p>这些方法必须返回一个原始值。如果 <code>toString</code> 或 <code>valueOf</code> 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p>
<p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p>
<ul>
<li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li>
<li><code>valueOf</code> 方法返回对象自身。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">// [object Object]</span></span><br><span class="line">alert(user.valueOf() === user); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<p>所以如果我们将一个对象当做字符串来使用，例如 alerty(obj) 将会得到<code>[object Object]</code>。</p>
<h3 id="1-4-自定义转化方法"><a href="#1-4-自定义转化方法" class="headerlink" title="1.4 自定义转化方法"></a>1.4 自定义转化方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  money: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;string&quot;</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;name: &quot;<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>&quot;&#125;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span></span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span></span><br><span class="line">alert(+user); <span class="comment">// valueOf -&gt; 1000</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// valueOf -&gt; 1500</span></span><br></pre></td></tr></table></figure>


<p>通常我们希望一个全能的地方来处理所有的原始转换。可以只实现toString 来实现。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(user); <span class="comment">// toString -&gt; John</span></span><br><span class="line">alert(user + <span class="number">500</span>); <span class="comment">// toString -&gt; John500</span></span><br></pre></td></tr></table></figure>
<p>如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换。</p>
<h3 id="1-5-转换可以返回任何原始类型"><a href="#1-5-转换可以返回任何原始类型" class="headerlink" title="1.5 转换可以返回任何原始类型"></a>1.5 转换可以返回任何原始类型</h3><p>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p>
<p>没有限制 <code>toString()</code> 是否返回字符串，或 <code>Symbol.toPrimitive</code> 方法是否为 <code>&quot;number&quot;</code> hint 返回数字。</p>
<p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p>
<blockquote>
<p>Tips：由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p>
<p>相反，<code>Symbol.toPrimitive</code> 更严格，它 <strong>必须</strong> 返回一个原始值，否则就会出现 error。</p>
</blockquote>
<h3 id="1-6-进一步的转换"><a href="#1-6-进一步的转换" class="headerlink" title="1.6 进一步的转换"></a>1.6 进一步的转换</h3><p>许多运算符和函数执行类型转换， 例如乘法，将操作数转化为数字。</p>
<p>如果我们将对象作为参数传递，则会出现两个运算阶段：</p>
<ol>
<li>对象被转化为原始值。根据上面转化的规则。</li>
<li>如果还需进一步计算。则生成的原始值会进一步的转换。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="comment">// toString 在没有其他方法的情况下处理所有转换</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj * <span class="number">2</span>); <span class="comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。</span></span><br></pre></td></tr></table></figure>
<p>比如上面的例字：</p>
<ol>
<li>乘法 <code>obj * 2</code> 首先将对象转换为原始值（字符串 “2”）。</li>
<li>之后 <code>&quot;2&quot; * 2</code> 变为 <code>2 * 2</code>（字符串被转换为数字）。</li>
</ol>
<h3 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h3><p>对象到原始值的转换，是自动触发的。</p>
<p>有三种类型的hint：</p>
<ul>
<li>“string” 对于 alert 和其他需要字符串的操作。</li>
<li>“number” 对于数学运算。</li>
<li>“default” 少数运算符，通常对象已和 “number” 相同的方式实现 default 转换。</li>
</ul>
<p>规范明确描述了哪个运算符使用哪个 hint。</p>
<p>转换算法是：</p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</li>
<li>否则，如果 hint 是 “string”<ul>
<li>尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li>
</ul>
</li>
<li>否则，如果 hint 是 “number” 或者 “default”<ul>
<li>尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li>
</ul>
</li>
</ol>
<p>所有这些方法都必须返回一个原始值才能工作（如果已定义）。</p>
<p><strong>在实际使用中，通常只实现 <code>obj.toString()</code> 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(七)</title>
    <url>/2023/01/18/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%83)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-七"><a href="#JS笔记之JS对象基础知识-七" class="headerlink" title="JS笔记之JS对象基础知识(七)"></a>JS笔记之JS对象基础知识(七)</h1><h2 id="1-symbol类型"><a href="#1-symbol类型" class="headerlink" title="1 symbol类型"></a>1 symbol类型</h2><p>根据规范，对象的关键字数据类型只有两种，字符串和symbol类型，如果使用数字或者 true会自动转化为字符串类型。</p>
<h3 id="1-1-symbol定义"><a href="#1-1-symbol定义" class="headerlink" title="1.1 symbol定义"></a>1.1 symbol定义</h3><p>symbol表示唯一的标识符，可以使用Symbol()来创建这种类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure>
<p>创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id 是描述为 &quot;id&quot; 的 symbol</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-使用Symbol"><a href="#1-2-使用Symbol" class="headerlink" title="1.2 使用Symbol"></a>1.2 使用Symbol</h3><p>在JS中大多数数值都支持字符串的隐士转换，但Symbol不会被自动转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-显示Symbol"><a href="#1-3-显示Symbol" class="headerlink" title="1.3 显示Symbol"></a>1.3 显示Symbol</h3><p>如果要显示一个Symbol，需要使用toString()，或者获取<code>symbol.description</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">alert(id.toString()); <span class="comment">// Symbol(id)，现在它有效了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">alert(id.description); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>


<h3 id="1-4-隐藏属性"><a href="#1-4-隐藏属性" class="headerlink" title="1.4 隐藏属性"></a>1.4 隐藏属性</h3><p>Symbol 允许我们创建对象的隐藏属性，代码的任何其他的部分都不能访问后者重写这些属性。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="comment">// 属于另一个代码</span></span><br><span class="line">  name: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">user[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">alert( user[id] ); <span class="comment">// 我们可以使用 symbol 作为键来访问数据</span></span><br></pre></td></tr></table></figure>
<p>这样写的好处就是：因为<code>user</code> 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 <code>user</code> 对象是安全的。</p>
<h3 id="1-5-对象字面量中的-symbol"><a href="#1-5-对象字面量中的-symbol" class="headerlink" title="1.5 对象字面量中的 symbol"></a>1.5 对象字面量中的 symbol</h3><p>在通过字面量创建对象时，需要使用方括号把它括起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  [id]: <span class="number">123</span> <span class="comment">// 而不是 &quot;id&quot;：123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：Symbol 属性会在for..in 中被跳过。</p>
<p>Object.keys(user) 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p>
<p>但是 <strong>Object.assign</strong> 会同时复制字符串和Symbol属性。</p>
</blockquote>
<h3 id="1-6-全局Symbol"><a href="#1-6-全局Symbol" class="headerlink" title="1.6 全局Symbol"></a>1.6 全局Symbol</h3><p>通常所有的Symbol都是不同的对象，即使他们有相同的名字。但是有时候我们想要相同名字的symbol具有相同的实体，例如应用程序的不同部分想要访问的symbol 指的是完全相同的属性。</p>
<p>在JS中有一个全局的Symbol注册表，可以创建并在全局访问他们，可以确保每次访问相同名字的symbol返回的都是相同的Symbol。</p>
<h3 id="1-7-Symbol-for-key"><a href="#1-7-Symbol-for-key" class="headerlink" title="1.7 Symbol.for(key)"></a>1.7 Symbol.for(key)</h3><p>key 为Symbol的描述。从注册表读取并创建symbol， 读取时如果不存在自动创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从全局注册表中读取</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>); <span class="comment">// 如果该 symbol 不存在，则创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同的 symbol</span></span><br><span class="line">alert( id === idAgain ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注册表内的Symbol被称为全局Symbol，如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 ——这就是它们的用途。</p>
<h3 id="1-8-Symbol-keyFor-key"><a href="#1-8-Symbol-keyFor-key" class="headerlink" title="1.8 Symbol.keyFor(key)"></a>1.8 Symbol.keyFor(key)</h3><p>可以根据Symbol的变量名返回Symbol的描述。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 name 获取 symbol</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>.for(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 symbol 获取 name</span></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(sym) ); <span class="comment">// name</span></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(sym2) ); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>
<p>Symbol.keyFor使用全局注册表来查找symbol的键，所以它不适用于非全局的Symbol，如果Symbol不是全局的他将无法找回并返回Undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(globalSymbol) ); <span class="comment">// name，全局 symbol</span></span><br><span class="line">alert( <span class="built_in">Symbol</span>.keyFor(localSymbol) ); <span class="comment">// undefined，非全局</span></span><br><span class="line"></span><br><span class="line">alert( localSymbol.description ); <span class="comment">// name</span></span><br></pre></td></tr></table></figure>
<h3 id="1-9-系统Symbol"><a href="#1-9-系统Symbol" class="headerlink" title="1.9 系统Symbol"></a>1.9 系统Symbol</h3><p>JS内部有许多的系统Symbol，我们可以用他们来微调对象的各个方面。在<a href="https://tc39.es/ecma262/#sec-well-known-symbols">symbol列表</a>中找到。</p>
<h3 id="1-10-总结"><a href="#1-10-总结" class="headerlink" title="1.10 总结"></a>1.10 总结</h3><ul>
<li><p><code>symbol</code> 是唯一标识符的基本类型</p>
</li>
<li><p>symbol 是使用带有可选描述（name）的 <code>Symbol()</code> 调用创建的。</p>
</li>
<li><p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回（如果需要的话则创建）一个以 <code>key</code> 作为名字的全局 symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 symbol 时，返回的就是同一个 symbol。</p>
</li>
</ul>
<p>symbol 有两个主要的使用场景：</p>
<ol>
<li><p>“隐藏” 对象属性。</p>
<p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
<p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
</li>
<li><p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内建行为。例如：使用 <code>Symbol.iterator</code> 来进行 <a href="https://zh.javascript.info/iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a href="https://zh.javascript.info/object-toprimitive">对象原始值的转换</a> 等等。</p>
</li>
</ol>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(六)</title>
    <url>/2023/01/18/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%85%AD)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-六"><a href="#JS笔记之JS对象基础知识-六" class="headerlink" title="JS笔记之JS对象基础知识(六)"></a>JS笔记之JS对象基础知识(六)</h1><h2 id="1-可选链-“-”"><a href="#1-可选链-“-”" class="headerlink" title="1 可选链 “?.”"></a>1 可选链 “?.”</h2><p>可选链<code>?.</code>是一种访问嵌套对象属性的安全的方式，即使中间的属性不存在，也不会出现错误。</p>
<h3 id="1-1-“不存在的属性”的问题"><a href="#1-1-“不存在的属性”的问题" class="headerlink" title="1.1 “不存在的属性”的问题"></a>1.1 “不存在的属性”的问题</h3><p>例如在一个嵌套的对象中，我们获取user对象的address对象的street属性，但是实际上user是一个空对象，此时JS会返回错误，这是正常的返回，但是有时候我们需要的不抛出异常，而是返回<code>undefined</code>，表示user对象的address对象没有该属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span></span><br><span class="line"></span><br><span class="line">alert(user.address.street); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>
<p>又或者是我们获取htmlDOM元素得时候，获取某个元素的 innerHTML 属性，如果获取不到该元素，也会抛出一个异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 如果 <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.elem&#x27;</span>) 的结果为 <span class="literal">null</span>，则这里不存在这个元素</span><br><span class="line"><span class="keyword">let</span> html = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.elem&#x27;</span>).innerHTML; <span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-如何去避免这一问题呢？"><a href="#1-2-如何去避免这一问题呢？" class="headerlink" title="1.2 如何去避免这一问题呢？"></a>1.2 如何去避免这一问题呢？</h3><p>可能比较容易想到的方法就是获取到该对象以后，使用三元运算符进行比较：<code>user.address ? user.address.street : undefined</code>，但是<code>user.address</code>重复出现，如果对象之间如果嵌套的更深，代码则会有大量重复。</p>
<p>还有一个方法是使用<code>&amp;&amp;</code>运算符，但是任然会有 大量的代码重复。使用可选链就可以解决该问题。</p>
<h3 id="1-3-可选链语法"><a href="#1-3-可选链语法" class="headerlink" title="1.3 可选链语法"></a>1.3 可选链语法</h3><p>如果可选链<code>?.</code>前面的值为<code>undefined</code>和<code>null</code> 它会停止运算，并且返回<code>ubdefined</code>。</p>
<p>例如<code>value?.pop</code>:</p>
<ul>
<li>如果value存在，则结果与value.pop 属性值相同。</li>
<li>如果当value的是undefined和null时，则返回undefined。</li>
</ul>
<p>比如使用这种方式访问上面的 <code>user.address.street</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( user?.address?.street ); <span class="comment">// undefined（不报错）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips：<code>?.</code>使其前面（左边）的值成为可选值，但不会对后面的值起作用。</p>
</blockquote>
<blockquote>
<p><strong>不要过度使用可选链</strong></p>
<p>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</p>
<p>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</p>
<p>那么，如果 <code>user</code> 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</p>
</blockquote>
<blockquote>
<p><strong><code>?.</code> 前的变量必须已声明</strong></p>
<p>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误。可选链仅适用于已声明的变量。</p>
</blockquote>
<h3 id="1-4-可选链的短路效应"><a href="#1-4-可选链的短路效应" class="headerlink" title="1.4 可选链的短路效应"></a>1.4 可选链的短路效应</h3><p>即可选链的左边不存在，就会立刻停止运行（短路效应）。因此如果在<code>?.</code>的右侧有任何下一步的操作都不会执行。</p>
<h3 id="1-5-可选链的变体："><a href="#1-5-可选链的变体：" class="headerlink" title="1.5 可选链的变体：?.[] ?.()"></a>1.5 可选链的变体：?.[] ?.()</h3><p>可选链不是一个运算符，而是一中特殊的语法结构，他还可以与函数以及方括号一起使用。</p>
<p>例如<code>?.()</code>调用一个可能不存在的函数。在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userAdmin = &#123;</span><br><span class="line">  <span class="function"><span class="title">admin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;I am admin&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userGuest = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">userAdmin.admin?.(); <span class="comment">// I am admin</span></span><br><span class="line"></span><br><span class="line">userGuest.admin?.(); <span class="comment">// 啥都没发生（没有这样的方法）</span></span><br></pre></td></tr></table></figure>
<p>使用方括号获取属性的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;firstName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">alert( user1?.[key] ); <span class="comment">// John</span></span><br><span class="line">alert( user2?.[key] ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>此外还可以将<code>?.</code>和 <code>delete</code>一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> user?.name; <span class="comment">// 如果 user 存在，则删除 user.name</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>Tips：需要注意的是可选链可以进行安全的读取和删除，但是不能进行写入。可选链不能用在赋值语句的左边。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">user?.name = <span class="string">&quot;John&quot;</span>; <span class="comment">// Error，不起作用</span></span><br><span class="line"><span class="comment">// 因为它在计算的是：undefined = &quot;John&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p>可选链的语法格式有大概几种：</p>
<ul>
<li>obj?.prop    —&gt; 如果obj存在则返回<code>obj.prop</code>如果不存在则返回<code>undefined</code>。</li>
<li>obj?.[prop]  —&gt; 如果obj存在则返回<code>obj.prop</code>如果不存在则返回<code>undefined</code>。、</li>
<li>obj.method?.()  —&gt; 如果<code>obj.method</code>存在则调用<code>obj.method()</code>，否则返回 <code>undefined</code>。</li>
</ul>
<p>我们应该谨慎的使用<code>?.</code>，根据我们的代码逻辑，仅在当做部分不存在的可接受的条件下使用最好。且该语法格式是JS新出的特性，可能会存在兼容问题，旧式浏览器可能需要 polyfills。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(五)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%94)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-五"><a href="#JS笔记之JS对象基础知识-五" class="headerlink" title="JS笔记之JS对象基础知识(五)"></a>JS笔记之JS对象基础知识(五)</h1><h2 id="1-构造器和操作符new"><a href="#1-构造器和操作符new" class="headerlink" title="1 构造器和操作符new"></a>1 构造器和操作符new</h2><p>创建对象可以使用字面量的方式：{} 也可以使用new操作符，相较于字面量创建对象的方式，new操作符能够方面的创建许多类似的对象，例如多个用户和菜单对象。</p>
<h3 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h3><p>构造函数在技术上是常规函数，只是有两个约定：</p>
<ul>
<li>他的命名都是一大写字母开头。</li>
<li>只能有<code>new</code>操作符来执行。</li>
</ul>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// Jack</span></span><br><span class="line">alert(user.isAdmin); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-构造器的执行步骤："><a href="#1-2-构造器的执行步骤：" class="headerlink" title="1.2 构造器的执行步骤："></a>1.2 构造器的执行步骤：</h3><ol>
<li>一个新的空对象被创建并分配给this。</li>
<li>函数体执行，通常他会修改<code>this</code>,并为其添加新的属性。</li>
<li>返回<code>this</code>的值。</li>
</ol>
<p>总的来说 new User(…) 做的就是如下的事情：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123;</span><br><span class="line">    name:<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    isAdmin:<span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以 user1 和 user2 的结果是相通的对象。</span></span><br></pre></td></tr></table></figure>
<p>所以接下来我们创建新的对象，就可以使用 <code>new User(&#39;Alice&#39;)</code> <code>new User(&#39;Ann&#39;)</code>等， 要比每次都是用字面量要更与阅读。</p>
<p><strong>这就是构造起的主要目的：实可重用的对象创建代码。</strong></p>
<p>从技术上将，除了箭头函数以外，任何函数都可以用作构造器，即可以通过<code>new</code>来运行，他会执行上面的构造器的执行步骤。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>
<p>封装构建单个对象的代码的技巧：</p>
<p>如果有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数并立即使用 new 调用它</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.isAdmin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……用于用户创建的其他代码</span></span><br><span class="line">  <span class="comment">// 也许是复杂的逻辑和语句</span></span><br><span class="line">  <span class="comment">// 局部变量等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个构造函数不能被再次调用，因为他不保存在任何地方，只是被创建和调用。</p>
<h3 id="1-3-构造器模式测试：new-target"><a href="#1-3-构造器模式测试：new-target" class="headerlink" title="1.3 构造器模式测试：new.target"></a>1.3 构造器模式测试：new.target</h3><p>在一个函数内部我们是可以使用new.target 属性来检查他是否被使用new调用了。对于常规调用，它是 undefined, 但是对于new的调用，则等于该函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带 &quot;new&quot;：</span></span><br><span class="line">User(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 &quot;new&quot;：</span></span><br><span class="line"><span class="keyword">new</span> User(); <span class="comment">// function User &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>
<p>主要的使用方式：被使用在函数的内部，来判断该函数是被通过new调用的构造器模式，还是常规模式；也可以让new调用和常规调用最相同的工作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123; <span class="comment">// 如果你没有通过 new 运行我</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(name); <span class="comment">// ……我会给你添加 new</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = User(<span class="string">&quot;John&quot;</span>); <span class="comment">// 将调用重定向到新用户</span></span><br><span class="line">alert(john.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>


<h3 id="1-4-构造起的return"><a href="#1-4-构造起的return" class="headerlink" title="1.4 构造起的return"></a>1.4 构造起的return</h3><p>通常构造器没有return，他们的任务是将所有必须要写入的东西写入到this，并自动转化为结果，但是如果有return语句就会有不同的规则：</p>
<ul>
<li>如果返回的是一个对象，怎返回这个对象，不返回this。</li>
<li>如果返回的是一个原始类型，则忽略。</li>
</ul>
<p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BigUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;Godzilla&quot;</span> &#125;;  <span class="comment">// &lt;-- 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> BigUser().name );  <span class="comment">// Godzilla，得到了那个对象</span></span><br></pre></td></tr></table></figure>
<p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmallUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// &lt;-- 返回 this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( <span class="keyword">new</span> SmallUser().name );  <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>Tips：构造函数没有参数，可以在被new调用的时候可以省略参数。（这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User; <span class="comment">// &lt;-- 没有参数</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>
<p>使用构造函数来创建对象会带来很大的灵活性。构造函数可以传入一些参数，又或者是一些方法。使创建的对象更加灵活。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><ul>
<li>构造函数或者简称构造器，就是常规函数，只不过对他有着共同的约定，就是首字母大写。</li>
<li>构造函数只能使用<code>new</code>来调用，这样就意味着在创建了一个空的对象<code>this</code>, 并且最后返回了这个<code>this</code>。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(四)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%9B%9B)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-四"><a href="#JS笔记之JS对象基础知识-四" class="headerlink" title="JS笔记之JS对象基础知识(四)"></a>JS笔记之JS对象基础知识(四)</h1><h2 id="1-对象方法，this"><a href="#1-对象方法，this" class="headerlink" title="1 对象方法，this"></a>1 对象方法，this</h2><p>通常创建对象来表示显示世界中的实体，比如用户或者订单。在现实世界中用户可以进行操作，比如登录注销，往购物车中添加商品。</p>
<p>在JS中 行为（action）由属性中的函数表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi(); <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们给<code>user</code>对象的<code>sayHi</code>属性赋值了一个函数，这种对象的属性的函数被称为对象的方法。</p>
<p><strong>通常，全局中定义的函数称之为函数，对象中的属性是函数的话称之为方法。</strong></p>
<p><strong>我们在代码中使用对象表示实体时，这就是所谓的面向对象编程，简称OOP。</strong></p>
<h3 id="1-1-方法简写"><a href="#1-1-方法简写" class="headerlink" title="1.1 方法简写"></a>1.1 方法简写</h3><p>方法还有一个简写的方式 （可能会在继承层面会有些微的差别）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些对象作用一样</span></span><br><span class="line"></span><br><span class="line">user = &#123;</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;		</span><br><span class="line">    alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写看起来更好，对吧？</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span></span><br><span class="line">    alert(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="1-2-方法中的this"><a href="#1-2-方法中的this" class="headerlink" title="1.2 方法中的this"></a>1.2 方法中的this</h3><p>通常对象的方法可能需要访问对象的其他的属性，为了访问改对象，在方法中可以使用<code>this</code>这个关键字。<code>this</code>的值就是在点之前（<strong>object</strong>.attr）的这个对象，即调用该方法的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;this&quot; 指的是“当前的对象”</span></span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>同样也可以使用这种方式访问到user的name属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    alert( user.name ); <span class="comment">// 导致错误</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是上述例子有一个明显的问题：如果给user重新赋值，那将访问到错误的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line">user = <span class="literal">null</span>; <span class="comment">// 重写让其更明显</span></span><br><span class="line"></span><br><span class="line">admin.sayHi(); <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of null</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-this-不受限制"><a href="#1-3-this-不受限制" class="headerlink" title="1.3 this 不受限制"></a>1.3 this 不受限制</h3><p>在JS中，<code>this</code>关键字可以用于任何函数，即使他不是对象的方法。 下面这样写也不会错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="built_in">this</span>.name );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以不回错误，是因为<code>this</code>的值是计算出来的，它取决于代码的上下文。例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="built_in">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在两个对象中使用相同的函数</span></span><br><span class="line">user.f = sayHi;</span><br><span class="line">admin.f = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个调用有不同的 this 值</span></span><br><span class="line"><span class="comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span></span><br><span class="line">user.f(); <span class="comment">// John（this == user）</span></span><br><span class="line">admin.f(); <span class="comment">// Admin（this == admin）</span></span><br><span class="line"></span><br><span class="line">admin[<span class="string">&#x27;f&#x27;</span>](); <span class="comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure>
<p>严格模式下，在没有对象的情况下调用：<code>this === undefined</code>，在非严格模式下，<code>this</code>是 全局对象，（浏览器中的Window）。通常这种调用是程序出错了。如果在一个函数内部有 <code>this</code>，那么通常意味着它是在对象上下文环境中被调用的</p>
<p><strong>在JS中<code>this</code>是自由的，他的值是实时计算出来的，他的值并不取决于方法声明的位置，而是取决于在“点符号之前”的是什么对象。</strong></p>
<p><strong>在运行时对<code>this</code>求值的这个概念优优点也有缺点，一方面函数可以被重用于不同的对象，另一方面更大的灵活性造成了更大的出错的可能性。</strong></p>
<p>箭头函数没有自己的this</p>
<p>箭头函数有些特别：它们没有自己的 <code>this</code>。这是箭头函数的一个特性，当我们并不想要一个独立的 <code>this</code>，反而想从外部上下文中获取时，它很有用。</p>
<h3 id="1-4-总结："><a href="#1-4-总结：" class="headerlink" title="1.4 总结："></a>1.4 总结：</h3><ul>
<li>存储在对象属性中的函数被称为方法。</li>
<li>方法允许对对像进行类似 obj.dosomething() 这样的操作。</li>
<li>方法可以将对象引用为<code>this</code>。</li>
<li><code>this</code>的值是在程序运行时得到的。</li>
<li>一个函数在运行时可能就定义了<code>this</code>，但是这个<code>this</code>只有在函数被调用时才会有值。</li>
<li>可以在对象之间复制函数。（不太懂）</li>
<li>以方法的语法调用函数时，<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li>
<li>箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(三)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%89)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-三"><a href="#JS笔记之JS对象基础知识-三" class="headerlink" title="JS笔记之JS对象基础知识(三)"></a>JS笔记之JS对象基础知识(三)</h1><h2 id="1-垃圾回收"><a href="#1-垃圾回收" class="headerlink" title="1 垃圾回收"></a>1 垃圾回收</h2><p>对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。</p>
<h3 id="1-1-什么是垃圾？"><a href="#1-1-什么是垃圾？" class="headerlink" title="1.1 什么是垃圾？"></a>1.1 什么是垃圾？</h3><p>在JS引擎运行时，我们创建的一些原始值、对象，经过使用之后就没有就再也没有使用过，这些个原始值，或者对象都是垃圾。</p>
<h3 id="1-2-有哪些垃圾？"><a href="#1-2-有哪些垃圾？" class="headerlink" title="1.2 有哪些垃圾？"></a>1.2 有哪些垃圾？</h3><p>任何变量或者对象在未来的程序运行中总不会被访问的b变量和对象都是垃圾。</p>
<h3 id="1-3-什么是垃圾回收？"><a href="#1-3-什么是垃圾回收？" class="headerlink" title="1.3 什么是垃圾回收？"></a>1.3 什么是垃圾回收？</h3><p>JS对内存管理的一种手段。</p>
<h3 id="1-4-为什么垃圾回收？"><a href="#1-4-为什么垃圾回收？" class="headerlink" title="1.4 为什么垃圾回收？"></a>1.4 为什么垃圾回收？</h3><p>释放内存，节约资源。</p>
<h3 id="1-5-如何垃圾回收？"><a href="#1-5-如何垃圾回收？" class="headerlink" title="1.5 如何垃圾回收？"></a>1.5 如何垃圾回收？</h3><p>JS中的内存管理概念<strong>可达性</strong>，就是能够通过某种凡是访问到的值，他们一定是存在于内存中的。</p>
<p>比如一些明显的可达的值：</p>
<ul>
<li>当前执行的函数，他的局部变量和参数。</li>
<li>当前嵌套调用链上的其他的函数，他们的局部变量和函数。</li>
<li>全局变量</li>
<li>一些内部的对象</li>
</ul>
<p>一个值可以通过引用链从根访问任何其他值，则认为该值也是可达的。</p>
<p>一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user 具有对这个对象的引用</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/tc/image-20230117154427386.png" alt="image-20230117154427386"></p>
<p>user 指的的时这个 Object的对象的引用，全局变量 <code>&quot;user&quot;</code> 引用了对象 <code>&#123;name：&quot;John&quot;&#125;</code>。</p>
<p>如果 user 被重写，赋予了其他的值，那么这个引用就没了，</p>
<p><img src="https://origin.chaizz.com/tc/image-20230117155148312.png" alt="image-20230117155148312"></p>
<p>现在这个 Object 变成不可达的了，垃圾收集器就会将它视为垃圾，然后进行回收。</p>
<p>垃圾回收的内部算法：</p>
<ol>
<li>垃圾收集器找到所有的根并标记它们。</li>
<li>然后它遍历并标记来自它的引用。</li>
<li>然后他遍历标记的对象并标记它们额的引用，所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>循环操作直到所有可达的对象都被访问到并标记。</li>
<li>没有被标记的测会被删除。</li>
</ol>
<p>JS 引擎对垃圾回收做了优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。</p>
<h3 id="1-6-一些优化建议："><a href="#1-6-一些优化建议：" class="headerlink" title="1.6 一些优化建议："></a>1.6 一些优化建议：</h3><ul>
<li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</li>
<li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</li>
<li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(二)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%8C)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-二"><a href="#JS笔记之JS对象基础知识-二" class="headerlink" title="JS笔记之JS对象基础知识(二)"></a>JS笔记之JS对象基础知识(二)</h1><h2 id="1-对象的引用和复制"><a href="#1-对象的引用和复制" class="headerlink" title="1 对象的引用和复制"></a>1 对象的引用和复制</h2><p>对象和原始类型（数字字符串布尔类型等）的区别就是对象是<strong>通过引用</strong> 存储和复制的，而原始类型总是作为一个整体复制。</p>
<h3 id="1-1-JS赋值时会发生什么？"><a href="#1-1-JS赋值时会发生什么？" class="headerlink" title="1.1 JS赋值时会发生什么？"></a>1.1 JS赋值时会发生什么？</h3><p>首先原始类型进行赋值时，message 和 phrase 是两个独立的变量。之间没有什么直接的关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> phrase = message;</span><br></pre></td></tr></table></figure>
<p>而对象不是这样的，一个对象被赋值给某个变量，这个变量存储的并不是对象的本身，而是这个对象的内存的地址。</p>
<p>就像一把钥匙对应一个柜子，这把钥匙可以对该柜子打开并添加、取走里面的内容，此时又根据这把钥匙重新配了一个一个钥匙，而新配的这把钥匙也能够打开这个柜子。 这两把钥匙都可以对这个柜子修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line"></span><br><span class="line">admin.name = <span class="string">&#x27;Pete&#x27;</span>; <span class="comment">// 通过 &quot;admin&quot; 引用来修改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user.name); <span class="comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到	</span></span><br></pre></td></tr></table></figure>
<p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p>
<h3 id="1-2-通过引用来比较"><a href="#1-2-通过引用来比较" class="headerlink" title="1.2 通过引用来比较"></a>1.2 通过引用来比较</h3><p>仅当两个对象为同一个对象时，两者才相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 复制引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a == b ); <span class="comment">// true，都引用同一对象</span></span><br><span class="line"><span class="built_in">console</span>.log( a === b ); <span class="comment">// true	</span></span><br></pre></td></tr></table></figure>
<p>而这里我们创建了两个空对象，看起来都是空的对象，但他们并不相等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;; <span class="comment">// 两个独立的对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a == b ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-克隆与合并"><a href="#1-3-克隆与合并" class="headerlink" title="1.3 克隆与合并"></a>1.3 克隆与合并</h3><p>如果想要复制一个全新对象，可以循环遍历原有的对象，然后建立新的对象并进行创建。</p>
<p>还可以使用 <code>Object.assign(dest, [src1, src2, src3...])</code> 来创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> permissions1 = &#123; <span class="attr">canView</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123; <span class="attr">canEdit</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span></span><br><span class="line"><span class="built_in">Object</span>.assign(user, permissions1, permissions2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果被拷贝的属性已经存在，怎会覆盖掉原有的属性。</p>
<p>以上的情况都是建立在对象的属性都是原始类型的情况下，但是有些对象可能包含其他的对象，如果使用<code>Object.assign()</code> 不会对深层的对象进行拷贝，而是引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  sizes: &#123;</span><br><span class="line">    height: <span class="number">182</span>,</span><br><span class="line">    width: <span class="number">50</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="built_in">Object</span>.assign(&#123;&#125;, user);</span><br><span class="line"></span><br><span class="line">alert( user.sizes === clone.sizes ); <span class="comment">// true，同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user 和 clone 分享同一个 sizes</span></span><br><span class="line">user.sizes.width++;       <span class="comment">// 通过其中一个改变属性值</span></span><br><span class="line">alert(clone.sizes.width); <span class="comment">// 51，能从另外一个获取到变更后的结果</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，并让 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。可以使用递归实现， 或者也可以使用现成的轮子， lodash 库的 <a href="https://lodash.com/docs/4.17.15#cloneDeep">_.cloneDeep(obj)</a>。</p>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p>
<p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。</p>
<p>为了创建“真正的拷贝”（一个克隆），我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS对象基础知识(一)</title>
    <url>/2023/01/17/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%B8%80)/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="JS笔记之JS对象基础知识-一"><a href="#JS笔记之JS对象基础知识-一" class="headerlink" title="JS笔记之JS对象基础知识(一)"></a>JS笔记之JS对象基础知识(一)</h1><p>js 对象是用来存储键值对或者更复杂的实体信息。</p>
<h2 id="1-创建空对象的两种方法"><a href="#1-创建空对象的两种方法" class="headerlink" title="1 创建空对象的两种方法"></a>1 创建空对象的两种方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// “构造函数” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;  <span class="comment">// “字面量” 的语法</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-创建对象"><a href="#1-1-创建对象" class="headerlink" title="1.1 创建对象"></a>1.1 创建对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;     <span class="comment">// 一个对象</span></span><br><span class="line">  name: <span class="string">&#x27;John&#x27;</span>,  <span class="comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span></span><br><span class="line">  age: <span class="number">30</span>,        <span class="comment">// 键 &quot;age&quot;，值 30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象属性的操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(user.age); <span class="comment">// 获取对象</span></span><br><span class="line">user.age = <span class="number">100</span>  <span class="comment">// 修改属性值</span></span><br><span class="line"><span class="keyword">delete</span> user.age <span class="comment">// 使用delete 删除对象的属性</span></span><br><span class="line">user.sex = <span class="string">&#x27;man&#x27;</span> <span class="comment">// 新增属性值</span></span><br></pre></td></tr></table></figure>
<p>创建对象也可以使用对个词语作为属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  <span class="string">&#x27;likes birds&#x27;</span>: <span class="literal">true</span>,  <span class="comment">// 多词属性名必须加引号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的最后一个属性应以逗号结尾，这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。</p>
<p>如果在对象中使用多词语属性，那么就不能使用【对象.属性】来获取对象的属性值， 必须使用方括号。</p>
<p>因为点符号要求是有效的变量标识符，所以不能包含空格、不以数字开头、也不包含特殊符号（除了<code>_</code>和<code>$</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(user[<span class="string">&quot;likes birds&quot;</span>]);</span><br></pre></td></tr></table></figure>


<h3 id="1-2-计算属性"><a href="#1-2-计算属性" class="headerlink" title="1.2 计算属性"></a>1.2 计算属性</h3><p>可以通获取变量来动态的创建对象属性，这叫做计算属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = prompt(<span class="string">&quot;Which fruit to buy?&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( bag.apple ); <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-3-属性值简写"><a href="#1-3-属性值简写" class="headerlink" title="1.3 属性值简写"></a>1.3 属性值简写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeUser</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    <span class="comment">// ……其他的属性</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = makeUser(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<p>在上述的例子中属性名和属性值一样，可以使用简写的形式，类似下面这种， 也可以进行混用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeUser</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name, <span class="comment">// 与 name: name 相同</span></span><br><span class="line">    age,  <span class="comment">// 与 age: age 相同</span></span><br><span class="line">    sex:<span class="string">&#x27;man&#x27;</span>, <span class="comment">// 简写与不简写混用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user = makeUser(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-属性名称限制"><a href="#1-4-属性名称限制" class="headerlink" title="1.4 属性名称限制"></a>1.4 属性名称限制</h3><p>在定义变量的时候， 我们不能使用js的一些和关键字保留字，但是在定义对象的属性时， 是可以使用的。所以对象的属性名是没有限制的，属性名可以是任意的字符串或者是symbol。例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;test&quot;</span> <span class="comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会输出相同的属性（数字 0 被转为字符串 &quot;0&quot;）</span></span><br><span class="line">alert( obj[<span class="string">&quot;0&quot;</span>] ); <span class="comment">// test</span></span><br><span class="line">alert( obj[<span class="number">0</span>] ); <span class="comment">// test (相同的属性)</span></span><br></pre></td></tr></table></figure>


<h3 id="1-5-属性存在性测试，-‘in’-操作符"><a href="#1-5-属性存在性测试，-‘in’-操作符" class="headerlink" title="1.5 属性存在性测试， ‘in’ 操作符"></a>1.5 属性存在性测试， ‘in’ 操作符</h3><p>在Python中获取一个对象的不存在的属性时会直接抛出异常，而js则不会，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_ex = &#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ex</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(dict_ex[<span class="string">&#x27;c&#x27;</span>])   <span class="comment"># 会直接提示  KeyError: &#x27;c&#x27;</span></span><br><span class="line">    Ex().c    <span class="comment"># 会直接提示  AttributeError: &#x27;Ex&#x27; object has no attribute &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">alert( user.noSuchProperty === <span class="literal">undefined</span> ); <span class="comment">// true 意思是没有这个属性</span></span><br></pre></td></tr></table></figure>
<p>检查属性是否存在的操作符 <code>&quot;in&quot;</code>，语法格式：<code>&#39;key&#39; in object</code> 例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">alert( <span class="string">&quot;age&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// true，user.age 存在</span></span><br><span class="line">alert( <span class="string">&quot;blabla&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// false，user.blabla 不存在。</span></span><br></pre></td></tr></table></figure>
<p>使用<code>in</code> 和使用<code>===undefined</code> 判断属性是否存在的区别，那就是当一个对象的属性存在，但是他的值恰好就是<code>undefined</code>， 此时使用 <code>===undefined</code> 就无法准确地判断对象属性是否存在（这种情况也少之又少）。</p>
<h3 id="1-6-for…in-循环"><a href="#1-6-for…in-循环" class="headerlink" title="1.6 for…in 循环"></a>1.6 for…in 循环</h3><p>主要用来遍历对象的所有的键。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="comment">// 对此对象属性中的每个键执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-7-对象有顺序吗？"><a href="#1-7-对象有顺序吗？" class="headerlink" title="1.7 对象有顺序吗？"></a>1.7 对象有顺序吗？</h3><p>有但不多，对像中的<strong>整数的属性</strong>会被排序，以升序排列，其他的属性会按照创建的顺序显示。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;49&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">  <span class="string">&quot;41&quot;</span>: <span class="string">&quot;Switzerland&quot;</span>,</span><br><span class="line">  <span class="string">&quot;44&quot;</span>: <span class="string">&quot;Great Britain&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;1&quot;</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(code); <span class="comment">// 1, 41, 44, 49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数属性的解释：这里的“整数属性”指的是一个可以在<strong>不做任何更改</strong>的情况下与一个整数进行相互转换的字符串，像是 “+49” 或者是 “1.3342” 就不行了。</p>
<p>所以为了解决以上的例子，能够按属性的定义顺序输出可以在属性名前加一个<code>+</code>号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;+49&quot;</span>: <span class="string">&quot;Germany&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+41&quot;</span>: <span class="string">&quot;Switzerland&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+44&quot;</span>: <span class="string">&quot;Great Britain&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;+1&quot;</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( +code ); <span class="comment">// 49, 41, 44, 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
































































]]></content>
      <categories>
        <category>JavaScript</category>
        <category>对象</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>VitePress搭建文档网站</title>
    <url>/2022/11/30/VitePress%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>​            </p>
<a id="more"></a>

<h1 id="VitePress搭建文档"><a href="#VitePress搭建文档" class="headerlink" title="VitePress搭建文档"></a>VitePress搭建文档</h1><blockquote>
<p>在VitePress官方文档中指明它是基于Vite构建的一个VuePress的小兄弟，同时也对VuePress存在的几个问题进行一些改进：</p>
<ul>
<li> 更快</li>
<li> 使用Vue3</li>
<li> 更加轻巧</li>
</ul>
</blockquote>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p><a href="https://vitejs.cn/vitepress/guide/getting-started.html">以下步骤来自官网</a></p>
<p><strong>步骤 1:</strong> 创建并进入一个目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkdir vitepress-starter &amp;&amp; <span class="built_in">cd</span> vitepress-starter</span><br></pre></td></tr></table></figure>
<p><strong>步骤 2:</strong> 初始化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn init</span><br></pre></td></tr></table></figure>
<p><strong>步骤 3:</strong> 本地安装 VitePress</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn add --dev vitepress</span><br></pre></td></tr></table></figure>
<p><strong>步骤 4:</strong> 创建你第一篇文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkdir docs &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;# Hello VitePress&#x27;</span> &gt; docs/index.md</span><br></pre></td></tr></table></figure>
<p><strong>步骤 5:</strong> 在 <code>package.json</code>.添加一些<code>script</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;docs:dev&quot;</span>: <span class="string">&quot;vitepress dev docs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;docs:build&quot;</span>: <span class="string">&quot;vitepress build docs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;docs:serve&quot;</span>: <span class="string">&quot;vitepress serve docs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤 6:</strong> 在本地服务器上启动文档站点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn docs:dev</span><br></pre></td></tr></table></figure>
<p>VitePress 会在 <code>http://localhost:5173 </code>启动一个热重载的开发服务器。</p>
<h2 id="二、设置基本信息"><a href="#二、设置基本信息" class="headerlink" title="二、设置基本信息"></a>二、设置基本信息</h2><p>进入项目根目录，在根目录中有一个 <code>docs</code> 文件夹，进入并创建 <code>.vitepress</code> 文件夹。在 <code>.vitepress</code> 文件夹中创建VitePress的配置文件 <code>config.js</code>。</p>
<p>目录结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>


<p>在配置文件中为网站设置相关信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;网站标题&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;网站介绍&#x27;</span>,</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        logo: <span class="string">&quot;/logo.svg&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>themeConfig.logo </code>配置可以配置网站首页的图标, 需要指定图标文件在公共文件夹下。即在 <code>docs</code> 文件夹下新建 <code>public</code> 文件，然后将 <code>logo.svg</code> 存放在此文件夹下。一些公共图片等也都可以放在此文件夹下。</p>
<p><img src="https://origin.chaizz.com/d963f51c709711edb4470242ac190002.png"></p>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>


<h2 id="三、设置导航栏"><a href="#三、设置导航栏" class="headerlink" title="三、设置导航栏"></a>三、设置导航栏</h2><p>在 <code>config.js</code> 中配置 <code>themeConfig.nav</code> 设置导航栏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;网站标题&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;网站介绍&#x27;</span>,</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        logo: <span class="string">&quot;/logo.svg&quot;</span>,</span><br><span class="line">        nav: [</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&quot;Guide&quot;</span>,</span><br><span class="line">                items: [</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 1&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-1&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 2&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-2&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 3&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-3&#x27;</span>&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>nav</code> 是一个数组，每个元素代表一个导航栏标签，标签有两个属性 <code>text</code> 和 <code>link</code> 。</p>
<p><code>text</code> ：标签名<code>link</code> ：跳转的url。也可以使用下拉导航栏，例如上面中的示例。此时 <code>link</code> 元素改为 <code>items</code>，在 <code>items</code> 中是每个标签的属性。导航栏相对应的跳转url, 是在 <code>docs</code> 文件夹下创建同名的文件夹。</p>
<p><strong>非下拉导航栏</strong>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nav: [</span><br><span class="line">    &#123;</span><br><span class="line">        text: &quot;Guide&quot;,</span><br><span class="line">        link: &quot;&#x2F;guide&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--guide</span><br><span class="line">|	|	|--index.md</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>
<p><strong>下拉导航栏</strong>格式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nav: [</span><br><span class="line">    &#123;</span><br><span class="line">        text: <span class="string">&quot;Guide&quot;</span>,</span><br><span class="line">        items: [</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 1&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-1&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 2&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-2&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 3&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-3&#x27;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--guide</span><br><span class="line">|	|	|--guide-<span class="number">1.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">2.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">3.</span>md</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>


<h2 id="四、设置侧边栏"><a href="#四、设置侧边栏" class="headerlink" title="四、设置侧边栏"></a>四、设置侧边栏</h2><p>在 <code>config.js</code> 中配置 <code>themeConfig.sidebar</code> 设置侧边栏。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    title: <span class="string">&#x27;网站标题&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;网站介绍&#x27;</span>,</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        logo: <span class="string">&quot;/logo.svg&quot;</span>,</span><br><span class="line">        nav: [</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&quot;Guide&quot;</span>,</span><br><span class="line">                items: [</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 1&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-1&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 2&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-2&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&#x27;guide 3&#x27;</span>, <span class="attr">link</span>: <span class="string">&#x27;/guide/guide-3&#x27;</span>&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        sidebar: [</span><br><span class="line">            &#123;</span><br><span class="line">                text: <span class="string">&quot;web&quot;</span>,</span><br><span class="line">                items: [</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&quot;js&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/js/&quot;</span>,&#125;,</span><br><span class="line">                    &#123;<span class="attr">text</span>: <span class="string">&quot;css&quot;</span>, <span class="attr">link</span>: <span class="string">&quot;/css/&quot;</span>&#125;,</span><br><span class="line">                ],</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>sidebar</code> 和 <code>nav</code> 设置方式一致，二级菜单使用 <code>items</code> 设置。</p>
<p>目录结构为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|--docs</span><br><span class="line">|	|--guide</span><br><span class="line">|	|	|--guide-<span class="number">1.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">2.</span>md</span><br><span class="line">|	|	|--guide-<span class="number">3.</span>md</span><br><span class="line">|	|--.vitepress</span><br><span class="line">|	|	|--config.js</span><br><span class="line">|	|--public</span><br><span class="line">|	|	|--logo.svg</span><br><span class="line">|	|--css</span><br><span class="line">|	|	|--index.md</span><br><span class="line">|	|--js</span><br><span class="line">|	|	|--index.md</span><br><span class="line">|	|--index.md</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>建站</category>
        <category>VitePress</category>
      </categories>
      <tags>
        <tag>VitePress</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Js事件</title>
    <url>/2022/10/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="事件冒泡及捕获"><a href="#事件冒泡及捕获" class="headerlink" title="事件冒泡及捕获"></a>事件冒泡及捕获</h1><p>js的事件冒泡和捕获是两种机制，主要描述一个元素上有两个相同类型的事件处理器被激活会发生什么。</p>
<p>例如该例子：<a href="https://github.com/mdn/learning-area/blob/main/javascript/building-blocks/events/show-video-box.html">源码</a></p>
<p>他显示和隐藏一个包含 <video> 元素的 <div> 元素。</div></video></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Display video<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.mp4&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.webm&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn&#x27;t support HTML video. Here is a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>link to the video<span class="tag">&lt;/<span class="name">a</span>&gt;</span> instead.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>当<code>button</code>元素按钮被单击时，他将显示视频，其实改变<code>div</code>的<code>class</code>属性值从<code>hidden</code>变<code>showing</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> videoBox = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayVideo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (videoBox.getAttribute(<span class="string">&#x27;class&#x27;</span>) === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">        videoBox.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;showing&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, displayVideo);</span><br></pre></td></tr></table></figure>
<p>当我们再添加几个<code>click</code>事件处理器，第一个添加在<code>&lt;div&gt;</code>元素上，第二个添加在<code>&lt;video&gt;</code>元素上。这个想法是当视频 (<code>&lt;video&gt;</code>）外 <code>&lt;div&gt;</code>元素内这块区域被单击时，这个视频盒子应该再次隐藏；当单击视频 (<code>&lt;video&gt;</code>）本身，这个视频将开始播放。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">videoBox.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> videoBox.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;hidden&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line"></span><br><span class="line">video.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> video.play());</span><br></pre></td></tr></table></figure>


<h2 id="1-问题就出现了"><a href="#1-问题就出现了" class="headerlink" title="1 问题就出现了"></a>1 问题就出现了</h2><p>当点击<code>video</code>开始播放视频时，<code>div</code>被隐藏， 这是因为<code>video</code>在<code>div</code>之内，所以点击<code>video</code>实际上也同时运行了<code>div</code>上的事件处理程序。</p>
<p>综合以上示例：</p>
<p>当一个事件发生在具有父元素的元素上（本例子的video元素）时，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。</p>
<p>在捕获阶段：</p>
<ul>
<li>浏览器检查元素的最外层祖先<code>html</code>，是否在捕获阶段中注册了一个onclick事件处理程序，如果是，则运行它。</li>
<li>然后，他移动到<code>html</code>中点击元素的下一个祖先元素，并执行相同的操作，接下来是点击元素再下一个祖先元素，以此类推，直到到达实际点击的元素。</li>
</ul>
<p>在冒泡阶段恰恰相反：</p>
<ul>
<li>浏览器检查实际点击的元素是否在冒泡阶段中注册了一个<code>onclick</code>事件处理程序，如果是，则运行它。</li>
<li>然后他移动到下一个直接的祖先元素，并做同样的事情，再到下一个祖先元素，直到他到达<code>html</code>元素。</li>
</ul>
<p><strong>在现代浏览器中，默认情况下，所有的时间处理程序，都是在冒泡阶段进行注册。</strong> 因此上述例子当我们点击视频时，这个单击事件从<code>video</code>元素向外冒泡直到<code>html</code>元素，沿着这个事件冒泡线路：</p>
<ul>
<li>首先发现了<code>video.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>第一次开始播放。</li>
<li>接着还发现了<code>videoBox.onclick...</code>事件处理器并且运行它，因此这个视频<code>&lt;video&gt;</code>也隐藏起来了。</li>
</ul>
<h2 id="2-解决方法："><a href="#2-解决方法：" class="headerlink" title="2 解决方法："></a>2 解决方法：</h2><p>标准事件对象具有可用的名为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>stopPropagation()</code></a>的函数，当在事件对象上调用该函数时，它只会让当前事件处理程序运行，但事件不会在<strong>冒泡</strong>链上进一步扩大，因此将不会有更多事件处理器被运行 (不会向上冒泡)。所以，我们可以通过改变前面代码块中的第二个处理函数来解决当前的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line">video.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> video.play());</span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">video.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    video.play();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>注：</strong>如上所述，默认情况下，所有事件处理程序都是在冒泡阶段注册的，这在大多数情况下更有意义。如果您真的想在捕获阶段注册一个事件，那么可以通过使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a>注册您的处理程序，并将可选的第三个属性设置为 true。</p>
<h2 id="3-延伸"><a href="#3-延伸" class="headerlink" title="3 延伸"></a>3 延伸</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>正式因为冒泡的机制， 所以我们可以利用该机制，实现下面这样的行为：如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。这种行为称之为事件委托。这个概念的更多的例子-<a href="https://davidwalsh.name/event-delegate">How JavaScript Event Delegation Works</a>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>事件</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记之JS异步编程之Promise</title>
    <url>/2022/10/13/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8BPromise/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><blockquote>
<p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p>
</blockquote>
<p>浏览器在执行js代码时，是按照书写的顺序一行一行的执行，会等待代码的解析和工作，在上一行执行完毕后才会执行下一行。执行同步函数时也是如此。</p>
<p>单当遇到一个耗时的同步函数时，操作会非常消耗时间且我们无法做其他事情。</p>
<p>我们希望我们的程序可以：</p>
<ul>
<li>通过调用一个函数来启动一个长期运行的操作。</li>
<li>然函数开始 操作时立即返回，这样我们的程序就可以保持对其他事件做出反应能力。</li>
<li>单操作完成时通知我们操作的结果。</li>
</ul>
<p>以上的功能是异步寒函数为我们提供的能力。</p>
<p>我们常见的事件处理程序就是异步编程的一种形式。即提供的函数，将在事件发生时被调用（而不是立即被用用），如果事件操作已经完成，那么就可以看到事件是如何被用来通知调用者异步函数调用的结果的。</p>
<p>例如一些早期的API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>,可以通过给 <code>XMLHttpRequest</code> 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。</p>
<p>事件处理程序是一种特殊的回调函数，而回调函数则是一个被传递到另一个函数中的会在合适的时候被调用的函数。回调函数曾经是 JavaScript 中实现异步函数的主要方式。</p>
<p>然而回调函数本身也接受被回调，基于回调的代码则会非常难理解。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep1</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = init + <span class="number">1</span>;</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep2</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = init + <span class="number">2</span>;</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep3</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = init + <span class="number">3</span>;</span><br><span class="line">    callback(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doOperation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doStep1(<span class="number">0</span>, <span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        doStep2(result1, <span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">            doStep3(result2, <span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`结果：<span class="subst">$&#123;result3&#125;</span>`</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doOperation();</span><br></pre></td></tr></table></figure>
<p>由于以上原因大多数现代的异步API都不使用回调，事实上JS中的异步编程的基础是 Promise 。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 是现代js中异步编程的基础，是一个由异步函数返回的 可以向我们指示当前操作所处的 对象的状态。在 Promise 返回给调用者的时候，操作往往还没有完成，但是 Promise 对象可以让我们操作最终完成时对其处理（无论成功还是失败）。</p>
<p>在基于 Promise 的API中，异步函数会启动操作并返回 Promise 对象，然后，你可以将处理函数附加到 Promise 对象上，当操作完成时（成功或者失败），这些处理函数将会执行。</p>
<p>示例：使用fetch()API 来解释promise。</p>
<p>打开网站：<a href="https://example.org/">https://example.org</a> 在控制台中输入以下的代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 fetch() API，并将返回值赋给 fetchPromise 变量。</span></span><br><span class="line">const fetchPromise = fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧接着，输出 fetchPromise 变量，输出结果应该像这样：Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;。这告诉我们有一个 Promise 对象，它有一个 state属性，值是 &quot;pending&quot;。&quot;pending&quot; 状态意味着操作仍在进行中。</span></span><br><span class="line">console.log(fetchPromise);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个处理函数传递给 Promise 的 then() 方法。当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 Response 对象。</span></span><br><span class="line">fetchPromise.then( response =&gt; &#123;</span><br><span class="line">  console.log(`已收到响应：$&#123;response.status&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出一条信息，说明我们已经发送了这个请求。</span></span><br><span class="line">console.log(&quot;已发送请求……&quot;);</span><br></pre></td></tr></table></figure>
<p>控制台的响应结果应该是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123; &lt;state&gt;: <span class="string">&quot;pending&quot;</span> &#125;</span><br><span class="line">已发送请求……</span><br><span class="line">已收到响应：<span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到已发送请求在响应之前输出了，如果是同步函数，则会在最后返回【已发送请求……】。</p>
<p>当通过 fetch()API得到一个Response对象时，需要调用另一个函数来接受这个响应，这次我们想要得到json格式的数据，可以调用Response.json()方法。 json()也是也是一个异步函数，因此我们连续调用两个异步函数。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const fetchPromise = fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line">fetchPromise.then( response =&gt; &#123;</span><br><span class="line">  const jsonPromise = response.json();</span><br><span class="line">  jsonPromise.then( json =&gt; &#123;</span><br><span class="line">    console.log(json);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>在这个示例中fetch()返回的 Promise 对象的then()方法，调用了response.json()方法，json()同样返回了一个 Promise 对象。 jsonPromise的then()方法输出了json的内容。</p>
<p>以上的代码看起来和之前的多层级回调差不多，确实是这样。但是 Promise 的优雅之处在于then()也是返回一个 Promise 对象，这个 Promise 将指示 <code>then()</code> 中调用的异步函数的完成状态。这意味着我们可以（当然也应该）把上面的代码改写成这样：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const fetchPromise = fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        return response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(json =&gt; &#123;</span><br><span class="line">        console.log(json[0].name);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<p>我们不必在第一个then()方法里面写另外一个then()方法，我们可以直接返回json()返回的 Promise ,并且在改返回值上调用第二个then()，这种调用方式叫做<strong>Promise链</strong>。意味着当我们连续调用异步函数的时候就可以避免嵌套带来的代码不美观易懂。</p>
<h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><p>上述的一个response请求示例是一个理想的代码，因为没有添加异常的处理。Promise 对象中提供了一个catch()方法来处理错误，她很像then()，可以调用它并传入一个处理函数。然后，当异步操作<em>成功</em>时，传递给then()的处理函数被调用，而当异步操作<em>失败</em>时，传递给catch()的处理函数被调用。</p>
<p>如果将catch()添加到 Promise 链的末尾，它就可以在任何异步函数失败时被调用。于是，我们就可以将一个操作实现为几个连续的异步函数调用，并在一个地方处理所有错误。</p>
<p>例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const fetchPromise = fetch(&#x27;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        if (!response.ok) &#123;</span><br><span class="line">            throw new Error(`HTTP 请求错误：$&#123;response.status&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">        return response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(json =&gt; &#123;</span><br><span class="line">        console.log(json[0].name);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">        console.error(`无法获取产品列表：$&#123;error&#125;`);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>


<h2 id="Promise-术语"><a href="#Promise-术语" class="headerlink" title="Promise 术语"></a>Promise 术语</h2><p>首先 Promise 有三种状态：</p>
<ul>
<li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。这是调用fetch()返回 Promise 时的状态，此时请求还在进行中。</li>
<li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。当 Promise 完成时，它的then()处理函数被调用。</li>
<li><strong>已拒绝（rejected）</strong>：意味着操作失败。当一个 Promise 失败时，它的catch()处理函数被调用。</li>
</ul>
<p>有时我们用 <strong>已敲定（settled）</strong> 这个词来同时表示 <strong>已兑现（fulfilled）</strong> 和 <strong>已拒绝（rejected）</strong> 两种情况。</p>
<p>如果一个 Promise 处于已决议（resolved）状态，或者它被“锁定”以跟随另一个 Promise 的状态，那么它就是 <strong>已兑现（fulfilled）</strong>。</p>
<p>文章 <a href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/">Let’s talk about how to talk about promises</a> 对这些术语的细节做了很好的解释。</p>
<blockquote>
<p>注：这里的成功或者失败取决于使用的API。例如：fetch()认为服务器返回一个错误（如<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404">404 Not Found</a>）时请求成功，但如果网络错误阻止请求被发送，则认为请求失败。</p>
</blockquote>
<p>文章 <a href="https://thenewtoys.dev/blog/2021/02/08/lets-talk-about-how-to-talk-about-promises/">Let’s talk about how to talk about promises</a> 对这些术语的细节做了很好的解释。</p>
<h2 id="合并使用多个-Promise"><a href="#合并使用多个-Promise" class="headerlink" title="合并使用多个 Promise"></a>合并使用多个 Promise</h2><p>当操作有几个异步函数组成时，而且需要在下一个函数开始之前完成每一个函数，需要的就是 Promise 链。但是在其他的一些情况下，可能需要合并多个异步函数的调用。</p>
<p>有时你需要所有的 Promise 都得到实现，但它们并不相互依赖。在这种情况下，==将它们一起启动然后在它们全部被兑现后得到通知会更有效率==。这里需要 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a> 方法。它接收一个 Promise 数组，并返回一个单一的 Promise。</p>
<p>由 Promise.all() 返回的 Promise 有以下的特性：</p>
<p>1、当且仅当数组中所有的 Promise都被兑现时，才会通知then()函数，并提供一个包含所有响应的数组，数组中响应的顺序与被传入all()的 Promise 相等。</p>
<p>2、会被拒绝–如果数组中任何一个 Promise 被拒绝，此时 catch()处理函数被调用，并提供被拒绝的 Promise 所抛出的错误。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise1 = fetch(<span class="string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fetchPromise2 = fetch(<span class="string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fetchPromise3 = fetch(<span class="string">&#x27;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([fetchPromise1, fetchPromise2, fetchPromise3])</span><br><span class="line">    .then(<span class="function"><span class="params">responses</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> response <span class="keyword">of</span> responses) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`获取失败：<span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>有时，可能需要等待一组 Promise 中的某一个 Promise 的执行，而不关心是哪一个。在这种情况下，你需要 Promise.any()这就像Promise.all()，不过在 Promise 数组中的任何一个被兑现时它就会被兑现，如果所有的 Promise 都被拒绝，它也会被拒绝。</p>
<blockquote>
<p>注：在这种情况下，我们无法预测哪个获取请求会先被兑现。</p>
</blockquote>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>async 关键字提供了一种更简单的方法来处理基于异步 Promise 的代码，在一个函数的开头添加 async 可以使其成为一个异步函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在异步函数中，可以在调用一个返回 Promise 的函数之前使用 <code>await</code> 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProducts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span></span><br><span class="line">        <span class="comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`HTTP 请求错误：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span></span><br><span class="line">        <span class="comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span></span><br><span class="line">        <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">        <span class="built_in">console</span>.log(json[<span class="number">0</span>].name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`无法获取产品列表：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchProducts();</span><br></pre></td></tr></table></figure>
<p>上面的代码使用await关键字 让异步函数想同步函数一样去执行，但是，即使像同步函数那样也无法使用下面那样的代码进行操作：(因为异步函数总是返回一个 Promise)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">async function fetchProducts() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const response = await fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line">        if (!response.ok) &#123;</span><br><span class="line">            throw new Error(`HTTP 请求错误：$&#123;response.status&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">        const json = await response.json();</span><br><span class="line">        return json;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.error(`无法获取产品列表：$&#123;error&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const json = fetchProducts();</span><br><span class="line">console.log(json[0].name);   // json 是一个 Promise 对象，因此这句代码无法正常工作</span><br></pre></td></tr></table></figure>


<p>但是我们可以这样做：(因为异步函数返回一个 Promise 可以调用.then()方法)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">async function fetchProducts() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const response = await fetch(&#x27;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&#x27;);</span><br><span class="line">        if (!response.ok) &#123;</span><br><span class="line">            throw new Error(`HTTP 请求错误：$&#123;response.status&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line">        const json = await response.json();</span><br><span class="line">        return json;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.error(`无法获取产品列表：$&#123;error&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const jsonPromise = fetchProducts();</span><br><span class="line">jsonPromise.then((json) =&gt; console.log(json[0].name));</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在实际开发过程中可能会在 Promise 链的地方使用async函数， await将会强制异步操作以串联的形式工作。如果下一个操作的结果取决于上一个操作的结果，这是非常必要的，反之 Promise.all() 这样的操作会有更好的性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Promise 是现代JavaScript异步编程的基础，他避免的深度嵌套，是表达和理解异步操作变的更加容易，并且还支持一种类似于同步编程中 <code>try...catch</code> 语句的错误处理方式。</p>
<p><code>async</code> 和 <code>await</code> 关键字使得从一系列连续的异步函数调用中建立一个操作变得更加容易，避免了创建显式 Promise 链，并允许你像编写异步代码那样编写同步代码。</p>
<p>Promise 在所有现代浏览器的最新版本中都可以使用；唯一会出现支持问题的地方是 Opera Mini 和 IE11 及更早的版本。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记之Js代码调用策略</title>
    <url>/2022/10/12/JS%E7%AC%94%E8%AE%B0%E4%B9%8BJS%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="Js代码调用策略"><a href="#Js代码调用策略" class="headerlink" title="Js代码调用策略"></a>Js代码调用策略</h1><p>javascript代码位置和css一样，可以设置为内部样式、内联样式、外部样式。HTML代码渲染是由上而下加载，js代码的位置可能会导致js获取DOM元素时，无法获取未渲染的HTML标签，从而引发错误。</p>
<p>想要脚本调用的时候符合预期，需要解决一系列问题。</p>
<p>例如当js代码处于文档头处，解析HTML文档体之前。这样做是有隐患的，需要使用一些结构来避免错误发生。</p>
<h2 id="1-使用-DOMContentLoaded-解决"><a href="#1-使用-DOMContentLoaded-解决" class="headerlink" title="1 使用 DOMContentLoaded 解决"></a>1 使用 DOMContentLoaded 解决</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    . . .</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是一个事件监听器，他监听浏览器的<strong>DOMContentLoaded</strong>事件，即HTML加载、解释完毕事件。事件将触发 … 的代码，从而避免了错误发生。</p>
<h2 id="2-使用-async-解决"><a href="#2-使用-async-解决" class="headerlink" title="2 使用 async 解决"></a>2 使用 async 解决</h2><p>在调用外部js代码时可以使用js的一项现代技术（async）来解决这一问题，他告知浏览器在遇到<javascript> 元素时不用中断后续HTML内容的加载。</javascript></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> 外部脚本 async 属性可以解决调用顺序问题，但是async只适用于外部脚本。</p>
<p>一般解决此问题的旧方法是：把脚本元素放在底部，这样脚本就可以再HTML内容解析之后加载了。这种方案和上面 DOMContentLoaded 的问题是：==只有在所有 HTML DOM 加载完成后才开始脚本的加载/解析过程。对于有大量 JavaScript 代码的大型网站，可能会带来显著的性能损耗。这也是 async 属性诞生的初衷。==</p>
<h2 id="3-async-和-defer"><a href="#3-async-和-defer" class="headerlink" title="3 async 和 defer"></a>3 async 和 defer</h2><p>上述的脚本阻塞问题实际有两种解决方案 —— <code>async</code> 和 <code>defer</code>。</p>
<p>浏览器遇到acync脚本时不会阻塞渲染HTML，而是直接下载然后运行，这样脚本的执行顺序就无法把控，仅仅是脚本不会阻止剩余页面的渲染。当页面和脚本之间独立，且不依赖于本页面的其它任何脚本时，<code>async</code> 是最理想的选择。</p>
<p>比如页面有多个脚本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;js/script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;js/script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>三者的调用顺序是不一定的，<code>jquery</code> 可能在 <code>script2</code> 和 <code>script3</code> 之后调用，如果这样的话，后两个脚本中依赖 <code>jquery</code> 的函数将产生错误，因为脚本运行时 <code>jquery</code> 尚未加载。</p>
<p>解决这一问题可使用 <code>defer</code> 属性，脚本将按照在页面中出现的顺序加载和运行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code> 必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code> 之前。</p>
<p>总结：</p>
<ul>
<li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li>
<li>如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>调用策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 4 安装注册</title>
    <url>/2022/10/11/Sublime%20Text4%20%E5%AE%89%E8%A3%85%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p>​                     </p>
<a id="more"></a>

<h1 id="sublime-text-4-注册方法"><a href="#sublime-text-4-注册方法" class="headerlink" title="sublime text 4 注册方法"></a>sublime text 4 注册方法</h1><blockquote>
<p>Sublime Text 是一个文本<a href="https://baike.baidu.com/item/%E7%BC%96%E8%BE%91%E5%99%A8/9067697?fromModule=lemma_inlink">编辑器</a>（收费<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053?fromModule=lemma_inlink">软件</a>，可以无限期试用），同时也是一个先进的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048?fromModule=lemma_inlink">代码</a>编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的<a href="https://baike.baidu.com/item/Vim?fromModule=lemma_inlink">Vim</a>。</p>
</blockquote>
<h2 id="1-sublime-text-4-最新激活方法-版本4143"><a href="#1-sublime-text-4-最新激活方法-版本4143" class="headerlink" title="1 sublime text 4 最新激活方法 (版本4143)"></a>1 sublime text 4 最新激活方法 (版本4143)</h2><ol>
<li>打开网站 <a href="https://hexed.it/">hexed.it</a>。在网站上面导航栏左上角点击打开文件，选择sublime text 安装文件夹下的 <code>sublime_text.exe</code>。</li>
<li>按下 ctrl+f 搜索，在网站右侧边栏搜索输入框输入： <code>80 78 05 00 0f 94 c1</code> 。</li>
<li>在网站右侧边栏，搜索方案中选择启动替换，在替换输入框中输入 <code>c6 40 05 01 48 85 c9</code>，只需替换一次。</li>
<li>点击网站上面导航栏中的另存为，直接替换原有的<code>sublime_text.exe</code>文件。</li>
<li>再次打开 sublime text 4 即可查看已注册成功。</li>
</ol>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2023-02-07_09-37-52.png"></p>
<h2 id="2-sublime-text-4-激活方法-版本4126-（已失效）"><a href="#2-sublime-text-4-激活方法-版本4126-（已失效）" class="headerlink" title="2 sublime text 4 激活方法(版本4126) （已失效）"></a>2 sublime text 4 激活方法(版本4126) （已失效）</h2><p>注册码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">—– BEGIN LICENSE —–</span><br><span class="line"></span><br><span class="line">Mifeng User</span><br><span class="line"></span><br><span class="line">Single User License</span><br><span class="line"></span><br><span class="line">EA7E-1184812</span><br><span class="line"></span><br><span class="line">C0DAA9CD 6BE825B5 FF935692 1750523A</span><br><span class="line"></span><br><span class="line">EDF59D3F A3BD6C96 F8D33866 3F1CCCEA</span><br><span class="line"></span><br><span class="line">1C25BE4D 25B1C4CC 5110C20E 5246CC42</span><br><span class="line"></span><br><span class="line">D232C83B C99CCC42 0E32890C B6CBF018</span><br><span class="line"></span><br><span class="line">B1D4C178 2F9DDB16 ABAA74E5 95304BEF</span><br><span class="line"></span><br><span class="line">9D0CCFA9 8AF8F8E2 1E0A955E 4771A576</span><br><span class="line"></span><br><span class="line">50737C65 325B6C32 817DCB83 A7394DFA</span><br><span class="line"></span><br><span class="line">27B7E747 736A1198 B3865734 0B434AA5</span><br><span class="line"></span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
        <category>SublimeText</category>
      </categories>
      <tags>
        <tag>SublimeText</tag>
      </tags>
  </entry>
  <entry>
    <title>flask常用扩展</title>
    <url>/2022/08/30/Flask%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>​                  </p>
<a id="more"></a>

<h1 id="Flask-常用扩展"><a href="#Flask-常用扩展" class="headerlink" title="Flask 常用扩展"></a>Flask 常用扩展</h1><h2 id="1-Flask-Cors"><a href="#1-Flask-Cors" class="headerlink" title="1 Flask-Cors"></a>1 Flask-Cors</h2><p>用于处理跨域资源共享的扩展。 <a href="https://flask-cors.corydolphin.com/en/latest/api.html">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -U flask-cors</span><br></pre></td></tr></table></figure>


<h2 id="2-Flask-Limiter-Memcached"><a href="#2-Flask-Limiter-Memcached" class="headerlink" title="2 Flask-Limiter Memcached"></a>2 Flask-Limiter Memcached</h2><p>给接口提供速率限制，可以设置各种后端配置来提供限制功能，如：Redis、MongoDB、Memcached、In-Memory（在内存中限制）。<a href="https://flask-limiter.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-Limiter</span><br></pre></td></tr></table></figure>


<h2 id="3-Flask-JWT-Extended"><a href="#3-Flask-JWT-Extended" class="headerlink" title="3 Flask-JWT-Extended"></a>3 Flask-JWT-Extended</h2><p>添加了flask的JWT支持，且增加了其他的功能：自动加载用户、自定义声明验证Token等。<a href="https://flask-jwt-extended.readthedocs.io/en/stable/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-JWT-Extended</span><br></pre></td></tr></table></figure>


<h2 id="4-flask-marshmallow"><a href="#4-flask-marshmallow" class="headerlink" title="4 flask-marshmallow"></a>4 flask-marshmallow</h2><p>用户python对象的一个序列化反序列换的库。在flask中可与 Flask-SQLAlchemy集成。<a href="https://flask-marshmallow.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install flask-marshmallow</span><br></pre></td></tr></table></figure>


<h2 id="5-Flask-SQLAlchemy"><a href="#5-Flask-SQLAlchemy" class="headerlink" title="5 Flask-SQLAlchemy"></a>5 Flask-SQLAlchemy</h2><p>flask的一个orm扩展。<a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure>


<h2 id="6-marshmallow-sqlalchemy"><a href="#6-marshmallow-sqlalchemy" class="headerlink" title="6 marshmallow-sqlalchemy"></a>6 marshmallow-sqlalchemy</h2><p>sqlalchemy与marshmallow的集成，用于对orm对象的序列化与反序列化。<a href="https://marshmallow-sqlalchemy.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install marshmallow-sqlalchemy</span><br></pre></td></tr></table></figure>


<h2 id="7-Fask-Migrate"><a href="#7-Fask-Migrate" class="headerlink" title="7 Fask-Migrate"></a>7 Fask-Migrate</h2><p>使用 Alembic 为 Flask 应用程序处理 SQLAlchemy 数据库迁移。<a href="https://flask-migrate.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-Migrate</span><br></pre></td></tr></table></figure>


<h2 id="8-Flask-Admin"><a href="#8-Flask-Admin" class="headerlink" title="8 Flask-Admin"></a>8 Flask-Admin</h2><p>类似Django-admin的一个后台管理页面。<a href="https://flask-admin.readthedocs.io/en/latest/">文档地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Flask-Admin</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS转换过渡和动画</title>
    <url>/2022/08/24/CSS%E8%BD%AC%E6%8D%A2%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>​                 </p>
<a id="more"></a>

<h1 id="CSS转换过渡和动画"><a href="#CSS转换过渡和动画" class="headerlink" title="CSS转换过渡和动画"></a>CSS转换过渡和动画</h1><p>转换可以对元素进行移动、缩放、转动、拉伸。转换的效果是让某个元素改变形状，大小和位置。可以使用2D和3D来转换元素，</p>
<h2 id="1-2D转换"><a href="#1-2D转换" class="headerlink" title="1 2D转换"></a>1 2D转换</h2><h3 id="1-1-平移-translate"><a href="#1-1-平移-translate" class="headerlink" title="1.1 平移 translate"></a>1.1 平移 translate</h3><p>根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>,<span class="number">100px</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：是从左边元素移动50个像素，并从顶部移动100像素。</p>
<h3 id="1-2-旋转-rotate"><a href="#1-2-旋转-rotate" class="headerlink" title="1.2 旋转 rotate"></a>1.2 旋转 rotate</h3><p>顺时针旋转的角度。负值是逆时针旋转。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：将元素顺时针旋转30度。</p>
<h3 id="1-3-缩放-scale"><a href="#1-3-缩放-scale" class="headerlink" title="1.3 缩放 scale"></a>1.3 缩放 scale</h3><p>增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">-ms-transform</span>:<span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">/* 标准语法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：将元素转变宽度为原来的大小的2倍，和其原始大小3倍的高度。</p>
<h3 id="1-4-倾斜-skew"><a href="#1-4-倾斜-skew" class="headerlink" title="1.4 倾斜 skew"></a>1.4 倾斜 skew</h3><p>包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>,<span class="number">20deg</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上css规则：将元素在X轴和Y轴上倾斜20度30度。</p>
<h3 id="1-5-以上方法的缩写-matrix"><a href="#1-5-以上方法的缩写-matrix" class="headerlink" title="1.5 以上方法的缩写 matrix"></a>1.5 以上方法的缩写 matrix</h3><p>matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。</p>
<p>表示以下函数：matrix( scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY() )</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">/* IE 9 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">matrix</span>(<span class="number">0.866</span>,<span class="number">0.5</span>,-<span class="number">0.5</span>,<span class="number">0.866</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">/* Safari and Chrome */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-CSS-过渡"><a href="#2-CSS-过渡" class="headerlink" title="2 CSS 过渡"></a>2 CSS 过渡</h2><h3 id="2-1-transition-使某种想过转变到另一种效果。"><a href="#2-1-transition-使某种想过转变到另一种效果。" class="headerlink" title="2.1 transition 使某种想过转变到另一种效果。"></a>2.1 transition 使某种想过转变到另一种效果。</h3><ul>
<li>transition-property 应用过渡的CSS属性。</li>
<li>transition-duration 过渡的CSS时间，默认是0。</li>
<li>transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。</li>
<li>transition-delay    规定过渡效果何时开始。默认是 0 （立即开始）。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transition-property</span>: width;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br><span class="line">    <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">-webkit-transition-property</span>:width;</span><br><span class="line">    <span class="attribute">-webkit-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition-timing-function</span>:linear;</span><br><span class="line">    <span class="attribute">-webkit-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-transition-以上属性简写"><a href="#2-2-transition-以上属性简写" class="headerlink" title="2.2 transition 以上属性简写"></a>2.2 transition 以上属性简写</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">    <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">-webkit-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-CSS-动画"><a href="#3-CSS-动画" class="headerlink" title="3 CSS 动画"></a>3 CSS 动画</h2><p>动画是使元素从一种样式逐渐变化为另一种样式的效果，可以改变任意多的样式任意多的次数。</p>
<p>使用百分比来规定变化发生的时间，或者使用关键字<code>from</code>和<code>to</code>等同于0%和100%。为了有更好的体验，应该使用定义0%和100%。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span>; <span class="comment">/* Safari 与 Chrome */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> myfirst &#123;</span><br><span class="line">    0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">    25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">    50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">    100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> myfirst /* Safari 与 Chrome */ &#123;</span><br><span class="line">    0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">    25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">    50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">    100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-animation-相关属性"><a href="#3-1-animation-相关属性" class="headerlink" title="3.1 animation 相关属性"></a>3.1 animation 相关属性</h3><ul>
<li>@keyframes    规定动画规则。</li>
<li>animation-name    规定 @keyframes 动画的名称。    </li>
<li>animation-duration    规定动画完成一个周期所花费的秒或毫秒。默认是 0。    </li>
<li>animation-timing-function    规定动画的速度曲线。默认是 “ease”。    </li>
<li>animation-fill-mode    规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。    </li>
<li>animation-delay    规定动画何时开始。默认是 0。    </li>
<li>animation-iteration-count    规定动画被播放的次数。默认是 1。    </li>
<li>animation-direction    规定动画是否在下一周期逆向地播放。默认是 “normal”。    </li>
<li>animation-play-state    规定动画是否正在运行或暂停。默认是 “running”</li>
</ul>
<h3 id="3-2-设置所有属性示例"><a href="#3-2-设置所有属性示例" class="headerlink" title="3.2 设置所有属性示例"></a>3.2 设置所有属性示例</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: myfirst;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">    <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">    <span class="comment">/* Safari 与 Chrome: */</span></span><br><span class="line">    <span class="attribute">-webkit-animation-name</span>: myfirst;</span><br><span class="line">    <span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line">    <span class="attribute">-webkit-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">-webkit-animation-iteration-count</span>: infinite;</span><br><span class="line">    <span class="attribute">-webkit-animation-direction</span>: alternate;</span><br><span class="line">    <span class="attribute">-webkit-animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简写示例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">    <span class="comment">/* Safari 与 Chrome: */</span></span><br><span class="line">    <span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


























































]]></content>
      <categories>
        <category>CSS</category>
        <category>动画</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS媒体查询</title>
    <url>/2022/08/22/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>



<h1 id="CSS媒体查询"><a href="#CSS媒体查询" class="headerlink" title="CSS媒体查询"></a>CSS媒体查询</h1><p>CSS 媒体查询为你提供了一种应用 CSS 的方法，仅在浏览器和设备的环境与你指定的规则相匹配的时候 CSS 才会真的被应用</p>
<p>媒体查询是响应式 Web 设计的关键部分，因为它允许你按照视口的尺寸创建不同的布局，不过它也可以用来探测和你的站点运行的环境相关联的其它条件，比如用户是在使用触摸屏还是鼠标。</p>
<h2 id="1-媒体查询基础"><a href="#1-媒体查询基础" class="headerlink" title="1 媒体查询基础"></a>1 媒体查询基础</h2><p>最简单的媒体查询语法看起来是像这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> media-type <span class="keyword">and</span> (media-feature-rule) &#123;</span><br><span class="line">  <span class="comment">/* CSS rules go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它由以下部分组成：</p>
<ul>
<li>一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；</li>
<li>一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试；</li>
<li>一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。</li>
</ul>
<h2 id="2-媒体类型"><a href="#2-媒体类型" class="headerlink" title="2 媒体类型"></a>2 媒体类型</h2><ul>
<li>all：适用于所有设备。</li>
<li>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档。</li>
<li>screen：主要用于屏幕。</li>
<li>speech：主要用于语音合成器</li>
</ul>
<h2 id="3-媒体特征规则"><a href="#3-媒体特征规则" class="headerlink" title="3 媒体特征规则"></a>3 媒体特征规则</h2><h3 id="3-1宽和高-width-height"><a href="#3-1宽和高-width-height" class="headerlink" title="3.1宽和高 width height"></a>3.1宽和高 width height</h3><p>为了建立响应式设计（已经广受浏览器支持），我们一般最常探测的特征是视口宽度，而且我们可以使用min-width、max-width和width媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用 CSS。</p>
<p>在实践中一般比较常用的是 min- 和 max- </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">400px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-朝向-orientation"><a href="#3-2-朝向-orientation" class="headerlink" title="3.2 朝向 orientation"></a>3.2 朝向 orientation</h3><p>可以用它测得竖放（portrait）模式 和横放（landscape）模式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准的桌面视图是横放朝向的，在这种朝向上能够表现良好的设计，在处于竖放模式的手机或平板电脑上可能不会表现得这么好。对朝向的测试可以帮你建立一个为竖放设备优化的布局。</p>
<h3 id="3-3-使用可指点设备（可悬浮在元素上）"><a href="#3-3-使用可指点设备（可悬浮在元素上）" class="headerlink" title="3.3 使用可指点设备（可悬浮在元素上）"></a>3.3 使用可指点设备（可悬浮在元素上）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">hover:</span> hover) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-复杂的媒体查询"><a href="#4-复杂的媒体查询" class="headerlink" title="4 复杂的媒体查询"></a>4 复杂的媒体查询</h2><p>使用与、或、非组合上面的媒体查询逻辑。</p>
<p>规则：body 的文字只会在viewport至少为 400 像素宽，且设备横放时应用变为蓝色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。</p>
<p>规则：body会在viewport至少为 400 像素宽的时候<strong>或者</strong>设备处于横放状态的时候应用变为蓝色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用not`操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
        <category>媒体查询</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局-弹性盒子与网格布局</title>
    <url>/2022/08/22/CSS%E5%B8%83%E5%B1%80-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E4%B8%8E%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS布局-弹性盒子与网格布局"><a href="#CSS布局-弹性盒子与网格布局" class="headerlink" title="CSS布局-弹性盒子与网格布局"></a>CSS布局-弹性盒子与网格布局</h1><p>css的布局技术可以让我们控制他们的相对正常布局流、周边元素、父容器或者主视口/窗口的位置。常见的布局形式有：正常布局流、display属性布局、弹性盒子布局、网格布局、浮动布局、定位布局、表格布局、多列布局。</p>
<p>每种技术都有他们的用途，通过理解各个布局的相关理念，构建理想的布局方案。</p>
<p>一些布局技术会覆盖默认的布局技术；</p>
<p>display：默认的一些属性<code>inline</code>、<code>block</code>、<code>inline-block</code>在正常布局流中的表现形式为对应的盒模型的属性。</p>
<p>在CSS中实现页面的布局的主要方法是设定<code>display</code>的值，正常的布局流中所有的属性都有一个<code>display</code>的值，例如在段落下面显示另外一个段落，是因为他的<code>display</code>的值是<code>block</code>吗，如果在段落中添加了一个连接，这个段落并不会换行，是应为连接<code>a</code>的<code>display</code>的属性值是<code>inline</code>。</p>
<p>在讨论布局时，最重要的两个值是<code>display</code>:<code>flex</code>和<code>display</code>:<code>grid</code>。</p>
<h2 id="1-弹性布局：flex"><a href="#1-弹性布局：flex" class="headerlink" title="1 弹性布局：flex"></a>1 弹性布局：flex</h2><p>主要解决问题：</p>
<ul>
<li><p>在父内容里面垂直居中一个块内容。</p>
</li>
<li><p>使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度/高度可用。</p>
</li>
<li><p>使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。</p>
</li>
</ul>
<p>使用方法：在想要进行 flex 布局的父元素上应用<code>display:flex</code>，所有的子元素都会按照flex进行布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了可以设置父容器的属性以外，还有很多属性可以设置到flex items上，这些属性可以改变flex items在flex布局中占用宽/高的方式，允许它们通过伸缩来适应可用空间。</p>
<p>例如在所有的flex items上设置<code>flex:1</code>可以设置所有的flex items都伸展并填充容器。</p>
<h3 id="1-1-flex模型说明"><a href="#1-1-flex模型说明" class="headerlink" title="1.1 flex模型说明"></a>1.1 flex模型说明</h3><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p>
<p><img src="https://origin.chaizz.com/tc/flex_terms.png" alt="flex_terms.png"></p>
<ul>
<li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li>
<li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li>
<li>设置了 <code>display: flex</code> 的父元素，被称之为 <strong>flex 容器（flex container）。</strong></li>
<li>在 flex 容器中表现为柔性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）。</li>
</ul>
<p>在flex布局中提供了==行列==布局的选项，通过<code>flex-direction</code>设置，他可以指定主轴的方向，默认行布局值为<code>row</code>，按照语言的默认方向排成一排。使用<code>column</code> 值将改为列布局，还有<code>row-reverse</code> 和 <code>column-reverse</code> 值反向排列 flex items。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;</span><br></pre></td></tr></table></figure>
<p>在布局中使用固定宽度或者固定高度，flex items可能会溢出弹性盒子，可以使用<code>flx-wrap:wrap</code>来避免这种情况。同时也可以设置每个flex items的最小宽度<code>flex:200px</code>，使用了以上属性，溢出的flex items将会移动到下一行。</p>
<p>可以将<code>flex-direction</code>和<code>flex-wrap</code>缩写为 <code>flex-flow</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;</span><br><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 缩写为 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">row</span> <span class="selector-tag">wrap</span>;</span><br></pre></td></tr></table></figure>


<p>上文中通过<code>flex:200px</code> 来控制flex items的宽度，如何动态的设置flex items 占用空间的比例呢？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 1;</span><br></pre></td></tr></table></figure>
<p>这是一个没有单位的比例值，表示每个 flex 项沿主轴的可用空间大小。例如设置为1代表每个flex items占用的空间是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为这是一个比例值，所以数字的大小所产生的效果是一样的。</p>
<p>也可以指定flex的最小值<code>flex: 1 2-00px;</code>， 表示每个flex items先给出200px，然后剩余的空间按照分配的比例共享。</p>
<h3 id="1-2-flex的缩写与全写"><a href="#1-2-flex的缩写与全写" class="headerlink" title="1.2 flex的缩写与全写"></a>1.2 flex的缩写与全写</h3><p>可以指定最多三个值的缩写属性：(不建议使用全写)</p>
<ul>
<li>第一个即上文中的无比例单位，也可以单独指定全写<code>flex-grow: 1;</code>。</li>
<li>第二个无单位比例是<code>flex-shrink</code>，一般用于溢出容器的flex items，他指定了从每个flex items取出多少溢出量，以阻止它们溢出它们的容器。（高级）</li>
<li>第三个是最小值，可以单独指定全写<code>flex-basis</code>。</li>
</ul>
<h3 id="1-3-弹性布局水平和垂直对齐"><a href="#1-3-弹性布局水平和垂直对齐" class="headerlink" title="1.3 弹性布局水平和垂直对齐"></a>1.3 弹性布局水平和垂直对齐</h3><p>通过<code>align-items</code>控制flex items在交叉轴上的位置</p>
<ul>
<li>默认的值是 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。</li>
<li><code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。</li>
<li> <code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。</li>
</ul>
<p>可以在每个单独的flex items设置特殊的布局<code>align-self: flex-end;</code>。</p>
<p>通过<code>justify-content</code>控制flex items在主轴上的位置。</p>
<ul>
<li>默认值是 <code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。</li>
<li>使用 <code>flex-end</code> 来让 flex 项到结尾处，与上面的值相反。</li>
<li>使用<code>center</code> 让 flex 项在主轴居中，但是每个元素之间不会有间隔。</li>
<li>使用 <code>space-around</code> 让flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li>
<li>使用 <code>space-between</code>，它和 <code>space-around</code> 非常相似，只是它不会在两端留下任何空间。</li>
</ul>
<h3 id="1-4-flex-items-排序"><a href="#1-4-flex-items-排序" class="headerlink" title="1.4 flex items 排序"></a>1.4 flex items 排序</h3><p>弹性盒子可以改变flex items的布局的位置，而不会影响到dom元素的顺序。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>所有 flex items 的默认 <code>order</code> 的值是0。</li>
<li>order 值大的 flex items 比 order 值小的在显示顺序中更靠后。</li>
<li>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。</li>
<li>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。</li>
</ul>
<p>也可以给 order 设置负值使它们比值为 0 的元素排得更前面。</p>
<h2 id="2-网格布局：grid"><a href="#2-网格布局：grid" class="headerlink" title="2 网格布局：grid"></a>2 网格布局：grid</h2><p>网格是由一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。</p>
<p>一个网格通常还有许多的列与行，以及行与行、列与列之间的间隙，间隙一般称为沟槽。</p>
<p><img src="https://origin.chaizz.com/tc/grid.png" alt="img"></p>
<p>与弹性盒子的区别：在定义网格后，网页并不会马上发生变化。因为<code>display: grid</code>的声明只创建了一个只有一列的网格，所以你的子项还是会像正常布局流那样从上而下一个接一个的排布</p>
<h3 id="2-1-给网格设置列"><a href="#2-1-给网格设置列" class="headerlink" title="2.1 给网格设置列"></a>2.1 给网格设置列</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置列的单位可以是具体的px，或者百分比也可以是fr，他比px和百分比更加的灵活，这个单位表示了一个可用空间的一个比例。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fe</span>;</span><br></pre></td></tr></table></figure>
<p>设置了fr，每一列的宽度们可以随着空间的变小而变小。</p>
<blockquote>
<p><strong><code>fr</code>单位分配的是<em>可用</em>空间而非<em>所有</em>空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。</strong></p>
</blockquote>
<h3 id="2-2-网格间隙"><a href="#2-2-网格间隙" class="headerlink" title="2.2 网格间隙"></a>2.2 网格间隙</h3><p>使用 <code>grid-column-gap</code>属性来定义列间隙；使用 <code>grid-row-gap</code>来定义行间隙；使用 <code>grid-gap</code> 可以同时设定两者。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>间隙距离可以用任何长度单位包括百分比来表示，但不能使用<code>fr</code>单位。</p>
<h3 id="2-3-重复构建行-列"><a href="#2-3-重复构建行-列" class="headerlink" title="2.3 重复构建行/列"></a>2.3 重复构建行/列</h3><p>可以使用<code>repeat</code>来重复构建具有某些宽度配置的某些列。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-4-显式网格和隐式网格"><a href="#2-4-显式网格和隐式网格" class="headerlink" title="2.4 显式网格和隐式网格"></a>2.4 显式网格和隐式网格</h3><p>显式网格是我们用<code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。</p>
<p>隐式网格的行列大小默认是auto，大小会根据放入的内容自动调整。也可以使用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>手动设置隐式网格的大小。</p>
<p>简单来说，隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显式网格自动生成的网格部分。</p>
<h3 id="2-4-minmax函数"><a href="#2-4-minmax函数" class="headerlink" title="2.4 minmax函数"></a>2.4 minmax函数</h3><p>函数为一个行/列的尺寸设置了取值范围。比如设定为 <code>minmax(100px, auto)</code>，那么尺寸就至少为 100 像素，并且如果内容尺寸大于 100 像素则会根据内容自动调整。</p>
<p>浮动布局：例如<code>float:left</code>值可以让块级元素相互排成一行。</p>
<p>position：允许精准设置盒子中的盒子的位置，正常布局流中的默认值为<code>static</code>，他的值会引起不同元素的布局方式，例如将元素固定到浏览器左上角的。</p>
<p>表格布局：表格的布局方式，可以用在非表格内容上，可以使用<code>display:table</code>和相关属性在非表格元素上使用。</p>
<p>多列布局：<code>multi-column-layout</code>属性可以让快按照列布局，类似报纸的形式。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局-浮动与定位与多列布局</title>
    <url>/2022/08/22/CSS%E5%B8%83%E5%B1%80-%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS布局-浮动与定位与多列布局"><a href="#CSS布局-浮动与定位与多列布局" class="headerlink" title="CSS布局-浮动与定位与多列布局"></a>CSS布局-浮动与定位与多列布局</h1><h2 id="1-浮动-float"><a href="#1-浮动-float" class="headerlink" title="1 浮动 float"></a>1 浮动 float</h2><p>浮动属性最初只用在成块的文本内的图像上，使用浮动来布局页面被看做传统的布局方法。</p>
<h3 id="1-1-添加浮动"><a href="#1-1-添加浮动" class="headerlink" title="1.1 添加浮动"></a>1.1 添加浮动</h3><p>浮动元素会脱离正常的文档布局流，并吸附到其父容器的左/右边元素）。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右/左侧的空间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;  <span class="comment">/*  left和right */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-清除浮动"><a href="#1-2-清除浮动" class="headerlink" title="1.2 清除浮动"></a>1.2 清除浮动</h3><p>一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也受到浮动元素的影响，我们需要 <em>停止</em> 它；这是通过添加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 属性实现的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cleared</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear 属性接受下列值：</p>
<ul>
<li><code>left</code>：停止任何活动的左浮动</li>
<li><code>right</code>：停止任何活动的右浮动</li>
<li><code>both</code>：停止任何活动的左右浮动</li>
</ul>
<h3 id="1-3-清除浮动元素周围的盒子"><a href="#1-3-清除浮动元素周围的盒子" class="headerlink" title="1.3 清除浮动元素周围的盒子"></a>1.3 清除浮动元素周围的盒子</h3><p>第一种方式，其过程为：先向包含浮动内容及其本身的盒子后方插入一些生成的内容，并将生成的内容清除浮动。（比较传统的形式）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式和在盒子后面手动添加类似div的块元素 ，并设置样式为<code>clear:both</code>的效果是一样的。</p>
<p>第二种方式 使用 <code>overflow</code>(以上方案的替代方法)。</p>
<p>将包裹元素的 <code>overflow</code>属性设置为<code>visible</code>外其他的值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto; <span class="comment">/* 设置为auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分情况下这种小技巧都可以奏效，但是可能会出现莫名其妙的滚动条或裁剪阴影，这是使用 overflow 带来的一些副作用。</p>
<p>第三种形式， 比较现代的形式。</p>
<p>使用<code>display:flow-root</code>可以无需小技巧来创建块格式化上下文（BFC），在使用上没有副作用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-定位-position"><a href="#2-定位-position" class="headerlink" title="2 定位 position"></a>2 定位 position</h2><p>理解定位首先熟悉文档流。</p>
<blockquote>
<p>文档流</p>
<p>围绕元素内容添加任何内边距，边界和外边距来布置单个元素盒子，这就是盒模型。默认请况下，块级元素的宽度是父级元素宽度的100%，高度是内容的高度，内联元素的宽高和内容一样宽高一样，不能对内联元素设置宽–他们只是位于块级元素的内容中，如果要控制内联元素的大小需要将其设置为<code>display:block</code>。</p>
<p>正常的布局流是将元素放置在浏览器视口内的系统，块级元素在视口中垂直布局——每个都将显示在上一个元素下面的新行上，并且它们的外边距将分隔开它们；</p>
<p>内联元素表现不一样——它们不会出现在新行上；相反，它们互相之间以及任何相邻（或被包裹）的文本内容位于同一行上，只要在父块级元素的宽度内有空间可以这样做。如果没有空间，那么溢流的文本或元素将向下移动到新行。</p>
<p>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫外边距折叠。</p>
</blockquote>
<p>定位是允许我们覆盖上面描述的基本文档流行为。</p>
<h3 id="2-1-静态定位-static"><a href="#2-1-静态定位-static" class="headerlink" title="2.1 静态定位 static"></a>2.1 静态定位 static</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态定位是每个元素获取的默认值–它只是意味着“将元素放入它在文档布局流中的正常位置。</p>
<h3 id="2-2-相对定位-relative"><a href="#2-2-相对定位-relative" class="headerlink" title="2.2 相对定位 relative"></a>2.2 相对定位 relative</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他与静态定位非常相似。占据在正常文档流中，可以通过 top、bottom、left、right改变元素的位置。</p>
<p>以上四个值是用来精确指定元素的位置，</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">.positioned &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: <span class="number">30</span>px;</span><br><span class="line">    left: <span class="number">30</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-3-绝对定位-absolute"><a href="#2-3-绝对定位-absolute" class="headerlink" title="2.3 绝对定位 absolute"></a>2.3 绝对定位 absolute</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。这意味着我们可以创建不干扰页面上其他元素的位置的隔离的 UI 功能。例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的 UI 功能……</p>
<p>==绝对定位是根据他的父元素的position 属性来进行绝对定位==，如果所有的父元素都没有显式地定义 position 属性，那么所有的父元素默认情况下 position 属性都是 static。绝对定位元素会被放在<html>元素的外面，并且根据浏览器视口来定位。</html></p>
<h3 id="2-4-z-index"><a href="#2-4-z-index" class="headerlink" title="2.4 z-index"></a>2.4 z-index</h3><p>当元素开始重叠的时候，是什么决定了那些元素应该出现在顶层，哪些在底层？</p>
<p>在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。</p>
<p>网页也有一个 z 轴：一条从屏幕到面前的线，z-index 值影响定位元素位于该轴上的位置；正值将它们移动到顶层即向屏幕外垂直延伸到面前，负值将它们向下移动到底层向屏幕里垂直延伸。默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。</p>
<p>z-index 只接受无单位索引值。</p>
<h3 id="2-5-固定定位-fixed"><a href="#2-5-固定定位-fixed" class="headerlink" title="2.5 固定定位 fixed"></a>2.5 固定定位 fixed</h3><p>这种定位方式与绝对定位的方式完全相同，只有一个区别：绝对定位将元素固定在相对于其位置最近的祖先。（（如果没有，则为初始包含它的块）而固定定位固定元素则是相对于浏览器视口本身</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>相对位置和固定位置的混合体 sticky</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个值比其他的值要新，他是相对位置个绝对位置的混合体，表现行为和相对定位一样，直到它滚动到某个阈值点为止，他就变得固定了。</p>
<p>sticky 一种常用的用法，是创建一个滚动索引页面。在此页面上，不同的标题会停留在页面顶部。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-多列布局"><a href="#3-多列布局" class="headerlink" title="3 多列布局"></a>3 多列布局</h2><h3 id="3-1-设置列数-column-count"><a href="#3-1-设置列数-column-count" class="headerlink" title="3.1 设置列数 column-count"></a>3.1 设置列数 column-count</h3><p>创建的这些列具有弹性的宽度 — 由浏览器计算出每一列分配多少空间。</p>
<h3 id="3-2-设置列宽-column-width"><a href="#3-2-设置列宽-column-width" class="headerlink" title="3.2 设置列宽 column-width"></a>3.2 设置列宽 column-width</h3><p>浏览器将按照你指定的宽度尽可能多的创建列；任何剩余的空间之后会被现有的列平分。 这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p>
<h3 id="3-3-给多列增加样式"><a href="#3-3-给多列增加样式" class="headerlink" title="3.3 给多列增加样式"></a>3.3 给多列增加样式</h3><p>Multicol 创建的列无法单独的设定样式。不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。</p>
<ul>
<li><code>column-gap</code> 改变列间间隙。</li>
<li><code>column-rule</code> 在列间加入分割线。</li>
</ul>
<p><code>column-rule</code>。和 <code>border</code>属性类似， <code>column-rule</code> 是 <code>column-rule-color</code>和 <code>column-rule-style</code>的缩写，接受同 <code>border</code> 一样的单位。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">4px</span> dotted <span class="built_in">rgb</span>(<span class="number">79</span>, <span class="number">185</span>, <span class="number">227</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-4-列与内容折断"><a href="#3-4-列与内容折断" class="headerlink" title="3.4 列与内容折断"></a>3.4 列与内容折断</h3><p>使用对列布局时把内容放入多列布局容器内，内容被拆成碎块放进列中，从而影响阅读体验。可以在列上使用这一属性避免<code>break-inside:avoid</code>。 现阶段旧属性 <code>page-break-inside: avoid</code> 能够获得更好的浏览器支持。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>布局</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式化文本</title>
    <url>/2022/08/19/CSS%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h2 id="1-CSS文本样式"><a href="#1-CSS文本样式" class="headerlink" title="1 CSS文本样式"></a>1 CSS文本样式</h2><h3 id="1-1-字体栈"><a href="#1-1-字体栈" class="headerlink" title="1.1 字体栈"></a>1.1 字体栈</h3><p>因为无法抱枕没字网页的上使用的字体的可用性，所以可以提供一个字体栈，这样浏览器就可以有多种选择。只需要使用<code>font-famioly</code>属性，其值用几个逗号分离的字体名称组成。使用方式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Trebuchet MS&quot;</span>, Verdana, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，浏览器会检查第一个字体，在征集其中是否可用，如果不可用则会顺延到下一个字体，在进行检查以此类推，都不可用则会使用默认的字体。</p>
<blockquote>
<p><strong>备注：</strong> 有一些字体名称不止一个单词，比如<code>Trebuchet MS</code> ，那么就需要用引号包裹。</p>
</blockquote>
<h3 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h3><p>主要注意字体的单位</p>
<ul>
<li>px：将像素的值赋予文本，他是一个绝对的单位，任何情况下页面上的文本大小都是固定的。</li>
<li>em：1em等于当前元素的父元素上设置的字体的大小，如果设置了大量的不同字体大小的嵌套元素， 可能会导致字体大小非常混乱。</li>
<li>rem：1rem等于html中根元素的字体的大小（<html>），而不是父元素的字体大小，但是不支持IE8及以下版本。</html></li>
</ul>
<p>标签的<code>font-size</code>属性是从根元素（<html>）继承的m，所以一切都是从根元素的开始，==浏览器的默认<code>font-size</code> 标准设置的值为 16px==。在根元素中的任何段落中的没有设置字体大小的元素都有一个默认值：16px，其他的元素有默认的代大小，比如<code>h1</code>的默认大小为2em，转化为像素为32px。</html></p>
<h3 id="1-3-字体样式"><a href="#1-3-字体样式" class="headerlink" title="1.3 字体样式"></a>1.3 字体样式</h3><p><code>font-style</code>: 用来打开和关闭文本 italic (斜体)。可能的值如下 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态)：</p>
<ul>
<li><code>normal</code>: 将文本设置为普通字体 (将存在的斜体关闭)</li>
<li><code>italic</code>: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。</li>
<li><code>oblique</code>: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。</li>
</ul>
<p><code>font-weight</code>: 设置文字的粗体大小。这里有很多值可选 (比如-light,-normal,-bold,-extrabold,-black, 等等), 不过事实上你很少会用到<code>normal</code>和<code>bold</code>以外的值：</p>
<ul>
<li><code>normal</code>, <code>bold</code>: 普通或者<strong>加粗</strong>的字体粗细</li>
<li><code>lighter</code>, <code>bolder</code>: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。<code>100</code>–<code>900</code>: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。</li>
</ul>
<p><code>text-transform</code>: 允许你设置要转换的字体。值包括：</p>
<ul>
<li><code>none</code>: 防止任何转型。</li>
<li><code>uppercase</code>: 将所有文本转为大写。</li>
<li><code>lowercase</code>: 将所有文本转为小写。</li>
<li><code>capitalize</code>: 转换所有单词让其首字母大写。</li>
<li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。</li>
</ul>
<p><code>text-decoration</code>: 设置/取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为：</p>
<ul>
<li><code>none</code>: 取消已经存在的任何文本装饰。</li>
<li><code>underline</code>: 文本下划线。</li>
<li><code>overline</code>: 文本上划线</li>
<li><code>line-through</code>: 穿过文本的线。</li>
</ul>
<p><code>text-decoration</code>可以一次接受多个值 比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-decoration</span>: <span class="selector-tag">underline</span> <span class="selector-tag">overline</span></span><br></pre></td></tr></table></figure>
<p><code>text-decoration</code>是一个缩写形式，它由<code>text-decoration-line</code>,<code>text-decoration-style</code>和<code>text-decoration-color</code>构成。你可以使用这些属性值的组合来创建有趣的效果，比如</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-decoration</span>: <span class="selector-tag">line-through</span> <span class="selector-tag">red</span> <span class="selector-tag">wavy</span></span><br></pre></td></tr></table></figure>
<p>文字样式示例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.4rem</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">font-weight</span>: lighter;</span><br><span class="line">    <span class="attribute">font-family</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through underline overline wheat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-4-文字阴影"><a href="#1-4-文字阴影" class="headerlink" title="1.4 文字阴影"></a>1.4 文字阴影</h3><p>使用<code>text-shadow</code>设置文字阴影。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: 4<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">red</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>, 但是 px 是比较合适的。这个值必须指定。</li>
<li>阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。</li>
<li>模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为 0，这意味着没有模糊。可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>.</li>
<li>阴影的基础颜色，可以使用大多数的 CSS 颜色单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#colors">CSS color unit</a>. 如果没有指定，默认为 <code>black</code>.</li>
</ol>
<blockquote>
<p><strong>备注：</strong> 正偏移值可以向右移动阴影，但也可以使用负偏移值来左右移动阴影，例如 <code>-1px -1px</code>。</p>
</blockquote>
<p>字体还可以指定多个阴影：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-shadow</span>: <span class="selector-tag">-1px</span> <span class="selector-tag">-1px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#aaa</span>,</span><br><span class="line">             0<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,0.5),</span><br><span class="line">             4<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,0.7),</span><br><span class="line">             0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 7<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0,0,0,0.4);</span><br></pre></td></tr></table></figure>
<h3 id="1-5-文本布局"><a href="#1-5-文本布局" class="headerlink" title="1.5 文本布局"></a>1.5 文本布局</h3><p><code>text-align</code></p>
<p>该属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同：</p>
<ul>
<li><code>left</code>: 左对齐文本。</li>
<li><code>right</code>: 右对齐文本。</li>
<li><code>center</code>: 居中文字</li>
<li><code>justify</code>: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>，打破一些更长的词语。</li>
</ul>
<p><code>line-height</code> </p>
<p>该属性设置文本每行之间的高，可以接受大多数单位 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units#length_and_size">length and size units</a>，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 来获得 <code>line-height</code>。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。==推荐的行高大约是 1.5–2 (双倍间距)==。 所以要把我们的文本行高设置为字体高度的 1.5 倍，你可以使用这个：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">line-height</span>: 1.5;</span><br></pre></td></tr></table></figure>


<p><code>letter-spacing</code> 和 <code>word-spacing</code></p>
<p>以上两个值可以设置字母与字母之间的间距、或是单词与单词之间的间距。</p>
<h2 id="2-css列表样式"><a href="#2-css列表样式" class="headerlink" title="2 css列表样式"></a>2 css列表样式</h2><h3 id="2-1-列表特定样式"><a href="#2-1-列表特定样式" class="headerlink" title="2.1 列表特定样式"></a>2.1 列表特定样式</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。（这个属性在控制项目符号的位置，大小等方面是有限的，最好使用<code>background</code>）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: square;</span><br><span class="line">  <span class="attribute">list-style-image</span>: <span class="built_in">url</span>(example.png);</span><br><span class="line">  <span class="attribute">list-style-position</span>: inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的三种属性，可以使用一个单独的属性<code>list-style</code>来设置，属性值可以任意顺序排列，可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside），如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: square <span class="built_in">url</span>(example.png) inside;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-管理列表计数"><a href="#2-2-管理列表计数" class="headerlink" title="2.2 管理列表计数"></a>2.2 管理列表计数</h3><p>在列表上进行不同的计数方式，例如设置<code>ol</code>标签的序号，正序倒序，指定数值。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-start"><code>start</code></a> 属性允许你从 1 以外的数字开始计数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Wash and chop the salad.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2022-08-19_14-52-03.png"></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-reversed"><code>reversed</code></a> 属性将启动列表倒计数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">&quot;4&quot;</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Wash and chop the salad.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2022-08-19_14-53-32.png"></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ol#attr-value"><code>value</code></a> 属性允许设置列表项指定数值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;6&quot;</span>&gt;</span>Wash and chop the salad.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;8&quot;</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2022-08-19_14-54-25.png"></p>
<h2 id="3-CSS连接样式"><a href="#3-CSS连接样式" class="headerlink" title="3 CSS连接样式"></a>3 CSS连接样式</h2><p>善于利用伪类有效地建立链接状态是很重要的，以及如何为链接添加样式来实现常用的功能，比如说导航栏、选项卡。</p>
<h3 id="3-1-连接状态"><a href="#3-1-连接状态" class="headerlink" title="3.1 连接状态"></a>3.1 连接状态</h3><p>连接处于不同的状态，都处于一个状态都可以利用对应的伪类来应用样式。</p>
<p>没有访问过的状态，连接的默认状态，可以使用<code>:link</code>来应用样式。</p>
<p>被访问过的状态（存在与浏览器的历史状态），可以使用<code>:visited</code>来应用样式。</p>
<p>鼠标悬停在连接上的状态，可以使用<code>:hover</code>伪类来应用样式。</p>
<p>被选中的时状态 (比如通过键盘的 Tab 移动到这个链接的时候，或者使用编程的方法来选中这个链接 <code>HTMLElement.focus()</code>) 可以使用<code> :focus</code>伪类来应用样式。</p>
<p>一个链接当它被激活的状态 (比如被点击的时候)，它可以使用<code>:active</code>伪类来应用样式。</p>
<p>连接的一些默认状态</p>
<ul>
<li>链接具有下划线。</li>
<li>未访问过的 (Unvisited) 的链接是蓝色的。</li>
<li>访问过的 (Visited) 的链接是紫色的。</li>
<li>悬停 (Hover) 在一个链接的时候鼠标的光标会变成一个小手的图标。</li>
<li>选中 (Focus) 链接的时候，链接周围会有一个轮廓。</li>
<li>激活 (Active) 链接（点击链接时）的时候会变成红色 。</li>
</ul>
<h3 id="3-2-连接中包含图标"><a href="#3-2-连接中包含图标" class="headerlink" title="3.2 连接中包含图标"></a>3.2 连接中包含图标</h3><p>常见的做法是在链接中包含图标，使链接提供更多关于链接指向的内容的信息。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;http&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;icons8-external-link-26.png&#x27;</span>) no-repeat <span class="number">100%</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">16px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">19px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-web字体"><a href="#4-web字体" class="headerlink" title="4 web字体"></a>4 web字体</h2><p>在浏览器中使用指定字体。</p>
<p>首先，在 CSS 的开始处有一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>块，它指定要下载的字体文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;myFont&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;myFont.ttf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后应用到文档中去：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;myFont&quot;</span>, <span class="string">&quot;Bitstream Vera Serif&quot;</span>, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















































]]></content>
      <categories>
        <category>CSS</category>
        <category>文本样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS背景和边框</title>
    <url>/2022/08/18/CSS%E8%83%8C%E6%99%AF%E5%92%8C%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS背景和边框"><a href="#CSS背景和边框" class="headerlink" title="CSS背景和边框"></a>CSS背景和边框</h1><p>设计CSS的背景和边框，可以是CSS的样式更具有多样性。CSS背景可以做哪些不同的事情？</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><h3 id="1-1-颜色背景：background-color"><a href="#1-1-颜色背景：background-color" class="headerlink" title="1.1 颜色背景：background-color"></a>1.1 颜色背景：<code>background-color</code></h3><p>定义了CSS中任何元素的背景颜色，属性接受的是有效的color值，==背景会扩展到元素的内容和内边距的下面==。</p>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2022-08-18_09-57-45.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#567895</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Background Colors<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Try changing the background <span class="tag">&lt;<span class="name">span</span>&gt;</span>colors<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-图片背景：background-image"><a href="#1-2-图片背景：background-image" class="headerlink" title="1.2 图片背景：background-image"></a>1.2 图片背景：<code>background-image</code></h3><p>该属性允许在元素的背景中显示图像，但是要注意的是：大图不会缩小以适应标签方框，而小图则是平铺</p>
<p>填充方框。<strong>如果除了背景图像外，还指定了背景颜色，则图像将颜色覆盖。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.a</span>, <span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: black solid <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;9.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;400.jpeg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2022-08-18_10-14-47.png"></p>
<h4 id="1-2-1-控制背景的平铺行为：background-repeat"><a href="#1-2-1-控制背景的平铺行为：background-repeat" class="headerlink" title="1.2.1 控制背景的平铺行为：background-repeat"></a>1.2.1 控制背景的平铺行为：<code>background-repeat</code></h4><ul>
<li><code>no-repeat</code> 不重复。</li>
<li><code>repeat-x</code> 水平重复。</li>
<li><code>repeat-y</code> 垂直重复。</li>
<li><code>repeat</code> 在两个方向重复。</li>
</ul>
<h4 id="1-2-2-调整背景图像的大小：-background-size"><a href="#1-2-2-调整背景图像的大小：-background-size" class="headerlink" title="1.2.2 调整背景图像的大小： background-size"></a>1.2.2 调整背景图像的大小： <code>background-size</code></h4><p>可以设置长度（100px 200px），百分比。</p>
<ul>
<li><p><code>cover</code>：浏览器将图像等比例放大，和元素盒子一样大，但是当图片尺寸和盒子尺寸不一致是往往会跳出盒子。</p>
</li>
<li><p><code>contain</code>：浏览器使图像的大小适应盒子内，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</p>
</li>
</ul>
<h4 id="1-2-3-背景图像定位：background-position"><a href="#1-2-3-背景图像定位：background-position" class="headerlink" title="1.2.3 背景图像定位：background-position"></a>1.2.3 背景图像定位：<code>background-position</code></h4><p>设置背景图像显示在其应用到的盒子中的位置，在盒子中坐标系（0，0）位于盒子的左上角。默认额的背景图像位置为（0,0）。</p>
<ul>
<li> <code>background-position</code> 是 <code>background-position-x</code> 和 <code>background-position-y</code>的简写，它们允许您分别设置不同的坐标轴的值。</li>
</ul>
<h4 id="1-2-4-背景附加：background-attachment"><a href="#1-2-4-背景附加：background-attachment" class="headerlink" title="1.2.4 背景附加：background-attachment"></a>1.2.4 背景附加：<code>background-attachment</code></h4><p>==此属性只有在有内容要滚动时才会有效果==。</p>
<p>它可以接受以下值：<a href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html">示例</a></p>
<ul>
<li><code>scroll</code>: 只有在页面滚动时背景图像在会滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li>
<li><code>fixed</code>: 使元素的背景固定在页面的某个位置上，这样当页面或元素内容滚动时，它都不会滚动。它将始终保持在屏幕上相同的位置。</li>
<li><code>local</code>: 使用该值元素滚动和页面滚动都会导致背景图像滚动。</li>
</ul>
<h3 id="1-3-渐变背景"><a href="#1-3-渐变背景" class="headerlink" title="1.3 渐变背景"></a>1.3 渐变背景</h3><p>当渐变用于背景时，也可以使用像图像一样的 <code>background-image</code>属性设置。</p>
<p><img src="/2022/08/18/CSS%E8%83%8C%E6%99%AF%E5%92%8C%E8%BE%B9%E6%A1%86/Users\LHKJ0\Pictures\WEB\CSS\Snipaste_2022-08-18_10-56-41.png">s</p>
<p>使用<code>background</code>可以设置全部的属性，但是在设置属性时有一些<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background">规则</a>：</p>
<ul>
<li><code>background-color</code> 只能在逗号之后指定。</li>
<li><code>background-size</code> 值只能包含在背景位置之后，用’/‘字符分隔，例如：<code>center/80%</code>。</li>
</ul>
<p>例如指定多个 <code>background-image</code> 的值时，用逗号分隔每个值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">image1</span><span class="selector-class">.png</span>), <span class="selector-tag">url</span>(<span class="selector-tag">image2</span><span class="selector-class">.png</span>), <span class="selector-tag">url</span>(<span class="selector-tag">image3</span><span class="selector-class">.png</span>), <span class="selector-tag">url</span>(<span class="selector-tag">image4</span><span class="selector-class">.png</span>);</span><br><span class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>, <span class="selector-tag">repeat-x</span>, <span class="selector-tag">repeat</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: 10<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>,  <span class="selector-tag">top</span> <span class="selector-tag">right</span>;</span><br></pre></td></tr></table></figure>
<p>不同的属性值， 与其他属性中相同位置的值匹配。</p>
<h2 id="2-边框"><a href="#2-边框" class="headerlink" title="2 边框"></a>2 边框</h2><p>使用 border属性设置 CSS 中盒子设置边框的颜色、宽度和样式。 </p>
<h3 id="2-1-边框样式：border-style"><a href="#2-1-边框样式：border-style" class="headerlink" title="2.1 边框样式：border-style"></a>2.1 边框样式：<code>border-style</code></h3><p>关键字用于描述边框样式。它可以有以下取值：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style">示例</a></p>
<table>
<thead>
<tr>
<th align="left"><code>none</code></th>
<th align="left">和关键字 <code>hidden</code> 类似，不显示边框。在这种情况下，如果没有设定背景图片，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 计算后的值将是 <code>0</code>，即使先前已经指定过它的值。在单元格边框重叠情况下，<code>none</code> 值优先级最低，意味着如果存在其他的重叠边框，则会显示为那个边框。</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>hidden</code></td>
<td align="left">和关键字 <code>none</code> 类似，不显示边框。在这种情况下，如果没有设定背景图片，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 计算后的值将是 <code>0</code>，即使先前已经指定过它的值。在单元格边框重叠情况下，<code>hidden</code> 值优先级最高，意味着如果存在其他的重叠边框，边框不会显示。</td>
</tr>
<tr>
<td align="left"><code>dotted</code></td>
<td align="left">显示为一系列圆点。标准中没有定义两点之间的间隔大小，视不同实现而定。圆点半径是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 计算值的一半。</td>
</tr>
<tr>
<td align="left"><code>dashed</code></td>
<td align="left">显示为一系列短的方形虚线。标准中没有定义线段的长度和大小，视不同实现而定。</td>
</tr>
<tr>
<td align="left"><code>solid</code></td>
<td align="left">显示为一条实线。</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left">显示为一条双实线，宽度是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a> 。</td>
</tr>
<tr>
<td align="left"><code>groove</code></td>
<td align="left">显示为有雕刻效果的边框，样式与 <code>ridge</code> 相反。</td>
</tr>
<tr>
<td align="left"><code>ridge</code></td>
<td align="left">显示为有浮雕效果的边框，样式与 <code>groove</code> 相反。</td>
</tr>
<tr>
<td align="left"><code>inset</code></td>
<td align="left">显示为有陷入效果的边框，样式与 <code>outset</code> 相反。当它指定到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a> 为 <code>collapsed</code> 的单元格时，会显示为 <code>groove</code> 的样式。</td>
</tr>
<tr>
<td align="left"><code>outset</code></td>
<td align="left">显示为有突出效果的边框，样式与 <code>inset</code> 相反。当它指定到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-collapse"><code>border-collapse</code></a> 为 <code>collapsed</code> 的单元格时，会显示为 <code>ridge</code> 的样式。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CSS</category>
        <category>背景和边框</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端包管理器之pnpm</title>
    <url>/2022/08/18/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8Bpnpm/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="前端包管理器之pnpm"><a href="#前端包管理器之pnpm" class="headerlink" title="前端包管理器之pnpm"></a>前端包管理器之pnpm</h1><p><a href="https://pnpm.io/zh/motivation">pnpm</a> 正如他官网的口号一样：速度快、节省磁盘空间的软件包管理器。</p>
<p>主要解决了npm的一些痛点：</p>
<ul>
<li>如果有多个项目，那么使用npm的情况下每个项目就会有各自的依赖，可能会造成依赖的重复，浪费磁盘空间。</li>
<li>不同版本的依赖，存储在同一位置，且不会因为版本的不同而修改保存依赖包的所有文件。</li>
</ul>
<p>最终的体现结果就是依赖的存储空间变少了，速速也会变快，官方声称构建速度是同类构建工具的将近2倍。</p>
<h2 id="1-安装pnpm"><a href="#1-安装pnpm" class="headerlink" title="1 安装pnpm"></a>1 安装pnpm</h2><p>建议写卸载现有的npm,node和nvm等其他的包管理器，和node版本管理器。</p>
<p>没有安装nodejs的情况下安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iwr</span> https://get.pnpm.io/install.ps1 <span class="literal">-useb</span> | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure>
<p>已经安装了npm的情况下安装, 直接全局安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> pnpm</span><br></pre></td></tr></table></figure>
<p>安装后修改如果嫌pnpm的命令长，可以改为短命令：pn</p>
<p>在windows中只需要两步：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、使用管理员打开终端</span></span><br><span class="line">notepad <span class="variable">$profile</span>.AllUsersAllHosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、在 profile.ps1 文件里加入：</span></span><br><span class="line"><span class="built_in">set-alias</span> <span class="literal">-name</span> pn <span class="literal">-value</span> pnpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存后，打开新的窗口直接使用 pn -v</span></span><br></pre></td></tr></table></figure>


<h2 id="2-pnpm的常用命令"><a href="#2-pnpm的常用命令" class="headerlink" title="2 pnpm的常用命令"></a>2 pnpm的常用命令</h2><p>大部分都和npm一致, 少数会有区别</p>
<h3 id="2-1-node环境管理"><a href="#2-1-node环境管理" class="headerlink" title="2.1 node环境管理"></a>2.1 node环境管理</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看有哪些可安装的node版本</span></span><br><span class="line">pn env list -<span class="literal">-remote</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地已经安装的node版本 或者是  pn env ls</span></span><br><span class="line">pn env list </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装/切换具体的node lts 版本, 或者指定版本号， 或者是 latest最新稳定版本   --global 可以简写为-g 和npm使用 别名差不多。 </span></span><br><span class="line">pn env use -<span class="literal">-global</span> lts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定版本的node</span></span><br><span class="line">pn env remove -<span class="literal">-global</span> <span class="number">14.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-设置-pnpm-配置"><a href="#2-2-设置-pnpm-配置" class="headerlink" title="2.2  设置 pnpm 配置"></a>2.2  设置 pnpm 配置</h3><p>Windows路径为：<strong>C:\Users&lt;UserName&gt;.npmrc</strong>，可以手动打开进行配置</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前配置   -g 列出全局配置</span></span><br><span class="line">pn config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 pnpm 的源</span></span><br><span class="line"><span class="comment"># 淘宝</span></span><br><span class="line">pn config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 腾讯</span></span><br><span class="line">pn config <span class="built_in">set</span> registry http://mirrors.cloud.tencent.com/npm/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 华为</span></span><br><span class="line">pn config <span class="built_in">set</span> registry https://repo.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure>
<h3 id="2-3-安装-更新-卸载包和相关依赖"><a href="#2-3-安装-更新-卸载包和相关依赖" class="headerlink" title="2.3 安装/更新/卸载包和相关依赖"></a>2.3 安装/更新/卸载包和相关依赖</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -g 全局安装  -D 保存到 devDependencies</span></span><br><span class="line">pn add <span class="literal">-g</span> pkg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line"><span class="comment"># 在不带参数的情况下使用时，将更新所有依赖关系</span></span><br><span class="line">pn update pkg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载 -g 全局卸载</span></span><br><span class="line">pn remove <span class="literal">-g</span> pkg</span><br><span class="line"><span class="comment"># 别名：rm, uninstall, un</span></span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>前端包管理器</category>
        <category>pnpm</category>
      </categories>
      <tags>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>前端包管理器之npm</title>
    <url>/2022/08/18/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8Bnpm/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="前端包管理器之npm"><a href="#前端包管理器之npm" class="headerlink" title="前端包管理器之npm"></a>前端包管理器之npm</h1><p>npm是一个软件注册中心，有大量的开发者和组织将软件上传到npm。npm是由三部分构成， website、cli、register。 我们最常用的就是npm cli。</p>
<h2 id="1-安装npm"><a href="#1-安装npm" class="headerlink" title="1 安装npm"></a>1 安装npm</h2><p>要使用npm, 需要安装node.js和npm软件，node.js 是一个异步事件驱动的 JavaScript 运行时。</p>
<p>node.js 就像其他的语言一样，有很多的版本， npm官网推荐使用<code>nvm</code>–一个node版本管理器，为了解决nodejs各种版本不兼容的问题，类似Python的conda。</p>
<p>nvm: 一个node版本管理器， 提供不同版本的node和npm安装。</p>
<p>node.js: 一个JavaScript运行时。</p>
<p>npm: 一个前端包管理器。</p>
<h2 id="2-安装nvm"><a href="#2-安装nvm" class="headerlink" title="2 安装nvm"></a>2 安装nvm</h2><p>在windwos上安装 nvm <a href="https://github.com/coreybutler/nvm-windows">Github地址</a>，<a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a>。 直接下载 .exe 可执行文件进行安装。</p>
<p>常用命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nvm version <span class="comment"># 显示nvm的版本</span></span><br><span class="line"></span><br><span class="line">nvm list <span class="comment"># 列出当前系统安装的node.js 版本列表，使用【*】开头的代表，正在使用的版本。</span></span><br><span class="line"></span><br><span class="line">nvm list available <span class="comment"># 列出可供下载的nodejs版本</span></span><br><span class="line"></span><br><span class="line">nvm url </span><br><span class="line"></span><br><span class="line">nvm install &lt;版本号&gt;  [--<span class="type">insecure</span>]   <span class="comment"># 安装指定版本的nodejs， 加上--insecure绕过远程验证。</span></span><br><span class="line"></span><br><span class="line">nvm root &lt;path&gt;: <span class="comment"># 设置nvm存放不同版本node.js的目录。如果&lt;path&gt;未设置，将显示当前根目录。</span></span><br><span class="line"></span><br><span class="line">nvm node_mirror &lt;node_mirror_url&gt; <span class="comment"># 设置node国内镜像：https://npmmirror.com/mirrors/node/</span></span><br><span class="line"></span><br><span class="line">nvm npm_mirror &lt;npm_mirror_url&gt; <span class="comment"># 设置npm国内镜像：https://npmmirror.com/mirrors/npm/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上三个配置也可以到nvm的安装路径下的settings.txt设置</span></span><br></pre></td></tr></table></figure>
<p>使用nvm install nodejs版本号。 即可安装和nodejs匹配的npm。</p>
<h2 id="3-npm的常用命令"><a href="#3-npm的常用命令" class="headerlink" title="3 npm的常用命令"></a>3 npm的常用命令</h2><h3 id="3-1-查询npm的版本"><a href="#3-1-查询npm的版本" class="headerlink" title="3.1 查询npm的版本"></a>3.1 查询npm的版本</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="literal">-v</span> </span><br></pre></td></tr></table></figure>
<h3 id="3-2-初始化或更新一个包"><a href="#3-2-初始化或更新一个包" class="headerlink" title="3.2 初始化或更新一个包"></a>3.2 初始化或更新一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成它而不让它问任何问题</span></span><br><span class="line">npm init <span class="literal">-y</span> </span><br></pre></td></tr></table></figure>
<h3 id="3-3-安装一个包"><a href="#3-3-安装一个包" class="headerlink" title="3.3 安装一个包"></a>3.3 安装一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm installl package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名 i，add, in, ins, inst, insta, instal, isnt, isnta, isntal, isntall</span></span><br><span class="line"><span class="comment"># npm install package -g   全局安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># npm i package@latest 指定最新版本， 或者版本号</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-全新安装项目-（安装一个干净的项目）"><a href="#3-4-全新安装项目-（安装一个干净的项目）" class="headerlink" title="3.4 全新安装项目 （安装一个干净的项目）"></a>3.4 全新安装项目 （安装一个干净的项目）</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm ci</span><br><span class="line"><span class="comment"># 别名: clean-install, ic, install-clean, isntall-clean</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令与 npm install 类似，不同之处在于它旨在用于自动化环境，例如测试平台、持续集成和部署——或任何您希望确保对依赖项进行全新安装的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 npm install 和 npm ci 的主要区别是：</span></span><br><span class="line"><span class="comment"># 1.该项目必须具有现有的 package-lock.json 或 npm-shrinkwrap.json。</span></span><br><span class="line"><span class="comment"># 2. 如果包锁中的依赖项与 package.json 中的依赖项不匹配，npm ci 将退出并出错，而不是更新包锁。</span></span><br><span class="line"><span class="comment"># 3. npm ci 一次只能安装整个项目： 不能使用此命令添加单个依赖项。</span></span><br><span class="line"><span class="comment"># 4. 如果 node_modules 已经存在，它将在 npm ci 开始安装之前自动删除。</span></span><br><span class="line"><span class="comment"># 5. 它永远不会写入 package.json 或任何包锁： 安装基本上被冻结了。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-管理-npm-配置文件"><a href="#3-5-管理-npm-配置文件" class="headerlink" title="3.5 管理 npm 配置文件"></a>3.5 管理 npm 配置文件</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> &lt;key&gt;=&lt;value&gt; [&lt;<span class="type">key</span>&gt;=&lt;<span class="type">value</span>&gt; <span class="type">...</span>]</span><br><span class="line">npm config get [&lt;<span class="type">key</span>&gt; [&lt;<span class="type">key</span>&gt; <span class="type">...</span>]]</span><br><span class="line">npm config delete &lt;key&gt; [&lt;<span class="type">key</span>&gt; <span class="type">...</span>]</span><br><span class="line">npm config list [--<span class="type">json</span>]</span><br><span class="line">npm config edit</span><br><span class="line">npm config fix</span><br><span class="line"><span class="comment"># 别名: c</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-列出安装的包"><a href="#3-6-列出安装的包" class="headerlink" title="3.6 列出安装的包"></a>3.6 列出安装的包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">ls</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># npm ls --all 列出所有包的依赖</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-启动一个包"><a href="#3-7-启动一个包" class="headerlink" title="3.7 启动一个包"></a>3.7 启动一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">start</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将运行在包的 &quot;scripts&quot; 对象的 &quot;start&quot; 属性中指定的预定义命令。如果 &quot;scripts&quot; 对象没有定义 &quot;start&quot; 属性，npm 将运行 node server.js。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-8-停止一个包"><a href="#3-8-停止一个包" class="headerlink" title="3.8 停止一个包"></a>3.8 停止一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm stop </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将运行在包的 &quot;scripts&quot; 对象的 &quot;stop&quot; 属性中指定的预定义命令。与 npm start 不同，如果未定义 &quot;stop&quot; 属性，则不会运行默认脚本。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-9-测试一个包"><a href="#3-9-测试一个包" class="headerlink" title="3.9 测试一个包"></a>3.9 测试一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm test </span><br><span class="line"><span class="comment"># 这将运行在包的 &quot;scripts&quot; 对象的 &quot;test&quot; 属性中指定的预定义命令。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-10-卸载一个包"><a href="#3-10-卸载一个包" class="headerlink" title="3.10 卸载一个包"></a>3.10 卸载一个包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm uninstall package</span><br><span class="line"><span class="comment"># 别名： unlink, remove, rm, r, un</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将卸载一个包，完全删除代表它安装的所有 npm。</span></span><br><span class="line"><span class="comment"># 它还会从 package.json 中的 dependencies、devDependencies、optionalDependencies 和 peerDependencies 对象中删除包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 --no-save  不会从package.json、npm-shrinkwrap.json 或 package-lock.json 文件中删除。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-11-更新包"><a href="#3-11-更新包" class="headerlink" title="3.11 更新包"></a>3.11 更新包</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm update package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名: up, upgrade, udpate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此命令会将列出的所有包更新到最新版本（由 tag 配置 指定），同时尊重包及其依赖项的 semver 约束（如果它们也需要相同的包）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它还将安装缺少的包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定了 -g 标志，此命令将更新全局安装的包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果未指定包名称，则将更新指定位置（全局或本地）中的所有包。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，默认情况下，npm update 不会更新项目 package.json 中直接依赖项的 semver 值，如果你还想更新 package.json 中的值，你可以运行： npm update --save</span></span><br></pre></td></tr></table></figure>


<p>详细的命令来自 <a href="https://npm.nodejs.cn/">npm中文网</a>。</p>
]]></content>
      <categories>
        <category>前端包管理器</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS溢出</title>
    <url>/2022/08/17/CSS%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<p>CSS溢出</p>
<p>在CSS中一切皆盒子，我们可以设置盒子的大小，但是当我们的内容大于盒子的大小的时候，就会导致内容溢出。</p>
<p>控制溢出的几种方式</p>
<p>overflow</p>
<p>默认值：<code>visible</code>，默认情况下溢出是可见的。</p>
<p>如果想让溢出的元素裁减掉，可以使用<code>hidden</code>。</p>
<p>既不裁剪也不希望溢出，<code>scroll</code> 更合适，他会在原本的盒子上加一个滚动条，既保证盒子的大小，也不会将数据裁减掉。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333333</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>This box has a height and a width. This means that if there is too much content to be displayed within the assigned height, there will be an overflow situation. If overflow is set to hidden then any overflow will not be visible.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This content is outside of the box.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2022-08-18_14-22-00.png"></p>
<p>以上的情况确实显示滚动条，但是横向也显示了滚动条，如果只希望在Y轴上显示可以使用<code>overflow-y: scroll</code>。同理x轴：<code>overflow-x: scroll</code>。</p>
<p>使用<code>overflow: auto</code>，由浏览器决定是否显示滚动条。桌面浏览器一般仅仅会在有足以引起溢出的内容的时候这么做。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>溢出</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS盒模型</title>
    <url>/2022/08/17/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><p>在CSS中所有的元素都被一个个的<em>“盒子”</em>包围着，CSS的布局处理元素排列正式通过盒子来实现的。</p>
<p>在CSS中有两种盒子是被广泛使用的：块级（block）盒子和内联（inline）盒子。这两种盒子会在页面上表现出两种不同的行为。</p>
<h2 id="1-块级盒子"><a href="#1-块级盒子" class="headerlink" title="1 块级盒子"></a>1 块级盒子</h2><ul>
<li>盒子会在内联的方向上扩展并占据父容器的在该方向上的所有可用空间，大多数情况下意味着盒子会和父容器一样宽。</li>
<li>每个盒子都会换行。</li>
<li><code>width</code>和<code>hright</code>属性可以发挥作用。</li>
<li>内边距（padding）外边距（margin）和边框（border）会将其他的元素从当前格子周围推开。(相邻两个块级盒子之间的垂直间距会遵循外边距折叠原则被折叠。)</li>
</ul>
<p>除非特殊指定，诸如<code>h1</code>等和段落<code>p</code>默认都是块级的盒子。</p>
<h2 id="2-内联盒子"><a href="#2-内联盒子" class="headerlink" title="2 内联盒子"></a>2 内联盒子</h2><ul>
<li>内联盒子不会产生换行。</li>
<li><code>width</code>和<code>hright</code>属性不起作用。</li>
<li>垂直方向的内边距（padding）外边距（margin）和边框（border）==会被应用==，但是==不会==把其他的处于<code>inline</code>状态的盒子推开。</li>
<li>水平方向的内边距（padding）外边距（margin）和边框（border）==会被应用==，==会==把其他的处于<code>inline</code>状态的盒子推开。</li>
</ul>
<p>针对块级盒子和内联盒子可以使用<code>display</code>属性设置<code>block</code>和<code>inline</code>。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="* 补充"></a>* 补充</h2><p>以上叙述中是CSS盒模型的外部显示类型，决定盒子是内联盒子还是块级盒子。同样盒模型也有一个内部显示类型，它决定了盒子内部是如何布局的，默认是按照<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Normal_Flow">正常文档流布局</a>，但是可以通过<code>flex</code>的<code>display</code>属性来更改内部显示类型。</p>
<p>例如：如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。==该盒子的所有直接子元素都会成为 flex 元素==。会根据==<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">弹性盒子</a>==规则进行布局。</p>
<p>块级和内联是web上默认的行为，它们被称为正常文档流，如果没有其他的说明，盒子的默认布局就是块级或者内联。</p>
<h2 id="3-盒模型的组成部分"><a href="#3-盒模型的组成部分" class="headerlink" title="3 盒模型的组成部分"></a>3 盒模型的组成部分</h2><ul>
<li>Content Box：这个区域使用来显示内容，大小可以通过设置<code>width</code>和<code>height</code>。</li>
<li>Padding Box：包围在内容区域外部的空白区域，大小可以通过<code>padding</code>设置。</li>
<li>Border Box：盒子的边框区域，大小通过<code>border</code>设置。</li>
<li>Margin Box：盒子的最外围区域，是盒子和其他元素之间的空白区域，大小通过<code>margin</code>设置。</li>
</ul>
<p>如下图：</p>
<p><img src="https://origin.chaizz.com/tc/box-model.png"></p>
<h2 id="4-标准盒模型"><a href="#4-标准盒模型" class="headerlink" title="4 标准盒模型"></a>4 标准盒模型</h2><p>在标准盒模型中，给盒子设置width和height，实际设置的是content box padding和border再加上一起设置的width和height再决定了盒子的大小。</p>
<p>假设定义了 <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>和<code>padding</code>:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>计算出的模型宽度 = 410px(350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。</p>
<p><img src="/2022/08/17/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/Users\LHKJ0\Pictures\WEB\CSS\standard-box-model.png"></p>
<blockquote>
<p>注意：margin不计入实际大小，但是它会影响盒子实际占用的空间，影响的是盒子外部的空间，盒子的范围到边框为止，不会延伸到margin。</p>
</blockquote>
<h2 id="5-替代盒模型"><a href="#5-替代盒模型" class="headerlink" title="5 替代盒模型"></a>5 替代盒模型</h2><p>这个模型所有的宽度都是可见宽度，所以内容的宽度是总宽度减去边框的宽度和内边距的宽度。</p>
<p>默认浏览器会使用标准盒模型，需要使用替代模型需要设置 <code>box-sizing:border-box</code>。如果想让所有元素都是用替代模型，只需要在html元上指定<code>box-sizing</code>，然后设置所有元素继承该属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *<span class="selector-pseudo">::before</span>, *<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-盒子模型的属性解析"><a href="#6-盒子模型的属性解析" class="headerlink" title="6 盒子模型的属性解析"></a>6 盒子模型的属性解析</h2><h3 id="6-1-外边距（margin）"><a href="#6-1-外边距（margin）" class="headerlink" title="6.1 外边距（margin）"></a>6.1 外边距（margin）</h3><p>外边距是盒子周围看不到的一些空间，他会把其他的元素从盒子旁边推开，外边距的属性可以为正也可以为负，设置负值会导致和其他的内容重叠。无论是使用标准盒子模型还是替代盒子模型，外边距总是在计算可见部分后额外的添加。</p>
<p>可以使用<code>margin</code>设置四个反向的内容，也可以分别使用四个独立的属性设置：<code>margin-top</code>、<code>margin-right</code>、<code>margin-left</code>、<code>margin-right</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;        <span class="comment">/* 绝对长度 */</span></span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">1em</span>;         <span class="comment">/*相对于字体大小 */</span></span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">5%</span>;          <span class="comment">/*相对于最相邻的父级元素块（block）的宽度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>外边距折叠：如果有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的那个外边距的大小。</p>
<p>有设定<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float">float</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#absolute">position=absolute</a>的元素不会产生外边距重叠行为。</p>
</blockquote>
<h3 id="6-2-内边距（padding）"><a href="#6-2-内边距（padding）" class="headerlink" title="6.2 内边距（padding）"></a>6.2 内边距（padding）</h3><p>内边距位于边框和内容之间，==且不能有负数的形式==，应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>简写属性控制元素所有边，或者每边单独使用等价的普通属性：<code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code>。</p>
<h3 id="6-3-边框（border）"><a href="#6-3-边框（border）" class="headerlink" title="6.3 边框（border）"></a>6.3 边框（border）</h3><p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p>
<p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性一次设置所有四个边框的宽度、颜色和样式。</p>
<p>分别设置每边的宽度、颜色和样式，可以使用：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></p>
<p>设置所有边的颜色、样式或宽度，请使用以下属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></p>
<p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-style"><code>border-top-style</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-color"><code>border-top-color</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-width"><code>border-right-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-style"><code>border-right-style</code></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-color"><code>border-right-color</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-width"><code>border-bottom-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-style"><code>border-bottom-style</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-color"><code>border-bottom-color</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-width"><code>border-left-width</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-style"><code>border-left-style</code>、</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-color"><code>border-left-color</code></a></p>
<h2 id="7-盒子模型和内联盒子"><a href="#7-盒子模型和内联盒子" class="headerlink" title="7 盒子模型和内联盒子"></a>7 盒子模型和内联盒子</h2><p>以上所有的方法都完全适用于块级盒子，有些属性也可以应用于内联盒子。在内联合中应用宽度、高度、边距、边框和内边距时，宽度和高度是被忽略的，外边距、内边距和边框是生效的。但是他们不会改变其他内容与盒子的关系，因此内边距和边框会与段落中的其他单词重叠。</p>
<p><img src="/2022/08/17/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/Users\LHKJ0\Pictures\WEB\CSS\Snipaste_2022-08-17_17-29-30.png"></p>
<p>为了解决以上的问题可以使用：display: inline-block。display 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用：不希望一个元素切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p>
<p>一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果：</p>
<ul>
<li>设置<code>width</code> 和<code>height</code> 属性会生效。</li>
<li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li>
</ul>
<p>但是，它不会跳转到新行，如果显式添加 <code>width</code> 和 <code>height</code> 属性，它只会变得比其内容更大。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>盒模型</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS层叠与继承</title>
    <url>/2022/08/16/CSS%E5%B1%82%E5%8F%A0%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS-层叠与继承"><a href="#CSS-层叠与继承" class="headerlink" title="CSS 层叠与继承"></a>CSS 层叠与继承</h1><blockquote>
<p>某些时候项目过程中，会有些样式效果没有生效，很有可能就是创建了应用于两个元素的同一规则。</p>
</blockquote>
<h2 id="1-层叠"><a href="#1-层叠" class="headerlink" title="1 层叠"></a>1 层叠</h2><p>层叠可以理解为覆盖，简单的说就是CSS规则的顺序很重要，当应用两条同级别的规则到同一个元素的时候，最后的一个规则即是生效的规则。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123; </span><br><span class="line">    <span class="attribute">color</span>: red; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123; </span><br><span class="line">    <span class="attribute">color</span>: blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is my heading.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2 优先级"></a>2 优先级</h2><p>浏览器根据优先级决定当多个规则有不同选择器对应相同的元素的时候需要应用那个规则，他基本上是一个衡量选择器具体选择哪些区域的尺度：</p>
<ul>
<li><p>外链CSS地址优先级最低。</p>
</li>
<li><p>标签选择器选择页面上该类型的所有元素，他的优先级低一点。</p>
</li>
<li><p>类选择器相对于标签选择器会具体一点，他会选择页面上中有特定<code>class</code>属性值的元素，所以他的优先级就要高一点。</p>
</li>
<li><p>ID选择器是针对于网页中唯一的标签属性优先级会更高一点。</p>
</li>
<li><p>内联样式优先级最高。</p>
</li>
</ul>
<h3 id="2-1-浏览器如何计算优先级"><a href="#2-1-浏览器如何计算优先级" class="headerlink" title="2.1 浏览器如何计算优先级"></a>2.1 浏览器如何计算优先级</h3><p>不同的选择器会有不同的分值，把这些分值相加就得到特定选择器的权重，然后再进行匹配。</p>
<p>一个选择器有四个部分的分值相加可以认为是：个十百千 四位数的个位数。</p>
<ol>
<li>千位：如果是内联样式，该位得一分，没有声明选择器所以得分是1000（内联样式优先级最高）。</li>
<li>百位：ID选择器得一分。</li>
<li>十位：类选择器得一分（包括属性选择器、伪类选择器）。</li>
<li>元素（标签）选择器，伪元素选择器器得一分。</li>
</ol>
<blockquote>
<p><strong>备注：</strong> 通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
</blockquote>
<blockquote>
<p><strong>警告：</strong> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 1. specificity: 1-0-1 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">/* 2. specificity: 2-0-1 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-id">#inner</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. specificity: 1-0-4 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">div</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. specificity: 1-1-3 */</span></span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">div</span> <span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5. specificity: 0-2-4 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. specificity: 0-2-3 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> dashed black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. specificity: 0-3-3 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-class">.nav</span><span class="selector-pseudo">:nth-child(2)</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> double black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>针对上面的代码解释：</p>
<ul>
<li>前面两个选择器都是链接背景颜色的样式 — 第二个赢了使得背景变成蓝色因为它多了一个 ID 选择器：优先级 201 vs. 101。</li>
<li>第三四个选择器都是链接文本颜色样式 — 第二个（第四个）赢了使得文本变成白色因为它虽然少一个元素选择器，但是多了一个类选择器，多了 9 分。所以优先级是 113 vs. 104。</li>
<li>第 5 到 7 个选择器都是鼠标悬停时链接边框样式。第六个显然输给第五个优先级是 23 vs. 24 — 少了个元素选择器。 第七个，比第五第六都高 — 子选择器数量相同，但是有一个元素选择器变成类选择器。所以最后优先级是 33 vs. 23 和 24。</li>
</ul>
<p><strong>注意</strong></p>
<p>有一个特殊的CSS可以覆盖上面的所有的优先级计算：<code>!important</code> 用于修改特定属性的值，能够覆盖普通规则的值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#winning</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.better</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;better&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;better&quot;</span> <span class="attr">id</span>=<span class="string">&quot;winning&quot;</span>&gt;</span>One selector to rule them all!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>代码解释：</p>
<p>按照以上代码渲染出的效果应该是：<code>class=&quot;better&quot;</code>的p标签背景是灰色的，字体颜色为白色，内边距为5px，没有边框。</p>
<p><code>id=&quot;winning&quot;</code>的p标签背景色是红色的，字体颜色为白色，内边距为5px。同样没有边框。因为在两个p标签都有类属性：<code>better</code> 且<code>better</code>的<code>border</code>设置了<code>!important</code>。尽管优先级比较低，也使用了这个CSS样式。</p>
<p>__覆盖<code>!important</code>__的方法就是使用另外一个<code>!important</code> 具有相同的优先级且顺序靠后的，或者是优先级跟高。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>相互冲突的声明按照以下顺序适用，后面的覆盖前面的。</p>
<ol>
<li>用户代理样式表中的声明（浏览器的默认样式，在没有设置其他的样式时使用）。</li>
<li>用户样式表中的常规声明 (由用户设置的自定义样式)。</li>
<li>作者样式表中的常规声明 (这些是我们 web 开发人员设置的样式)。</li>
<li>作者样式表中的<code>!important</code>声明。</li>
<li>用户样式表中的<code>!important</code> 声明</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
        <category>层叠与继承</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/2022/08/16/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><blockquote>
<p>CSS中使用选择器来指定网页上我们想要格式化的HTML元素</p>
</blockquote>
<h2 id="1-选择器列表"><a href="#1-选择器列表" class="headerlink" title="1 选择器列表"></a>1 选择器列表</h2><p>如果有多个使用相同样式的CSS选择器，那么这些选择器可以被编排为一个列表。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个标签使用了同样的样式可以写成两个分开的规则，也可以则合起来，在他们之间加上逗号即可组成为一个选择器列表。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>在使用选择器列表时，如果任何一个选择器无效（存在语法错误）那么整条规则都会被疏略。</p>
<h2 id="2-选择器种类"><a href="#2-选择器种类" class="headerlink" title="2 选择器种类"></a>2 选择器种类</h2><table>
<thead>
<tr>
<th><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors">标签选择器</a></th>
<th><code>h1 &#123; &#125;</code></th>
<th align="left">html标签</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">通配选择器</a></td>
<td><code>* &#123; &#125;</code></td>
<td align="left">选择所有元素</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors">类选择器</a></td>
<td><code>.box &#123; &#125;</code></td>
<td align="left">类选择器</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors">ID 选择器</a></td>
<td><code>#unique &#123; &#125;</code></td>
<td align="left">标签选择器</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">标签属性选择器</a></td>
<td><code>a[title] &#123; &#125;</code></td>
<td align="left">根据标签一个元素上某个标签的属性的存在选择元素</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类选择器</a></td>
<td><code>a:hover &#123;&#125;</code></td>
<td align="left">表示一个元素的特定的状态  <em>(在鼠标指针悬浮到一个元素上的时候选择这个元素)</em></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">伪元素选择器</a></td>
<td><code>p::first-line &#123; &#125;</code></td>
<td align="left">选择一个元素的某个部分而不是元素自己 <em>(<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行)</em></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator">后代选择器</a></td>
<td><code>article p</code></td>
<td align="left">（通常用单个空格（” “）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator">子代选择器</a></td>
<td><code>article &gt; p</code></td>
<td align="left">当使用 <code>&gt;</code> 选择符分隔两个元素时，它只会匹配那些作为第一个元素的**直接后代 (**子元素) 的第二元素。与之相比，当两个元素由 <a href="https://developer.mozilla.org/en-US/CSS/Descendant_selectors">后代选择器</a> 相连时，它表示匹配存在的所有由第一个元素作为祖先元素 (但不一定是父元素) 的第二个元素，无论它在 DOM 中”跳跃” 多少次。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator">相邻兄弟选择器</a></td>
<td><code>h1 + p</code></td>
<td align="left">介于两个选择器之间，当第二个元素<em>紧跟在</em>第一个元素之后，并且两个元素都是属于同一个父<code>元素</code>的子元素，则第二个元素将被选中。</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">通用兄弟选择器</a></td>
<td><code>h1 ~ p</code></td>
<td align="left">兄弟选择符，位置无须紧邻，只须同层级，<code>A~B</code> 选择<code>A</code>元素之后所有同层级<code>B</code>元素。</td>
</tr>
</tbody></table>
<h3 id="2-1-标签、类和-ID-选择器"><a href="#2-1-标签、类和-ID-选择器" class="headerlink" title="2.1 标签、类和 ID 选择器"></a>2.1 标签、类和 ID 选择器</h3><p><strong>类型选择器</strong>有时也叫做“标签名选择器<em>”</em>或者是”元素选择器“，因为它在文档中选择了一个 HTML 标签/元素的缘故。</p>
<p>类选择器以一个句点（<code>.</code>）开头，会选择文档中应用了这个类的所有元素。</p>
<p>ID 选择器开头为<code>#</code>而非句点，和类选择器是同种用法。</p>
<h4 id="2-1-1-全局选择器"><a href="#2-1-1-全局选择器" class="headerlink" title="2.1.1 全局选择器"></a>2.1.1 全局选择器</h4><p>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容。</p>
<p>更易读的全局选择器， 例如：</p>
<p>如果我想选中任何<code>&lt;article&gt;</code>元素的第一子元素，不论它是什么元素，都给它加粗。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来可能会和 为元素选择器混淆</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:first-child</span></span><br></pre></td></tr></table></figure>
<p>为了避免这种混淆，我们可以向<code>:first-child</code>选择器加入全局选择器，这样选择器所做的事情很容易就能看懂。选择器正选中<code>&lt;article&gt;</code>元素的<em>任何</em>第一子元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> *<span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-属性选择器"><a href="#2-2-属性选择器" class="headerlink" title="2.2 属性选择器"></a>2.2 属性选择器</h3><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr]</code></td>
<td align="left"><code>a[title]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td>
</tr>
<tr>
<td align="left"><code>[attr=value]</code></td>
<td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr~=value]</code></td>
<td align="left"><code>p[class~=&quot;special&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td>
</tr>
<tr>
<td align="left">`[attr</td>
<td align="left">=value]`</td>
<td align="left">`div[lang</td>
</tr>
</tbody></table>
<h4 id="2-2-1-字符串匹配选择器"><a href="#2-2-1-字符串匹配选择器" class="headerlink" title="2.2.1 字符串匹配选择器"></a>2.2.1 字符串匹配选择器</h4><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>[attr^=value]</code></td>
<td align="left"><code>li[class^=&quot;box-&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td>
</tr>
<tr>
<td align="left"><code>[attr$=value]</code></td>
<td align="left"><code>li[class$=&quot;-box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td>
</tr>
<tr>
<td align="left"><code>[attr*=value]</code></td>
<td align="left"><code>li[class*=&quot;box&quot;]</code></td>
<td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td>
</tr>
</tbody></table>
<p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。这个标记告诉浏览器，要以大小写不敏感的方式匹配 ASCII 字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式进行匹配，<strong>在HTML中是大小写敏感的</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">li[class^=&quot;a&quot; i] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Case-insensitivity<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;A&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;Ab&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-伪类伪元素选择器"><a href="#2-3-伪类伪元素选择器" class="headerlink" title="2.3 伪类伪元素选择器"></a>2.3 伪类伪元素选择器</h3><h4 id="2-3-1-伪类选择器"><a href="#2-3-1-伪类选择器" class="headerlink" title="2.3.1 伪类选择器"></a>2.3.1 伪类选择器</h4><p>它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。伪元素开头为双单冒号<code>:</code>。</p>
<p>应用案例：</p>
<p>比如要让某个文章的第一段加粗，字体变大。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">            melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">            greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用以上样式的确可以实现需求，但是此时文章开头又加入了一段话，就需要将 <code>class=&quot;first&quot;</code>改到第一段，比较麻烦。此时就可以使用伪类选择器<code>class=&quot;first&quot;</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">            melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">            greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样始终能够保持article下面第一个标签样式被加粗字体变大。</p>
<p>此外还有其他的几个伪类选择器</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a> 父元素的最后一个元素。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a> 匹配没有任何兄弟元素的元素。等效的选择器还可以写成 <code>:first-child:last-child</code>或者<code>:nth-child(1):nth-last-child(1)</code>,当然，前者的权重会低一点。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a> 表示任意内容未通过验证的 <code>input</code>或其他 <code>form</code> 元素， 这个伪类对于突出显示用户的字段错误非常有用。</li>
</ul>
<p>用户行为伪类也叫做动态伪类。表现形式为像是一个类在用户和元素交互的时候加到了元素上一样。</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:hover"><code>:hover</code></a>——上面提到过，只会在用户将指针挪到元素上的时候才会激活，一般就是链接元素。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:focus"><code>:focus</code></a>——只会在用户使用键盘控制，选定元素的时候激活。</li>
</ul>
<h5 id="常见的伪类类型"><a href="#常见的伪类类型" class="headerlink" title="常见的伪类类型"></a>常见的伪类类型</h5><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a></td>
<td align="left">在用户激活（例如点击）元素的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link"><code>:any-link</code></a></td>
<td align="left">匹配一个链接的<code>:link</code>和<code>:visited</code>状态。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:blank"><code>:blank</code></a></td>
<td align="left">匹配空输入值的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">``元素</a>。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked"><code>:checked</code></a></td>
<td align="left">匹配处于选中状态的单选或者复选框。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API"><code>:current</code> </a></td>
<td align="left">匹配正在展示的元素，或者其上级元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default"><code>:default</code></a></td>
<td align="left">匹配一组相似的元素中默认的一个或者更多的 UI 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir"><code>:dir</code></a></td>
<td align="left">基于其方向性（HTML<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir"><code>dir</code></a>属性或者 CSS<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/direction"><code>direction</code></a>属性的值）匹配一个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled"><code>:disabled</code></a></td>
<td align="left">匹配处于关闭状态的用户界面元素</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty"><code>:empty</code></a></td>
<td align="left">匹配除了可能存在的空格外，没有子元素的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled"><code>:enabled</code></a></td>
<td align="left">匹配处于开启状态的用户界面元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first"><code>:first</code></a></td>
<td align="left">匹配<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Paged_Media">分页媒体</a>的第一页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a></td>
<td align="left">匹配兄弟元素中的第一个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type"><code>:first-of-type</code></a></td>
<td align="left">匹配兄弟元素中第一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a></td>
<td align="left">当一个元素有焦点的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible"><code>:focus-visible</code></a></td>
<td align="left">当元素有焦点，且焦点对用户可见的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within"><code>:focus-within</code></a></td>
<td align="left">匹配有焦点的元素，以及子代元素有焦点的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:future"><code>:future</code> </a></td>
<td align="left">匹配当前元素之后的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a></td>
<td align="left">当用户悬浮到一个元素之上的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate"><code>:indeterminate</code></a></td>
<td align="left">匹配未定态值的 UI 元素，通常为<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox">复选框</a>。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range"><code>:in-range</code></a></td>
<td align="left">用一个区间匹配元素，当值处于区间之内时匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>的位于不可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang"><code>:lang</code></a></td>
<td align="left">基于语言（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang">lang</a>属性的值）匹配元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></td>
<td align="left">匹配兄弟元素中最末的那个元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type"><code>:last-of-type</code></a></td>
<td align="left">匹配兄弟元素中最后一个某种类型的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left"><code>:left</code></a></td>
<td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 </a>中，匹配左手边的页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a></td>
<td align="left">匹配未曾访问的链接。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:local-link"><code>:local-link</code></a></td>
<td align="left">匹配指向和当前文档同一网站页面的链接。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a></td>
<td align="left">匹配传入的选择器列表中的任何选择器。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not"><code>:not</code></a></td>
<td align="left">匹配作为值传入自身的选择器未匹配的物件。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a></td>
<td align="left">匹配一列兄弟元素中的元素——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type"><code>:nth-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child"><code>:nth-last-child</code></a></td>
<td align="left">匹配一列兄弟元素，从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type"><code>:nth-last-of-type</code></a></td>
<td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素），从后往前倒数。兄弟元素按照<em>an+b</em>形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></td>
<td align="left">匹配没有兄弟元素的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type"><code>:only-of-type</code></a></td>
<td align="left">匹配兄弟元素中某类型仅有的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional"><code>:optional</code></a></td>
<td align="left">匹配不是必填的 form 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range"><code>:out-of-range</code></a></td>
<td align="left">按区间匹配元素，当值不在区间内的的时候匹配。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:past"><code>:past</code> </a></td>
<td align="left">匹配当前元素之前的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown"><code>:placeholder-shown</code></a></td>
<td align="left">匹配显示占位文字的 input 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:playing"><code>:playing</code> </a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:paused"><code>:paused</code> </a></td>
<td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only"><code>:read-only</code></a></td>
<td align="left">匹配用户不可更改的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write"><code>:read-write</code></a></td>
<td align="left">匹配用户可更改的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required"><code>:required</code></a></td>
<td align="left">匹配必填的 form 元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right"><code>:right</code></a></td>
<td align="left">在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Pages">分页媒体 </a>中，匹配右手边的页。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a></td>
<td align="left">匹配文档的根元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope"><code>:scope</code></a></td>
<td align="left">匹配任何为参考点元素的的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid"><code>:valid</code></a></td>
<td align="left">匹配诸如<code>&lt;input&gt;</code>元素的处于可用状态的元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target"><code>:target</code></a></td>
<td align="left">匹配当前 URL 目标的元素（例如如果它有一个匹配当前<a href="https://en.wikipedia.org/wiki/Fragment_identifier">URL 分段</a>的元素）。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a></td>
<td align="left">匹配已访问链接。</td>
</tr>
</tbody></table>
<h4 id="2-3-2-伪元素选择器"><a href="#2-3-2-伪元素选择器" class="headerlink" title="2.3.2 伪元素选择器"></a>2.3.2 伪元素选择器</h4><p>伪元素和伪类的形式差不多，但是是表现得像往标记文本中加入全新的 HTML 元素一样，伪元素开头为双冒号<code>::</code>。</p>
<p>应用案例：</p>
<p>比如要让某个文章的第一行字体加粗，变大。</p>
<p>如果用span来实现，当无法知道屏幕的大小，或者字体大小的时候就无法准确选择第一行，所以伪元素选择器就可以完全很好的实现这一样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">            melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">            greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>特别的伪元素 <code>::before</code>和<code>::after</code>和<code>cotent</code>属性一起使用，使用CSS将内容插入到你的文档中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;This should show before the other content.&quot;</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Content in the box in my HTML page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些伪元素并不会在 Web 浏览器上经常这么做，更推荐的用法是插入一些图标，作为一个视觉性的提示，或者插入一个空字符串，并设计他的样式，使其成为一个视觉的性的提示。</p>
<h5 id="常见的伪元素类型"><a href="#常见的伪元素类型" class="headerlink" title="常见的伪元素类型"></a>常见的伪元素类型</h5><table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a></td>
<td align="left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter"><code>::first-letter</code></a></td>
<td align="left">匹配元素的第一个字母。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line"><code>::first-line</code></a></td>
<td align="left">匹配包含此伪元素的元素的第一行。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error"><code>::grammar-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的语法错误的那部分。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection"><code>::selection</code></a></td>
<td align="left">匹配文档中被选择的那部分。</td>
</tr>
<tr>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error"><code>::spelling-error</code></a></td>
<td align="left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td>
</tr>
</tbody></table>
<h3 id="2-4-关系选择器"><a href="#2-4-关系选择器" class="headerlink" title="2.4 关系选择器"></a>2.4 关系选择器</h3><p>关系选择器都是针对于第二个元素。</p>
<h4 id="2-4-1-后代选择器"><a href="#2-4-1-后代选择器" class="headerlink" title="2.4.1 后代选择器"></a>2.4.1 后代选择器</h4><p>使用空格隔开（“ ”），组合两个选择器，比如第二个选择器的元素被选择，且其余的相同元素都和第二个选择器有同一个祖先的都会被选择。（不管多少代都会被选择）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text in .box<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text in .box2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text in .box<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Text not in .box<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-子代关系选择器"><a href="#2-4-2-子代关系选择器" class="headerlink" title="2.4.2 子代关系选择器"></a>2.4.2 子代关系选择器</h4><p>子代关系选择器是个大于号（<code>&gt;</code>），只会在选择器选中直接子元素的时候匹配。（只选择第一代的所有相同元素）</p>
<h4 id="2-4-3-邻接兄弟选择器"><a href="#2-4-3-邻接兄弟选择器" class="headerlink" title="2.4.3 邻接兄弟选择器"></a>2.4.3 邻接兄弟选择器</h4><p>邻接兄弟选择器（<code>+</code>）用来选中恰好处于另一个在继承关系上同级的元素旁边的元素。</p>
<p>比如要设置紧跟<code>h1</code>的<code>p</code>标签，设计样式，如果在他们之间再加一个其他的标签，就无法应用样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;h2&gt;哈哈哈&lt;/h2&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo</span><br><span class="line">        melon azuki bean garlic.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard</span><br><span class="line">        greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-通用兄弟选择器"><a href="#2-4-4-通用兄弟选择器" class="headerlink" title="2.4.4 通用兄弟选择器"></a>2.4.4 通用兄弟选择器</h4><p>选中一个标签的兄弟标签，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（<code>~</code>）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> ~ <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>I am a div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am another paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>使用关系选择器可以将以上任意选择器组合起来，达到选择某个元素的目的。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>选择器</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Docker镜像瘦身[Python]</title>
    <url>/2022/08/04/%E8%AE%B0%E4%B8%80%E6%AC%A1Docker%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<p>​      </p>
<a id="more"></a>

<blockquote>
<p>前言：</p>
<p>​    在使用Python开发时，需要将镜像发布到私有仓库中或者阿里云仓库中，然后在K8S拉取镜像部署，但是项目经过打包后镜像大小高达3.1G。</p>
<p>​    每次打包镜像需要花费的时间太久且镜像拉取时间太长。</p>
</blockquote>
<h1 id="镜像优化历程"><a href="#镜像优化历程" class="headerlink" title="镜像优化历程"></a>镜像优化历程</h1><h2 id="一、初始版Dockerfile内容"><a href="#一、初始版Dockerfile内容" class="headerlink" title="一、初始版Dockerfile内容"></a>一、初始版Dockerfile内容</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dpkg -i rocketmq-client-cpp-2.0.0.amd64.deb </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -i https://mirrors.aliyun.com/pypi/simple/ --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;run.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>


<p>构建镜像后镜像大小为3个多G</p>
<p>优化解决方案：</p>
<ul>
<li><strong>避免出现多层</strong></li>
<li><strong>使用官方精简版本镜像</strong></li>
</ul>
<h2 id="二、第二版Dockerfile内容"><a href="#二、第二版Dockerfile内容" class="headerlink" title="二、第二版Dockerfile内容"></a>二、第二版Dockerfile内容</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i -E <span class="string">&#x27;s/(deb|security).debian.org/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list \</span></span><br><span class="line"><span class="bash">  &amp;&amp; dpkg -i rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt update -y \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt install -y python3-dev default-libmysqlclient-dev build-essential \</span></span><br><span class="line"><span class="bash">  &amp;&amp; pip install -i https://pypi.mirrors.ustc.edu.cn/simple/  --no-cache-dir -r requirements_base.txt \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt clean -y \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /var/cache/debconf/* \</span></span><br><span class="line"><span class="bash">    /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    /var/<span class="built_in">log</span>/* \</span></span><br><span class="line"><span class="bash">    /var/tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br></pre></td></tr></table></figure>


<p>因为该项目使用了 <code>rocketmq</code> 所以需要使用 <code>rocketmq-client-cpp-2.0.0.amd64.deb</code> 起初打算使用 <code>python:3.8-alpine</code> 但是 <code>rocketmq</code> 没有 <code>alpine</code> 系统的包，只有 <code>debian</code> 的安装包。如果使用这个 <code>python:3.8-alpine</code>  基础镜像需要自己重新编译，所以选择了<code>python:3.8-slim</code> 这个基础镜像。</p>
<p>此外还需要安装mysqlclient的依赖库，所以需要更新apt源安装依赖。</p>
<p>将更新安装的apt依赖缓存删除。</p>
<p>此次镜像构建钩还有<strong>2.6G</strong>，依然很大。</p>
<p>优化解决方案：</p>
<ul>
<li>避免出现多层</li>
<li>使用官方精简版本镜像</li>
<li><strong>多层构建</strong></li>
</ul>
<h2 id="三、第三版DockerFile内容"><a href="#三、第三版DockerFile内容" class="headerlink" title="三、第三版DockerFile内容"></a>三、第三版DockerFile内容</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span> as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./requirements_base.txt .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -i https://pypi.mirrors.ustc.edu.cn/simple/  --no-cache-dir -r requirements_base.txt \</span></span><br><span class="line"><span class="bash">&amp;&amp; find /usr/<span class="built_in">local</span>/lib -name <span class="string">&#x27;*.pyc&#x27;</span> -delete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder   /usr/<span class="built_in">local</span>/lib/python3.8/site-packages /usr/<span class="built_in">local</span>/lib/python3.8/site-packages</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder  /usr/<span class="built_in">local</span>/bin/celery  /usr/<span class="built_in">local</span>/bin/celery</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder  /usr/lib/x86_64-linux-gnu/libmariadb.so  /usr/lib/x86_64-linux-gnu/libmariadb.so</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./rocketmq-client-cpp-2.0.0.amd64.deb .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  dpkg -i rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; apt clean -y \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm rocketmq-client-cpp-2.0.0.amd64.deb \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /var/cache/debconf/* \</span></span><br><span class="line"><span class="bash">    /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    /var/<span class="built_in">log</span>/* \</span></span><br><span class="line"><span class="bash">    /var/tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; rm -rf /tmp/* \</span></span><br><span class="line"><span class="bash">  &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br></pre></td></tr></table></figure>


<p>首先将需要安装的Python依赖安装且作为一个基础镜像，然后将 <code>/usr/local/lib/python3.8/site-packages</code> 安装的依赖复制到新的镜像中。</p>
<p>同样需要复制 <code>celery</code>的 启动文件：<code>/usr/local/bin/celery </code> 到新的镜像中, 否则使用 <code>celry -A pro worker</code> 会提示 <code>celery not found</code>的错误。</p>
<p>mysqlclient的依赖库在debian系统中是 <code>libmariadb.so</code> 也复制到 <code>/usr/lib/x86_64-linux-gnu/libmariadb.so</code> 动态库中去。</p>
<p>至此Python项目镜像大小由原来的<strong>3.1G</strong>缩小为<strong>567M</strong></p>
<p><img src="https://origin.chaizz.com/Snipaste_2022-08-04_18-05-28.png"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Kuboard</title>
    <url>/2022/07/28/%E9%83%A8%E7%BD%B2Kuboard/</url>
    <content><![CDATA[<p>​           </p>
<a id="more"></a>

<p>参考链接</p>
<blockquote>
<p><a href="https://www.kuboard.cn/install/v3/install-built-in.html">安装 Kuboard v3 - 内建用户库 | Kuboard</a></p>
</blockquote>
<blockquote>
<p>Kuboard 是一款专为 Kubernetes 设计的免费管理界面，兼容 Kubernetes 版本 1.13 及以上。Kuboard 每周发布一个 beta 版本，最长每月发布一个正式版本，经过两年的不断迭代和优化，已经具备多集群管理、权限管理、监控套件、日志套件等丰富的功能，并且有 1000+ 的企业将 Kuboard 应用于其生产环境。</p>
</blockquote>
<p>一、前期准备</p>
<ul>
<li><p>搭建完成Kubernetes 集群。 </p>
</li>
<li><p>Docker 安装完毕</p>
</li>
</ul>
<p>二、安装Kuboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard \</span><br><span class="line">  -p 80:80/tcp \</span><br><span class="line">  -p 10081:10081/tcp \</span><br><span class="line">  -e KUBOARD_ENDPOINT=&quot;http://192.158.59.130:80&quot; \</span><br><span class="line">  -e KUBOARD_AGENT_SERVER_TCP_PORT=&quot;10081&quot; \</span><br><span class="line">  -v /root/kuboard-data:/data \</span><br><span class="line">  eipwork/kuboard:v3</span><br></pre></td></tr></table></figure>
<p>三、访问 Kuboard</p>
<p>在浏览器输入 <code>http://your-host-ip:80</code> 即可访问 Kuboard v3.x 的界面，登录方式：</p>
<ul>
<li>用户名： <code>admin</code></li>
<li>密 码： <code>Kuboard123</code></li>
</ul>
]]></content>
      <categories>
        <category>K8S</category>
        <category>Kuboard</category>
      </categories>
      <tags>
        <tag>Kuboard</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机K8s集群搭建</title>
    <url>/2022/07/28/%E9%83%A8%E7%BD%B2k8S%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<p>参考链接</p>
<blockquote>
<p><a href="https://www.kuboard.cn/install/v3/install.html">安装 Kubernetes 多集群管理工具 - Kuboard v3 | Kuboard</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/Sunzz/p/15184167.html">安装Kubernetes(k8s)保姆级教程—无坑版 - Sunzz - 博客园</a></p>
</blockquote>
<h1 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h1><h2 id="1-1-系统环境"><a href="#1-1-系统环境" class="headerlink" title="1.1 系统环境"></a>1.1 系统环境</h2><p>VMware 虚拟机环境下</p>
<p>系统：Ubuntu 22.04 LTS</p>
<p>CPU：2核 | 内存：4G | 硬盘：50G</p>
<h2 id="1-2-节点信息"><a href="#1-2-节点信息" class="headerlink" title="1.2 节点信息"></a>1.2 节点信息</h2><p><strong>master：</strong> 192.168.59.130</p>
<p><strong>node01：</strong> 192.168.59.131</p>
<p><strong>node02：</strong> 192.168.59.132</p>
<p>确保每个虚拟机唯一节点、网络通畅、开放端口：6443，禁用Swap</p>
<h2 id="1-3-关闭防火墙"><a href="#1-3-关闭防火墙" class="headerlink" title="1.3 关闭防火墙"></a>1.3 关闭防火墙</h2><p>根据使用的网络模式选择，此处关闭。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld &amp;&amp; systemctl disable firewalld &amp;&amp; iptables -F</span><br></pre></td></tr></table></figure>
<h2 id="1-4-关闭-selinux"><a href="#1-4-关闭-selinux" class="headerlink" title="1.4 关闭 selinux"></a>1.4 关闭 selinux</h2><p>安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统）关闭是因为可能会导致一些不明的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config &amp;&amp; setenforce 0</span><br></pre></td></tr></table></figure>
<h2 id="1-5-关闭Swap"><a href="#1-5-关闭Swap" class="headerlink" title="1.5 关闭Swap"></a>1.5 关闭Swap</h2><p>此操作必须执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>
<h2 id="1-6-修改hosts文件设置主机名"><a href="#1-6-修改hosts文件设置主机名" class="headerlink" title="1.6 修改hosts文件设置主机名"></a>1.6 修改hosts文件设置主机名</h2><p>在每个节点上操作，保证每个虚拟机主机名唯一。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加以下内容</span></span><br><span class="line">192.168.59.130 master.local</span><br><span class="line">192.168.59.131 node01.local</span><br><span class="line">192.168.59.132 node02.local</span><br></pre></td></tr></table></figure>
<p>在对应的节点上设置主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> master 节点</span></span><br><span class="line">hostnamectl set-hostname master.local </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node01</span></span><br><span class="line">hostnamectl set-hostname node01.local </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node02</span></span><br><span class="line">hostnamectl set-hostname node02.local </span><br></pre></td></tr></table></figure>
<h2 id="1-7-允许-iptables-检查桥接流量"><a href="#1-7-允许-iptables-检查桥接流量" class="headerlink" title="1.7 允许 iptables 检查桥接流量"></a>1.7 允许 iptables 检查桥接流量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<p>加载ip_vs内核模块 </p>
<p>不清楚什么意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe ip_vs</span><br><span class="line">modprobe ip_vs_rr</span><br><span class="line">modprobe ip_vs_wrr</span><br><span class="line">modprobe ip_vs_sh</span><br><span class="line">modprobe nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>设置开机启动</p>
<p>不清楚什么意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/modules-load.d/ip_vs.conf &lt;&lt; EOF </span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack_ipv4</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h1 id="二、搭建方式"><a href="#二、搭建方式" class="headerlink" title="二、搭建方式"></a>二、搭建方式</h1><p>本次使用命令行方式安装，方面理解各个组件的作用。</p>
<h2 id="2-1-图形化操作"><a href="#2-1-图形化操作" class="headerlink" title="2.1 图形化操作"></a>2.1 图形化操作</h2><p>直接使用[Kuboard-Spray](<a href="https://github.com/eip-work/kuboard-spray">GitHub - eip-work/kuboard-spray: 使用图形化的界面离线安装、维护、升级高可用的 K8S 集群</a>)图形化工具进行搭建。</p>
<h2 id="2-2-命令行安装"><a href="#2-2-命令行安装" class="headerlink" title="2.2 命令行安装"></a>2.2 命令行安装</h2><p><strong>以下操作每个节点都需要执行</strong></p>
<h3 id="2-2-1-安装Docker"><a href="#2-2-1-安装Docker" class="headerlink" title="2.2.1 安装Docker"></a>2.2.1 安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>设置Docker 开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>修改Docker的源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 registry-mirrors 为如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;你的阿里云镜像加速地址&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新加载systemctl配置</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-配置kubernetes源"><a href="#2-2-2-配置kubernetes源" class="headerlink" title="2.2.2 配置kubernetes源"></a>2.2.2 配置kubernetes源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line"></span><br><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - </span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新apt-get</span></span><br><span class="line">sudo att-get upadte -y </span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-安装kubeadm、kubelet、kubectl"><a href="#2-2-3-安装kubeadm、kubelet、kubectl" class="headerlink" title="2.2.3 安装kubeadm、kubelet、kubectl"></a>2.2.3 安装kubeadm、kubelet、kubectl</h3><p>建议安装1.23.6 或以下版本的软件，安装最新版（1.24.+）会有问题，且下面安装kuboard 兼容性未在最新版（1.24.+）验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y kubelet=1.23.6-00  kubeadm=1.23.6-00 kubectl=1.23.6-00</span><br></pre></td></tr></table></figure>
<p>设置开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>
<p><strong>以下操作在master节点执行</strong></p>
<h3 id="2-2-4-master-节点初始化"><a href="#2-2-4-master-节点初始化" class="headerlink" title="2.2.4 master 节点初始化"></a>2.2.4 master 节点初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --kubernetes-version 1.23.6 \</span><br><span class="line">  --apiserver-advertise-address=192.168.59.130 \</span><br><span class="line">  --service-cidr=10.96.0.0/16 \</span><br><span class="line">  --pod-network-cidr=10.245.0.0/16 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubernetes-version 必须与下载的版本一致。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apiserver-advertise-address：API 服务器所公布的其正在监听的 IP 地址（本机内网地址）。如果未设置，则使用默认网络接口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> service-cidr：为服务的虚拟 IP 地址另外指定 IP 地址段， 默认值：10.96.0.0/12。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pod-network-cidr：指明 pod 网络可以使用的 IP 地址段，如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> image-repository：选择用于拉取控制平面镜像的容器仓库，  默认值：k8s.gcr.io。</span></span><br></pre></td></tr></table></figure>
<p>等待拉取镜像，出现以下字样代表master节点初始化成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a Pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  /docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p>记住 <code>kubeadm init</code> 输出的 <code>kubeadm join</code> 命令。 需要使用此命令将子节点加入集群。</p>
<h3 id="2-2-5-配置kubectl"><a href="#2-2-5-配置kubectl" class="headerlink" title="2.2.5 配置kubectl"></a>2.2.5 配置kubectl</h3><p>要使用非 root 用户可以运行 kubectl，请运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p> <code>root</code> 用户，则可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p>使用kubectl 查看节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p>目前是只能看到master节点，状态是NotReady，下面是子节点加入后的状态，且网络集群网络联通后的状态。</p>
<p><img src="https://origin.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png"></p>
<h3 id="2-2-6-子节点加入集群"><a href="#2-2-6-子节点加入集群" class="headerlink" title="2.2.6 子节点加入集群"></a>2.2.6 子节点加入集群</h3><p>使用上面初始化后的提示的指令， 分别在各个子节点上执行指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p>接下来在看看节点状态，下面是子节点加入后的状态，且网络集群网络联通后的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<img title src="https://origin.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png" alt data-align="inline">

<h3 id="2-2-7-安装flannel网络插件"><a href="#2-2-7-安装flannel网络插件" class="headerlink" title="2.2.7 安装flannel网络插件"></a>2.2.7 安装flannel网络插件</h3><p>下载插件，<a href="https://blog.csdn.net/weixin_44293949/article/details/121863559">解决raw.githubusercontent.com无法访问的问题</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>下载到本地后更改第128行，和上文中的<code>pod-network-cidr</code> 一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;Network&quot;: &quot;10.245.0.0/16&quot;</span><br></pre></td></tr></table></figure>
<p>运行 yaml文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yaml</span><br></pre></td></tr></table></figure>
<p>查看flannel 结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get pods -o wide</span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/f296cd5a0e3811ed90590242ac140002.png"></p>
<p>再次查看各个node的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png"></p>
<p>至此集群方式的Kubernetes 安装完成。</p>
<hr>
<h1 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h1><h2 id="问题一：出现-initial-timeout-of-40s-passed。"><a href="#问题一：出现-initial-timeout-of-40s-passed。" class="headerlink" title="问题一：出现 initial timeout of 40s passed。"></a>问题一：出现 initial timeout of 40s passed。</h2><p>在一开始部署的时候安装：kubelet、kubeadm、kubectl，没有指定版本，直接使用的最新版（1.24.+），在往上查了半天，找到一篇博客后（地址忘记了）提示说可能是由于版本的问题，然后在重新安装指定版本的kubelet、kubeadm、kubectl 工具，接下来一路畅通。</p>
<p>重新初始化是需要执行 <code>kubeadm reset</code> ，此命令是还原由 <code>kubeadm init</code> 或 <code>kubeadm join</code> 所做的更改。</p>
]]></content>
      <categories>
        <category>K8S</category>
        <category>Kubernets</category>
      </categories>
      <tags>
        <tag>Kubernets</tag>
      </tags>
  </entry>
  <entry>
    <title>Python三器一闭</title>
    <url>/2022/04/30/Python%E4%B8%89%E5%99%A8%E4%B8%80%E9%97%AD/</url>
    <content><![CDATA[<p>​                              </p>
<a id="more"></a>

<h1 id="1、迭代器"><a href="#1、迭代器" class="headerlink" title="1、迭代器"></a>1、迭代器</h1><h2 id="什么是迭代？"><a href="#什么是迭代？" class="headerlink" title="什么是迭代？"></a>什么是迭代？</h2><blockquote>
<p> 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
</blockquote>
<h2 id="什么是可迭代对象？"><a href="#什么是可迭代对象？" class="headerlink" title="什么是可迭代对象？"></a>什么是可迭代对象？</h2><p>Python中的可迭代对象并不是指某一种具体的数据类型，是指存储了若干个元的容器，且这这个容器中的元素可以通过<code>__iter()__</code> 和 <code>__getitem__()</code> 访问。</p>
<p>常用的可迭代对象有：<code>list</code>、<code>tuple</code>，<code>dict</code>，<code>str</code>，<code>set</code>、生成器和带有<code>yield</code>的生成器函数。</p>
<p>判断一个对象是否是可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>([], Iterable)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>获取可迭代对象的迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">print(<span class="built_in">type</span>(item))  <span class="comment"># &lt;class &#x27;range&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line">print(<span class="built_in">type</span>(iterator)) <span class="comment"># &lt;class &#x27;range_iterator&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>iter()</code> 内部做了什么？</strong></p>
<ul>
<li>检查对象内部是否实现了<code>__iter__()</code> 如果实现了， 则调用它，获取一个迭代器。</li>
<li>如果没有实现<code>__iter__()</code>方法，但是 实现了<code>__getitem__()</code>，python内部会实现一个迭代器。</li>
<li>如果 以上都失败，则会抛出异常：说明对象不可迭代。</li>
</ul>
<p><strong><code>for x in range(10): print(x) </code>循环执行了什么？</strong></p>
<p>获取可迭代对象的迭代器， 然后在调用<code>next()</code>方法获取下一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 获取迭代器</span></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 获取迭代器</span></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 0</span></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 2</span></span><br><span class="line">...</span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p><strong>for 循环即先获取可迭代对象的迭代器，然后在调用<code>next()</code>方法，且在超过迭代对象的长度时，自动捕获错误：<code>StopIteration</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p><strong>如何自定义可迭代对象</strong>？</p>
<p>如上文那样，在一个对象中实现这个<code>__iter__()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterator)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>以上类MyList的对象 实现了<code>__iter__()</code>， 所以他是一个可迭代对象，且 <code>print(isinstance(my_list, Iterable))</code> 判断为True。但是 <code>print(isinstance(my_list, Iterator))</code> 为False</p>
<p><strong>如何实现一个迭代器呢</strong>？</p>
<p>如下面代码所示在可迭代对象中再实现<code>__next__()</code> 方法 即可让改对象成为一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterator)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p><strong>综上所述：</strong></p>
<p>对一个可迭代对象调用<code>iter()</code> 方法，其实内部就是寻找<code>__iter__()</code>，并调用，返回的对象当做迭代器。</p>
<p>对一个迭代器对象调用<code>next()</code> 方法，其实内部就是寻找<code>__next__()</code>，并调用，返回可迭代对象的下一个元素。</p>
<blockquote>
<p><strong>所以一个迭代器一定是个可迭代对象，但是可迭代对象并不一定是个迭代器。</strong></p>
</blockquote>
<h1 id="2、生成器"><a href="#2、生成器" class="headerlink" title="2、生成器"></a>2、生成器</h1><h2 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h2><p>在python 中通俗的理解：一边循环一边计算的机制成为生成器，生成器是一种特殊的迭代器。</p>
<h1 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h1><h1 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h1>]]></content>
      <categories>
        <category>Python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署MySQL8</title>
    <url>/2022/02/19/Docker%E9%83%A8%E7%BD%B2MySQL8/</url>
    <content><![CDATA[<p>​                         </p>
<a id="more"></a>



<p>s</p>
<h1 id="1、安装Docker"><a href="#1、安装Docker" class="headerlink" title="1、安装Docker"></a>1、安装Docker</h1><p>略</p>
<h1 id="2、直接运行命令"><a href="#2、直接运行命令" class="headerlink" title="2、直接运行命令"></a>2、直接运行命令</h1><p>后台启动MySQL，然后进入容器中设置MySQL用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name MYSQL8.0 -e MYSQL_ROOT_PASSWORD=123456  mysql:latest</span><br></pre></td></tr></table></figure>
<h1 id="3、设置MySQL远程连接以及密码"><a href="#3、设置MySQL远程连接以及密码" class="headerlink" title="3、设置MySQL远程连接以及密码"></a>3、设置MySQL远程连接以及密码</h1><h2 id="1、进入容器内部"><a href="#1、进入容器内部" class="headerlink" title="1、进入容器内部"></a>1、进入容器内部</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID/容器名 bash</span><br></pre></td></tr></table></figure>
<h2 id="2、登录MySQL"><a href="#2、登录MySQL" class="headerlink" title="2、登录MySQL"></a>2、登录MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>
<h2 id="3、-设置root用户名以及密码规则"><a href="#3、-设置root用户名以及密码规则" class="headerlink" title="3、 设置root用户名以及密码规则"></a>3、 设置root用户名以及密码规则</h2><p>设置密码不过期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39; password expire never;</span><br></pre></td></tr></table></figure>
<p>设置密码规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;123456&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="4、刷新权限"><a href="#4、刷新权限" class="headerlink" title="4、刷新权限"></a>4、刷新权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>使用Navicat连接 成功 OK！</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>部署</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar</title>
    <url>/2022/02/13/Pulasr%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>

<p>敬请期待…</p>
]]></content>
      <categories>
        <category>Pulsar</category>
      </categories>
      <tags>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile知识总结</title>
    <url>/2021/11/20/Dockerfile%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​            </p>
<a id="more"></a>



<blockquote>
<p>使用Dockerfile 能够构建一个自定义镜像。通常情况下是将自己的应用打包成镜像，在容器中使用。</p>
</blockquote>
<h2 id="Dockerfile-命令"><a href="#Dockerfile-命令" class="headerlink" title="Dockerfile 命令"></a>Dockerfile 命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>表示当前镜像是基于那个镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像的维护者和邮箱</td>
</tr>
<tr>
<td>RUN</td>
<td>构建镜像的时候需要运行的命令</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>容器内对外暴露的端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定创建容器后默认进入容器的工作目录</td>
</tr>
<tr>
<td>ENV</td>
<td>用来构建镜像过程中设置的环境变量 key=value</td>
</tr>
<tr>
<td>ADD</td>
<td>将宿主机下的文件拷贝到容器中，且会自动处理url和压缩包</td>
</tr>
<tr>
<td>COPY</td>
<td>类似于ADD，将从构建的Dockerfile目录中复制镜像的目录中</td>
</tr>
<tr>
<td>VOLUME</td>
<td>容器数据卷</td>
</tr>
<tr>
<td>CMD</td>
<td>制定一个容器运行的命令，如果有多个命令，只执行最后一个。会被docker run 后面的命令替代</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定一个容器启动时要运行的命令和参数，和CMD一样</td>
</tr>
</tbody></table>
<h3 id="1、FROM-命令语法"><a href="#1、FROM-命令语法" class="headerlink" title="1、FROM 命令语法"></a>1、FROM 命令语法</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;]   <span class="comment"># 设置镜像的版本，不写为最新版本  latest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、RUN-命令"><a href="#2、RUN-命令" class="headerlink" title="2、RUN 命令"></a>2、RUN 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RUN 后面直接写shell命令, RUN 的命令是在构建镜像中执行。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello word</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;yum&quot;</span>,<span class="string">&quot;install&quot;</span>,<span class="string">&quot;-y&quot;</span>,<span class="string">&quot;vim&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="3、EXPOSR-命令"><a href="#3、EXPOSR-命令" class="headerlink" title="3、EXPOSR 命令"></a>3、EXPOSR 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对一些需要端口的服务</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<h3 id="4、WORKDIR-命令"><a href="#4、WORKDIR-命令" class="headerlink" title="4、WORKDIR 命令"></a>4、WORKDIR 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来为Dockerfile中的任何 RUN/CMD/ENTRYPOINT/CPOY/ADD/ 指令设置工作目录，如果WORKDIR  不存在，即使他没有在后续得命令中被使用，也将会被创建。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/myserver</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /aaa</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> bb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR 可以使用多次，如果使用的是相对命令 ，会与上一次的路径相对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如上面的命令:docker会创建/opt/myserve，也会创建/aaa/bb，在进入容器内会进入最后的WORKDIR的路径下即：/aaa/bb</span></span><br></pre></td></tr></table></figure>
<h3 id="5、ADD-命令"><a href="#5、ADD-命令" class="headerlink" title="5、ADD 命令"></a>5、ADD 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来从Dockerfile的当前目录中复制文件，目录，或者下载URL,并将他们添加到位于容器内指定的文件中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> bb.txt /aaa/bb</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> https://origin.chaizz.com/497261de494511ec9d7c5254006b8f1d.png /aaa/bb</span></span><br><span class="line"><span class="comment"># 可以将文件复制到容器中，也可以通过URL下载文件到容器中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 apache-tomcat-8.5.73-src.tar.gz 解压到 /aaa/bb </span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-8.5.73-src.tar.gz /aaa/bb</span></span><br><span class="line"><span class="comment"># 将apache-tomcat-8.5.73-src 改名 为tomcat</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv apache-tomcat-8.5.73-src  tomcat</span></span><br><span class="line"><span class="comment"># 将工作目录改为 tomcat</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> tomcat</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6、COPY-命令"><a href="#6、COPY-命令" class="headerlink" title="6、COPY 命令"></a>6、COPY 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件复制到指定容器内部的目录</span></span><br><span class="line"><span class="comment"># COPY a.txt /aaa/bb</span></span><br></pre></td></tr></table></figure>


<h3 id="7、volume-目录"><a href="#7、volume-目录" class="headerlink" title="7、volume 目录"></a>7、volume 目录</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许在容器运行的时候将目录挂载到宿主机的目录上</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /aaa/bb/tomcat/webapps</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="8、ENV-命令"><a href="#8、ENV-命令" class="headerlink" title="8、ENV 命令"></a>8、ENV 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置当前容器的环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> BASE_DIR</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="9、ENTRYPOINT-命令"><a href="#9、ENTRYPOINT-命令" class="headerlink" title="9、ENTRYPOINT 命令"></a>9、ENTRYPOINT 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器运行的命令和参数  ENTRYPOINT的命令是在容器构建完成之后启动的时候执行,要覆盖ENTRYPOINT  他的指令 需要在docker run 的时候加上 --entrypoint ls </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> ls <span class="variable">$BASE_DIR</span>/tomcat</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;<span class="variable">$BASE_DIR</span>/tomcat&quot;</span>]</span></span><br></pre></td></tr></table></figure>


<h3 id="10、CMD-命令"><a href="#10、CMD-命令" class="headerlink" title="10、CMD 命令"></a>10、CMD 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只执行最后一个，如果在 docker run 之后指定了命令(不需要参数) 会将CMD的指令覆盖，不再执行CMD的指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> ls <span class="variable">$BASR_DIR</span></span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;<span class="variable">$BASR_DIR</span>&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常 CMD 和 ENTRYPOINT 结合使用 ：ENTRYPOINT作为固定的命令或者参数， CMD 作为可变的参数，附加在ENTRYPOINT命令之后。 然后ENTRYPOINT + CMD 结合为一条命令。  即可实现在docker run 的时候可以指定参数运行同一个容器</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引问题</title>
    <url>/2021/11/18/MySQL%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>​     </p>
<a id="more"></a>

<p>针对以上索引问题，首先要知道什么是主键索引、非主键索引、聚簇索引、非聚簇索引。</p>
<p>主键索引：即MySQL的索引，如果没有主键那么MySQl会自动在表中挑选一个唯一且非空的字段来当做主键索引，如果没有的话MySQL内部自己会创建一个ROW_ID来当做主键，也会建立主键索引。主键索引的叶子结点存储的是整行的数据。</p>
<p>非主键索引：即非主键以外的列建立的索引。非主键索引存储的是主键索引的值。</p>
<h3 id="什么是索引回表？"><a href="#什么是索引回表？" class="headerlink" title="什么是索引回表？"></a>什么是索引回表？</h3><p>索引回表指的就是在查询某一列数据是判断条件为非主键索引，name查到这条复合条件的所有记录就需要在根据非主键索引获得的主键索引的值，在取主键索引的B+树中在此查询一次才能获取到全部的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ID 是主键索引 ，只需要一次查询就可以获取符合条件的全部记录。</span><br><span class="line">select * from ex_table where ID&#x3D;1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># n 是非主键索引，查询到的结果是符合条件的主键索引的ID，所以还需要早根据主键的ID,再在主键索引的B+树上查询一次</span><br><span class="line">select * from ex_table where n &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>以上情况就是索引回表。</p>
<h3 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h3><p>如果执行的语句是 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select idfrom T where n between 1 and 10;</span><br></pre></td></tr></table></figure>
<p>现在的SQL只需要得到ID 的值，而 ID 的值已经在 n 索引的B+树上了，因此可以直接获得查询结果，不需要回表。也就是说，在这个查询里面，索引 n已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<h3 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h3><p>索引下推（index condition pushdown ）简称ICP，在MySQL5.6的版本上推出，用于优化查询，默认是开启的，可以通过以下的命令关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set optimizer_switch &#x3D; &#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>
<p>当使用索引下推时如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>索引下推的好处：</p>
<p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</strong></p>
<p>假如有以下MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 索引值为 name age 为组合索引。</span><br><span class="line"></span><br><span class="line">select * from user where name like &#39;张%&#39; and age &#x3D; 20;</span><br></pre></td></tr></table></figure>


<p>在关闭索引下推的时候，InnoDB引擎会根据只name找到复合条件的索引字段，如下图中的左边绿色，然后就将数据返回给MySQL服务器，由MySQL服务器去判断其他的符合条件的数据。MySQL服务器会拿着查到的ID：1、2  在进行回表查询。</p>
<p><img src="https://origin.chaizz.com/161026e0486011ec9d7c5254006b8f1d.png"></p>
<p>在使用索引下推的时候，InnoDB会直接找出符合索引条件的字段的ID，将符合条件的结果发送给MySQL服务器，这个过程只需要回表一次。如下图。</p>
<p><img src="https://origin.chaizz.com/a47dc42c486b11ec9d7c5254006b8f1d.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis底层原理</title>
    <url>/2021/11/18/Redis%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="Redis-数据结构底层实现"><a href="#Redis-数据结构底层实现" class="headerlink" title="Redis 数据结构底层实现"></a>Redis 数据结构底层实现</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Redis 是由C实现的，所以Redis的String字符串是由C语言中的String改进而来的。</p>
<p>在C语言中，C的一个字符串是由数组组成的，”sdasd\0”，在C语言中一个字符串是由\0 结尾，但是在Redis中，String类型可以存储任意数据类型，所以使用\0结尾容易发生截断。所以在Redis中实现了一个简单动态字符串 （SDS &gt; simple dynamic string）来存储数据。</p>
<p>SDS ：他自定义了一个数据长度来代表数据的长度，在Redis 内部定义了多种 sdshdr5、sdshdr8、sdshdr16。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct__attribute__ ((__packed__)) sdshdr5&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flages;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">struct__attribute__ ((__packed__)) sdshdr8&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flages;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://origin.chaizz.com/61cb3042481111ec9d7c5254006b8f1d.png"></p>
<p><img src="https://origin.chaizz.com/a48dbb8e481111ec9d7c5254006b8f1d.png"></p>
<p>如上图，在底层sdshdr5 是这样定义的：==一个flags 占用一个字节，它又有八bit，前三位表示数据类型，后五位描述数据长度。buffer 是存储的实际数据。==</p>
<p>Redis 数据扩容：内部实现就是将原本的数据长度成倍的扩容，</p>
<p>比如原本的数据长度            len：7  </p>
<p>实际的数据长度                    buf [5] ：”aaaaa”</p>
<p>空闲的数据长度                    free：2</p>
<p>现在需要将数据改为 “ aaaaaaaa”  数据长度为8。 那么数据就会变成如下这样：</p>
<p>新的的数据长度                    len：7 * 2 = 14  </p>
<p>实际的数据长度                    buf [8] ：”aaaaaaaa”</p>
<p>空闲的数据长度                    free：6</p>
<p>所以这样情况下不需要重新分配新内存空间。其中Redis的字符串在复制结束的时候也会自动的加上\0字符，也是为了兼容C语言的一个字符操作的库。</p>
<h2 id="Redis底层数据结构的编码"><a href="#Redis底层数据结构的编码" class="headerlink" title="Redis底层数据结构的编码"></a>Redis底层数据结构的编码</h2><p>当我们在使用 set、 hset 、lpush 这些api去设置Redis 的键值的时候，Redis 会根据我们设置的值的不同在内部采用不同的编码格式。当我们在存储一些不同的值的时候，Redis底层也会自动给我们做一些优化。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 不同长度不同类型的数据</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set longstr aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set shortstr aaa</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set intvalue 100</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding shortstr</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding longstr</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding intvalue</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们在查看他们的类型的时候都是String</span> </span><br><span class="line">127.0.0.1:6379&gt; type intvalue</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type longstr</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type shortstr</span><br><span class="line">string</span><br></pre></td></tr></table></figure>


<p>当Value的值小于等于44时，string的编码是 embstr ，大于44是raw。</p>
<p>为什么是44呢？</p>
<p>CPU从内存中拿数据时，是有一个缓存行的概念， 最少的拿的数据长度是64个字节 （64 Byte）。</p>
<p>在Redisobject 中 占了16个字节（16 Byte）</p>
<p>Redis sdshdr8 里面 需要占用4个字节，所以还剩44个字节，Redis为了减少一次缓存IO ， 直接将小于等于44 字节的数据取回来 。所以 超过44个字节就会存储为raw编码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">hash</span> 也有不同的编码格式</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset ahash1 f v</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset ahash f v f2 v2222222222222222222222222222222222222222222222222222222</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; type ahash</span><br><span class="line">hash</span><br><span class="line">127.0.0.1:6379&gt; type ahash1</span><br><span class="line">hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding  ahash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding  ahash1</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpush list1 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; type list1</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; object encoding list1</span><br><span class="line">&quot;quicklist&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>从同一边放同一边出 就是一个栈的数据结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush llist a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>从同一边放另一边出 就是一个类似队列的数据结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list1 a b c</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;c&quot;</span><br></pre></td></tr></table></figure>


<p>List 的数据结构是一个双端链表 ：quicklist 。 在Redis 的底层是一个ziplist  更加紧凑的压缩列表。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。他将所有的元素紧挨着一块存储，分配的是一块连续的内存。<br>当数据量比较多的时候，才会改为quicklist，因为普通的链表需要的附加的指针空间更大，会比较浪费空间。<br>比如列表里面存储的只是Int的类型的数据，结构上还需要两个额外的指针：prev和next。<br><img src="https://origin.chaizz.com/4e0057b4450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist 使用双向指针串起来，这样既满足了插入删除性能，又不会出现太大的空间冗余。如上图所示。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>是一种无序、自动去重的的数据结构（如果是一些整形数（编码为intset），其实是有序的）。</p>
<p>他的底层实现是一个value为null的字典，当数据是整形的时候，set集合会将编码改为intset 数据结构，一下两个条件任意满足时set将使用hashtable 存储数据，</p>
<ul>
<li>元素个数大于set-max-intset-entrires</li>
<li>元素无法用整形表示</li>
</ul>
<p>set-max-intset-entrires （intset最大存储的元素个数）最大为512。超过则用hashtable编码。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>Hash 类型对应的数据机构有两种：ziplist （压缩列表） 和 hashtable（哈希表） ，当field-value 的长度较短且个数较少的时候，使用ziplist，否则使用hashtable。</p>
<p>hash-max-ziplist-entries 512</p>
<p>ziplist 的元素超过512个 将改为hashtable编码</p>
<p>hash-max-zipl;ist-value 64</p>
<p>单个元素大小超过64个字节的时候将改为hashtable</p>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>SortedSet 是Redis的一个特别的数据结构，他的底层使用了两个数据结构 ziplist    skiplist。</p>
<ol>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素的列表</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-Linux</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>搬运自掘金用户：<a href="https://juejin.cn/user/2506542243918030/posts">小杰要吃蛋</a> [侵删]</p>
<h3 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h3><ul>
<li><p>Linux是一套免费使用和自由传播的类似Unix操作系统，一般的WEB项目都是部署都是放在Linux操作系统上面。 Linux是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744a2d148acc2~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="Windows和Linux的区别"><a href="#Windows和Linux的区别" class="headerlink" title="Windows和Linux的区别"></a>Windows和Linux的区别</h3><ul>
<li>Windows是微软开发的操作系统，民用操作系统，可用于娱乐、影音、上网。  Windows操作系统具有强大的日志记录系统和强大的桌面应用。好处是它可以帮我们实现非常多绚丽多彩的效果，可以非常方便去进行娱乐、影音、上网。</li>
<li>Linux的应用相对单纯很多，没有什么绚丽多彩的效果，因此Linux的性能是非常出色的，可以完全针对机器的配置有针对性的优化，</li>
<li>简单来说Windows适合普通用户进行娱乐办公使用，Linux适合软件开发部署</li>
</ul>
<h3 id="Unix和Linux有什么区别？"><a href="#Unix和Linux有什么区别？" class="headerlink" title="Unix和Linux有什么区别？"></a>Unix和Linux有什么区别？</h3><ul>
<li>Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为Unix和Linux操作系统是一样的，然而，事实并非如此，以下是两者的区别。<ol>
<li>开源性<br> Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。</li>
<li>跨平台性<br> Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。</li>
<li>可视化界面<br> Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。</li>
<li>硬件环境<br> Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度较大。</li>
<li>用户群体<br> Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。<br> 相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用！</li>
</ol>
</li>
</ul>
<h3 id="什么是-Linux-内核？"><a href="#什么是-Linux-内核？" class="headerlink" title="什么是 Linux 内核？"></a>什么是 Linux 内核？</h3><ul>
<li>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。<ol>
<li>系统内存管理</li>
<li>应用程序管理</li>
<li>硬件设备管理</li>
<li>文件系统管理</li>
</ol>
</li>
</ul>
<h3 id="Linux的基本组件是什么？"><a href="#Linux的基本组件是什么？" class="headerlink" title="Linux的基本组件是什么？"></a>Linux的基本组件是什么？</h3><ul>
<li>就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和GUI，系统实用程序和应用程序。Linux比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。</li>
</ul>
<h3 id="Linux-的体系结构"><a href="#Linux-的体系结构" class="headerlink" title="Linux 的体系结构"></a>Linux 的体系结构</h3><ul>
<li>从大的方面讲，Linux 体系结构可以分为两块：</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744a2d1cc127a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</li>
<li>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</li>
</ul>
<p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p>
<ul>
<li><p>1、现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。</p>
</li>
<li><p>2、Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</p>
</li>
<li><p>用户空间和内核空间是程序执行的</p>
<p>两种不同的状态</p>
<p>，我们可以通过两种方式完成用户空间到内核空间的转移：</p>
<ul>
<li>系统调用；</li>
<li>硬件中断。</li>
</ul>
</li>
</ul>
<h3 id="BASH和DOS之间的基本区别是什么？"><a href="#BASH和DOS之间的基本区别是什么？" class="headerlink" title="BASH和DOS之间的基本区别是什么？"></a>BASH和DOS之间的基本区别是什么？</h3><ul>
<li>BASH和DOS控制台之间的主要区别在于3个方面：<ul>
<li>BASH命令区分大小写，而DOS命令则不区分;</li>
<li>在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔符，\是目录分隔符</li>
<li>DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没有遵循这样的惯例。</li>
</ul>
</li>
</ul>
<h3 id="Linux-开机启动过程？"><a href="#Linux-开机启动过程？" class="headerlink" title="Linux 开机启动过程？"></a>Linux 开机启动过程？</h3><blockquote>
<p>了解即可。</p>
</blockquote>
<ul>
<li>1、主机加电自检，加载 BIOS 硬件信息。</li>
<li>2、读取 MBR 的引导文件(GRUB、LILO)。</li>
<li>3、引导 Linux 内核。</li>
<li>4、运行第一个进程 init (进程号永远为 1 )。</li>
<li>5、进入相应的运行级别。</li>
<li>6、运行终端，输入用户名和密码。</li>
</ul>
<h3 id="Linux系统缺省的运行级别？"><a href="#Linux系统缺省的运行级别？" class="headerlink" title="Linux系统缺省的运行级别？"></a>Linux系统缺省的运行级别？</h3><ul>
<li>关机。</li>
<li>单机用户模式。</li>
<li>字符界面的多用户模式(不支持网络)。</li>
<li>字符界面的多用户模式。</li>
<li>未分配使用。</li>
<li>图形界面的多用户模式。</li>
<li>重启。</li>
</ul>
<h3 id="Linux-使用的进程间通信方式？"><a href="#Linux-使用的进程间通信方式？" class="headerlink" title="Linux 使用的进程间通信方式？"></a>Linux 使用的进程间通信方式？</h3><blockquote>
<p>了解即可，不需要太深入。</p>
</blockquote>
<ul>
<li>1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</li>
<li>2、信号(signal) 。</li>
<li>3、消息队列。</li>
<li>4、共享内存。</li>
<li>5、信号量。</li>
<li>6、套接字(socket) 。</li>
</ul>
<h3 id="Linux-有哪些系统日志文件？"><a href="#Linux-有哪些系统日志文件？" class="headerlink" title="Linux 有哪些系统日志文件？"></a>Linux 有哪些系统日志文件？</h3><ul>
<li>比较重要的是 <code>/var/log/messages</code> 日志文件。</li>
</ul>
<blockquote>
<p>该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。</p>
<p>另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。</p>
</blockquote>
<h3 id="Linux系统安装多个桌面环境有帮助吗？"><a href="#Linux系统安装多个桌面环境有帮助吗？" class="headerlink" title="Linux系统安装多个桌面环境有帮助吗？"></a>Linux系统安装多个桌面环境有帮助吗？</h3><ul>
<li>通常，一个桌面环境，如KDE或Gnome，足以在没有问题的情况下运行。尽管系统允许从一个环境切换到另一个环境，但这对用户来说都是优先考虑的问题。有些程序在一个环境中工作而在另一个环境中无法工作，因此它也可以被视为选择使用哪个环境的一个因素。</li>
</ul>
<h3 id="什么是交换空间？"><a href="#什么是交换空间？" class="headerlink" title="什么是交换空间？"></a>什么是交换空间？</h3><ul>
<li>交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</li>
</ul>
<h3 id="什么是root帐户"><a href="#什么是root帐户" class="headerlink" title="什么是root帐户"></a>什么是root帐户</h3><ul>
<li>root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户。</li>
</ul>
<h3 id="什么是LILO？"><a href="#什么是LILO？" class="headerlink" title="什么是LILO？"></a>什么是LILO？</h3><ul>
<li>LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行。</li>
</ul>
<h3 id="什么是BASH？"><a href="#什么是BASH？" class="headerlink" title="什么是BASH？"></a>什么是BASH？</h3><ul>
<li>BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由/ bin / sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。</li>
</ul>
<h3 id="什么是CLI？"><a href="#什么是CLI？" class="headerlink" title="什么是CLI？"></a>什么是CLI？</h3><ul>
<li><strong>命令行界面</strong>（英语<strong>：command-line interface</strong>，缩写]<strong>：CLI</strong>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为<strong>字符用户界面</strong>（CUI）。</li>
<li>通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。</li>
</ul>
<h3 id="什么是GUI？"><a href="#什么是GUI？" class="headerlink" title="什么是GUI？"></a>什么是GUI？</h3><ul>
<li>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</li>
<li>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。</li>
</ul>
<h3 id="开源的优势是什么？"><a href="#开源的优势是什么？" class="headerlink" title="开源的优势是什么？"></a>开源的优势是什么？</h3><ul>
<li>开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益。</li>
</ul>
<h3 id="GNU项目的重要性是什么？"><a href="#GNU项目的重要性是什么？" class="headerlink" title="GNU项目的重要性是什么？"></a>GNU项目的重要性是什么？</h3><ul>
<li>这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。</li>
</ul>
<h2 id="磁盘、目录、文件"><a href="#磁盘、目录、文件" class="headerlink" title="磁盘、目录、文件"></a>磁盘、目录、文件</h2><h3 id="简单-Linux-文件系统？"><a href="#简单-Linux-文件系统？" class="headerlink" title="简单 Linux 文件系统？"></a>简单 Linux 文件系统？</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p>
<ul>
<li><p>也就是说在 Linux 系统中有一个重要的概念<strong>：一切都是文件</strong>。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p>
</li>
<li><p>Linux 支持 5 种文件类型，如下图所示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744a2d70c1faf~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="Linux-的目录结构是怎样的？"><a href="#Linux-的目录结构是怎样的？" class="headerlink" title="Linux 的目录结构是怎样的？"></a>Linux 的目录结构是怎样的？</h3><blockquote>
<p>这个问题，一般不会问。更多是实际使用时，需要知道。</p>
</blockquote>
<ul>
<li><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744a2d6e0c867~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<p>常见目录说明</p>
<p>：</p>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>目录</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；</td>
</tr>
<tr>
<td>/etc</td>
<td>存放系统管理和配置文件；</td>
</tr>
<tr>
<td>/home</td>
<td>存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</td>
</tr>
<tr>
<td>/usr</td>
<td>用于存放系统应用程序；</td>
</tr>
<tr>
<td>/opt</td>
<td>额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</td>
</tr>
<tr>
<td>/root</td>
<td>超级用户（系统管理员）的主目录（特权阶级）；</td>
</tr>
<tr>
<td>/sbin</td>
<td>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</td>
</tr>
<tr>
<td>/dev</td>
<td>用于存放设备文件；</td>
</tr>
<tr>
<td>/mnt</td>
<td>系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</td>
</tr>
<tr>
<td>/boot</td>
<td>存放用于系统引导时使用的各种文件；</td>
</tr>
<tr>
<td>/lib</td>
<td>存放着和系统运行相关的库文件 ；</td>
</tr>
<tr>
<td>/tmp</td>
<td>用于存放各种临时文件，是公用的临时文件存储点；</td>
</tr>
<tr>
<td>/var</td>
<td>用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</td>
</tr>
<tr>
<td>/lost+found</td>
<td>这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="什么是-inode-？"><a href="#什么是-inode-？" class="headerlink" title="什么是 inode ？"></a>什么是 inode ？</h3><blockquote>
<p>一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix/Linux 文件系统和硬盘储存的基础。</p>
</blockquote>
<ul>
<li>理解inode，要从文件储存说起。</li>
<li>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</li>
<li>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</li>
<li>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</li>
<li>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</li>
</ul>
<p><strong>简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？</strong></p>
<blockquote>
<p>如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。</p>
</blockquote>
<ul>
<li>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。<ul>
<li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li>
<li>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</li>
</ul>
</li>
</ul>
<h3 id="什么是硬链接和软链接？"><a href="#什么是硬链接和软链接？" class="headerlink" title="什么是硬链接和软链接？"></a>什么是硬链接和软链接？</h3><ul>
<li><strong>硬链接</strong>：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。<ul>
<li>不足：<ol>
<li>不可以在不同文件系统的文件间建立链接；</li>
<li>只有超级用户才可以为目录创建硬链接。</li>
</ol>
</li>
</ul>
</li>
<li><strong>软链接</strong>：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<ul>
<li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li>
</ul>
</li>
<li><strong>实际场景下，基本是使用软链接</strong>。总结区别如下：<ul>
<li>硬链接不可以跨分区，软件链可以跨分区。</li>
<li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li>
<li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li>
</ul>
</li>
</ul>
<h3 id="RAID-是什么"><a href="#RAID-是什么" class="headerlink" title="RAID 是什么?"></a>RAID 是什么?</h3><blockquote>
<p>RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。</p>
<p>RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。</p>
</blockquote>
<ul>
<li>当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="一台-Linux-系统初始化环境后需要做一些什么安全工作？"><a href="#一台-Linux-系统初始化环境后需要做一些什么安全工作？" class="headerlink" title="一台 Linux 系统初始化环境后需要做一些什么安全工作？"></a>一台 Linux 系统初始化环境后需要做一些什么安全工作？</h3><ul>
<li><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p>
<blockquote>
<p>修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l</p>
</blockquote>
</li>
<li><p>2、服务器使用密钥登陆，禁止密码登陆。</p>
</li>
<li><p>3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p>
</li>
<li><p>4、装 fail2ban 这种防止 SSH 暴力破击的软件。</p>
</li>
<li><p>5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p>
<blockquote>
<p>也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。</p>
</blockquote>
</li>
<li><p>6、修改历史命令记录的条数为 10 条。</p>
</li>
<li><p>7、只允许有需要的服务器可以访问外网，其它全部禁止。</p>
</li>
<li><p>8、做好软件层面的防护。</p>
<ul>
<li>8.1 设置 nginx_waf 模块防止 SQL 注入。</li>
<li>8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</li>
</ul>
</li>
</ul>
<h3 id="什么叫-CC-攻击？什么叫-DDOS-攻击？"><a href="#什么叫-CC-攻击？什么叫-DDOS-攻击？" class="headerlink" title="什么叫 CC 攻击？什么叫 DDOS 攻击？"></a>什么叫 CC 攻击？什么叫 DDOS 攻击？</h3><ul>
<li><p>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</p>
</li>
<li><p>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</p>
<blockquote>
<p>攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。</p>
</blockquote>
</li>
</ul>
<p><strong>怎么预防 CC 攻击和 DDOS 攻击？</strong></p>
<ul>
<li>防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</li>
</ul>
<blockquote>
<p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p>
</blockquote>
<h3 id="什么是网站数据库注入？"><a href="#什么是网站数据库注入？" class="headerlink" title="什么是网站数据库注入？"></a>什么是网站数据库注入？</h3><ul>
<li>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</li>
<li>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</li>
<li>SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</li>
</ul>
<p><strong>如何过滤与预防？</strong></p>
<ul>
<li>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</li>
</ul>
<h3 id="Shell-脚本是什么？"><a href="#Shell-脚本是什么？" class="headerlink" title="Shell 脚本是什么？"></a>Shell 脚本是什么？</h3><ul>
<li>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="如何选择-Linux-操作系统版本"><a href="#如何选择-Linux-操作系统版本" class="headerlink" title="如何选择 Linux 操作系统版本?"></a>如何选择 Linux 操作系统版本?</h3><p><strong>一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。</strong></p>
<ul>
<li><p>根据具体要求：</p>
<ul>
<li>安全性要求较高，则选择 Debian 或者 FreeBSD 。</li>
<li>需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。</li>
<li>想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。</li>
<li>【重点】<strong>根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束</strong>。</li>
</ul>
<blockquote>
<p>CentOS 7 系列，也慢慢使用的会比较多了。</p>
</blockquote>
</li>
</ul>
<h3 id="如何规划一台-Linux-主机，步骤是怎样？"><a href="#如何规划一台-Linux-主机，步骤是怎样？" class="headerlink" title="如何规划一台 Linux 主机，步骤是怎样？"></a>如何规划一台 Linux 主机，步骤是怎样？</h3><ul>
<li><p>1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。</p>
<blockquote>
<p>不同的用途，机器的配置会有所不同。</p>
</blockquote>
</li>
<li><p>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。</p>
</li>
<li><p>3、需要优化系统的哪些参数，需要创建哪些用户等等的。</p>
</li>
</ul>
<h3 id="请问当用户反馈网站访问慢，你会如何处理？"><a href="#请问当用户反馈网站访问慢，你会如何处理？" class="headerlink" title="请问当用户反馈网站访问慢，你会如何处理？"></a>请问当用户反馈网站访问慢，你会如何处理？</h3><p><strong>有哪些方面的因素会导致网站网站访问慢？</strong></p>
<ul>
<li><p>1、服务器出口带宽不够用</p>
<blockquote>
<ul>
<li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li>
<li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li>
</ul>
</blockquote>
</li>
<li><p>2、服务器负载过大，导致响应不过来</p>
<blockquote>
<p>可以从两个方面入手分析：</p>
<ul>
<li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li>
<li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li>
</ul>
</blockquote>
</li>
<li><p>3、数据库瓶颈</p>
<blockquote>
<ul>
<li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li>
<li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li>
</ul>
</blockquote>
</li>
<li><p>4、网站开发代码没有优化好</p>
<blockquote>
<ul>
<li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>针对网站访问慢，怎么去排查？</strong></p>
<ul>
<li><p>1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</p>
<blockquote>
<p>不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p>
</blockquote>
</li>
<li><p>2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p>
</li>
<li><p>3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</p>
</li>
<li><p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</p>
</li>
</ul>
<p><strong>怎么去解决？</strong></p>
<ul>
<li>1、如果是出口带宽问题，那么久申请加大出口带宽。</li>
<li>2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li>
<li>3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li>
<li>4、申请购买 CDN 服务，加载用户的访问。</li>
<li>5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</li>
</ul>
<h3 id="Linux-性能调优都有哪几种方法？"><a href="#Linux-性能调优都有哪几种方法？" class="headerlink" title="Linux 性能调优都有哪几种方法？"></a>Linux 性能调优都有哪几种方法？</h3><ul>
<li>1、Disabling daemons (关闭 daemons)。</li>
<li>2、Shutting down the GUI (关闭 GUI)。</li>
<li>3、Changing kernel parameters (改变内核参数)。</li>
<li>4、Kernel parameters (内核参数)。</li>
<li>5、Tuning the processor subsystem (处理器子系统调优)。</li>
<li>6、Tuning the memory subsystem (内存子系统调优)。</li>
<li>7、Tuning the file system (文件系统子系统调优)。</li>
<li>8、Tuning the network subsystem（网络子系统调优)。</li>
</ul>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h6 id="cd-（change-directory：英文释义是改变目录）切换目录"><a href="#cd-（change-directory：英文释义是改变目录）切换目录" class="headerlink" title="cd （change directory：英文释义是改变目录）切换目录"></a>cd （change directory：英文释义是改变目录）切换目录</h6><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">cli复制代码<span class="keyword">cd</span> <span class="string">../</span> ;跳到上级目录</span><br><span class="line"><span class="keyword">cd</span> <span class="string">/opt</span> ;不管现在到那直接跳到指定的opt文件夹中</span><br><span class="line"><span class="keyword">cd</span> ~ ;切换当前用户的家目录。root用户的家目录就是root目录。</span><br></pre></td></tr></table></figure>
<h6 id="pwd-（print-working-directory：显示当前工作目录的绝对路径）"><a href="#pwd-（print-working-directory：显示当前工作目录的绝对路径）" class="headerlink" title="pwd （print working directory：显示当前工作目录的绝对路径）"></a>pwd （print working directory：显示当前工作目录的绝对路径）</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码pwd </span><br><span class="line">显示当前的绝对路劲</span><br></pre></td></tr></table></figure>
<h6 id="ls-（ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls-只列出文件名或目录名）"><a href="#ls-（ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls-只列出文件名或目录名）" class="headerlink" title="ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）"></a>ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）</h6><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">abnf复制代码ls -a <span class="comment">;显示所有文件夹,隐藏文件也显示出来</span></span><br><span class="line">ls -R <span class="comment">;连同子目录一起列出来</span></span><br></pre></td></tr></table></figure>
<h6 id="ll-（ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll-结果是详细-有时间-是否可读写等信息）"><a href="#ll-（ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll-结果是详细-有时间-是否可读写等信息）" class="headerlink" title="ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息）"></a>ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息）</h6><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">mipsasm复制代码<span class="keyword">ll </span>-a <span class="comment">;显示所有文件,隐藏文件也显示出来</span></span><br><span class="line"><span class="keyword">ll </span>-R <span class="comment">;连同子目录内容一起列出来</span></span><br><span class="line"><span class="keyword">ll </span>-h <span class="comment">;友好展示详情信息,可以看大小</span></span><br><span class="line"><span class="keyword">ll </span>-al <span class="comment">;即能显示隐藏文件又能显示详细列表。 </span></span><br></pre></td></tr></table></figure>
<h6 id="touch-（touch：创建文件）创建文件"><a href="#touch-（touch：创建文件）创建文件" class="headerlink" title="touch （touch：创建文件）创建文件"></a>touch （touch：创建文件）创建文件</h6><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake复制代码touch <span class="keyword">test</span>.txt  ;创建<span class="keyword">test</span>.txt文件</span><br><span class="line">touch /opt/java/<span class="keyword">test</span>.java ;在指定目录创建<span class="keyword">test</span>.java文件</span><br></pre></td></tr></table></figure>
<h6 id="mkdir-（mkdir：创建目录）-创建目录"><a href="#mkdir-（mkdir：创建目录）-创建目录" class="headerlink" title="mkdir （mkdir：创建目录） 创建目录"></a>mkdir （mkdir：创建目录） 创建目录</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash复制代码mkdir 文件夹名称 ;在此目录创建文件夹</span><br><span class="line">mkdir /opt/java/jdk ;在指定目录创建文件夹</span><br></pre></td></tr></table></figure>
<h6 id="cat-（concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）"><a href="#cat-（concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）" class="headerlink" title="cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）"></a>cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）</h6><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">llvm复制代码cat lj.log <span class="comment">;快捷查看文件命令 </span></span><br><span class="line">Ctrl + <span class="keyword">c</span> <span class="comment">;暂停显示文件</span></span><br><span class="line">Ctrl + d <span class="comment">;退出查看文件命令</span></span><br></pre></td></tr></table></figure>
<h6 id="more-（more：更多的意思）分页查看文件命令（不能快速定位到最后一页）"><a href="#more-（more：更多的意思）分页查看文件命令（不能快速定位到最后一页）" class="headerlink" title="more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）"></a>more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">css</span>复制代码回车：向下<span class="selector-tag">n</span>行，需要定义，默认为1行。</span><br><span class="line">空格键：向下滚动一屏或<span class="selector-tag">Ctrl</span>+<span class="selector-tag">F</span></span><br><span class="line"><span class="selector-tag">B</span>：返回上一层或<span class="selector-tag">Ctrl</span>+<span class="selector-tag">B</span></span><br><span class="line"><span class="selector-tag">q</span>：退出<span class="selector-tag">more</span></span><br></pre></td></tr></table></figure>
<h6 id="less-（lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）"><a href="#less-（lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）" class="headerlink" title="less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）"></a>less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）</h6><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake复制代码<span class="keyword">less</span> -m 显示类似于more命令的百分比。</span><br><span class="line"><span class="keyword">less</span> -N 显示每行的行号。(大写的N)</span><br><span class="line">两参数一起使用如：<span class="keyword">less</span> -mN 文件名，如此可分页并显示行号。</span><br><span class="line"></span><br><span class="line">空格键：前下一页或page down。</span><br><span class="line">回车：向下一行。</span><br><span class="line">b：后退一页 或 page up。</span><br><span class="line">q：退出。</span><br><span class="line">d：前进半页。</span><br><span class="line">u：后退半页</span><br></pre></td></tr></table></figure>
<h6 id="tail（尾巴）-查看文件命令（看最后多少行）"><a href="#tail（尾巴）-查看文件命令（看最后多少行）" class="headerlink" title="tail（尾巴） 查看文件命令（看最后多少行）"></a>tail（尾巴） 查看文件命令（看最后多少行）</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apache</span></span><br><span class="line">复制代码tail -10 ;文件名 看最后10行</span><br></pre></td></tr></table></figure>
<h6 id="cp（copy单词缩写，复制功能）"><a href="#cp（copy单词缩写，复制功能）" class="headerlink" title="cp（copy单词缩写，复制功能）"></a>cp（copy单词缩写，复制功能）</h6><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">awk复制代码cp <span class="regexp">/opt/</span>java<span class="regexp">/java.log /</span>opt<span class="regexp">/logs/</span> ;把java.log 复制到<span class="regexp">/opt/</span>logs/下</span><br><span class="line">cp <span class="regexp">/opt/</span>java<span class="regexp">/java.log /</span>opt<span class="regexp">/logs/</span>aaa.log ;把java.log 复制到<span class="regexp">/opt/</span>logs/下并且改名为aaa.log</span><br><span class="line">cp -r <span class="regexp">/opt/</span>java <span class="regexp">/opt/</span>logs ;把文件夹及内容复制到logs文件中</span><br></pre></td></tr></table></figure>
<h6 id="mv（move单词缩写，移动功能，该文件名称功能）"><a href="#mv（move单词缩写，移动功能，该文件名称功能）" class="headerlink" title="mv（move单词缩写，移动功能，该文件名称功能）"></a>mv（move单词缩写，移动功能，该文件名称功能）</h6><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">awk复制代码mv <span class="regexp">/opt/</span>java<span class="regexp">/java.log /</span>opt<span class="regexp">/mysql/</span> ;移动文件到mysql目录下</span><br><span class="line">mv java.log mysql.log ;把java.log改名为mysql.log</span><br></pre></td></tr></table></figure>
<h6 id="rm（remove：移除的意思）删除文件，或文件夹"><a href="#rm（remove：移除的意思）删除文件，或文件夹" class="headerlink" title="rm（remove：移除的意思）删除文件，或文件夹"></a>rm（remove：移除的意思）删除文件，或文件夹</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash复制代码-f或--force 强制删除文件或目录。删除文件不包括文件夹的文件	</span><br><span class="line">-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并删除。 </span><br><span class="line">-rf 强制删除文件夹及内容</span><br><span class="line"></span><br><span class="line">rm 文件名 ;安全删除命令  （yes删除 no取消）</span><br><span class="line">rm -rf 强制删除文件夹及内容</span><br><span class="line">rm -rf *  删除当前目录下的所有内容。</span><br><span class="line">rm -rf /* 删除Linux系统根目录下所有的内容。系统将完蛋。   </span><br></pre></td></tr></table></figure>
<h6 id="find-（find：找到的意思）查找指定文件或目录"><a href="#find-（find：找到的意思）查找指定文件或目录" class="headerlink" title="find （find：找到的意思）查找指定文件或目录"></a>find （find：找到的意思）查找指定文件或目录</h6><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">routeros复制代码* 表示0~多个任意字符。</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">find</span> -name 文件名;按照指定名称查找在当前目录下查找文件</span><br><span class="line"><span class="builtin-name">find</span> / -name 文件名按照指定名称全局查找文件</span><br><span class="line"><span class="builtin-name">find</span> -name <span class="string">&#x27;*文件名&#x27;</span> ;任意前缀加上文件名在当前目录下查找文件</span><br><span class="line"><span class="builtin-name">find</span> / -name <span class="string">&#x27;*文件名*&#x27;</span> ;全局进行模糊查询带文件名的文件 </span><br></pre></td></tr></table></figure>
<h6 id="vi-（VIsual：视觉）文本编辑器-类似win的记事本-（操作类似于地下的vim命令，看底下vim-的操作）"><a href="#vi-（VIsual：视觉）文本编辑器-类似win的记事本-（操作类似于地下的vim命令，看底下vim-的操作）" class="headerlink" title="vi （VIsual：视觉）文本编辑器  类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作）"></a>vi （VIsual：视觉）文本编辑器  类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作）</h6><h6 id="vim-（VI-IMproved：改进版视觉）改进版文本编辑器-（不管是文件查看还是文件编辑-按-Shift-上或者下可以上下移动查看视角）"><a href="#vim-（VI-IMproved：改进版视觉）改进版文本编辑器-（不管是文件查看还是文件编辑-按-Shift-上或者下可以上下移动查看视角）" class="headerlink" title="vim （VI IMproved：改进版视觉）改进版文本编辑器     （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）"></a>vim （VI IMproved：改进版视觉）改进版文本编辑器     （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）</h6><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">llvm复制代码输入”vim 文件名” 打开文件，刚刚时是”一般模式”。</span><br><span class="line"></span><br><span class="line">一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退出）等。</span><br><span class="line">插入模式：可以编辑文件内容。</span><br><span class="line">底行模式：可以进行强制退出操作<span class="punctuation">,</span>不保存   :q!</span><br><span class="line">		 可以进行保存并退出操作       :wq</span><br><span class="line"></span><br><span class="line">按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。</span><br><span class="line">在编辑模式下按”Esc” 即可到一般模式</span><br><span class="line">在一般模式下按”:”，冒号进入底行模式。</span><br><span class="line"></span><br><span class="line">在一般模式下的快捷键</span><br><span class="line">	dd <span class="comment">;删除一整行</span></span><br><span class="line">	X <span class="comment">;向前删除  等同于windowns系统中的删除键</span></span><br><span class="line">	<span class="keyword">x</span> <span class="comment">;向后删除和大写x相反方向</span></span><br><span class="line">	Ctrl + f <span class="comment">;向后看一页</span></span><br><span class="line">	Ctrl + b <span class="comment">;向前看一页</span></span><br><span class="line">	u <span class="comment">;撤销上一步操作</span></span><br><span class="line">	/word <span class="comment">;向下查找word关键字  输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过n的方向相反）</span></span><br><span class="line">	?log <span class="comment">;向上查找log关键字  输入:n查找上一个,N查找下一个</span></span><br><span class="line">	:<span class="number">1</span><span class="punctuation">,</span><span class="number">90</span>s/redis/Redis/g <span class="comment">;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1代表其实行,n2代表结尾行,g是必须要的</span></span><br><span class="line">	:<span class="number">0</span> <span class="comment">;光标移动到第一行</span></span><br><span class="line">	:$ <span class="comment">;光标移动到最后一行</span></span><br><span class="line">	:<span class="number">300</span> <span class="comment">;光标移动到300行,输入多少数字移动到多少行</span></span><br><span class="line">	:w  <span class="comment">;保存</span></span><br><span class="line">	:w! <span class="comment">;强制保存</span></span><br><span class="line">	:q  <span class="comment">;退出</span></span><br><span class="line">	:q! <span class="comment">;强制退出</span></span><br><span class="line">	<span class="number">5</span>dd <span class="comment">;删除后面5行,打一个参数为自己填写</span></span><br><span class="line">	<span class="number">5</span><span class="keyword">x</span> <span class="comment">;删除此光标后面5个字符</span></span><br><span class="line">	d<span class="number">1</span>G <span class="comment">;删除此光标之前的所有</span></span><br><span class="line">	d<span class="number">0</span> <span class="comment">;从光标当前位置删除到此行的第一个位置</span></span><br><span class="line">	yy <span class="comment">;复制</span></span><br><span class="line">	p <span class="comment">;在光标的下面进行粘贴</span></span><br><span class="line">	P <span class="comment">;在光标的上门进行粘贴</span></span><br></pre></td></tr></table></figure>
<h6 id="管道命令（把多个命令组合起来使用）"><a href="#管道命令（把多个命令组合起来使用）" class="headerlink" title="| 管道命令（把多个命令组合起来使用）"></a>| 管道命令（把多个命令组合起来使用）</h6><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">coq</span><br><span class="line">复制代码管道命令的语法：命令<span class="number">1</span> | <span class="type">命令2</span> | <span class="type">命令3</span>。</span><br></pre></td></tr></table></figure>
<h6 id="grep-（grep-：正则表达式）正则表达式，用于字符串的搜索工作-模糊查询-。不懂可以先过"><a href="#grep-（grep-：正则表达式）正则表达式，用于字符串的搜索工作-模糊查询-。不懂可以先过" class="headerlink" title="grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过"></a>grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过</h6><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span>复制代码单独使用：</span><br><span class="line"><span class="keyword">grep</span> String test.java ；在test.java文件中查找String的位置，返回整行</span><br><span class="line">一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用）</span><br><span class="line"></span><br><span class="line"><span class="keyword">ps</span> aux|<span class="keyword">grep</span> java ；查找带java关键字的进程</span><br><span class="line"><span class="keyword">ll</span> |<span class="keyword">grep</span> java ；查找带java关键字的文件夹及文件</span><br></pre></td></tr></table></figure>
<h6 id="yum-install-y-lrzsz-命令（实现win到Linux文件互相简单上传文件）"><a href="#yum-install-y-lrzsz-命令（实现win到Linux文件互相简单上传文件）" class="headerlink" title="yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）"></a>yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码#（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉文件</span><br><span class="line">#等待下载完了就可以输入：</span><br><span class="line"></span><br><span class="line">rz  从win系统中选择文件上传到Linux系统中</span><br><span class="line"></span><br><span class="line">sz  文件名 选择Linux系统的文件复制到win系统中</span><br></pre></td></tr></table></figure>
<h6 id="tar-（解压-压缩-命令）"><a href="#tar-（解压-压缩-命令）" class="headerlink" title="tar （解压  压缩  命令）"></a>tar （解压  压缩  命令）</h6><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">erlang复制代码常用的组合命令：</span><br><span class="line">-z 是否需要用gzip压缩。</span><br><span class="line">-c 建立一个压缩文件的参数指令<span class="params">(create)</span> –压缩</span><br><span class="line">	-x 解开一个压缩文件的参数指令<span class="params">(extract)</span> –解压  </span><br><span class="line">	-v 压缩的过程中显示文件<span class="params">(verbose)</span></span><br><span class="line">	-f 使用档名，在f之后要立即接档中<span class="params">(file)</span></span><br><span class="line">	常用解压参数组合：zxvf</span><br><span class="line">	常用压缩参数组合：zcvf </span><br><span class="line"></span><br><span class="line">解压命令：</span><br><span class="line">tar -zxvf redis-3.<span class="number">2.8</span>.tar.gz ；解压到当前文件夹</span><br><span class="line">tar -zxvf redis-<span class="number">3.2</span>.<span class="number">8</span>.tar.gz -C /opt/java/ ；解压到指定目录</span><br><span class="line"></span><br><span class="line">压缩命令：（注意 语法有点反了，我反正每次都搞反）</span><br><span class="line">tar -zcvf redis-<span class="number">3.2</span>.<span class="number">8</span>.tar.gz  redis-<span class="number">3.2</span>.<span class="number">8</span>/  ;语法 tar -zcvf  压缩后的名称  要压缩的文件</span><br><span class="line">tar -zcvf 压缩后的文件（可指定目录）  要压缩的文件（可指定目录） </span><br></pre></td></tr></table></figure>
<h6 id="ps-（process-status：进程状态，类似于windows的任务管理器）"><a href="#ps-（process-status：进程状态，类似于windows的任务管理器）" class="headerlink" title="ps （process status：进程状态，类似于windows的任务管理器）"></a>ps （process status：进程状态，类似于windows的任务管理器）</h6><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">awk复制代码常用组合：ps -ef     标准的格式查看系统进程</span><br><span class="line">	  ps -aux    BSD格式查看系统进程</span><br><span class="line">	  ps -aux|grep redis  BSD格式查看进程名称带有redis的系统进程（常用技巧）</span><br><span class="line"><span class="regexp">//</span>显示进程的一些属性,需要了解（ps aux）</span><br><span class="line">USER     <span class="regexp">//</span>用户名</span><br><span class="line">PID		 <span class="regexp">//</span>进程ID号,用来杀死进程的</span><br><span class="line">%CPU     <span class="regexp">//</span>进程占用的CPU的百分比</span><br><span class="line">%MEM     <span class="regexp">//</span>占用内存的的百分比</span><br><span class="line">VSZ      <span class="regexp">//</span>该进程使用的虚拟內存量（KB）</span><br><span class="line">RSS      <span class="regexp">//</span>该进程占用的固定內存量（KB）</span><br><span class="line">STAT     <span class="regexp">//</span>进程的状态</span><br><span class="line">START    <span class="regexp">//</span>该进程被触发启动时间</span><br><span class="line">TIME     <span class="regexp">//</span>该进程实际使用CPU运行的时间</span><br></pre></td></tr></table></figure>
<h6 id="clear-清屏命令。（强迫症患者使用）"><a href="#clear-清屏命令。（强迫症患者使用）" class="headerlink" title="clear  清屏命令。（强迫症患者使用）"></a>clear  清屏命令。（强迫症患者使用）</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell复制代码<span class="built_in">kill</span> 命令用来中止一个进程。（要配合<span class="built_in">ps</span>命令使用，配合pid关闭进程）</span><br><span class="line">（<span class="built_in">ps</span>类似于打开任务管理器，<span class="built_in">kill</span>类似于关闭进程）</span><br><span class="line">	<span class="built_in">kill</span> <span class="literal">-5</span> 进程的PID ;推荐,和平关闭进程</span><br><span class="line">	<span class="built_in">kill</span> <span class="literal">-9</span> PID ;不推荐,强制杀死进程</span><br></pre></td></tr></table></figure>
<h6 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h6><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">armasm</span>复制代码用于查看和更改网络接口的地址和参数，包括<span class="built_in">IP</span>地址、网络掩码、广播地址，使用权限是超级用户。（一般是用来查看的，很少更改）</span><br><span class="line">如果此命令输入无效，先输入yum -y install net-tools</span><br><span class="line"><span class="symbol">ifconfig</span></span><br></pre></td></tr></table></figure>
<h6 id="ping-（用于检测与目标的连通性）语法：ping-ip地址"><a href="#ping-（用于检测与目标的连通性）语法：ping-ip地址" class="headerlink" title="ping （用于检测与目标的连通性）语法：ping ip地址"></a>ping （用于检测与目标的连通性）语法：ping ip地址</h6><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">armasm</span>复制代码测试：</span><br><span class="line"><span class="number">1</span>、在Windows操作系统中cmdipconfig，查看本机<span class="built_in">IP</span>地址：</span><br><span class="line"><span class="number">2</span>、再到LInux系统中输入 ping <span class="built_in">ip</span>地址</span><br><span class="line">（公司电脑，我就不暴露<span class="built_in">Ip</span>了,没图片  自己去试）</span><br><span class="line">按Ctrl + C 可以停止测试。</span><br></pre></td></tr></table></figure>
<h6 id="free-命令-（显示系统内存）"><a href="#free-命令-（显示系统内存）" class="headerlink" title="free 命令 （显示系统内存）"></a>free 命令 （显示系统内存）</h6><figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ldif复制代码#显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</span></span><br><span class="line"><span class="attribute">-b 以Byte显示内存使用情况</span></span><br><span class="line"><span class="attribute">-k 以kb为单位显示内存使用情况</span></span><br><span class="line"><span class="attribute">-m 以mb为单位显示内存使用情况</span></span><br><span class="line"><span class="attribute">-g 以gb为单位显示内存使用情况</span></span><br><span class="line"><span class="attribute">-s&lt;间隔秒数&gt; 持续显示内存</span></span><br><span class="line"><span class="attribute">-t 显示内存使用总合</span></span><br></pre></td></tr></table></figure>
<h6 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h6><figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ldif复制代码#显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</span></span><br><span class="line"><span class="attribute">-c 显示完整的进程命令</span></span><br><span class="line"><span class="attribute">-s 保密模式</span></span><br><span class="line"><span class="attribute">-p &lt;进程号&gt; 指定进程显示</span></span><br><span class="line"><span class="attribute">-n &lt;次数&gt;循环显示次数</span></span><br></pre></td></tr></table></figure>
<h6 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h6><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apache</span>复制代码#Linux netstat命令用于显示网络状态。</span><br><span class="line"><span class="comment">#利用netstat指令可让你得知整个Linux系统的网络情况。</span></span><br><span class="line"><span class="comment">#语法：</span></span><br><span class="line"><span class="attribute">netstat</span><span class="meta"> [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span></span><br></pre></td></tr></table></figure>
<h6 id="file-（可查看文件类型）"><a href="#file-（可查看文件类型）" class="headerlink" title="file （可查看文件类型）"></a>file （可查看文件类型）</h6><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">applescript</span><br><span class="line">复制代码<span class="built_in">file</span> 文件名</span><br></pre></td></tr></table></figure>
<h6 id="重启linux"><a href="#重启linux" class="headerlink" title="重启linux"></a>重启linux</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">nginx</span><br><span class="line">复制代码Linux centos 重启命令：reboot</span><br></pre></td></tr></table></figure>
<h6 id="关机linux"><a href="#关机linux" class="headerlink" title="关机linux"></a>关机linux</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码Linux centos 关机命令：halt</span><br></pre></td></tr></table></figure>
<h6 id="同步时间命令"><a href="#同步时间命令" class="headerlink" title="同步时间命令"></a>同步时间命令</h6><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">stylus</span><br><span class="line">复制代码ntpdate ntp1<span class="selector-class">.aliyun</span>.com</span><br></pre></td></tr></table></figure>
<h6 id="更改为北京时间命令"><a href="#更改为北京时间命令" class="headerlink" title="更改为北京时间命令"></a>更改为北京时间命令</h6><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">awk复制代码rm -rf <span class="regexp">/etc/</span>localtime</span><br><span class="line">ln -s <span class="regexp">/usr/</span>share<span class="regexp">/zoneinfo/</span>Asia<span class="regexp">/Shanghai /</span>etc/localtime</span><br></pre></td></tr></table></figure>
<h6 id="查看时间命令："><a href="#查看时间命令：" class="headerlink" title="查看时间命令："></a>查看时间命令：</h6><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">applescript</span><br><span class="line">复制代码<span class="built_in">date</span></span><br></pre></td></tr></table></figure>
<p>作者：小杰要吃蛋<br>链接：<a href="https://juejin.cn/post/6844904127059738637">https://juejin.cn/post/6844904127059738637</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-Nginx</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-Nginx/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>搬运自掘金用户：<a href="https://juejin.cn/user/2506542243918030/posts">小杰要吃蛋</a> [侵删]</p>
<h3 id="什么是Nginx？"><a href="#什么是Nginx？" class="headerlink" title="什么是Nginx？"></a>什么是Nginx？</h3><ul>
<li>Nginx是一个 轻量级/高性能的反向代理Web服务器，他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发，现在中国使用nginx网站用户有很多，例如：新浪、网易、 腾讯等。</li>
</ul>
<h3 id="为什么要用Nginx？"><a href="#为什么要用Nginx？" class="headerlink" title="为什么要用Nginx？"></a>为什么要用Nginx？</h3><ul>
<li>跨平台、配置简单、方向代理、高并发连接：处理2-3万并发连接数，官方监测能支持5万并发，内存消耗小：开启10个nginx才占150M内存 ，nginx处理静态文件好，耗费内存少，</li>
<li>而且Nginx内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。</li>
<li>使用Nginx的话还能：<ol>
<li>节省宽带：支持GZIP压缩，可以添加浏览器本地缓存</li>
<li>稳定性高：宕机的概率非常小</li>
<li>接收用户请求是异步的</li>
</ol>
</li>
</ul>
<h3 id="为什么Nginx性能这么高？"><a href="#为什么Nginx性能这么高？" class="headerlink" title="为什么Nginx性能这么高？"></a>为什么Nginx性能这么高？</h3><ul>
<li>因为他的事件处理机制：异步非阻塞事件处理机制：运用了epoll模型，提供了一个队列，排队解决</li>
</ul>
<h3 id="Nginx怎么处理请求的？"><a href="#Nginx怎么处理请求的？" class="headerlink" title="Nginx怎么处理请求的？"></a>Nginx怎么处理请求的？</h3><ul>
<li>nginx接收一个请求后，首先由listen和server_name指令匹配server模块，再匹配server模块里的location，location就是实际地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码    server &#123;            		    	# 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class="line">        listen       80；      		        # 提供服务的端口，默认80</span><br><span class="line">        server_name  localhost；    		# 提供服务的域名主机名</span><br><span class="line">        location &#x2F; &#123;            	        # 第一个location区块开始</span><br><span class="line">            root   html；       		# 站点的根目录，相当于Nginx的安装目录</span><br><span class="line">            index  index.html index.htm；    	# 默认的首页文件，多个用空格分开</span><br><span class="line">        &#125;          				# 第一个location区块结果</span><br><span class="line">    &#125;           </span><br></pre></td></tr></table></figure>
<h3 id="什么是正向代理和反向代理？"><a href="#什么是正向代理和反向代理？" class="headerlink" title="什么是正向代理和反向代理？"></a>什么是正向代理和反向代理？</h3><ol>
<li>正向代理就是一个人发送一个请求直接就到达了目标的服务器</li>
<li>反方代理就是请求统一被Nginx接收，nginx反向代理服务器接收到之后，按照一定的规    则分发给了后端的业务处理服务器进行处理了</li>
</ol>
<h3 id="使用“反向代理服务器的优点是什么"><a href="#使用“反向代理服务器的优点是什么" class="headerlink" title="使用“反向代理服务器的优点是什么?"></a>使用“反向代理服务器的优点是什么?</h3><ul>
<li>反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。</li>
</ul>
<h3 id="Nginx的优缺点？"><a href="#Nginx的优缺点？" class="headerlink" title="Nginx的优缺点？"></a>Nginx的优缺点？</h3><ul>
<li>优点：<ol>
<li>占内存小，可实现高并发连接，处理响应快</li>
<li>可实现http服务器、虚拟主机、方向代理、负载均衡</li>
<li>Nginx配置简单</li>
<li>可以不暴露正式的服务器IP地址</li>
</ol>
</li>
<li>缺点： 动态处理差：nginx处理静态文件好,耗费内存少，但是处理动态页面则很鸡肋，现在一般前端用nginx作为反向代理抗住压力，</li>
</ul>
<h3 id="Nginx应用场景？"><a href="#Nginx应用场景？" class="headerlink" title="Nginx应用场景？"></a>Nginx应用场景？</h3><ol>
<li>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</li>
<li>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。</li>
<li>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。</li>
<li>nginz 中也可以配置安全管理、比如可以使用Nginx搭建API接口网关,对每个接口服务进行拦截。</li>
</ol>
<h3 id="Nginx目录结构有哪些？"><a href="#Nginx目录结构有哪些？" class="headerlink" title="Nginx目录结构有哪些？"></a>Nginx目录结构有哪些？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码[root@localhost ~]# tree &#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">├── client_body_temp</span><br><span class="line">├── conf                             # Nginx所有配置文件的目录</span><br><span class="line">│   ├── fastcgi.conf                 # fastcgi相关参数的配置文件</span><br><span class="line">│   ├── fastcgi.conf.default         # fastcgi.conf的原始备份文件</span><br><span class="line">│   ├── fastcgi_params               # fastcgi的参数文件</span><br><span class="line">│   ├── fastcgi_params.default       </span><br><span class="line">│   ├── koi-utf</span><br><span class="line">│   ├── koi-win</span><br><span class="line">│   ├── mime.types                   # 媒体类型</span><br><span class="line">│   ├── mime.types.default</span><br><span class="line">│   ├── nginx.conf                   # Nginx主配置文件</span><br><span class="line">│   ├── nginx.conf.default</span><br><span class="line">│   ├── scgi_params                  # scgi相关参数文件</span><br><span class="line">│   ├── scgi_params.default  </span><br><span class="line">│   ├── uwsgi_params                 # uwsgi相关参数文件</span><br><span class="line">│   ├── uwsgi_params.default</span><br><span class="line">│   └── win-utf</span><br><span class="line">├── fastcgi_temp                     # fastcgi临时数据目录</span><br><span class="line">├── html                             # Nginx默认站点目录</span><br><span class="line">│   ├── 50x.html                     # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面</span><br><span class="line">│   └── index.html                   # 默认的首页文件</span><br><span class="line">├── logs                             # Nginx日志目录</span><br><span class="line">│   ├── access.log                   # 访问日志文件</span><br><span class="line">│   ├── error.log                    # 错误日志文件</span><br><span class="line">│   └── nginx.pid                    # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件</span><br><span class="line">├── proxy_temp                       # 临时目录</span><br><span class="line">├── sbin                             # Nginx命令目录</span><br><span class="line">│   └── nginx                        # Nginx的启动命令</span><br><span class="line">├── scgi_temp                        # 临时目录</span><br><span class="line">└── uwsgi_temp                       # 临时目录</span><br></pre></td></tr></table></figure>
<h3 id="Nginx配置文件nginx-conf有哪些属性模块"><a href="#Nginx配置文件nginx-conf有哪些属性模块" class="headerlink" title="Nginx配置文件nginx.conf有哪些属性模块?"></a>Nginx配置文件nginx.conf有哪些属性模块?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码worker_processes  1；                			# worker进程的数量</span><br><span class="line">events &#123;                              			# 事件区块开始</span><br><span class="line">    worker_connections  1024；          		# 每个worker进程支持的最大连接数</span><br><span class="line">&#125;                               			# 事件区块结束</span><br><span class="line">http &#123;                           			# HTTP区块开始</span><br><span class="line">    include       mime.types；         			# Nginx支持的媒体类型库文件</span><br><span class="line">    default_type  application&#x2F;octet-stream；            # 默认的媒体类型</span><br><span class="line">    sendfile        on；       				# 开启高效传输模式</span><br><span class="line">    keepalive_timeout  65；       			# 连接超时</span><br><span class="line">    server &#123;            		                # 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class="line">        listen       80；      			        # 提供服务的端口，默认80</span><br><span class="line">        server_name  localhost；    			# 提供服务的域名主机名</span><br><span class="line">        location &#x2F; &#123;            	        	# 第一个location区块开始</span><br><span class="line">            root   html；       			# 站点的根目录，相当于Nginx的安装目录</span><br><span class="line">            index  index.html index.htm；       	# 默认的首页文件，多个用空格分开</span><br><span class="line">        &#125;          				        # 第一个location区块结果</span><br><span class="line">        error_page   500502503504  &#x2F;50x.html；          # 出现对应的http状态码时，使用50x.html回应客户</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;          	        # location区块开始，访问50x.html</span><br><span class="line">            root   html；      		      	        # 指定对应的站点目录为html</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<h3 id="Nginx静态资源"><a href="#Nginx静态资源" class="headerlink" title="Nginx静态资源?"></a>Nginx静态资源?</h3><ul>
<li>静态资源访问，就是存放在nginx的html页面，我们可以自己编写</li>
</ul>
<h3 id="如何用Nginx解决前端跨域问题？"><a href="#如何用Nginx解决前端跨域问题？" class="headerlink" title="如何用Nginx解决前端跨域问题？"></a>如何用Nginx解决前端跨域问题？</h3><ul>
<li>使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。</li>
</ul>
<h3 id="Nginx虚拟主机怎么配置"><a href="#Nginx虚拟主机怎么配置" class="headerlink" title="Nginx虚拟主机怎么配置?"></a>Nginx虚拟主机怎么配置?</h3><ul>
<li>1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</li>
<li>2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</li>
<li>3、基于ip的虚拟主机。</li>
</ul>
<h4 id="基于虚拟主机配置域名"><a href="#基于虚拟主机配置域名" class="headerlink" title="基于虚拟主机配置域名"></a>基于虚拟主机配置域名</h4><ul>
<li>需要建立/data/www /data/bbs目录，windows本地hosts添加虚拟机ip地址对应的域名解析；对应域名网站目录下新增index.html文件；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码    #当客户端访问www.lijie.com,监听端口号为80,直接跳转到data&#x2F;www目录下文件</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.lijie.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   data&#x2F;www;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #当客户端访问www.lijie.com,监听端口号为80,直接跳转到data&#x2F;bbs目录下文件</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  bbs.lijie.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   data&#x2F;bbs;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于端口的虚拟主机"><a href="#基于端口的虚拟主机" class="headerlink" title="基于端口的虚拟主机"></a>基于端口的虚拟主机</h4><ul>
<li>使用端口来区分，浏览器使用域名或ip地址:端口号 访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码    #当客户端访问www.lijie.com,监听端口号为8080,直接跳转到data&#x2F;www目录下文件</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  8080.lijie.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   data&#x2F;www;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    #当客户端访问www.lijie.com,监听端口号为80直接跳转到真实ip服务器地址 127.0.0.1:8080</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.lijie.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">                index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="location的作用是什么？"><a href="#location的作用是什么？" class="headerlink" title="location的作用是什么？"></a>location的作用是什么？</h3><ul>
<li>location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作。</li>
</ul>
<h4 id="location的语法能说出来吗？"><a href="#location的语法能说出来吗？" class="headerlink" title="location的语法能说出来吗？"></a>location的语法能说出来吗？</h4><blockquote>
<p>注意：~ 代表自己输入的英文字母</p>
<table>
<thead>
<tr>
<th>匹配符</th>
<th>匹配规则</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>精确匹配</td>
<td>1</td>
</tr>
<tr>
<td>^~</td>
<td>以某个字符串开头</td>
<td>2</td>
</tr>
<tr>
<td>~</td>
<td>区分大小写的正则匹配</td>
<td>3</td>
</tr>
<tr>
<td>~*</td>
<td>不区分大小写的正则匹配</td>
<td>4</td>
</tr>
<tr>
<td>!~</td>
<td>区分大小写不匹配的正则</td>
<td>5</td>
</tr>
<tr>
<td>!~*</td>
<td>不区分大小写不匹配的正则</td>
<td>6</td>
</tr>
<tr>
<td>/</td>
<td>通用匹配，任何请求都会匹配到</td>
<td>7</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="Location正则案例"><a href="#Location正则案例" class="headerlink" title="Location正则案例"></a>Location正则案例</h4><ul>
<li>示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码    #优先级1,精确匹配，根路径</span><br><span class="line">    location &#x3D;&#x2F; &#123;</span><br><span class="line">        return 400;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写</span><br><span class="line">    location ^~ &#x2F;av &#123;</span><br><span class="line">       root &#x2F;data&#x2F;av&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #优先级3，区分大小写的正则匹配，匹配&#x2F;media*****路径</span><br><span class="line">    location ~ &#x2F;media &#123;</span><br><span class="line">          alias &#x2F;data&#x2F;static&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #优先级4 ，不区分大小写的正则匹配，所有的****.jpg|gif|png 都走这里</span><br><span class="line">    location ~* .*\.(jpg|gif|png|js|css)$ &#123;</span><br><span class="line">       root  &#x2F;data&#x2F;av&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #优先7，通用匹配</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="限流怎么做的？"><a href="#限流怎么做的？" class="headerlink" title="限流怎么做的？"></a>限流怎么做的？</h3><ul>
<li>Nginx限流就是限制用户请求速度，防止服务器受不了</li>
<li>限流有3种<ol>
<li>正常限制访问频率（正常流量）</li>
<li>突发限制访问频率（突发流量）</li>
<li>限制并发连接数</li>
</ol>
</li>
<li>Nginx的限流都是基于漏桶流算法，底下会说道什么是桶铜流</li>
</ul>
<p><strong>实现三种限流算法</strong></p>
<h5 id="1、正常限制访问频率（正常流量）："><a href="#1、正常限制访问频率（正常流量）：" class="headerlink" title="1、正常限制访问频率（正常流量）："></a>1、正常限制访问频率（正常流量）：</h5><ul>
<li>限制一个用户发送的请求，我Nginx多久接收一个请求。</li>
<li>Nginx中使用ngx_http_limit_req_module模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码	#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class="line">	limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;1r&#x2F;m;</span><br><span class="line"></span><br><span class="line">	#绑定限流维度</span><br><span class="line">	server&#123;</span><br><span class="line">		</span><br><span class="line">		location&#x2F;seckill.html&#123;</span><br><span class="line">			limit_req zone&#x3D;zone;	</span><br><span class="line">			proxy_pass http:&#x2F;&#x2F;lj_seckill;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1r/s代表1秒一个请求，1r/m一分钟接收一个请求， 如果Nginx这时还有别人的请求没有处理完，Nginx就会拒绝处理该用户请求。</li>
</ul>
<h5 id="2、突发限制访问频率（突发流量）："><a href="#2、突发限制访问频率（突发流量）：" class="headerlink" title="2、突发限制访问频率（突发流量）："></a>2、突发限制访问频率（突发流量）：</h5><ul>
<li>限制一个用户发送的请求，我Nginx多久接收一个。</li>
<li>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加burst参数以及nodelay参数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码	#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class="line">	limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;1r&#x2F;m;</span><br><span class="line"></span><br><span class="line">	#绑定限流维度</span><br><span class="line">	server&#123;</span><br><span class="line">		</span><br><span class="line">		location&#x2F;seckill.html&#123;</span><br><span class="line">			limit_req zone&#x3D;zone burst&#x3D;5 nodelay;</span><br><span class="line">			proxy_pass http:&#x2F;&#x2F;lj_seckill;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么就多了一个  burst=5 nodelay; 呢，多了这个可以代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求</li>
</ul>
<h5 id="3、-限制并发连接数"><a href="#3、-限制并发连接数" class="headerlink" title="3、 限制并发连接数"></a>3、 限制并发连接数</h5><ul>
<li>Nginx中的ngx_http_limit_conn_module模块提供了限制并发连接数的功能，可以使用limit_conn_zone指令以及limit_conn执行进行配置。接下来我们可以通过一个简单的例子来看下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码    http &#123;</span><br><span class="line">	limit_conn_zone $binary_remote_addr zone&#x3D;myip:10m;</span><br><span class="line">	limit_conn_zone $server_name zone&#x3D;myServerName:10m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            limit_conn myip 10;</span><br><span class="line">            limit_conn myServerName 100;</span><br><span class="line">            rewrite &#x2F; http:&#x2F;&#x2F;www.lijie.net permanent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的header被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过Nginx是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。接下来我们来看看两个算法的介绍：</li>
</ul>
<h3 id="漏桶流算法和令牌桶算法知道？"><a href="#漏桶流算法和令牌桶算法知道？" class="headerlink" title="漏桶流算法和令牌桶算法知道？"></a>漏桶流算法和令牌桶算法知道？</h3><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><ul>
<li><p>漏桶算法是网络世界中流量整形或速率限制时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。也就是我们刚才所讲的情况。漏桶算法提供的机制实际上就是刚才的案例：</p>
<p>突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172646dbb8b696~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><ul>
<li>令牌桶算法是网络流量整形和速率限制中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。<strong>令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。</strong></li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172646dbc20c88~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<h3 id="为什么要做动静分离？"><a href="#为什么要做动静分离？" class="headerlink" title="为什么要做动静分离？"></a>为什么要做动静分离？</h3><ul>
<li>Nginx是当下最热的Web容器，网站优化的重要点在于静态化网站，网站静态化的关键点则是是动静分离，动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们则根据静态资源的特点将其做缓存操作。</li>
<li>让静态的资源只走静态资源服务器，动态的走动态的服务器</li>
<li>Nginx的静态处理能力很强，但是动态处理能力不足，因此，在企业中常用动静分离技术。</li>
<li>对于静态资源比如图片，js，css等文件，我们则在反向代理服务器nginx中进行缓存。这样浏览器在请求一个静态资源时，代理服务器nginx就可以直接处理，无需将请求转发给后端服务器tomcat。 若用户请求的动态文件，比如servlet,jsp则转发给Tomcat服务器处理，从而实现动静分离。这也是反向代理服务器的一个重要的作用。</li>
</ul>
<h3 id="Nginx怎么做的动静分离？"><a href="#Nginx怎么做的动静分离？" class="headerlink" title="Nginx怎么做的动静分离？"></a>Nginx怎么做的动静分离？</h3><ul>
<li>只需要指定路径对应的目录。location/可以使用正则表达式匹配。并指定对应的硬盘中的目录。如下：（操作都是在Linux上）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码        location &#x2F;image&#x2F; &#123;</span><br><span class="line">            root   &#x2F;usr&#x2F;local&#x2F;static&#x2F;;</span><br><span class="line">            autoindex on;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码mkdir &#x2F;usr&#x2F;local&#x2F;static&#x2F;image</span><br></pre></td></tr></table></figure></li>
<li><p>进入目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码cd  &#x2F;usr&#x2F;local&#x2F;static&#x2F;image</span><br></pre></td></tr></table></figure></li>
<li><p>放一张照片上去#</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码1.jpg</span><br></pre></td></tr></table></figure></li>
<li><p>重启 nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码sudo nginx -s reload</span><br></pre></td></tr></table></figure></li>
<li><p>打开浏览器 输入 server_name/image/1.jpg 就可以访问该静态图片了</p>
</li>
</ol>
<h3 id="Nginx负载均衡的算法怎么实现的-策略有哪些"><a href="#Nginx负载均衡的算法怎么实现的-策略有哪些" class="headerlink" title="Nginx负载均衡的算法怎么实现的?策略有哪些?"></a>Nginx负载均衡的算法怎么实现的?策略有哪些?</h3><ul>
<li>为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。</li>
<li>Nginx负载均衡实现的策略有以下五种：</li>
</ul>
<h4 id="1-轮询-默认"><a href="#1-轮询-默认" class="headerlink" title="1 轮询(默认)"></a>1 轮询(默认)</h4><ul>
<li>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码upstream backserver &#123; </span><br><span class="line"> server 192.168.0.12; </span><br><span class="line"> server 192.168.0.13; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="2-权重-weight"><a href="#2-权重-weight" class="headerlink" title="2 权重 weight"></a>2 权重 weight</h4><ul>
<li>weight的值越大分配</li>
<li>到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码upstream backserver &#123; </span><br><span class="line"> server 192.168.0.12 weight&#x3D;2; </span><br><span class="line"> server 192.168.0.13 weight&#x3D;8; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>权重越高，在被访问的概率越大，如上例，分别是20%，80%。</li>
</ul>
<h4 id="3-ip-hash-IP绑定"><a href="#3-ip-hash-IP绑定" class="headerlink" title="3 ip_hash( IP绑定)"></a>3 ip_hash( IP绑定)</h4><ul>
<li>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，<code>并且可以有效解决动态网页存在的session共享问题</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码upstream backserver &#123; </span><br><span class="line"> ip_hash; </span><br><span class="line"> server 192.168.0.12:88; </span><br><span class="line"> server 192.168.0.13:80; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="4-fair-第三方插件"><a href="#4-fair-第三方插件" class="headerlink" title="4  fair(第三方插件)"></a>4  fair(第三方插件)</h4><ul>
<li>必须安装upstream_fair模块。</li>
<li>对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码upstream backserver &#123; </span><br><span class="line"> server server1; </span><br><span class="line"> server server2; </span><br><span class="line"> fair; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>哪个服务器的响应速度快，就将请求分配到那个服务器上。</li>
</ul>
<h4 id="5、url-hash-第三方插件"><a href="#5、url-hash-第三方插件" class="headerlink" title="5、url_hash(第三方插件)"></a>5、url_hash(第三方插件)</h4><ul>
<li>必须安装Nginx的hash软件包</li>
<li>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码upstream backserver &#123; </span><br><span class="line"> server squid1:3128; </span><br><span class="line"> server squid2:3128; </span><br><span class="line"> hash $request_uri; </span><br><span class="line"> hash_method crc32; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="Nginx配置高可用性怎么配置？"><a href="#Nginx配置高可用性怎么配置？" class="headerlink" title="Nginx配置高可用性怎么配置？"></a>Nginx配置高可用性怎么配置？</h3><ul>
<li>当上游服务器(真实访问服务器)，一旦出现故障或者是没有及时相应的话，应该直接轮训到下一台服务器，保证服务器的高可用</li>
<li>Nginx配置代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.lijie.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">		    ### 指定上游服务器负载均衡服务器</span><br><span class="line">		    proxy_pass http:&#x2F;&#x2F;backServer;</span><br><span class="line">			###nginx与上游服务器(真实访问的服务器)超时时间 后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="line">			proxy_connect_timeout 1s;</span><br><span class="line">			###nginx发送给上游服务器(真实访问的服务器)超时时间</span><br><span class="line">            proxy_send_timeout 1s;</span><br><span class="line">			### nginx接受上游服务器(真实访问的服务器)超时时间</span><br><span class="line">            proxy_read_timeout 1s;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Nginx怎么判断别IP不可访问？"><a href="#Nginx怎么判断别IP不可访问？" class="headerlink" title="Nginx怎么判断别IP不可访问？"></a>Nginx怎么判断别IP不可访问？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码# 如果访问的ip地址为192.168.9.115,则返回403</span><br><span class="line">if  ($remote_addr &#x3D; 192.168.9.115) &#123;  </span><br><span class="line">     return 403;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="怎么限制浏览器访问？"><a href="#怎么限制浏览器访问？" class="headerlink" title="怎么限制浏览器访问？"></a>怎么限制浏览器访问？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码## 不允许谷歌浏览器访问 如果是谷歌浏览器返回500</span><br><span class="line">if ($http_user_agent ~ Chrome) &#123;   </span><br><span class="line">    return 500;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Rewrite全局变量是什么？"><a href="#Rewrite全局变量是什么？" class="headerlink" title="Rewrite全局变量是什么？"></a>Rewrite全局变量是什么？</h3><blockquote>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$args</td>
<td>这个变量等于请求行中的参数，同$query_string</td>
</tr>
<tr>
<td>$content length</td>
<td>请求头中的Content-length字段。</td>
</tr>
<tr>
<td>$content_type</td>
<td>请求头中的Content-Type字段。</td>
</tr>
<tr>
<td>$document_root</td>
<td>当前请求在root指令中指定的值。</td>
</tr>
<tr>
<td>$host</td>
<td>请求主机头字段，否则为服务器名称。</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>客户端agent信息</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>客户端cookie信息</td>
</tr>
<tr>
<td>$limit_rate</td>
<td>这个变量可以限制连接速率。</td>
</tr>
<tr>
<td>$request_method</td>
<td>客户端请求的动作，通常为GET或POST。</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>客户端的IP地址。</td>
</tr>
<tr>
<td>$remote_port</td>
<td>客户端的端口。</td>
</tr>
<tr>
<td>$remote_user</td>
<td>已经经过Auth Basic  Module验证的用户名。</td>
</tr>
<tr>
<td>$request_filename</td>
<td>当前请求的文件路径，由root或alias指令与URI请求生成。</td>
</tr>
<tr>
<td>$scheme</td>
<td>HTTP方法（如http，https）。</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</td>
</tr>
<tr>
<td>$server_addr</td>
<td>服务器地址，在完成一次系统调用后可以确定这个值。</td>
</tr>
<tr>
<td>$server_name</td>
<td>服务器名称。</td>
</tr>
<tr>
<td>$server_port</td>
<td>请求到达服务器的端口号。</td>
</tr>
<tr>
<td>$request_uri</td>
<td>包含请求参数的原始URI，不包含主机名，如”/foo/bar.php?arg=baz”。</td>
</tr>
<tr>
<td>$uri</td>
<td>不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</td>
</tr>
<tr>
<td>$document_uri</td>
<td>与$uri相同。</td>
</tr>
</tbody></table>
</blockquote>
<p>作者：小杰要吃蛋<br>链接：<a href="https://juejin.cn/post/6844904125784653837">https://juejin.cn/post/6844904125784653837</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-消息队列</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>搬运自掘金用户：<a href="https://juejin.cn/user/2506542243918030/posts">小杰要吃蛋</a> [侵删]</p>
<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><ul>
<li>MQ就是消息队列。是软件和软件进行通信的中间件产品</li>
</ul>
<h2 id="MQ的优点"><a href="#MQ的优点" class="headerlink" title="MQ的优点"></a>MQ的优点</h2><ul>
<li>简答<ul>
<li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li>日志处理 - 解决大量日志传输。</li>
<li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
</li>
<li>详答</li>
</ul>
<h2 id="解耦、异步、削峰是什么？。"><a href="#解耦、异步、削峰是什么？。" class="headerlink" title="解耦、异步、削峰是什么？。"></a>解耦、异步、削峰是什么？。</h2><ul>
<li><p><strong>解耦</strong>：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>
<p><code>就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。</code></p>
</li>
<li><p><strong>异步</strong>：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</p>
</li>
<li><p><strong>削峰</strong>：减少高峰时期对服务器压力。</p>
</li>
</ul>
<h2 id="消息队列有什么缺点"><a href="#消息队列有什么缺点" class="headerlink" title="消息队列有什么缺点"></a>消息队列有什么缺点</h2><ul>
<li><p>缺点有以下几个：</p>
<ol>
<li><p><strong>系统可用性降低</strong></p>
<p>本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；</p>
</li>
<li><p><strong>系统复杂度提高</strong></p>
<p>加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。</p>
</li>
<li><p><strong>一致性问题</strong></p>
<p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</span><br></pre></td></tr></table></figure>
<h2 id="你们公司生产环境用的是什么消息中间件？"><a href="#你们公司生产环境用的是什么消息中间件？" class="headerlink" title="你们公司生产环境用的是什么消息中间件？"></a>你们公司生产环境用的是什么消息中间件？</h2><ul>
<li>这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。</li>
<li>举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。</li>
<li>但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。</li>
<li>然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。</li>
<li>另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</li>
<li>而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。</li>
<li>除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。</li>
<li>但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。</li>
<li>然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。</li>
<li>而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。</li>
<li>另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。</li>
<li>但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。</li>
<li>因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。</li>
</ul>
<h2 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d49883657~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>综上，各种对比之后，有如下建议：</li>
<li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li>
<li>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li>
<li>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://link.juejin.cn/?target=https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li>
<li>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li>
<li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<h2 id="MQ-有哪些常见问题？如何解决这些问题？"><a href="#MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="MQ 有哪些常见问题？如何解决这些问题？"></a>MQ 有哪些常见问题？如何解决这些问题？</h2><ul>
<li>MQ 的常见问题有：<ul>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ul>
</li>
</ul>
<p><strong>消息的顺序问题</strong></p>
<ul>
<li>消息有序指的是可以按照消息的发送顺序来消费。</li>
<li>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d4996c042~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>解决方案：<ol>
<li>保证生产者 - MQServer - 消费者是一对一对一的关系</li>
</ol>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d49baaae7~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>缺陷：<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。</li>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</li>
</ul>
</li>
</ul>
<p><strong>消息的重复问题</strong></p>
<ul>
<li>造成消息重复的根本原因是：网络不可达。</li>
<li>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</li>
<li>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</li>
</ul>
<h2 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a>什么是RabbitMQ？</h2><ul>
<li>RabbitMQ是一款开源的，Erlang编写的，消息中间件； 最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦 可以用它来：解耦、异步、削峰。</li>
</ul>
<h2 id="rabbitmq-的使用场景"><a href="#rabbitmq-的使用场景" class="headerlink" title="rabbitmq 的使用场景"></a>rabbitmq 的使用场景</h2><p>（1）服务间异步通信</p>
<p>（2）顺序消费</p>
<p>（3）定时任务</p>
<p>（4）请求削峰</p>
<h2 id="RabbitMQ基本概念"><a href="#RabbitMQ基本概念" class="headerlink" title="RabbitMQ基本概念"></a>RabbitMQ基本概念</h2><ul>
<li>Broker： 简单来说就是消息队列服务器实体</li>
<li>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列</li>
<li>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列</li>
<li>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li>
<li>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递</li>
<li>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。</li>
<li>Producer： 消息生产者，就是投递消息的程序</li>
<li>Consumer： 消息消费者，就是接受消息的程序</li>
<li>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</span><br></pre></td></tr></table></figure>
<h2 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h2><p><strong>一.simple模式（即最简单的收发模式）</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d49b7ccb7~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ol>
<li>消息产生消息，将消息放入队列</li>
<li>消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。</li>
</ol>
<p><strong>二.work工作模式(资源的竞争)</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d4a6f6be6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ol>
<li>消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。</li>
</ol>
<p><strong>三.publish/subscribe发布订阅(共享资源)</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d4a57e741~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ol>
<li>每个消费者监听自己的队列；</li>
<li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。</li>
</ol>
<p><strong>四.routing路由模式</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d7605829e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ol>
<li>消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;</li>
<li>根据业务功能定义路由字符串</li>
<li>从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。</li>
<li>业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;</li>
</ol>
<p><strong>五.topic 主题模式(路由模式的一种)</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717348d779d8b8d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ol>
<li>星号井号代表通配符</li>
<li>星号代表多个单词,井号代表一个单词</li>
<li>路由功能添加模糊匹配</li>
<li>消息产生者产生消息,把消息交给交换机</li>
<li>交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方式）</span><br></pre></td></tr></table></figure>
<h2 id="如何保证RabbitMQ消息的顺序性？"><a href="#如何保证RabbitMQ消息的顺序性？" class="headerlink" title="如何保证RabbitMQ消息的顺序性？"></a>如何保证RabbitMQ消息的顺序性？</h2><ul>
<li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</li>
<li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</li>
</ul>
<h2 id="消息如何分发？"><a href="#消息如何分发？" class="headerlink" title="消息如何分发？"></a>消息如何分发？</h2><ul>
<li>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能</li>
</ul>
<h2 id="消息怎么路由？"><a href="#消息怎么路由？" class="headerlink" title="消息怎么路由？"></a>消息怎么路由？</h2><ul>
<li>消息提供方-&gt;路由-&gt;一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；</li>
<li>常用的交换器主要分为一下三种：<ol>
<li>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</li>
<li>direct：如果路由键完全匹配，消息就被投递到相应的队列</li>
<li>topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符</li>
</ol>
</li>
</ul>
<h2 id="消息基于什么传输？"><a href="#消息基于什么传输？" class="headerlink" title="消息基于什么传输？"></a>消息基于什么传输？</h2><ul>
<li>由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。</li>
</ul>
<h2 id="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？</h2><ul>
<li>先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；</li>
<li>但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</li>
<li>针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性；<ul>
<li>比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；</li>
<li>假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</li>
</ul>
</li>
</ul>
<h2 id="如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？"><a href="#如何确保消息正确地发送至-RabbitMQ？-如何确保消息接收方消费了消息？" class="headerlink" title="如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？"></a>如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？</h2><p><strong>发送方确认模式</strong></p>
<ul>
<li>将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。</li>
<li>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。</li>
<li>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。</li>
<li>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li>
</ul>
<p><strong>接收方确认机制</strong></p>
<ul>
<li>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</li>
<li>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；</li>
</ul>
<p><strong>下面罗列几种特殊情况</strong></p>
<ul>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</li>
</ul>
<h2 id="如何保证RabbitMQ消息的可靠传输？"><a href="#如何保证RabbitMQ消息的可靠传输？" class="headerlink" title="如何保证RabbitMQ消息的可靠传输？"></a>如何保证RabbitMQ消息的可靠传输？</h2><ul>
<li>消息不可靠的情况可能是消息丢失，劫持等原因；</li>
<li>丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；</li>
</ul>
<ol>
<li><p><strong>生产者丢失消息</strong>：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；</p>
<p>transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</p>
<p>confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；</p>
<p>rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；</p>
<p>如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p>
</li>
<li><p><strong>消息队列丢数据</strong>：消息持久化。</p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p>
<p>这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。</p>
<p>这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢？</p>
<p>这里顺便说一下吧，其实也很容易，就下面两步</p>
<ol>
<li><p>将queue的持久化标识durable设置为true,则代表是一个持久的队列</p>
</li>
<li><p>发送消息的时候将deliveryMode=2</p>
</li>
</ol>
<p>这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据</p>
</li>
<li><p><strong>消费者丢失消息</strong>：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！</p>
<p>消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；</p>
<p>如果这时处理消息失败，就会丢失该消息；</p>
<p>解决方案：处理消息成功后，手动回复确认消息。</p>
</li>
</ol>
<h2 id="为什么不应该对所有的-message-都使用持久化机制？"><a href="#为什么不应该对所有的-message-都使用持久化机制？" class="headerlink" title="为什么不应该对所有的 message 都使用持久化机制？"></a>为什么不应该对所有的 message 都使用持久化机制？</h2><ul>
<li>首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。</li>
<li>其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。</li>
<li>所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</li>
</ul>
<h2 id="如何保证高可用的？RabbitMQ-的集群"><a href="#如何保证高可用的？RabbitMQ-的集群" class="headerlink" title="如何保证高可用的？RabbitMQ 的集群"></a>如何保证高可用的？RabbitMQ 的集群</h2><ul>
<li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</li>
</ul>
<ol>
<li><strong>单机模式</strong>，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式</li>
<li><strong>普通集群模式</strong>：<ul>
<li>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。</li>
<li>你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</li>
</ul>
</li>
<li><strong>镜像集群模式</strong>：<ul>
<li>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li>
<li>这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</li>
</ul>
</li>
</ol>
<h2 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？</h2><ul>
<li>消息积压处理办法：临时紧急扩容：</li>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。<br>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。<br>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。<br>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。<br>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。<br>MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</li>
<li>mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</li>
</ul>
<h2 id="设计MQ思路"><a href="#设计MQ思路" class="headerlink" title="设计MQ思路"></a>设计MQ思路</h2><ul>
<li>比如说这个消息队列系统，我们从以下几个角度来考虑一下：</li>
<li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li>
<li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li>
<li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li>
<li>能不能支持数据 0 丢失啊？可以呀，有点复杂的。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-Python</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-Python/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<h1 id="一、基础试题"><a href="#一、基础试题" class="headerlink" title="一、基础试题"></a>一、基础试题</h1><h2 id="1、对字典d-39-a-39-24-39-b-39-53-39-d-39-56-39-h-39-7-按照字典中的value值排序。"><a href="#1、对字典d-39-a-39-24-39-b-39-53-39-d-39-56-39-h-39-7-按照字典中的value值排序。" class="headerlink" title="1、对字典d = {&#39;a&#39;: 24, &#39;b&#39;: 53, &#39;d&#39;: 56, &#39;h&#39;: 7} 按照字典中的value值排序。"></a>1、对字典<code>d = &#123;&#39;a&#39;: 24, &#39;b&#39;: 53, &#39;d&#39;: 56, &#39;h&#39;: 7&#125;</code> 按照字典中的value值排序。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照字典中的键排序：</span></span><br><span class="line"><span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照字典中的键排序：</span></span><br><span class="line"><span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在转化为字典 使用dict 函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、反转字符串-“aSter”"><a href="#2、反转字符串-“aSter”" class="headerlink" title="2、反转字符串 “aSter”"></a>2、反转字符串 “aSter”</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;aSter&#x27;</span>[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取头不取尾</span></span><br></pre></td></tr></table></figure>
<h2 id="3、按照list1-中的元素的由从大到小排序"><a href="#3、按照list1-中的元素的由从大到小排序" class="headerlink" title="3、按照list1 中的元素的由从大到小排序"></a>3、按照list1 中的元素的由从大到小排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">50</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(list1, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse=True  由大到小 sorted排序默认由小到大</span></span><br></pre></td></tr></table></figure>
<h2 id="4、常用的字符串格式化有哪些？"><a href="#4、常用的字符串格式化有哪些？" class="headerlink" title="4、常用的字符串格式化有哪些？"></a>4、常用的字符串格式化有哪些？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="comment"># 1.占位符 %s</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;%s，你好!&quot;</span> % name</span><br><span class="line"><span class="comment"># 2. format</span></span><br><span class="line">str2 = <span class="string">&quot;&#123;&#125;， 你好!&quot;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure>
<h2 id="5、下面代码的输出结果是什么-？"><a href="#5、下面代码的输出结果是什么-？" class="headerlink" title="5、下面代码的输出结果是什么 ？"></a>5、下面代码的输出结果是什么 ？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>] </span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>[<span class="number">10</span>:])   </span><br><span class="line"></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>输出结果是空 不会产生IndexError错误，尝试用超出成员个数的Index来获取某个列表的成员。</p>
<h2 id="6、写一个列表生成式产生一个等差为11的等差数列。"><a href="#6、写一个列表生成式产生一个等差为11的等差数列。" class="headerlink" title="6、写一个列表生成式产生一个等差为11的等差数列。"></a>6、写一个列表生成式产生一个等差为11的等差数列。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([x*<span class="number">11</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>
<h2 id="7、给定两个列表怎么找出他们相同的元素和不同的元素"><a href="#7、给定两个列表怎么找出他们相同的元素和不同的元素" class="headerlink" title="7、给定两个列表怎么找出他们相同的元素和不同的元素"></a>7、给定两个列表怎么找出他们相同的元素和不同的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list2 = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">set1 = <span class="built_in">set</span>(list1)</span><br><span class="line">set2 = <span class="built_in">set</span>(list2)</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line">print(set1 ^ set2)</span><br></pre></td></tr></table></figure>
<h2 id="8、python代码实现删除一个list的重复的元素"><a href="#8、python代码实现删除一个list的重复的元素" class="headerlink" title="8、python代码实现删除一个list的重复的元素"></a>8、python代码实现删除一个list的重复的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]</span><br><span class="line">print(<span class="built_in">set</span>(list1))</span><br></pre></td></tr></table></figure>
<h2 id="9、举字符串、列表、元祖、字典的五个常用的用法。"><a href="#9、举字符串、列表、元祖、字典的五个常用的用法。" class="headerlink" title="9、举字符串、列表、元祖、字典的五个常用的用法。"></a>9、举字符串、列表、元祖、字典的五个常用的用法。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串：replace、strip、split、reverse、upper、lower、join</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表：append、pop、insert、remove、count、index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元祖：index、count、len()、dir()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典：get、keys、values、popitems、clear、uodate、items</span></span><br></pre></td></tr></table></figure>


<h2 id="10、什么是反射-？-以及他的应用场景。"><a href="#10、什么是反射-？-以及他的应用场景。" class="headerlink" title="10、什么是反射 ？ 以及他的应用场景。"></a>10、什么是反射 ？ 以及他的应用场景。</h2><p>反射就是通过字符串的形式去对象中访问或操作这个未知的属性或变量，是一种基于字符串的事件驱动。</p>
<p>在面向对象中把对象能够访问、查询、修改自身的状态或者行为称之为反射。</p>
<p>在python中，可以通过字符串的的形式来操作对象的属性。这种行为称之为python中的反射。</p>
<p><strong>python</strong> <strong>实现反射的手段：</strong></p>
<p>是通过四个内置函数来实现：<strong>hasattr(object,name)</strong> <strong>getattr(object,name,default=None) setattr(x,y,v) delattr(x,y)</strong></p>
<p>判断对象中是否有这个方法或变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;%s正在交谈&quot;</span>%self.name)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person(<span class="string">&quot;laowang&quot;</span>)    </span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;talk&quot;</span>))  <span class="comment"># True。因为存在talk方法</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;name&quot;</span>))  <span class="comment"># True。因为存在name变量</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;abc&quot;</span>))   <span class="comment"># False。因为不存在abc方法或变量</span></span><br></pre></td></tr></table></figure>


<p><strong>反射的好处 ：</strong></p>
<p>实现可插拔机制、动态导入模块（基于反射原理，获取当前的模块的成员）</p>
<h2 id="11、简述Python的深浅拷贝-，详细见链接。"><a href="#11、简述Python的深浅拷贝-，详细见链接。" class="headerlink" title="11、简述Python的深浅拷贝 ，详细见链接。"></a>11、简述Python的深浅拷贝 ，详细见<a href="https://zhuanlan.zhihu.com/p/54011712">链接</a>。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy() ： 浅拷贝，仅仅拷贝数据集合的第一层</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deepcopy() : 深拷贝，拷贝数据集合的所有层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="number">1</span>:<span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====赋值=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=a</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====浅拷贝=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=copy.copy(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====深拷贝=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"></span><br><span class="line">=====赋值=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line">=====浅拷贝=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919592320</span></span><br><span class="line"></span><br><span class="line">=====深拷贝=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919532928</span></span><br></pre></td></tr></table></figure>
<h2 id="12、Python的垃圾回收机制。网页地址"><a href="#12、Python的垃圾回收机制。网页地址" class="headerlink" title="12、Python的垃圾回收机制。网页地址"></a>12、Python的垃圾回收机制。<a href="https://zhuanlan.zhihu.com/p/83251959">网页地址</a></h2><ol>
<li><strong>引用计数</strong></li>
</ol>
<p>在python中每一个对象的的核心就是一个结构体PyObject，他的内部有一个引用计数器（（ob_refcnt）），程序在运行的过程中他会实时的更新 引用计数器（ob_refcnt）的值，来反映当前对象的名称数量，当某个对象的引用计数为零的时候，那么他的内存就会被释放掉。</p>
<p>导致引用计数加一的情况有 ：对象被创建、对象被引用、对象被作为参数传入一个函数中、对象存储在容器中。</p>
<p>导致引用计数减一的情况有：对象别名被显示销毁 del、对象别名被赋予新的对象、一个对象离开他的作用域、对象所在的容器被销毁或者是从容器中删除对象 。</p>
<p>我们可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数（注意，这里getrefcount()本身会使得引用计数加一）。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<p><strong>引用计数的优点</strong>：</p>
<p>高效、实现逻辑简单、具备实时性，一旦一个对象的引用计数归零，内存就直接释放了。</p>
<p><strong>引用计数的缺点：</strong></p>
<p>逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。</p>
<p>可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。</p>
<p>循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。</p>
<ol start="2">
<li><strong>标记-清除</strong></li>
</ol>
<p>它是解决容器对象（(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)）可能产生的循环引用的问题。不改动真实的而引用计数，而是将引用计数复制一份副本，改动该对象引用的副本，对于副本做得任何改动都不影响生命对象整体的维护。</p>
<p><strong>标记清除的步骤：</strong></p>
<p>标记阶段：GC会把所有活动对象打上标记，这些活动对象就像是一个点，他们之间使用引用关系来连接，最终每个点和边构成了一个有向图。</p>
<p><img src="https://origin.chaizz.com/8d3dc5ea460a11ec9d7c5254006b8f1d.png"></p>
<p>GC从跟对象触发遍历所整个图，如果该对象是可达的（reachable）也就是说还有对象在引用他，那么就标记该对象可达。如上图中从根对象开始遍历1、2、3、4是可达的，5、6、7是不可达的。（整个根对象就是全局对象，调用栈，寄存器）</p>
<p>清除阶段：遍历的对象不可达，就将其回收。通过分代回收来加速清理对象。</p>
<ol start="3">
<li><strong>分代回收</strong></li>
</ol>
<p>在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过**“分代回收”(Generational Collection)**以空间换时间的方法提高垃圾回收效率。</p>
<p>分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</p>
<p>分代回收 根据内存中对象的存活时间将他们分为三代，新生的对象放入0代，如果一个对象能在0代的垃圾回收机制中存活下来，GC就会将它放入1代中，如果1代的对象在1代的垃圾 回收过程中存货下来，则会进入二代。</p>
<p>分代回收的触发机制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果是一个元祖：(700, 10, 10)</p>
<ul>
<li>当分配对象分个数减去释放对象的个数差值大于700时，就会产生一次0代回收。</li>
<li>10次0代回收后进行一次1代回收。</li>
<li>10次1代回收后进行一次2代回收。</li>
</ul>
<p>对于0代的对象他们有可能只会被使用一次，所以需要被经常回收。经过一轮回收之后他们是那些使用比较频繁的对象，而且他们已经存活了很久的时间，大概率还会存活更久，因此二代的会后就不会那么频繁。</p>
<p>可以通过(700, 10, 10) 这三个值进行更改分代回收触发的条件。</p>
<p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<h2 id="13、如何打乱一个排好序的lisit对象"><a href="#13、如何打乱一个排好序的lisit对象" class="headerlink" title="13、如何打乱一个排好序的lisit对象"></a>13、如何打乱一个排好序的lisit对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">random.shuffle(alist)</span><br><span class="line"></span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h2 id="14、从0-99这100个数中随即取出十个数字-要求不能重复。"><a href="#14、从0-99这100个数中随即取出十个数字-要求不能重复。" class="headerlink" title="14、从0-99这100个数中随即取出十个数字 要求不能重复。"></a>14、从0-99这100个数中随即取出十个数字 要求不能重复。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.sample(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">99</span>),k=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>


<h2 id="15、Python如何捕获异常、处理异常-、抛出异常"><a href="#15、Python如何捕获异常、处理异常-、抛出异常" class="headerlink" title="15、Python如何捕获异常、处理异常 、抛出异常"></a>15、Python如何捕获异常、处理异常 、抛出异常</h2><p>捕获异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> </span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#else:不发生异常执行的语句</span></span><br><span class="line"><span class="comment">#finally：无论是否发生异常都执行的语句</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># raise Exception  抛出异常</span></span><br></pre></td></tr></table></figure>
<h2 id="16、python递归的大层数"><a href="#16、python递归的大层数" class="headerlink" title="16、python递归的大层数"></a>16、python递归的大层数</h2><p>最大递归为998</p>
<p>修改最大递归值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="17、列表推导式和生成器表达式-i-2-for-i-in-range-10-和-i-2-for-i-in-range-10-输出的结果分别是什么？"><a href="#17、列表推导式和生成器表达式-i-2-for-i-in-range-10-和-i-2-for-i-in-range-10-输出的结果分别是什么？" class="headerlink" title="17、列表推导式和生成器表达式[i % 2 for i in range(10)] 和 (i % 2 for i in range(10)) 输出的结果分别是什么？"></a>17、列表推导式和生成器表达式<code>[i % 2 for i in range(10)] </code>和 <code>(i % 2 for i in range(10)) </code>输出的结果分别是什么？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print((i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000002AD4E8F09E0</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="18-什么是闭包？"><a href="#18-什么是闭包？" class="headerlink" title="18. 什么是闭包？"></a>18. 什么是闭包？</h2><p>指的是定义在一个函数内部的函数 ，被外层函数包裹着。其特点是可以访问到外层函数的名字。 闭包有两种不同的方式，第一种是在函数内部就直接调用了；第二种是返回一个函数名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种形式 在外层函数中直接调用内层函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mark</span>(<span class="params">name</span>):</span></span><br><span class="line">  num = <span class="number">100</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">weight</span>):</span></span><br><span class="line">​    weight += <span class="number">1</span></span><br><span class="line">​    print(name, weight)</span><br><span class="line">  func(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">mark(<span class="string">&#x27;塞拉斯&#x27;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二种形式:在外层函数中返回内层函数对象    （也就是装饰器）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span>(<span class="params">name</span>):</span></span><br><span class="line">  num = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">height</span>):</span></span><br><span class="line">    height += <span class="number">1</span></span><br><span class="line">    print(name, num, height)</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">a = maker(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">a(<span class="number">999</span>)</span><br></pre></td></tr></table></figure>


<p> “闭包”的作用——保存函数的状态信息，使函数的局部变量信息依然可以保存下来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Maker</span>(<span class="params">step</span>):</span> <span class="comment"># 包装器</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span> <span class="comment"># 内部函数</span></span><br><span class="line">        <span class="comment"># nonlocal关键字的作用和前面的local是一样的，如果不使用该关键字，则不能在中内部函数改变“外部变量”的值</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        <span class="comment"># 改变外部变量的值（如果只是访问外部变量，则不需要适用nonlocal）</span></span><br><span class="line">        num = num + step</span><br><span class="line">        print(num)</span><br><span class="line">    <span class="keyword">return</span> fun1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="comment"># 调用外部包装器</span></span><br><span class="line">func2 = Maker(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 调用内部函数4次 输出的结果是 4、7、10、13</span></span><br><span class="line">    func2() </span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p> 这就是“闭包”的最大的作用——保存局部信息不被销毁。</p>
</blockquote>
<h2 id="19、字典推导式"><a href="#19、字典推导式" class="headerlink" title="19、字典推导式"></a>19、字典推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">d = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(a, b)&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20、python2和python3的差别"><a href="#20、python2和python3的差别" class="headerlink" title="20、python2和python3的差别"></a>20、python2和python3的差别</h2><p>新增的库 asyncio 内置库 asybs/await 原生协程支持异步编程。</p>
<p>Enum(枚举) mock、asyncio、ipaddress</p>
<p>print表达式 改为了方法 print（）</p>
<p>raw_input （） 改为input （）</p>
<p>Python3中的Str类型代表Unicode字符串，Python2中的Str类型代表bytes字节序列。</p>
<p>Python3中的 / 返回浮点数，Python2中根据结果而定，能被整除返回整数，否则返回浮点数</p>
<h2 id="21、文件操作-xreadlines-和Readlines-的区别"><a href="#21、文件操作-xreadlines-和Readlines-的区别" class="headerlink" title="21、文件操作 xreadlines 和Readlines 的区别"></a>21、文件操作 xreadlines 和Readlines 的区别</h2><p>readlines（）是把文件全部读取到内存，并解析成一个list ,当文件体积过大时要占用很多内存。</p>
<p>xreadlines（） 则是返回一个iter() file 迭代器，在python2.3之后，已经不推荐这样使用了，而是直接for循环迭代文件对象。</p>
<p>最好的方式是使用 with open as f，对可迭代对象 f，进行迭代遍历：for line in f，会自动地使用缓冲IO（buffered IO）以及内存管理，而不必担心任何大文件的问题。</p>
<h2 id="22、列举布尔值为False-的常见的值？"><a href="#22、列举布尔值为False-的常见的值？" class="headerlink" title="22、列举布尔值为False 的常见的值？"></a>22、列举布尔值为False 的常见的值？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>、[]、（）、&#123;&#125;、””、<span class="literal">False</span>、 <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<h2 id="23、匿名函数lambda-的用法。"><a href="#23、匿名函数lambda-的用法。" class="headerlink" title="23、匿名函数lambda 的用法。"></a>23、匿名函数lambda 的用法。</h2><p>Lambda 作为一个表达式，定义了一个匿名函数。如果使用lambda，lambda内不要包含循环 。lambda 是为了减少单行函数的定义而存在的。</p>
<h2 id="24、Python类中init-（self）-和-new-cls-的区别："><a href="#24、Python类中init-（self）-和-new-cls-的区别：" class="headerlink" title="24、Python类中init__（self） 和 __new(cls)的区别："></a>24、Python类中<strong>init__（self） 和 __new</strong>(cls)的区别：</h2><p><strong>init</strong>(self) ：负责初始化<strong>new</strong>(cls)创建的对象，是一个对象方法。接受self参数，以及其他初始化的参数 </p>
<p><strong>new</strong>(cls) ：创建<strong>init</strong>(self)初始化的对象。是一个类方法。在调用<strong>new</strong>(cls)之前连对象都没有。只接受一个参数 cls，必须要有返回值，返回实例化的对象。</p>
<h2 id="25、列出5个python标准库"><a href="#25、列出5个python标准库" class="headerlink" title="25、列出5个python标准库"></a>25、列出5个python标准库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准库：sys、os、re、urllib、logging、datetime、random、threading、multiprocessing、base64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三方库：requests、Scrapy、gevent、pygame、pymysql、pymongo、redis-py、Django、Flask、Werkzeug、celery、IPython、pillow</span></span><br></pre></td></tr></table></figure>
<h2 id="26、python中生成随机整数、随机小数、0–1之间小数方法"><a href="#26、python中生成随机整数、随机小数、0–1之间小数方法" class="headerlink" title="26、python中生成随机整数、随机小数、0–1之间小数方法"></a>26、python中生成随机整数、随机小数、0–1之间小数方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机整数</span></span><br><span class="line">print(random.randint(<span class="number">0</span>, <span class="number">99999</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机小数</span></span><br><span class="line">print(np.random.randn())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机 0-1 小数</span></span><br><span class="line">print(random.random())</span><br></pre></td></tr></table></figure>




<h2 id="27、type和instance的区别"><a href="#27、type和instance的区别" class="headerlink" title="27、type和instance的区别"></a>27、type和instance的区别</h2><p>type用于获取对象的类型，返回的是对象的类型</p>
<p>instance用于测试对象是否属于某种类型或者多种类型之一，返回的是布尔类型</p>
<p>type不能判断子类对象是否属于父类，instance能够判断</p>
<h2 id="28、python-实现装饰器"><a href="#28、python-实现装饰器" class="headerlink" title="28、python 实现装饰器"></a>28、python 实现装饰器</h2><p>通用装饰器</p>
<p>使用场景：常见的认证。权限控制、日志打印、函数执行耗时等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span>  wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        ts = time.time()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f&#x27;函数：<span class="subst">&#123;func.__name__&#125;</span> 耗时：<span class="subst">&#123;time.time() - ts&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;唱<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(sing(<span class="string">&#x27;儿歌&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 唱儿歌</span></span><br><span class="line"><span class="comment"># 函数：sing 耗时：0.0</span></span><br><span class="line"><span class="comment"># ok</span></span><br></pre></td></tr></table></figure>


<p>带参数的装饰器</p>
<p>可以根据装饰器的参数，进行返回不同的装饰效果，或者进行流程控制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">var</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            print(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            ts = time.perf_counter()</span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            print(<span class="string">f&#x27;函数：<span class="subst">&#123;func.__name__&#125;</span> 耗时：<span class="subst">&#123;time.perf_counter() - ts&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> var == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> inner</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> inner2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法</span></span><br><span class="line"><span class="meta">@outer(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;跳<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(dance(<span class="string">&#x27;恰恰&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 我是outer装饰器</span></span><br><span class="line"><span class="comment"># 跳恰恰</span></span><br><span class="line"><span class="comment"># ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="二、-数据库"><a href="#二、-数据库" class="headerlink" title="二、     数据库"></a>二、     数据库</h1><h2 id="1、什么是事务"><a href="#1、什么是事务" class="headerlink" title="1、什么是事务"></a>1、什么是事务</h2><p><strong>事务</strong>是数据库并发控制的基本单位。相当于对一系列sql语句的集合，事务要么全部执行成功，要么全部失败。</p>
<p>事务的四个特性 ：ACID </p>
<p>A（atomicity）：原子性：一个事务的操作要么全部完成要么全部失败。</p>
<p>C（consistency）：一致性：事务开始前后数据保持完整性没有被破坏。</p>
<p>I（isolation）：隔离性：允许多个事务同时对数据库进行读写和修改。</p>
<p>D（durability）：持久性：事务结束之后，修改是永久的。</p>
<p><strong>事务的并发控制可能产生的问题</strong>：</p>
<p>幻读：一个事务进行第二次查出现第一次没有的结果。</p>
<p>非重复读：一个事务读取两次读到两个不同的结果。</p>
<p>脏读：一个事务读取到另一个事物没有提交的修改。</p>
<p>丢失修改：并发写入导致其中的一些修改丢失。</p>
<p><strong>为了解决并发控制异常，定义了四种事务的隔离级别：</strong></p>
<p>读未提交：别的事务可以读到未提交的改变。</p>
<p>读已提交：只能读到已提交的数据。</p>
<p>可重复读：同一个事务先后读取结果一样。</p>
<p>串行化：事务完全串行化的执行，隔离级别最高，执行效率最低。</p>
<p><strong>解决高并发情况下的插入重复：</strong></p>
<p>   使用数据库的唯一索引。</p>
<p>   使用队列的异步写入。</p>
<p>   使用redis实现分布式锁。</p>
<h2 id="2、Mysql的数据类型："><a href="#2、Mysql的数据类型：" class="headerlink" title="2、Mysql的数据类型："></a>2、Mysql的数据类型：</h2><p>-   Char : 存储定长的字符串。</p>
<p>-   Varchar：存储定长的字符串。</p>
<p>-   Text ：存储文本比较长的类型</p>
<p>-   Tinyint：一个字节，-127 到 255</p>
<p>-   Int：四个字节 （）</p>
<p>-   Datetime：8个字节</p>
<p>-   Timestamp ：四个字节 只能存储到从1970到2038年</p>
<h2 id="3、MYSql-的两个常用的引擎"><a href="#3、MYSql-的两个常用的引擎" class="headerlink" title="3、MYSql 的两个常用的引擎"></a>3、MYSql 的两个常用的引擎</h2><p>Innodb :支持事务，支持外键、支持行锁、支持表锁。不支持全文索引。</p>
<p>Myisam: 不支持事务，不支持外键、只支持表锁 支持全文索引。</p>
<h2 id="4、Mysql-索引的原理以及优化常见的问题"><a href="#4、Mysql-索引的原理以及优化常见的问题" class="headerlink" title="4、Mysql 索引的原理以及优化常见的问题"></a>4、Mysql 索引的原理以及优化常见的问题</h2><p><strong>索引的类型 ：</strong></p>
<p>普通索引 create index</p>
<p>唯一索引 create unique index</p>
<p>多列索引</p>
<p>主键索引 只有一个，全文索引 （innodb 不支持）</p>
<p><strong>那些情况下用索引：</strong></p>
<p>经常用查询需条件的字段去创建索引 （where条件）</p>
<p>经常用坐标链接的字段</p>
<p>经常用在order by group by 后面的字段</p>
<p><strong>创建索引有哪些需要注意的：</strong></p>
<p>不能非空字段上创建索引，</p>
<p>不要在很多字段相同的字段上创建索引</p>
<p>索引的长度不要太长</p>
<p><strong>索引失效的情况：</strong></p>
<ul>
<li><p>对于多列索引，不是使用的第一部分，则不会使用索引（最左匹配原则）</p>
</li>
<li><p>% Like 语句 以%开头索引失效。</p>
</li>
<li><p>如果列类型是字  符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。（隐式转换）</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。</p>
</li>
<li><p> 查询条件使用函数在索引列上，或者 对索引列进行运算， 运算包括(+，-，*，/，! 等) </p>
</li>
<li><p>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</p>
</li>
</ul>
<p><strong>什么是聚集索引 和非聚集索引：</strong></p>
<p>非聚集索引：数据和索引单独存储。myisam ：使用的是非聚集索引。Innodb 主键索引是聚集索引</p>
<p><strong>如何排查慢查询：</strong></p>
<p>开启慢查询日志 slow_query_log_file</p>
<p>通过 explain 排序索引问题。</p>
<p>调整数据修改索引，是不是有隐式转换。</p>
<h2 id="5、SQL语句的编写问题"><a href="#5、SQL语句的编写问题" class="headerlink" title="5、SQL语句的编写问题"></a>5、SQL语句的编写问题</h2><p><strong>内连接：</strong>（Inner join）将左表和右表关联起来的数据进行返回。类似于求两个表的交集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a inner join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p><strong>外链接：</strong></p>
<p>左连接：返回左表中的所有数据，即使右表没有匹配的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a left join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p>右链接 ：返回右表中的所有数据，即使左表没有匹配的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a right join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p>没有匹配的字段都会自动设置为null。</p>
<h2 id="6、MySQL为什么使用B-树数据结构而不用B树，B-树相对于B树有什么优点"><a href="#6、MySQL为什么使用B-树数据结构而不用B树，B-树相对于B树有什么优点" class="headerlink" title="6、MySQL为什么使用B+树数据结构而不用B树，B+树相对于B树有什么优点"></a>6、MySQL为什么使用B+树数据结构而不用B树，B+树相对于B树有什么优点</h2><p>是因为B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，B+树只要遍历叶子节点就可以实现整棵树的遍历。B+树比B树多了一个双向链表，在进行范围查找的时候有更快的效率，且B+树在叶子节点冗余了上面的根节点。</p>
<h2 id="7、MySQL事务的特性以及隔离级别"><a href="#7、MySQL事务的特性以及隔离级别" class="headerlink" title="7、MySQL事务的特性以及隔离级别"></a>7、MySQL事务的特性以及隔离级别</h2><p><strong>事务的四大特性：</strong></p>
<p>原子性（atomicity）：事务的操作要么全部成功要么全部失败，是通过MySQL的undo log 来实现的。</p>
<p>一致性（consistency）：事务开始和结束之后不会对数据破坏，数据是符合预期的。原子性、隔离性、持久性共同实现一致性。</p>
<p>隔离性（isolation）：数据库允许多个事务对数据进行操作，隔离性可以放置数据库并发操作而导致数据的不一致问题。是通过LBCC+MVCC实现的。</p>
<p>持久性（durability）：事务结束之后对数据的改变是永久的，不会因为外界的干扰而导致数据更改。在数据库中是由redo Log 来实现的。</p>
<p><strong>事务的隔离级别：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv8YPTrg9lpFjt5WmnTicwibMqF5XDaZXJcrF9rCDmNxLp5z0gbHPzT11eQ5EyRtYBVdtkOVRQ5WABw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<h2 id="8、MySQL什么情况下会发生死锁，如何解决死锁"><a href="#8、MySQL什么情况下会发生死锁，如何解决死锁" class="headerlink" title="8、MySQL什么情况下会发生死锁，如何解决死锁"></a>8、MySQL什么情况下会发生死锁，如何解决死锁</h2><p><strong>什么是死锁：</strong>多个事务因竞争锁而造成的一种相互等待的僵局。</p>
<p><strong>出现死锁的情况：</strong></p>
<h2 id="9、简述乐观锁和悲观锁的区别以及使用场景"><a href="#9、简述乐观锁和悲观锁的区别以及使用场景" class="headerlink" title="9、简述乐观锁和悲观锁的区别以及使用场景"></a>9、简述乐观锁和悲观锁的区别以及使用场景</h2><p><strong>乐观锁：</strong>每次获取数据的时候，不会担心数据被修改，所以每次获取数据的时候不会对数据加锁，但是在更新数据的时候会判断数据是否被修改过，如果数据被修改过，则不进行数据更新，如果没有被修改过，则进行数据更新。由于数据没有加锁，所以这期间数据有可能被其他线程进行读写操作。</p>
<p><strong>悲观锁：</strong>每次获取数据的时候都会担心数据被修改，所以每次获取数据的时候都会加锁，确保自己在使用的过程中，数据不会被修改，使用完成后释放锁，由于数据被加锁所以其他的线程多数据进行修改需要进行等待。</p>
<p><strong>使用场景：</strong></p>
<p>悲观锁：比较适合写入的操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会加锁，这样会增加大量的开销，降低系统的吞吐量。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写操作，数据发生冲突的可能性就会增加，为了保证数据的一致性，底层就会不断的重新获取数据，会增加大量的查询操作，降低了性能。</p>
<h2 id="10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引"><a href="#10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引" class="headerlink" title="10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引"></a>10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引</h2><p><strong>聚簇索引：</strong>将数据和索引存放到一起，找到索引就找到数据了。innodb引擎使用聚簇索引。</p>
<p><strong>非聚簇索引：</strong>将数据和索引分开存放，索引结构的叶子结点存储的是数据的对应地址的指针，Myisam通过key-buffer把索引先缓存到内存中，当需要访问数据时候，在内存中直接搜索索引，然后通过素银找到对应的数据，这也就是索引不在key-buffer命中时，速度慢的原因。</p>
<h2 id="11、脏读和幻读产生的场景，InnoDB是如何解决幻读的"><a href="#11、脏读和幻读产生的场景，InnoDB是如何解决幻读的" class="headerlink" title="11、脏读和幻读产生的场景，InnoDB是如何解决幻读的"></a>11、脏读和幻读产生的场景，InnoDB是如何解决幻读的</h2><p><strong>脏读：</strong>一个事务在前后两次查询过程中得到的结果不一致由因为读取到另一个事务<strong>未提交</strong>的数据叫产生了脏读。它在事务隔离级别为：读未提交的情况下产生。</p>
<p><strong>幻读：</strong>在一个事务中前后两次查询读取到了不一样的结果数，是由于读取到其他的事务已经提交的新的数据。这种情况产生的叫做幻读，读未提交，读已提交这两种事务隔离级别下都会产生。</p>
<p><strong>解决幻读：</strong></p>
<p>是通过间隙锁+锁住本身的数据（next-key），间隙锁锁住一段范围，所以其他事务无法对这段范围的数据进行插入删除等操作，所以就不存在幻读的问题。</p>
<br> 

<p>如果事务隔离级别是 Read Commit ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。</p>
<p>如果事务的隔离级别是可重读，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.</p>
<h2 id="12、MySQL的主从复制的原理"><a href="#12、MySQL的主从复制的原理" class="headerlink" title="12、MySQL的主从复制的原理"></a>12、MySQL的主从复制的原理</h2><p>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:</p>
<p><img src="https://origin.chaizz.com/69080f8a407611ec9d7c5254006b8f1d.jpeg"></p>
<ul>
<li>从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li>
<li>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</li>
<li>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</li>
</ul>
<h2 id="13、主从复制延迟产生的原因，以及如何解决？"><a href="#13、主从复制延迟产生的原因，以及如何解决？" class="headerlink" title="13、主从复制延迟产生的原因，以及如何解决？"></a>13、主从复制延迟产生的原因，以及如何解决？</h2><p>产生延迟的原因：</p>
<ul>
<li>主从机器性能差异</li>
<li>主机器有大量的写操作，从机器有大量的读操作，从而影响从机器复制的性能。</li>
<li>大事务的执行，本身事物执行消耗了大量时间</li>
</ul>
<h2 id="14、缓存的适用场景？为什么使用缓存？"><a href="#14、缓存的适用场景？为什么使用缓存？" class="headerlink" title="14、缓存的适用场景？为什么使用缓存？"></a>14、缓存的适用场景？为什么使用缓存？</h2><p>-   缓解关系数据库的并发压力，</p>
<p>-   减少响应的时间</p>
<p>-   提升吞吐量</p>
<h2 id="15、Redis-和memcached-的区别："><a href="#15、Redis-和memcached-的区别：" class="headerlink" title="15、Redis 和memcached 的区别："></a>15、Redis 和memcached 的区别：</h2><p><strong>Redis 支持的数据类型：</strong></p>
<p>-   String ： 实现简单的KV键值对存储，计数器</p>
<p>-   List ： 双向链表，实现队列， 用户的的关注或者粉丝表表</p>
<p>-   Hash ： 用来存储彼此相关信息的键值对。</p>
<p>-   Set：存储不重复的元素，例如用户的关注着。</p>
<p>-   Sort set ：有序集合，存储实时信息排行榜</p>
<h2 id="16、Redis实现持久化的方式："><a href="#16、Redis实现持久化的方式：" class="headerlink" title="16、Redis实现持久化的方式："></a>16、<strong>Redis实现持久化的方式：</strong></h2><p>-   快照的方式， 把数据快照放在磁盘二进制文件中，dump.rdb （Redis默认开启）</p>
<p>-   AOF：每写一个命令追加到appendonly.aof 中。</p>
<p>-   修改redis 配置中实现</p>
<h2 id="17、Redis如何实现分布式锁"><a href="#17、Redis如何实现分布式锁" class="headerlink" title="17、Redis如何实现分布式锁"></a>17、<strong>Redis如何实现分布式锁</strong></h2><p>使用setnx 实现加锁，可以同时通过expire 添加超时时间。del删除锁，getset key value 先get在set 先返回key对应的值，如果没有就返回空，然后在将key设置为value。</p>
<ul>
<li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</li>
</ul>
<h2 id="18、缓存的使用模式："><a href="#18、缓存的使用模式：" class="headerlink" title="18、缓存的使用模式："></a>18、<strong>缓存的使用模式：</strong></h2><p>常用的有三种，</p>
<p>cache aside 同时更新缓存和数据库。（数据一致性的问题：解决，都是写入数据库，删除缓存。在更新缓存）Read/write through 先更新缓存。缓存负责同步的更新数据库。</p>
<p>write behind caching 先更新缓存，缓存定期异步更新数据库。</p>
<h2 id="19、如何缓解缓存穿透的问题："><a href="#19、如何缓解缓存穿透的问题：" class="headerlink" title="19、如何缓解缓存穿透的问题："></a>19、<strong>如何缓解缓存穿透的问题：</strong></h2><p><strong>产生的原因一：由于大量的请求查询缓存，查不到就回去数据库去取。数据库也查不到数据。（多数是由于非法攻击）</strong></p>
<p>解决：</p>
<ul>
<li><p>对参数进行合法性校验。</p>
</li>
<li><p>将查不到的数据返回一个none，把none缓存下来，有新的数据插入，在把none 删除，或者设置较短的缓存时间。</p>
</li>
<li><p>使用布隆过滤器</p>
</li>
</ul>
<h3 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个位数组（bitarray），开始所有数据全部置0，当一个元素讲过多个hash函数计算不同的哈希值，并通过哈希值找到对应的bitarray，将值改为1。<strong>（需要说明，布隆过滤器存在误判的可能）数组越长误判率越低，占用的空间也越大。）</strong></p>
<p><img src="https://origin.chaizz.com/128523c846b111ec9d7c5254006b8f1d.png"></p>
<p>以上是一个空的布隆过滤器，现在要插入这个A字段，经过三个hash函数计算得到了2、5、7 所以将将布隆过滤器的相对应的值设置为1。</p>
<p><img src="https://origin.chaizz.com/4c40b08646b211ec9d7c5254006b8f1d.png"></p>
<p>接下来继续插入B字段，计算出来的值为2、4、8，继续往布隆过滤器对相应的位置上设置为1，注意A和B同时hash计算出来的值一致。所以导致了布隆过滤器不能确保某个元素一定存在。</p>
<p><img src="https://origin.chaizz.com/9600ff0a46b211ec9d7c5254006b8f1d.png"></p>
<p>布隆过滤器的查询也很简单，例如我们要找一个字段C，只需要计算出他的hash值，如果该值为2、3、4，那么因为布隆过滤器对应bit位上的数据有一个不为1，所以就断定C不存在，但是如果他计算的值为1、4、8，name就不能确定他一定存在。</p>
<p>因此随着添加的值越来越多，bit位的占用也就就越多，布隆过滤器的误判性也就会越来越高。如果bit位都为1的话，那就是所有的数据都存在 ，这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p>
<h3 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h3><ul>
<li>网页爬虫对URL的去重，避免爬取相同的URL地址</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li>
<li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回，避免缓存及DB挂掉。</li>
<li>黑名单过滤。</li>
</ul>
<h2 id="20、如何缓解缓存击穿的问题"><a href="#20、如何缓解缓存击穿的问题" class="headerlink" title="20、如何缓解缓存击穿的问题"></a>20、如何缓解缓存击穿的问题</h2><p><strong>产生原因一：缓存中没有，数据库中有。</strong>一般是多是出现在数据初始化，以及key过期的情况。他的问题在于重新写入缓存需要一定的时间，如果是在高并发的情况下，过多的请求会打到DB上，给DB造成很大的压力。</p>
<p>解决方案：</p>
<ul>
<li>设置热点的缓存永不过期。要注意永不过期数据一致性会有问题。所以要给value设置一个逻辑过期时间，然后后台再开一个线程，扫描这些key，定期刷新。</li>
</ul>
<p><strong>产生原因二：某些非常热点的数据key 过期，大量的请求打到后端 。</strong></p>
<p>解决：</p>
<ul>
<li><p>分布式锁的线程，从数据库拉数据（允许少数的线程取访问数据库并产生缓存），然后其他的线程等待。</p>
</li>
<li><p>后台任务针对过期的key 自动刷新。（设置随机的过期时间）</p>
</li>
</ul>
<h2 id="21、如何缓解缓存雪崩的问题。"><a href="#21、如何缓解缓存雪崩的问题。" class="headerlink" title="21、如何缓解缓存雪崩的问题。"></a>21、<strong>如何缓解缓存雪崩的问题。</strong></h2><p><strong>产生原因：大量的请求，或者大量的缓存key同时失效，大量的请求同时请求到数据库。</strong></p>
<p>解决：</p>
<ul>
<li><p>多级缓存，不同级别的key设置不同的超时时间。</p>
</li>
<li><p>随机超时，key的超时时间随机设置，防止同时超时</p>
</li>
<li><p>在架构层解决，提升系统可用性，监控，报警完善。</p>
</li>
</ul>
<h2 id="22、如何保证Redis与数据库一致性"><a href="#22、如何保证Redis与数据库一致性" class="headerlink" title="22、如何保证Redis与数据库一致性"></a>22、如何保证Redis与数据库一致性</h2><p>当我们对数据修改的时候，实现删除缓存还是先写入数据库。</p>
<p><strong>操作方式一：先删除缓存，在写数据</strong>。</p>
<p><strong>产生的问题：</strong>在高并发场景下，当第一个线程删除了缓存，还没有来得及写入数据库，第二个线程读取数据时会发现缓存为空，那么就会读取数据库的旧数据，读完之后又会将读取到的结果写入缓存，这样缓存中数据就是脏数据。</p>
<p><strong>解决：</strong> <strong>先操作缓存，但是不删除缓存，将缓存修改为一个特殊值，当客户端读取到这个特殊值时，休眠一会再去查Redis。</strong>（需要注意的问题：①对业务是由侵入的。②：休眠时间对性能有影响）</p>
<p><strong>操作方式二：</strong> <strong>延时双删：先删除缓存，然后再写数据库，休眠一小会在删除缓存。</strong></p>
<p><strong>产生的问题：</strong> 如果过写操作很频繁，同样会有脏数据的的问题。</p>
<p>解决：这种方式主要针对写操作不频繁的场景。</p>
<p><strong>操作方式三： ** **先写数据库，再删除缓存</strong></p>
<p><strong>产生的问题：</strong> 如果数据写完了以后缓存修改失败。数据就会不一致。</p>
<p><strong>解决：</strong></p>
<ul>
<li>给缓存设置过期时间。（在缓存时间内，数据不一致）</li>
<li>引入MQ 保证原子操作。（在MQ重试时间内数据不一致）</li>
</ul>
<h2 id="23、Redis-如何设置key的过期时间。它的键删除策略实现原理是什么"><a href="#23、Redis-如何设置key的过期时间。它的键删除策略实现原理是什么" class="headerlink" title="23、Redis 如何设置key的过期时间。它的键删除策略实现原理是什么"></a>23、Redis 如何设置key的过期时间。它的键删除策略实现原理是什么</h2><p>设置过期时间 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expair key time </span><br><span class="line"></span><br><span class="line">setnx key value time</span><br></pre></td></tr></table></figure>


<p>Redis 过期key删除机制有两种，一种是被动方式，一种是主动方式。</p>
<p>懒汉式式删除（被动）<br>含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步(如果此时还不删除的话，我们就会获取到了已经过期的key了)</p>
<p>定期删除 （主动）<br>含义：每隔一段时间执行一次删除过期key操作</p>
<p>优点：通过平衡控制<strong>执行效率</strong>和<strong>执行时长</strong>，来减少删除操作对CPU时间的占用。</p>
<p>遍历每个database(默认16个)，检查当前库中指定个数的key(默认是20个)，随机抽查这些key，如果有过期的就删除。并且程序中有一个全局变量，用来记录扫描到了哪一个数据库（database）。</p>
<p>Redis 同时使用以上两种删除策略。</p>
<h2 id="24、Redis的RDB和AOF机制"><a href="#24、Redis的RDB和AOF机制" class="headerlink" title="24、Redis的RDB和AOF机制"></a>24、Redis的RDB和AOF机制</h2><p>RDB（redis database）：在指定<strong>时间间隔内</strong>将内存中的<strong>数据集快照</strong>写入磁盘，也就是快照，它恢复是将快照文件直接读到内存里面。（在Redis 的配置文件内设置时间间隔）<strong>RDB 默认开启。</strong></p>
<p>备份是如何执行的：<br>Redis 会单独的创建一个fork子进程来持久化，会先将数据写入一个临时文件中，等持久化过程都结束了，在用这个临时文件替换上次持久化的文件，整个过程主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据的恢复，且对于数据的完整性要求不那么敏感，那么RDB的方式要比AOF的方式更加的额高效，RDB的缺点就是<strong>最后一次持久化的数据可能会丢失。</strong></p>
<p>fork的作用就是复制一个与当前进程一样的进程，新的进程的所有的数据（变量，程序计数器等）都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件解释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查数据完整性、默认值 yes 在存储跨照后让Redis 使用CRC64算法来对数据进行校验。但是这样做会损失大约10%的性能。推荐开启。</span></span><br><span class="line">rdbchecksum  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis 无法写入磁盘的时候，直接关掉Redis的写操作，推荐yes</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 压缩文件</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将数据写入磁盘的时间间隔， 默认 六十分钟1次、五分钟一百次、一分钟一万次</span></span><br><span class="line">save 300 100</span><br></pre></td></tr></table></figure>



<p>RDB的优势：</p>
<ul>
<li>适合大规模数据的恢复。</li>
<li>对数据完整性和一致性要求不高时使用。</li>
<li>节省磁盘空间。</li>
<li>回恢复度快。</li>
</ul>
<p>RDB的劣势：</p>
<ul>
<li>在写入临时快照的时候，数据被克隆了一份，大致两倍的膨胀性需要考虑。</li>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据量庞大还是比较消耗性能。</li>
<li>在备份周期在一定时间间隔内做一次备份，所以如果Redis以外关掉，就会丢失最后一次快照的修改。</li>
</ul>
<p>RDB的备份恢复：<br>默认Redis启动会自动将Redis的快照文件（dump.rdb）读取到内存中。手动恢复的话只需要将快照文件复制到Redis启动目录下。</p>
<p>AOF（Append Only File）：以日志的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的所有<strong>写/修改/删除指令记录下来（读操作不记录）</strong>，只许追加文件但是不可以改文件，Redis启动之初，会自动读取范围见重新构建数据，换言之Redis重启的话就会根据日志文件的内容将写指令重头到尾在执行一遍，以完成数据的恢复工作。<strong>AOF默认不开启。</strong></p>
<p>开启AOF：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认为no 不开启， 将其改为yes 开启。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果RDB和AOF同时开启，Redis 默认会读取AOF的配置文件来恢复数据。</strong> </p>
<p>AOF 异常修复：<br>如果遇到AOF文件损坏，通过 redis-check-aof   –fix  appendonly.aof 进行恢复。</p>
<p>AOF的同步频率设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置AOF的同步频率 。</span></span><br><span class="line">	always：始终同步。</span><br><span class="line">	everysec ：每秒同步，每秒记入日志一次，如果宕机当前秒的数据可能会丢失。</span><br><span class="line">	no：redis 不主动同步，把同步的时机交给操作系统。</span><br><span class="line">appendfsync always   </span><br></pre></td></tr></table></figure>

<p>Rewrite 压缩<br>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过设置的阈值时，Redis回启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p>重写的原理：<br>AOF文件持续增长而过大时， 会fork 出一条新的进程将文件重写（也是先写临时文件最后在rename）Redis4.0后的版本重写，实际上就是把RDB的快照，以二进制的形式附在新的aof的头部，作为已有的历史数据，替换掉原来的流水操作。</p>
<p>AOF持久化的流程：</p>
<ul>
<li>客户端的请求命令会被append追加到AOF的缓冲区内。</li>
<li>AOF缓冲区根据AOF持久化策略（always/everysec/no）将操作sync同步到磁盘中的.aof文件中去。</li>
<li>AOF文件大小超过重写策略或者手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。</li>
</ul>
<h3 id="AOF与RDB对比："><a href="#AOF与RDB对比：" class="headerlink" title="AOF与RDB对比："></a>AOF与RDB对比：</h3><ul>
<li>AOF文件比RDB大，且更安全，但恢复速度慢。</li>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>RDB性能比AOF好。</li>
<li>如果两个都加载了Redis默认优先加载AOF。</li>
</ul>
<h2 id="25、Redis-主从复制核心原理"><a href="#25、Redis-主从复制核心原理" class="headerlink" title="25、Redis 主从复制核心原理"></a>25、Redis 主从复制核心原理</h2><p>主从复制配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">核心原理：通过执行slaveof 命令，让一个服务器复制另一个服务器的数据，主数据库负责写操作，从数据库负责读操作，当写操作导致数据变化时，会自动将数据同步给从数据库。</span><br><span class="line"></span><br><span class="line">全量复制：</span><br><span class="line"></span><br><span class="line">- 主节点通过bgsave命令fork子进程，进行RDB持久化（该过程是非常消耗CPU、内存的、硬盘IOd的）。</span><br><span class="line">- 主节点通过网络将RDB文件发送给从节点，对从节点的带宽会有很大的消耗。</span><br><span class="line">- 从节点清空老数据，载入新的RDB文件是阻塞的，无法响应客户端的命令，如果从节点执行bgrewriteof，也会带来额外的消耗。</span><br><span class="line"></span><br><span class="line">增量复制：</span><br><span class="line"></span><br><span class="line">- 复制偏移量：执行复制的双方主从节点分别会维护一个复制偏移量offset。</span><br><span class="line">- 复制及压缓冲区：主节点内部维护一个固定长度的、先进先出的队列作为复制缓冲区，如果缓冲区超过最大长度，那么只能进行全量复制。</span><br><span class="line">- 每个Redis启动都会产生一个ID， 主节点还会将自己的ID发送给从节点，如果主节点挂掉重新选举，主节点ID不一致那么只能全量复制。如果一致那就继续使用增量复制。</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;origin.chaizz.com&#x2F;2e7fbffc46d411ec9d7c5254006b8f1d.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 26、 索引回表 索引覆盖  索引下推</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">针对以上索引问题，首先要知道什么是主键索引、非主键索引、聚簇索引、非聚簇索引。</span><br><span class="line"></span><br><span class="line">主键索引：即MySQL的索引，如果没有主键那么MySQl会自动在表中挑选一个唯一且非空的字段来当做主键索引，如果没有的话MySQL内部自己会创建一个ROW_ID来当做主键，也会建立主键索引。主键索引的叶子结点存储的是整行的数据。</span><br><span class="line"></span><br><span class="line">非主键索引：即非主键以外的列建立的索引。非主键索引存储的是主键索引的值。</span><br><span class="line"></span><br><span class="line">### 什么是索引回表？</span><br><span class="line"></span><br><span class="line">索引回表指的就是在查询某一列数据是判断条件为非主键索引，name查到这条复合条件的所有记录就需要在根据非主键索引获得的主键索引的值，在取主键索引的B+树中在此查询一次才能获取到全部的数据。例如：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line"># ID 是主键索引 ，只需要一次查询就可以获取符合条件的全部记录。</span><br><span class="line">select * from ex_table where ID&#x3D;1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># n 是非主键索引，查询到的结果是符合条件的主键索引的ID，所以还需要早根据主键的ID,再在主键索引的B+树上查询一次</span><br><span class="line">select * from ex_table where n &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>以上情况就是索引回表。</p>
<h3 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h3><p>如果执行的语句是 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select idfrom T where n between 1 and 10;</span><br></pre></td></tr></table></figure>
<p>现在的SQL只需要得到ID 的值，而 ID 的值已经在 n 索引的B+树上了，因此可以直接获得查询结果，不需要回表。也就是说，在这个查询里面，索引 n已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<h3 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h3><p>索引下推（index condition pushdown ）简称ICP，在MySQL5.6的版本上推出，用于优化查询，默认是开启的，可以通过以下的命令关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch &#x3D; &#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>
<p>当使用索引下推时如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>索引下推的好处：</p>
<p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</strong></p>
<p>假如有以下MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 索引值为 name age 为组合索引。</span><br><span class="line"></span><br><span class="line">select * from user where name like &#39;张%&#39; and age &#x3D; 20;</span><br></pre></td></tr></table></figure>


<p>在关闭索引下推的时候，InnoDB引擎会根据只name找到复合条件的索引字段，如下图中的左边绿色，然后就将数据返回给MySQL服务器，由MySQL服务器去判断其他的符合条件的数据。MySQL服务器会拿着查到的ID：1、2  在进行回表查询。</p>
<p><img src="https://origin.chaizz.com/161026e0486011ec9d7c5254006b8f1d.png"></p>
<p>在使用索引下推的时候，InnoDB会直接找出符合索引条件的字段的ID，将符合条件的结果发送给MySQL服务器，这个过程只需要回表一次。</p>
<h1 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p><strong>CPU密集型计算（CPU-bound）：</strong>Io可以再很短的时间结束 ，而需要CPU进行大量的计算。</p>
<p>比如： 压缩解压缩， 加密解密，正则的表达式搜索</p>
<p><strong>IO密集型计算(I/O-bound)：</strong>指系统大部分时间是在等IO写入读取操作，CPU占用比较低。</p>
<p>比如：文件处理，网络爬虫操作，读写数据</p>
<p><strong>进程</strong>：是对程序运行的封装，是操作系统调度资源的基本单位。进程切换消耗的资源比较大。效率比较低。</p>
<p><strong>线程</strong>：是进程的基本单位，一个进程至少一个线程。可以实现进程的并发（并发是假的并行，相当于来回切换）。线程切换需要的资源一般，效率也一般。（在不考虑GIL的情况下）。</p>
<p>一个进程包括多个线程，线程依赖进程存在，共享进程的内存。</p>
<p>共享数据会导致线程安全。可以使用线程锁。或者在程序设计的时候就避免这种情况出现。</p>
<p><strong>为什么进程切换比线程切换消耗大：</strong></p>
<p>进程切换需要两步：①：切换页目录，使用新的地址空间。②：切换内核和硬件上下文。</p>
<p>对于Linux来说线程和进程最大的区别就是在于虚拟地址空间，每个进程都有自己的虚拟地址空间，而线程是共享进程的地址空间的，因此同一个进程中线程的切换不涉及到虚拟地址空间的转换。把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB(Translation Lookaside Buffer)来缓存页地址，用来加速页表查找。当进程切换后页表也要进行切换，页表切换后TLB就失效了，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快。</p>
<p><strong>保证线程安全的方式：</strong></p>
<ul>
<li><p>互斥锁：通过互斥机制防止多个线程同时访问公共资源。</p>
</li>
<li><p>信号量：控制同一时刻多个线程访问资源的线程数。</p>
</li>
<li><p>事件（信号）：通过通知的方式实现。</p>
</li>
</ul>
<p><strong>进程之间通信的方式：</strong></p>
<ul>
<li><p>匿名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li><p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
</li>
<li><p>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>消息队列（Queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<ul>
<li>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。</li>
<li>RabbitMQ : 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。</li>
</ul>
</li>
<li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。</p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p>套接字（socket） 用的比较多。套接字（socket）为通信的端点，每个套接字由一个 IP 地址和一个端口号组成。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。</p>
<ul>
<li>服务进程：socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;read()-&gt;write()-&gt;…-&gt;close()</li>
<li>客户进程：socket()-&gt;connect()-&gt;write()-&gt;read()-&gt;…-&gt;close();</li>
</ul>
</li>
</ul>
<p><strong>线程之间的通信方式：</strong></p>
<p>共享变量、共享内存、共享数据库、消息队列</p>
<p>Python中如何使用对进程（在CPU密集型中使用）：</p>
<p>Multiprocessing ：多进程模块  </p>
<h2 id="2、五种IO模型"><a href="#2、五种IO模型" class="headerlink" title="2、五种IO模型"></a>2、五种IO模型</h2><p>阻塞式IO （Blocking IO）</p>
<p>非阻塞式IO （NonBlocking IO）</p>
<p>IO 多路复用 （IO Multiplexing）</p>
<p>信号驱动IO（Signal Driven IO）不常用</p>
<p>异步IO （Asynchronous IO）不常用</p>
<h2 id="3、操作系统实现多路复用的方法"><a href="#3、操作系统实现多路复用的方法" class="headerlink" title="3、操作系统实现多路复用的方法"></a>3、操作系统实现多路复用的方法</h2><p>IO多路复用的本质就是select/poll/epoll 去监听多个socket对象，如果其中的socket对象有变化，只要有变化，用户进程就知道了。</p>
<p>Select 是不断的轮询监听的socket， socket的个数有限制，一般为1024个。</p>
<p>Poll 还是采用轮询的方式监听，之不过没有个数的限制。</p>
<p>Epoll 并不是采用轮训的方式去监听，而是当socket有变化的时候通过回调的方式主动地告知用户进程。</p>
<p>表面上看epoll的性能最好，但是在连接数少，连接数十分活跃的情况下，selecthe poll性能会比epoll好。因为epoll的通知机制需要很多回调函数。</p>
<h2 id="4、Python-实现IO多路复用的方法："><a href="#4、Python-实现IO多路复用的方法：" class="headerlink" title="4、Python 实现IO多路复用的方法："></a>4、Python 实现IO多路复用的方法：</h2><p>也是基于操作系统的select ,poll epoll方法。Pyhon3 中实现了selectors 模块。</p>
<p>事件类型：EVENT_READ 、EVENT_WRITE </p>
<p>DefaultSelector：自动根据系统来选择IO模型。其中的一些方法</p>
<p>a)   register（fileobj events data = none）</p>
<p>b)  unregister（fileobj）</p>
<p>c)   Modifiy(fileobj events data = none)</p>
<p>d)  Select(timeout=none, returns[keys, events])</p>
<p>e)   Close()</p>
<h2 id="5、Python的并发网络库："><a href="#5、Python的并发网络库：" class="headerlink" title="5、Python的并发网络库："></a>5、Python的并发网络库：</h2><p>Gevent 、asyncio、tornado</p>
<p>Tornado：是一个并发网络编程库，也是一个Web框架。</p>
<p>Gevent：基于几个绿色线程实现并发。底层是基于c语言实现的。基于 monkey patch gevent修改了内置的socket 改为非阻塞。 经常配合gunnicorn 部署作为wsgi server 。 </p>
<p>Asyncio ：基于原生的协程实现的。</p>
<h2 id="6、Linux中有哪些调度算法？"><a href="#6、Linux中有哪些调度算法？" class="headerlink" title="6、Linux中有哪些调度算法？"></a>6、Linux中有哪些调度算法？</h2><p>先来先服务调度算法和短作业优先调度算法</p>
<h2 id="7、操作系统如何管理内存的？"><a href="#7、操作系统如何管理内存的？" class="headerlink" title="7、操作系统如何管理内存的？"></a>7、操作系统如何管理内存的？</h2><p>内存又分为虚拟内存和物理内存。</p>
<p>虚拟内存的基本思想就是每个进程都有独立的逻辑地址空间，内存被分为大小相等的块，称为页，每个页都是一段连续的地址，对于进程来看貌似有很多的内存空间，但切实只有一部分是物理内存地址。</p>
<p>缺页中断，</p>
<h2 id="8、LRU-最近最少使用-Least-Recently-Used-算法"><a href="#8、LRU-最近最少使用-Least-Recently-Used-算法" class="headerlink" title="8、LRU:最近最少使用(Least Recently Used)算法"></a>8、LRU:最近最少使用(Least Recently Used)算法</h2><p>基于最近使用的也慢数据在未来一段时间仍有很大可能被使用，已经很久没有使用的数据在未来的很长一段时间内也仍然不会被使用这种思想的一种淘汰机制，它的主要衡量指标是时间，第二衡量指标是次数。利用双向链表来实现。</p>
<h2 id="9、LFU（Least-Frequently-Used）算法"><a href="#9、LFU（Least-Frequently-Used）算法" class="headerlink" title="9、LFU（Least Frequently Used）算法"></a>9、LFU（Least Frequently Used）算法</h2><p>即最少访问算法，根据访问缓存的历史频率来淘汰数据，核心思想是“如果数据在过去一段时间被访问的次数很少，那么将来被访问的概率也会很低”。</p>
<p>数据结构： 一般会维护两个数据结构：</p>
<p>哈希：用来提供对外部的访问，查询效率更高；</p>
<p>双向链表或队列：维护了对元素访问次数的排序</p>
<p><strong>优点：</strong></p>
<p>一般情况下，LFU效率要优于LRU，能够避免周期性或者偶发性的操作导致缓存命中率下降的问题</p>
<p><strong>缺点：</strong></p>
<p>复杂度较高：需要额外维护一个队列或双向链表，复杂度较高</p>
<p>对新缓存不友好：新加入的缓存容易被清理掉，即使可能会被经常访问</p>
<p>缓存污染：一旦缓存的访问模式发生变化，访问记录的历史存量，会导致缓存污染；</p>
<p>内存开销：需要对每一项缓存数据维护一个访问次数，内存成本较大；</p>
<p>处理器开销：需要对访问次数排序，会增加一定的处理器开销</p>
<h1 id="四、网络"><a href="#四、网络" class="headerlink" title="四、网络"></a>四、网络</h1><h2 id="1、Python-底层的网络编程模块有哪些？"><a href="#1、Python-底层的网络编程模块有哪些？" class="headerlink" title="1、Python 底层的网络编程模块有哪些？"></a>1、Python 底层的网络编程模块有哪些？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Socket 、urllib、requests、grab、pycurl</span><br></pre></td></tr></table></figure>


<h2 id="2、简述OSI七层含义"><a href="#2、简述OSI七层含义" class="headerlink" title="2、简述OSI七层含义"></a>2、简述OSI七层含义</h2><p>-   应用层：HTTP、FTP、NFS</p>
<p>-   表示层：Telnet、SNMP</p>
<p>-   会话层：SMTP、DNS</p>
<p>-   传输层：TCP、UDP</p>
<p>-   网络层：IP、TCP、ARP</p>
<p>-   数据链路层：Etherent、PPP、PDN、SLIP、FDDI</p>
<p>-   物理层：TEEE 802.1A、TEEE 802.11</p>
<p>应用层、表示层、会话层 也可以称之为应用层。</p>
<h2 id="3、输入一个URL中间的过程："><a href="#3、输入一个URL中间的过程：" class="headerlink" title="3、输入一个URL中间的过程："></a>3、输入一个URL中间的过程：</h2><ul>
<li>首先首先浏览器会解析域名找到对应的IP地址。<ul>
<li>浏览器会首先搜索浏览器自身的DNS缓存，(缓存时间较短，大概只有一分钟，且只能容纳1000条缓存)，看自身缓存是否有该域名对应的条目，而且没有过期，如果有且没有过期解析到此此结束。</li>
<li>如果浏览器自身的缓存李，没有找到对应的条目，那么浏览器就会搜索系统自身的DNS缓存，如果找到且没有过期，则停止搜索，解析结束。</li>
<li>如果在系统的DNS缓存也没有找到，那么尝试读取hosts文件，看看这里面是否有对应的IP地址，如果有则解析成功。</li>
<li>如果hosts文件也没有，浏览器就是发起一个DNS系统的调用，就会向本地配置的首选DNS服务器(一般是电信运营商提供的)，发起域名解析请求（通过UDP协议向DNS的53端口发期请求，这个请求是递归请求，也就是运行商必须提供给我们该域名的IP地址），运行商的DNS服务器首先查找自身的缓存，找到对应的条目且没有过期，则解析成功，如果没有，则由运营商的DNS代我们我们的浏览器发送迭代DNS解析,首先会找根域的DNS的I地址（这个DNS服务器都内置13台根域的DNS的IP地址），然后进一步请求，一般四部就可以找到域名对应的IP地址的。</li>
</ul>
</li>
<li>浏览器调用socket 函数，发起TCP 请求 （三次握手）与服务器建立连接。</li>
<li>建立连接之后发起应用层http的请求，如果有代理的话 到达nginx 然后再到uwsgi 最后再到web应用响应。</li>
<li>浏览器得到并解析解析html代码。</li>
<li>然后web应用在执行他的逻辑，然后返回response，通过tcp返回给用户，最后就会执行TCP的四次挥手。</li>
</ul>
<h2 id="4、TCP的三次握手四次分手："><a href="#4、TCP的三次握手四次分手：" class="headerlink" title="4、TCP的三次握手四次分手："></a>4、TCP的三次握手四次分手：</h2><p><strong>第一次握手：</strong></p>
<p>客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。</p>
<p><strong>第二次握手：</strong></p>
<p>服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD（同步已发送状态）状态。</p>
<p><strong>第三次握手：</strong></p>
<p>客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED（已建立连接）状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<p>三次握手：<br> “喂，你听得到吗？”<br> “我听得到呀，你听得到我吗？”<br> “我能听到你，今天 balabala……”</p>
<p><strong>TCP的四次挥手</strong>：</p>
<p> <strong>第一次分手：</strong></p>
<p>Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。</p>
<p><strong>第二次分手：</strong></p>
<p>Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。</p>
<p><strong>第三次分手：</strong></p>
<p>Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。</p>
<p><strong>第四次分手 ：</strong></p>
<p>Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</p>
<h2 id="5、为什么TCP需要四次分手呢？"><a href="#5、为什么TCP需要四次分手呢？" class="headerlink" title="5、为什么TCP需要四次分手呢？"></a>5、为什么TCP需要四次分手呢？</h2><p>因为建立连接时ACK和SYN可以放在一个报文里面来发送，而关闭连接时，被动的关闭方，可能还需要发送一些数据，再发送DIN报文确认同意可以关闭连接了，所以这里的ACK和Fin报文是分开发送的。</p>
<h2 id="6、TCP-UDP的区别："><a href="#6、TCP-UDP的区别：" class="headerlink" title="6、TCP/UDP的区别："></a>6、TCP/UDP的区别：</h2><p><strong>相同点：</strong></p>
<p>UDP协议和TCP协议都是传输层协议。</p>
<p><strong>不同点：</strong></p>
<p>-   TCP：面向有连接的（建立之前必选建立连接，结束之后关闭连接），可靠的、 基于字节流的。</p>
<p>-   UDP：无连接的（知道对端的IP和端口号就直接进行传输, 不需要建立连接。）不可靠（没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。）。面向报文的（应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。）。</p>
<p>TCP 只支持点对点的，UD支持一对一，一对多，多对多的交互通信。</p>
<h2 id="7、UDP如何尽量保持可靠"><a href="#7、UDP如何尽量保持可靠" class="headerlink" title="7、UDP如何尽量保持可靠"></a>7、UDP如何尽量保持可靠</h2><p>UDP他不属于连接性协议，因为具有资源消耗小，处理速度快的优点，随意即时通许，音视频数据在传输是使用UDP比较多，因为他们偶尔丢一两个包对数据也不会造成太大的影响，传输层无法保证数据的可靠传输，只能在应用层来实现，实现的方式可以参考TCP的可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>关键在于两点：</p>
<ul>
<li>提供超时重传，能避免数据丢失</li>
<li>提供确认序列号，可以对报文进行确认和排序。</li>
</ul>
<h2 id="8、TCP的keepalive和-http-的keep-alive的区别"><a href="#8、TCP的keepalive和-http-的keep-alive的区别" class="headerlink" title="8、TCP的keepalive和 http 的keep alive的区别"></a>8、TCP的keepalive和 http 的keep alive的区别</h2><p>http的keep-alive是为了让TCP活的更久一点，一边在同一个连接上传送多个http，提供socket效率，而TCP的keep-alicve是TCP的一种检测TCP连接的保鲜机制。检查TCP连接是否活跃。</p>
<h2 id="9、HTTP的1-0-、1-1、2-0-的主要区别"><a href="#9、HTTP的1-0-、1-1、2-0-的主要区别" class="headerlink" title="9、HTTP的1.0 、1.1、2.0 的主要区别"></a>9、HTTP的1.0 、1.1、2.0 的主要区别</h2><p><strong>HTTP1.0：</strong></p>
<ul>
<li>无状态，无连接的</li>
</ul>
<p><strong>HTTP1.1:</strong></p>
<ul>
<li>支持长连接，请求管道化，请求并行发送，响应仍然有序返回</li>
<li>增加缓存的处理，新的字段：cache-control</li>
<li>增加Host字段，适应虚机主机技术发展，即一台服务器支持多台主机。</li>
<li>支持断点传输</li>
</ul>
<p><strong>HTTP2.0</strong>:</p>
<ul>
<li>二进制分帧</li>
<li>多路复用（连接共享）</li>
<li>头部压缩（encoder）</li>
<li>服务器推送</li>
</ul>
<h2 id="10、HTTP请求的组成"><a href="#10、HTTP请求的组成" class="headerlink" title="10、HTTP请求的组成"></a>10、HTTP请求的组成</h2><p>状态行：请求码、请求方法（method）、路径、版本</p>
<p>请求头：HOST，数据类型（content_type），数据长度(content_length)，接收编码（accept-encoding）连接（keep-alive）、user-agent</p>
<p>请求体内容</p>
<h2 id="11、HTTP响应的组成："><a href="#11、HTTP响应的组成：" class="headerlink" title="11、HTTP响应的组成："></a>11、HTTP响应的组成：</h2><p>状态行：响应码、请求方法（method）、路径、版本</p>
<p>响应头：缓存（cache-contral）、数据类型（content_type），数据长度(content_length)、连接（cinnection）、</p>
<p>响应正文：内容</p>
<h2 id="12、HTTP响应的状态码："><a href="#12、HTTP响应的状态码：" class="headerlink" title="12、HTTP响应的状态码："></a>12、HTTP响应的状态码：</h2><p>1xx：服务器已经收到 需要请求者继续操作</p>
<p>2xx：成功，操作成功并接受处理</p>
<p>3xx：重定向 （301：用久重定向，302：临时重定向，304：not modified）</p>
<p>4xx：客户端错误（401：未认证，403：forbidben 没权限，404：not found 405：请求不被允许）</p>
<p>5xx：服务端错误；（500：服务错误，502：对用户访问请求超时）</p>
<h2 id="13、HTTP请求方法"><a href="#13、HTTP请求方法" class="headerlink" title="13、HTTP请求方法"></a>13、HTTP请求方法</h2><p>GET/POST/PUT/DELETE</p>
<h2 id="14、GET-POST的区别："><a href="#14、GET-POST的区别：" class="headerlink" title="14、GET/POST的区别："></a>14、GET/POST的区别：</h2><p>GET的请求参数是放在URL上面的，是明文的（长度是有限的）。POST是放在请求体里面的相对更安全。</p>
<h2 id="15、HTTP长连接："><a href="#15、HTTP长连接：" class="headerlink" title="15、HTTP长连接："></a>15、HTTP长连接：</h2><p>短连接：建立连接，数据传输，关闭连接，（连接建立和关闭的开销大）。</p>
<p>长连接：Connection:keep-alive, 来保持TCP不断开。</p>
<h2 id="16、Cookie-和-Session-的区别："><a href="#16、Cookie-和-Session-的区别：" class="headerlink" title="16、Cookie 和 Session 的区别："></a>16、Cookie 和 Session 的区别：</h2><p>Session 是服务器生成之后返回给客户端，通过URL或者是cookie</p>
<p>Cookie 是实现session的一种机制，通过http cookie 字段实现。</p>
<p>Session 是通过服务器保存session识别用户，cookie保存在客户端。</p>
<h2 id="17、-网络TCP-socket-编程实现原理"><a href="#17、-网络TCP-socket-编程实现原理" class="headerlink" title="17、 网络TCP socket 编程实现原理"></a>17、 网络TCP socket 编程实现原理</h2><p>服务进程：socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;read()-&gt;write()-&gt;…-&gt;close()</p>
<p>客户进程：socket()-&gt;connect()-&gt;write()-&gt;read()-&gt;…-&gt;close();</p>
<p><strong>创建客户端：</strong></p>
<ol>
<li><p>首先创建sokect对象</p>
</li>
<li><p>创建连接 connection </p>
</li>
</ol>
<p><strong>创建服务端</strong></p>
<ol>
<li><p>创建socket 对象。</p>
</li>
<li><p>绑定本地地址</p>
</li>
<li><p>Socket对象监听</p>
</li>
</ol>
<p><strong>使用socket 发送http请求：</strong></p>
<ol>
<li><p>创建socket 对象。</p>
</li>
<li><p>连接http 地址。</p>
</li>
<li><p>发送http请求。</p>
</li>
<li><p>接收返回对像。</p>
</li>
<li><p>关闭请求连接。</p>
</li>
</ol>
<h1 id="五、Python-WSGI-与WEB框架的常考问题"><a href="#五、Python-WSGI-与WEB框架的常考问题" class="headerlink" title="五、Python WSGI 与WEB框架的常考问题"></a>五、Python WSGI 与WEB框架的常考问题</h1><h2 id="1-什么是WSGI：和web框架交互的一个规范。"><a href="#1-什么是WSGI：和web框架交互的一个规范。" class="headerlink" title="1.   什么是WSGI：和web框架交互的一个规范。"></a>1.   什么是WSGI：和web框架交互的一个规范。</h2><p>主要是解决python web server 乱象 mod_python 、CGI、FastCGI 等。描述了 web server (Gunicorn/Uwsgi) 如何与web框架（django/flask）交互，web 框架如何处理请求。</p>
<h2 id="2、django请求的生命周期？"><a href="#2、django请求的生命周期？" class="headerlink" title="2、django请求的生命周期？"></a>2、django请求的生命周期？</h2><p>​    </p>
<p>用户在浏览器输入URL的时候，浏览器会生成请求头，和请求体发送给服务端。请求头he请求体中会包括浏览器的动作（这个动作通常为GET或者POST 体现在URL中）。</p>
<p>URL经过Django的服务器uwsgi,（如果有代理服务器的话，先经过代理服务器在由代理服务器设置的代理，转到uwsgi）然后请求到达django项目的中间件。通过中间件以后在到达路列表，进行匹配，匹配到路由规则，在访问视图层。</p>
<p>视图函数根据客户端的请求查询相应的数据，返回给django，然后django在把获取的序列化的数据返回。</p>
<h2 id="3、列举django中间件的五个方法"><a href="#3、列举django中间件的五个方法" class="headerlink" title="3、列举django中间件的五个方法"></a>3、列举django中间件的五个方法</h2><p>自定义中间件需要继承父类 （MiddlewareMixin）。</p>
<p><strong>process_request(request) ：</strong>此方法是在视图函数执行之前执行的。该方法包含一个参数 request。这个request和视图函数中的request是一样的。返回值可以是NONE 也可以是HttpeRsponse ，如果是none 那就走下一个中间件，如果是HttpeRsponse，django 将不会再走后面的视图函数，那就直接已改中间件为起点，倒序执行中间件，且执行的是视图函数执行之后的方法。该方法的应用场景：可以做认证、权限先关的事情。</p>
<p><strong>process_resopnse（request，response）：</strong>此方法是在视图函数执行之后执行的。该方法 有两个参数，request是请求对象，response是视图函数返回的httpresponse。该方法必须要有返回值，而且必须是response。</p>
<p><strong>process_exception(request, exception) ：</strong>此方法有两个函数，request 是HttpRequest 对象，exception 是视图函数异常产生的 Exception 对象。该方法只有在视图函数中出现异常了才执行，按照 settings 的注册倒序执行。在视图函数之后，在 process_response 方法之前执行。方法的返回值可以是一个 None 也可以是一个 HttpResponse 对象。如果是NONE 则会直接返回一个500的状态码，不会往下执行视图函数，如果是返回HttpResponse ，页面不会报错没返回状态码200，视图函数不执行，该中间件后续的 process_exception 方法也不执行，直接从最后一个中间件的 process_response 方法倒序开始执行。</p>
<p> <strong>process_view(request,view_func, view_args, view_kwargs) ：</strong>此方法是在视图函数之前，process_request 方法之后执行的。该方法有四个参数request 是 HttpRequest 对象；view_func 是 Django 即将使用的视图函数；view_args 是将传递给视图的位置参数的列表；view_kwargs 是将传递给视图的关键字参数的字典。返回值可以是 None、view_func(request) 或 HttpResponse 对象</p>
<p><strong>process_template_responseprocess（）</strong> ：这个渲染模板的时候执行的。</p>
<h2 id="4、简述什么叫FBV和CBV"><a href="#4、简述什么叫FBV和CBV" class="headerlink" title="4、简述什么叫FBV和CBV"></a>4、简述什么叫FBV和CBV</h2><p>FBV 叫做基于函数的视图，CBV是基于类的视图，使用CBV的优点，提高代码的复用性，使用面向对象的技术，可以用不同的函数（get()/post()）针对不同的请求处理，而不是通过if 判断请求方式。</p>
<h2 id="5、Django的内置组件"><a href="#5、Django的内置组件" class="headerlink" title="5、Django的内置组件"></a>5、Django的内置组件</h2><p>admin 是对modle 中的数据记性可视化的增删改查的组件。</p>
<p>model 数据库数据结构的映射对象。</p>
<p>form 生成html的代码，对数据进行检验，校验数据并返回。</p>
<h2 id="6、django的request对象是在什么时候创建的？"><a href="#6、django的request对象是在什么时候创建的？" class="headerlink" title="6、django的request对象是在什么时候创建的？"></a>6、django的request对象是在什么时候创建的？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIHandler</span>(<span class="params">base.BaseHandler</span>):</span></span><br><span class="line"></span><br><span class="line">    request = self.request_class(environ)</span><br></pre></td></tr></table></figure>
<p>请求走到WSGIHandler类的时候，执行cell方法，将environ封装成了request</p>
<h2 id="7、如何给CBV的程序添加装饰器。"><a href="#7、如何给CBV的程序添加装饰器。" class="headerlink" title="7、如何给CBV的程序添加装饰器。"></a>7、如何给CBV的程序添加装饰器。</h2><p>可以使用method_decorator 在类的get/post方法上添加 例如：@ method_decorator（func）</p>
<p>给类添加在类名上 例如：@ method_decorator（func，name=post）</p>
<h2 id="8、列举django-ORM中方法"><a href="#8、列举django-ORM中方法" class="headerlink" title="8、列举django ORM中方法"></a>8、列举django ORM中方法</h2><p>all():         查询所有结果 </p>
<p>filter(**kwargs):    它包含了与所给筛选条件相匹配的对象。获取不到返回None</p>
<p>get(**kwargs):    返回与所给筛选条件相匹配的对象，返回结果有且只有一个。 如果符合筛选条件的对象超过一个或者没有都会抛出错误。</p>
<p>exclude(**kwargs):   它包含了与所给筛选条件不匹配的对象</p>
<p>order_by(*field):    对查询结果排序</p>
<p>reverse():       对查询结果反向排序 </p>
<p>count():        返回数据库中匹配查询(QuerySet)的对象数量。 </p>
<p>first():        返回第一条记录 </p>
<p>last():        返回最后一条记录 </p>
<p>exists():       如果QuerySet包含数据，就返回True，否则返回False</p>
<p>values(*field):    返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系 model的实例化对象，而是一个可迭代的字典序列。</p>
<p>values_list(*field):  它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列</p>
<p>distinct():      从返回结果中剔除重复纪录</p>
<h2 id="9、select-related和prefetch-related的区别？"><a href="#9、select-related和prefetch-related的区别？" class="headerlink" title="9、select_related和prefetch_related的区别？"></a>9、select_related和prefetch_related的区别？</h2><p>前提：有外键存在时，可以很好的减少数据库请求的次数,提高性能</p>
<p>select_related通过多表join关联查询,一次性获得所有数据,只执行一次SQL查询。（针对于 一对一和一对多）</p>
<p>prefetch_related分别查询每个表,然后根据它们之间的关系进行处理,执行两次查询。（针对多对多）</p>
<p>select_related方法执行一次数据库查询，prefetch_related方法执行两次数据库查询</p>
<h2 id="10、列举django-ORM-中三张能写sql语句的方法。"><a href="#10、列举django-ORM-中三张能写sql语句的方法。" class="headerlink" title="10、列举django ORM 中三张能写sql语句的方法。"></a>10、列举django ORM 中三张能写sql语句的方法。</h2><p>使用execute(sql语句) 类似pymysql的形式。</p>
<p>使用extra() 方法 quersyt.extra(select={“key” ：“原生SQL语句”})</p>
<p>使用raw()方法  对象.objects.raw(sql语句)</p>
<h2 id="11、values和values-list的区别？"><a href="#11、values和values-list的区别？" class="headerlink" title="11、values和values_list的区别？"></a>11、values和values_list的区别？</h2><p>values : queryset类型的列表中是字典</p>
<p>values_list : queryset类型的列表中是元组</p>
<h2 id="12、Django的queryset有哪些特性？"><a href="#12、Django的queryset有哪些特性？" class="headerlink" title="12、Django的queryset有哪些特性？"></a>12、Django的queryset有哪些特性？</h2><p>主要有两个特性，一个是惰性的，另一个是的自带缓存。</p>
<p>惰性：在使用查询语句的时候，Django不会去主动的查询数据库，只有你使用了查询的对象，Django才会去访问数据库。</p>
<p>缓存：第一次访问数据库以后Django会把得到的数据保存在queryset内置的cache中。Django就不需要在进行重复的查询了。</p>
<h2 id="13、Django的模型继承有哪几种方式-它们有什么区别以及何时使用它们"><a href="#13、Django的模型继承有哪几种方式-它们有什么区别以及何时使用它们" class="headerlink" title="13、Django的模型继承有哪几种方式? 它们有什么区别以及何时使用它们?"></a>13、Django的模型继承有哪几种方式? 它们有什么区别以及何时使用它们?</h2><p>Django的模型继承有如下三种：</p>
<p>抽象模型（avstract model）：Django不会为抽象模型在数据库中生成自己的表，父类Meta 中的abstract=True 也不会传递给子类，如果被你发现多模型有很多共同字段的时，需要用抽象模型继承。</p>
<p>多表模型继承（multi-table-inheritance）：多表模型继承与抽象模型继承最大的区别在于Django也会为父类模型建立自己的数据库表。同时隐士的在父类和子类之间建立一个一对一关系。</p>
<p>代理模型（proxy model）：如果我们只改变某个模型的行为方法，而不是添加额外的字段或者创建额外的数据表，我们就可以使用代理模型，设置一个代理模型需要子类模型meta选项中设置proxy=True，django不会为代理模型生成新的数据表。</p>
<h2 id="14、简单说说看-Django的CSRF防御机制。"><a href="#14、简单说说看-Django的CSRF防御机制。" class="headerlink" title="14、简单说说看 Django的CSRF防御机制。"></a>14、简单说说看 Django的CSRF防御机制。</h2><p>Django的CSRF是通过Django的中间件 （django.middleware.csrf.CsrfViewMiddleware）来实现的。主要流程如下：</p>
<p>Django相应来自客户端的请求的时候，会在服务器生成一个csrftoken（一串64位的随机码），把这个token放在请求头的cookie里发给客户端返回给用户。</p>
<p>所有通过POSt提交的额表单，都要携带一个隐藏字段，通过模板文件中的<code>&#123;%csrf_token%&#125;</code>标签生成。</p>
<p>当用户通过提教交POST的时候，django会从请求头cookie中获取这个token的值，与生成的只比较是否一致。</p>
<h2 id="16、如何从数据表中获取一个随机的对象。"><a href="#16、如何从数据表中获取一个随机的对象。" class="headerlink" title="16、如何从数据表中获取一个随机的对象。"></a>16、如何从数据表中获取一个随机的对象。</h2><p>可以使用order_by（”?”）.first()</p>
<h2 id="17、说说aggregate和annotate方法的作用。"><a href="#17、说说aggregate和annotate方法的作用。" class="headerlink" title="17、说说aggregate和annotate方法的作用。"></a>17、说说aggregate和annotate方法的作用。</h2><p>Aggregate 是聚合的意思，是对一组值(比如queryset的某个字段)进行统计计算，并以字典(Dict)格式返回统计计算结果。支持 count（）max(),min()sun()avg()。</p>
<p>Annotate ：可以理解为分组，对数据集先进行分组然后再进行某些聚合操作或排序时，需要使用annotate方法来实现。与aggregate方法不同的是，annotate方法返回结果的不仅仅是含有统计结果的一个字典，而是包含有新增统计字段的查询集(queryset）</p>
<h2 id="18、常用的框架Django-Flask-Tornado-的对比。"><a href="#18、常用的框架Django-Flask-Tornado-的对比。" class="headerlink" title="18、常用的框架Django/Flask/Tornado 的对比。"></a>18、常用的框架Django/Flask/Tornado 的对比。</h2><p>Django ：大而全，内置ORM、Admin, 第三方的插件比较多。</p>
<p>Flask ：微框架、插件机制，比较灵活。</p>
<p>Tornado ：支持异步的微框架，和异步网络库。</p>
<h2 id="19、Django-常用的第三方插件："><a href="#19、Django-常用的第三方插件：" class="headerlink" title="19、Django 常用的第三方插件："></a>19、Django 常用的第三方插件：</h2><p>django-taggit 可以在文章中当作标签使用</p>
<p>django- Celery 异步分布式的队列。</p>
<p>djangorestframework REST API 的框架。可以做 序列化，分页。权限的管理，认证机制。</p>
<p>django-cors-headers ：管理跨域操作的插件。</p>
<p>django-haystack 全文检索引擎 </p>
<p>django -simple 后台UI界面 </p>
<p>django -captcha Django的验证码</p>
<p>django-debug-toolbar debug 调试工具</p>
<h2 id="20、Django中如何使用redis作为缓存"><a href="#20、Django中如何使用redis作为缓存" class="headerlink" title="20、Django中如何使用redis作为缓存"></a>20、Django中如何使用redis作为缓存</h2><p>安装django-redis ，在settings 设置缓存的服务期设置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django_redis.cache.RedisCache&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;redis://your_host_ip:6379&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;OPTIONS&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;CLIENT_CLASS&quot;</span>: <span class="string">&quot;django_redis.client.DefaultClient&quot;</span>,</span><br><span class="line">       <span class="string">&quot;PASSWORD&quot;</span>: <span class="string">&quot;yourpassword&quot;</span>,</span><br><span class="line">    		&#125;,</span><br><span class="line">  		&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>也可是设置超时时间 ：REDIS_TIMEOUT=7<em>24</em>60*60</p>
<h2 id="21、如何在模板中获取当前访问url地址"><a href="#21、如何在模板中获取当前访问url地址" class="headerlink" title="21、如何在模板中获取当前访问url地址"></a>21、如何在模板中获取当前访问url地址</h2><table>
<thead>
<tr>
<th>Method</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>request.path</td>
<td>/search/</td>
</tr>
<tr>
<td>request.get_full_path</td>
<td>search/?keyword=django</td>
</tr>
<tr>
<td>request.build_absolute_uri</td>
<td><a href="https://jackeygao.io/search/?keyword=django">https://jackeygao.io/search/?keyword=django</a></td>
</tr>
</tbody></table>
<h2 id="22、Django信号-Signals-的工作原理-主要应用场景及内置信号。"><a href="#22、Django信号-Signals-的工作原理-主要应用场景及内置信号。" class="headerlink" title="22、Django信号(Signals)的工作原理, 主要应用场景及内置信号。"></a>22、Django信号(Signals)的工作原理, 主要应用场景及内置信号。</h2><p>Django 提供一个了“信号分发器”机制，允许解耦的应用在框架的其它地方发生操作时会被通知到。通俗而讲Django信号的工作原理就是当某个事件发生的时候会发出一个信号(signals), 而监听这个信号的函数(receivers)就会立即执行。应用场景有很多比如：创建用户的时候在创建一个一对一关系的用户信息的模型对象。或者是用户下订单的时候邮件通知管理员的情况。</p>
<p>Django的内置信号 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django.db.models.signals.pre_save &amp; post_save在数据模型调用 save()方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.pre_init&amp; post_init在模型调用_init_方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.pre_delete &amp; post_delete在模型调用delete()方法或查询集调用delete() 方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.m2m_changed在模型多对多关系改变后发送。</span><br><span class="line"></span><br><span class="line">django.core.signals.request_started &amp; request_finished Django建立或关闭HTTP 请求时发送。</span><br></pre></td></tr></table></figure>


<h2 id="23、什么情况下需要自定义context-processors-上下文处理器"><a href="#23、什么情况下需要自定义context-processors-上下文处理器" class="headerlink" title="23、什么情况下需要自定义context_processors(上下文处理器)"></a>23、什么情况下需要自定义context_processors(上下文处理器)</h2><p>当你需要一个视图函数或者模板提供或设置全局变量的时候，需要用上下文管理器，我们在试图和模板中随意使用request这个变量，就是因为django.core.contenxt_process_request 把request变成了一个全局变量。上下文管理器（content_process）很多地方都有用，例如：一些博客的标签、归档，这些公共的信息，是每个文章都会用的东西，如果存在数据库中，就会每次使用都要从数据库查询回去数据，造成资源浪费，如果通过context_process 设置为全局变量，就不需要再每次都要查询数据库了。</p>
<h2 id="24、Django如何实现高并发？"><a href="#24、Django如何实现高并发？" class="headerlink" title="24、Django如何实现高并发？"></a>24、Django如何实现高并发？</h2><p>使用NGINX进行反向代理。</p>
<p>数据库的分库和读写分离(主从复制)。</p>
<p>使用redis做缓存。</p>
<p>耗时任务(收发邮件/写入文件)使用celery 异步处理。</p>
<p>使用Gzip压缩静态文件。</p>
<p>使用CDN加速静态文件。</p>
<h2 id="25、什么是MVC-："><a href="#25、什么是MVC-：" class="headerlink" title="25、什么是MVC ："></a>25、什么是MVC ：</h2><p>Modle：数据层，数据业务对象和数据库的交互(ORM)。</p>
<p>View：视图层，负责与用户交互和展示。 </p>
<p>Controller ：接收请求参数,调佣模型和视图完成请求。</p>
<h2 id="26、什么是ORM"><a href="#26、什么是ORM" class="headerlink" title="26、什么是ORM"></a>26、什么是ORM</h2><p>对象关系映射，用于实现业务对象与数据库表中字段映射。类似的有sqlalchemy 、Django 的 ORm 还有 Peewee</p>
<p>好处：代码更加的面向对象，代码量更少，灵活性更高，提升代码的开发效率。</p>
<h2 id="27、WEB安全的问题"><a href="#27、WEB安全的问题" class="headerlink" title="27、WEB安全的问题"></a>27、WEB安全的问题</h2><p>什么是SQL 注入：</p>
<p>通过特殊的参数传入web应用，导致后端执行了恶意代码。在动态的拼接SQL的时候产生。</p>
<p>如何防范：</p>
<p>永远不要相信用户的人任何输入</p>
<p>对输入的参数最好检查，过滤和转义特殊字符。</p>
<p>不要直接拼接sql使用ORM可以大大降低sql注入的风险。</p>
<p>数据库层：做好明文管理，不要存储明文敏感信息。</p>
<h2 id="28、什么是XSS"><a href="#28、什么是XSS" class="headerlink" title="28、什么是XSS :"></a>28、什么是XSS :</h2><p>恶意用户将代码植入到提供给其他用户使用的页面中。未经转义的恶意代码输出到其他的用户浏览器被执行。</p>
<p>嵌入到页面中的js脚本被执行，攻击用户。</p>
<h2 id="29、什么是前后端？有哪些优势。"><a href="#29、什么是前后端？有哪些优势。" class="headerlink" title="29、什么是前后端？有哪些优势。"></a>29、什么是前后端？有哪些优势。</h2><p>后端只负责提供数据，不再渲染模板。前端获取接口实现。</p>
<p>好处：前后端解耦，接口复用，减少开发量。提升工作效率。更利于调试，测试和部署。</p>
<p>缺点：动态加载不利于SEO。</p>
<h2 id="30、什么是-RESTful"><a href="#30、什么是-RESTful" class="headerlink" title="30、什么是 RESTful"></a>30、什么是 RESTful</h2><p>是一种以资源为中心的WEB软件架构风格，可以用ajax 和restful web服务架构应用。</p>
<p>设计概念和准则：</p>
<p>所有的事物抽象为资源，资源对应唯一的标识。</p>
<p>资源通过接口进行操作实现状态转移。操作本身是无状态的。</p>
<h1 id="六、数据结构算法"><a href="#六、数据结构算法" class="headerlink" title="六、数据结构算法"></a>六、数据结构算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># n = len(a)  # 获取列表的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j + <span class="number">1</span>]:</span><br><span class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="keyword">if</span> li[min_index] &gt; li[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            li[i], li[min_index] = li[min_index], li[i]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-计算机网络</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>搬运自掘金用户：<a href="https://juejin.cn/user/2506542243918030/posts">小杰要吃蛋</a> [侵删]</p>
<ul>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-1">什么是网络编程</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-2">网络编程中两个主要的问题</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-3">网络协议是什么</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-4">为什么要对网络协议分层</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-5">计算机网络体系结构</a><ul>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-6">1 TCP / UDP</a><ul>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-7">1.1 什么是TCP/IP和UDP</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-8">1.2 TCP与UDP区别：</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-9">1.3 TCP和UDP的应用场景：</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-10">1.4 形容一下TCP和UDP</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-11">1.5 运行在TCP 或UDP的应用层协议分析。</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-12">什么是ARP协议 (Address Resolution Protocol)？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-13">什么是NAT (Network Address Translation, 网络地址转换)？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-14">从输入址到获得页面的过程?</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-15">1.6 TCP的三次握手</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-24">1.7 TCP的四次挥手</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-31">2 Socket</a><ul>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-32">1 什么是Socket</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-33">2 socket属于网络的那个层面</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-34">3 Socket通讯的过程</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-35">4 TCP协议Socket代码示例：</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-36">5 UDP协议Socket代码示例：</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-37">6 Socket的常用类</a></li>
</ul>
</li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-38">3. HTTP</a><ul>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-39">什么是Http协议？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-40">Socket和http的区别和应用场景</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-41">什么是http的请求体？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-42">http的响应报文有哪些？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-43">http和https的区别？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-44">HTTPS工作原理</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-45">一次完整的HTTP请求所经历几个步骤?</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-46">常用HTTP状态码是怎么分类的，有哪些常见的状态码？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-47">Http协议中有那些请求方式</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-48">GET方法与POST方法的区别</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-49">http版本的对比</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-50">什么是对称加密与非对称加密</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-51">cookie和session对于HTTP有什么用？</a></li>
<li><a href="https://juejin.cn/post/6844904125692379143#heading-55">cookie和session对于HTTP有什么用？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="什么是网络编程"><a href="#什么是网络编程" class="headerlink" title="什么是网络编程"></a>什么是网络编程</h2><ul>
<li>网络编程的本质是多台计算机之间的数据交换。数据传递本身没有多大的难度，不就是把一个设备中的数据发送给其他设备，然后接受另外一个设备反馈的数据。现在的网络编程基本上都是基于请求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻相应连接，则需要一直启动。</li>
<li>例如以打电话为例，首先拨号的人类似于客户端，接听电话的人必须保持电话畅通类似于服务器。连接一旦建立以后，就客户端和服务器端就可以进行数据传递了，而且两者的身份是等价的。在一些程序中，程序既有客户端功能也有服务器端功能，最常见的软件就是QQ、微信这类软件了。</li>
</ul>
<h2 id="网络编程中两个主要的问题"><a href="#网络编程中两个主要的问题" class="headerlink" title="网络编程中两个主要的问题"></a>网络编程中两个主要的问题</h2><ol>
<li>一个是如何准确的定位网络上一台或多台主机，</li>
<li>另一个就是找到主机后如何可靠高效的进行数据传输。</li>
</ol>
<ul>
<li>在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。</li>
<li>而TCP层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心IP层是如何处理数据的。</li>
<li>目前较为流行的网络编程模型是客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提 出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也 能及时得到服务。</li>
</ul>
<h2 id="网络协议是什么"><a href="#网络协议是什么" class="headerlink" title="网络协议是什么"></a>网络协议是什么</h2><ul>
<li>在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</li>
</ul>
<h2 id="为什么要对网络协议分层"><a href="#为什么要对网络协议分层" class="headerlink" title="为什么要对网络协议分层"></a>为什么要对网络协议分层</h2><ul>
<li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li>
<li>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</li>
<li>易于实现和维护。</li>
<li>促进标准化工作。分开后，每层功能可以相对简单地被描述</li>
</ul>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297c7320a555~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>OSI参考模型<ul>
<li>OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。</li>
<li>OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297c7324a8f0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li><strong>TCP/IP参考模型</strong></li>
<li>TCP/IP四层协议（数据链路层、网络层、传输层、应用层）<ol>
<li>应用层 应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。</li>
<li>传输层 建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</li>
<li>网络层 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</li>
<li>数据链路层 通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的<code>硬件</code>和软件加到物理线路，这样就构成了数据链路，</li>
</ol>
</li>
</ul>
<h3 id="1-TCP-UDP"><a href="#1-TCP-UDP" class="headerlink" title="1 TCP / UDP"></a>1 TCP / UDP</h3><h4 id="1-1-什么是TCP-IP和UDP"><a href="#1-1-什么是TCP-IP和UDP" class="headerlink" title="1.1 什么是TCP/IP和UDP"></a>1.1 什么是TCP/IP和UDP</h4><ul>
<li>TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>
<li>UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</li>
</ul>
<h4 id="1-2-TCP与UDP区别："><a href="#1-2-TCP与UDP区别：" class="headerlink" title="1.2 TCP与UDP区别："></a>1.2 TCP与UDP区别：</h4><ul>
<li>TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；</li>
<li>UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>
<li>TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>
<li>UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li>TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li>TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li>UDP 的主机不需要维持复杂的连接状态表</li>
</ul>
<h4 id="1-3-TCP和UDP的应用场景："><a href="#1-3-TCP和UDP的应用场景：" class="headerlink" title="1.3 TCP和UDP的应用场景："></a>1.3 TCP和UDP的应用场景：</h4><ul>
<li>对某些实时性要求比较高的情况使用UDP，比如游戏，媒体通信，实时直播，即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失的情况</li>
</ul>
<h4 id="1-4-形容一下TCP和UDP"><a href="#1-4-形容一下TCP和UDP" class="headerlink" title="1.4 形容一下TCP和UDP"></a>1.4 形容一下TCP和UDP</h4><ul>
<li><p><strong>TCP通信可看作打电话：</strong></p>
<p>李三(拨了个号码)：喂，是王五吗？ 王五：哎，您谁啊？ 李三：我是李三，我想给你说点事儿，你现在方便吗？ 王五：哦，我现在方便，你说吧。 甲：那我说了啊？ 乙：你说吧。 (连接建立了，接下来就是说正事了…)</p>
</li>
<li><p><strong>UDP通信可看为学校里的广播：</strong></p>
<p>播音室：喂喂喂！全体操场集合</p>
</li>
</ul>
<h4 id="1-5-运行在TCP-或UDP的应用层协议分析。"><a href="#1-5-运行在TCP-或UDP的应用层协议分析。" class="headerlink" title="1.5 运行在TCP 或UDP的应用层协议分析。"></a>1.5 运行在TCP 或UDP的应用层协议分析。</h4><ul>
<li>运行在TCP协议上的协议：<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。</li>
<li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
</li>
<li>运行在UDP协议上的协议：<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
</li>
<li>运行在TCP和UDP协议上：<ul>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。</li>
<li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在<a href="https://link.juejin.cn/?target=http://zh.wikipedia.org/zh-cn/TCP">TCP</a>和<a href="https://link.juejin.cn/?target=http://zh.wikipedia.org/zh-cn/UDP">UDP</a>协议上）。</li>
<li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
<li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li>
</ul>
</li>
</ul>
<h4 id="什么是ARP协议-Address-Resolution-Protocol-？"><a href="#什么是ARP协议-Address-Resolution-Protocol-？" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)？"></a>什么是ARP协议 (Address Resolution Protocol)？</h4><ul>
<li><strong>ARP协议完成了IP地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向<strong>所在的局域网</strong>发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</li>
<li>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</li>
</ul>
<h4 id="什么是NAT-Network-Address-Translation-网络地址转换-？"><a href="#什么是NAT-Network-Address-Translation-网络地址转换-？" class="headerlink" title="什么是NAT (Network Address Translation, 网络地址转换)？"></a>什么是NAT (Network Address Translation, 网络地址转换)？</h4><ul>
<li>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</li>
</ul>
<h4 id="从输入址到获得页面的过程"><a href="#从输入址到获得页面的过程" class="headerlink" title="从输入址到获得页面的过程?"></a>从输入址到获得页面的过程?</h4><ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h4 id="1-6-TCP的三次握手"><a href="#1-6-TCP的三次握手" class="headerlink" title="1.6 TCP的三次握手"></a>1.6 TCP的三次握手</h4><h5 id="1-6-1-什么是TCP的三次握手"><a href="#1-6-1-什么是TCP的三次握手" class="headerlink" title="1.6.1 什么是TCP的三次握手"></a>1.6.1 什么是TCP的三次握手</h5><ul>
<li>在网络数据传输中，传输层协议TCP是要建立连接的可靠传输，TCP建立连接的过程，我们称为三次握手。</li>
</ul>
<h5 id="1-6-2-三次握手的具体细节"><a href="#1-6-2-三次握手的具体细节" class="headerlink" title="1.6.2 三次握手的具体细节"></a>1.6.2 三次握手的具体细节</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297c73467e00~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ol>
<li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li>
<li>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；</li>
<li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li>
</ol>
<ul>
<li>简单来说就是 ：<ol>
<li>客户端向服务端发送SYN</li>
<li>服务端返回SYN,ACK</li>
<li>客户端发送ACK</li>
</ol>
</li>
</ul>
<h5 id="1-6-3-用现实理解三次握手的具体细节"><a href="#1-6-3-用现实理解三次握手的具体细节" class="headerlink" title="1.6.3 用现实理解三次握手的具体细节"></a>1.6.3 用现实理解三次握手的具体细节</h5><ul>
<li>三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收机能正常。</li>
</ul>
<ol>
<li>第一次握手：客户什么都不能确认；服务器确认了对方发送正常</li>
<li>第二次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己接收正常，对方发送正常</li>
<li>第三次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己发送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。</li>
</ol>
<h5 id="1-6-4-建立连接可以两次握手吗？为什么"><a href="#1-6-4-建立连接可以两次握手吗？为什么" class="headerlink" title="1.6.4 建立连接可以两次握手吗？为什么?"></a>1.6.4 建立连接可以两次握手吗？为什么?</h5><ul>
<li>不可以。</li>
<li>因为可能会出现已失效的连接请求报文段又传到了服务器端。 &gt; client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</li>
<li>而且，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</li>
</ul>
<h5 id="1-6-5-可以采用四次握手吗？为什么？"><a href="#1-6-5-可以采用四次握手吗？为什么？" class="headerlink" title="1.6.5 可以采用四次握手吗？为什么？"></a>1.6.5 可以采用四次握手吗？为什么？</h5><ul>
<li>这个肯定可以。三次握手都可以保证连接成功了，何况是四次，但是会降低传输的效率。</li>
</ul>
<h5 id="1-6-6-第三次握手中，如果客户端的ACK未送达服务器，会怎样？"><a href="#1-6-6-第三次握手中，如果客户端的ACK未送达服务器，会怎样？" class="headerlink" title="1.6.6 第三次握手中，如果客户端的ACK未送达服务器，会怎样？"></a>1.6.6 第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h5><ul>
<li>Server端：由于Server没有收到ACK确认，因此会每隔 3秒 重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。</li>
<li>Client端，会出现两种情况：<ol>
<li>在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态</li>
<li>在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。</li>
</ol>
</li>
</ul>
<h5 id="1-6-7-如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#1-6-7-如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="1.6.7 如果已经建立了连接，但客户端出现了故障怎么办？"></a>1.6.7 如果已经建立了连接，但客户端出现了故障怎么办？</h5><ul>
<li>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li>
</ul>
<h5 id="1-6-8-初始序列号是什么？"><a href="#1-6-8-初始序列号是什么？" class="headerlink" title="1.6.8 初始序列号是什么？"></a>1.6.8 初始序列号是什么？</h5><ul>
<li>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</li>
</ul>
<h4 id="1-7-TCP的四次挥手"><a href="#1-7-TCP的四次挥手" class="headerlink" title="1.7 TCP的四次挥手"></a>1.7 TCP的四次挥手</h4><h5 id="1-7-1-什么是TCP的四次挥手"><a href="#1-7-1-什么是TCP的四次挥手" class="headerlink" title="1.7.1 什么是TCP的四次挥手"></a>1.7.1 什么是TCP的四次挥手</h5><ul>
<li>在网络数据传输中，传输层协议断开连接的过程我们称为四次挥手</li>
</ul>
<h5 id="1-7-2-四次挥手的具体细节"><a href="#1-7-2-四次挥手的具体细节" class="headerlink" title="1.7.2 四次挥手的具体细节"></a>1.7.2 四次挥手的具体细节</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297c746f6ee2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ol>
<li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li>
<li>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li>
<li>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li>
<li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li>
</ol>
<h5 id="1-7-3-用现实理解三次握手的具体细节TCP的四次挥手"><a href="#1-7-3-用现实理解三次握手的具体细节TCP的四次挥手" class="headerlink" title="1.7.3 用现实理解三次握手的具体细节TCP的四次挥手"></a>1.7.3 用现实理解三次握手的具体细节TCP的四次挥手</h5><ul>
<li>四次挥手断开连接是因为要确定数据全部传书完了</li>
</ul>
<ol>
<li>客户与服务器交谈结束之后，客户要结束此次会话，就会对服务器说：我要关闭连接了（第一 次挥手）</li>
<li>服务器收到客户的消息后说：好的，你要关闭连接了。（第二次挥手）</li>
<li>然后服务器确定了没有话要和客户说了，服务器就会对客户说，我要关闭连接了。(第三次挥 手)</li>
<li>客户收到服务器要结束连接的消息后说：已收到你要关闭连接的消息。(第四次挥手)，才关闭</li>
</ol>
<h5 id="1-7-4-为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#1-7-4-为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="1.7.4 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>1.7.4 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h5><ul>
<li>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</li>
</ul>
<h5 id="1-7-5-如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"><a href="#1-7-5-如果第二次挥手时服务器的ACK没有送达客户端，会怎样？" class="headerlink" title="1.7.5 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"></a>1.7.5 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h5><ul>
<li>客户端没有收到ACK确认，会重新发送FIN请求。</li>
</ul>
<h5 id="1-7-6-客户端TIME-WAIT状态的意义是什么？"><a href="#1-7-6-客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="1.7.6 客户端TIME_WAIT状态的意义是什么？"></a>1.7.6 客户端TIME_WAIT状态的意义是什么？</h5><ul>
<li>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</li>
</ul>
<h3 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2 Socket"></a>2 Socket</h3><h4 id="1-什么是Socket"><a href="#1-什么是Socket" class="headerlink" title="1 什么是Socket"></a>1 什么是Socket</h4><ul>
<li><p>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。</p>
</li>
<li><p>但是，Socket所支持的协议种类也不光TCP/IP、UDP，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p>
</li>
<li><p>socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的</p>
</li>
<li><p>Socket偏向于底层。一般很少直接使用Socket来编程，框架底层使用Socket比较多，</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297c768507e4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="2-socket属于网络的那个层面"><a href="#2-socket属于网络的那个层面" class="headerlink" title="2 socket属于网络的那个层面"></a>2 socket属于网络的那个层面</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297c7c7176ba~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个<a href="https://link.juejin.cn/?target=https://blog.csdn.net/weixin_43122090/article/details/104904625">外观模式</a>，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</li>
</ul>
<h4 id="3-Socket通讯的过程"><a href="#3-Socket通讯的过程" class="headerlink" title="3 Socket通讯的过程"></a>3 Socket通讯的过程</h4><ul>
<li>基于TCP：服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li>
<li>基于UDP：UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管</li>
</ul>
<h4 id="4-TCP协议Socket代码示例："><a href="#4-TCP协议Socket代码示例：" class="headerlink" title="4 TCP协议Socket代码示例："></a>4 TCP协议Socket代码示例：</h4><p><code>先运行服务端，在运行客户端</code>，</p>
<ol>
<li>服务端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="keyword">package</span> com.test.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TCP协议Socket使用BIO进行通行：服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在main线程中执行下面这些代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1单线程服务</span></span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端启动成功，监听端口为8000，等待客户端连接...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                socket = server.accept(); <span class="comment">//等待客户端连接</span></span><br><span class="line">                System.out.println(<span class="string">&quot;客户连接成功，客户信息为：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                in = socket.getInputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//读取客户端的数据</span></span><br><span class="line">                <span class="keyword">while</span> ((len = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//向客户端写数据</span></span><br><span class="line">                out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">&quot;hello!&quot;</span>.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>客户端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="keyword">package</span> com.test.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TCP协议Socket：客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建套接字对象socket并封装ip与port</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">        <span class="comment">//根据创建的socket对象获得一个输出流</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//控制台输入以IO的形式发送到服务器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;TCP连接成功 \n请输入：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] car = <span class="keyword">new</span> Scanner(System.in).nextLine().getBytes();</span><br><span class="line">            outputStream.write(car);</span><br><span class="line">            System.out.println(<span class="string">&quot;TCP协议的Socket发送成功&quot;</span>);</span><br><span class="line">            <span class="comment">//刷新缓冲区</span></span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>先运行服务端，在运行客户端</code>。测试结果发送成功：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297c9803dcaf~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<p>·</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297ca3ffbda2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<h4 id="5-UDP协议Socket代码示例："><a href="#5-UDP协议Socket代码示例：" class="headerlink" title="5 UDP协议Socket代码示例："></a>5 UDP协议Socket代码示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先运行服务端，在运行客户端</span><br></pre></td></tr></table></figure>
<ol>
<li>服务端：</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">reasonml复制代码<span class="comment">//UDP协议Socket：服务端</span></span><br><span class="line">public <span class="keyword">class</span> Server1 &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//DatagramSocket代表声明一个UDP协议的Socket</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> <span class="constructor">DatagramSocket(8888)</span>;</span><br><span class="line">            <span class="comment">//byte数组用于数据存储。</span></span><br><span class="line">            byte<span class="literal">[]</span> car = <span class="keyword">new</span> byte<span class="literal">[<span class="number">1024</span>]</span>;</span><br><span class="line">            <span class="comment">//DatagramPacket 类用来表示数据报包DatagramPacket</span></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> <span class="constructor">DatagramPacket(<span class="params">car</span>, <span class="params">car</span>.<span class="params">length</span>)</span>;</span><br><span class="line">            <span class="comment">// //创建DatagramPacket的receive()方法来进行数据的接收,等待接收一个socket请求后才执行后续操作；</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;等待UDP协议传输数据&quot;</span>);</span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            <span class="comment">//packet.getLength返回将要发送或者接收的数据的长度。</span></span><br><span class="line">            <span class="built_in">int</span> length = packet.get<span class="constructor">Length()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;啥东西来了：&quot;</span> + <span class="keyword">new</span> <span class="constructor">String(<span class="params">car</span>, 0, <span class="params">length</span>)</span>);</span><br><span class="line">            socket.close<span class="literal">()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;UDP协议Socket接受成功&quot;</span>);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>客户端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="comment">//UDP协议Socket：客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//DatagramSocket代表声明一个UDP协议的Socket</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">2468</span>);</span><br><span class="line">            <span class="comment">//字符串存储人Byte数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] car = <span class="string">&quot;UDP协议的Socket请求，有可能失败哟&quot;</span>.getBytes();</span><br><span class="line">            <span class="comment">//InetSocketAddress类主要作用是封装端口</span></span><br><span class="line">            InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//DatagramPacket 类用来表示数据报包DatagramPacket</span></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(car, car.length, address);</span><br><span class="line">            <span class="comment">//send() 方法发送数据包。</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">            System.out.println(<span class="string">&quot;UDP协议的Socket发送成功&quot;</span>);</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>先运行服务端，在运行客户端</code>。测试结果成功发送成功：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297ca5df17df~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<h4 id="6-Socket的常用类"><a href="#6-Socket的常用类" class="headerlink" title="6 Socket的常用类"></a>6 Socket的常用类</h4><table>
<thead>
<tr>
<th>类名</th>
<th>用于</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Socket</td>
<td>TCP协议</td>
<td>Socket类同时工作于客户端和服务端，所有方法都是通用的，这个类三个主要作用，校验包信息，发起连接（Client），操作流数据（Client/Server）</td>
</tr>
<tr>
<td>ServerSocket</td>
<td>TCP协议</td>
<td>ServerSocket表示为服务端，主要作用就是绑定并监听一个服务器端口，为每个建立连接的客户端“克隆/映射”一个Socket对象，具体数据操作都是通过这个Socket对象完成的，ServerSocket只关注如何和客户端建立连接</td>
</tr>
<tr>
<td>DatagramSocket</td>
<td>ODP协议</td>
<td>DatagramSocket 类用于表示发送和接收数据报包的套接字。</td>
</tr>
<tr>
<td>DatagramPacket</td>
<td>ODP协议</td>
<td>DatagramPacket 类用来表示数据报包，数据报包用来实现无连接包投递服务。</td>
</tr>
<tr>
<td>InetAddress</td>
<td>IP+端口号</td>
<td>Java提供了InetAddress类来代表互联网协议（IP）地址，InetAddress类没有提供构造器，而是提供了如下两个静态方法来获取InetAddress实例：</td>
</tr>
<tr>
<td>InetSocketAddress</td>
<td>IP+端口号</td>
<td>在使用Socket来连接服务器时最简单的方式就是直接使用IP和端口，但Socket类中并未提供这种方式，而是靠SocketAddress的子类InetSocketAddress来实现 IP 地址 + 端口号的创建，不依赖任何协议。</td>
</tr>
</tbody></table>
<h3 id="3-HTTP"><a href="#3-HTTP" class="headerlink" title="3. HTTP"></a>3. HTTP</h3><h4 id="什么是Http协议？"><a href="#什么是Http协议？" class="headerlink" title="什么是Http协议？"></a>什么是Http协议？</h4><ul>
<li><p>Http协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为“超文本传输协议”</p>
</li>
<li><p>Http协议属于应用层，及用户访问的第一层就是http</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297caf6776de~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="Socket和http的区别和应用场景"><a href="#Socket和http的区别和应用场景" class="headerlink" title="Socket和http的区别和应用场景"></a>Socket和http的区别和应用场景</h4><ul>
<li>Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；</li>
<li>Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。</li>
<li>http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接</li>
<li>http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等</li>
</ul>
<h4 id="什么是http的请求体？"><a href="#什么是http的请求体？" class="headerlink" title="什么是http的请求体？"></a>什么是http的请求体？</h4><ul>
<li>HTTP请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器那数据，先要表明我要什么吧</li>
<li>HTTP请求体由：请求行 、请求头、请求数据组成的，</li>
<li>注意：GIT请求是没有请求体的</li>
</ul>
<ol>
<li><p>POST请求</p>
</li>
<li><p>GIT请求是没有请求体的 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297cbc5c7a1c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"> <code>发现只有请求行和请求头，少了个请求体</code></p>
</li>
</ol>
<h4 id="http的响应报文有哪些？"><a href="#http的响应报文有哪些？" class="headerlink" title="http的响应报文有哪些？"></a>http的响应报文有哪些？</h4><ul>
<li><p>http的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文</p>
</li>
<li><p>响应报文包含三部分 状态行、响应首部字段、响应内容实体实现</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/1717297cbf073fa2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h4><ul>
<li>其实HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</li>
<li>区别：<ol>
<li>http需要拿到ca证书，需要钱的</li>
<li>端口不一样，http是80，https443</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式（http的连接很简单，是无状态的；HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。）</li>
</ol>
</li>
</ul>
<h4 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h4><ul>
<li>一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>四、发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ul>
<h4 id="一次完整的HTTP请求所经历几个步骤"><a href="#一次完整的HTTP请求所经历几个步骤" class="headerlink" title="一次完整的HTTP请求所经历几个步骤?"></a>一次完整的HTTP请求所经历几个步骤?</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</span><br></pre></td></tr></table></figure>
<ol>
<li><p>建立TCP连接</p>
<p>怎么建立连接的，看上面的三次捂手</p>
</li>
<li><p>Web浏览器向Web服务器发送请求行</p>
<p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.jsp HTTP/1.1。</p>
</li>
<li><p>Web浏览器发送请求头</p>
<p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</p>
</li>
<li><p>Web服务器应答</p>
<p>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></p>
</li>
<li><p>Web服务器发送应答头</p>
<p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>
</li>
<li><p>Web服务器向浏览器发送数据</p>
<p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</p>
</li>
<li><p>Web服务器关闭TCP连接</p>
</li>
</ol>
<h4 id="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"><a href="#常用HTTP状态码是怎么分类的，有哪些常见的状态码？" class="headerlink" title="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"></a>常用HTTP状态码是怎么分类的，有哪些常见的状态码？</h4><ul>
<li>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</li>
<li>状态码的类别：</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1xx：</td>
<td>指示信息–表示请求已接收，正在处理</td>
</tr>
<tr>
<td>2xx：</td>
<td>成功–表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td>3xx：</td>
<td>重定向–要完成请求必须进行更进一步的操作</td>
</tr>
<tr>
<td>4xx：</td>
<td>客户端错误–请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td>5xx：</td>
<td>服务器端错误–服务器未能实现合法的请求</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>常见的状态码：</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>200：</td>
<td>请求被正常处理</td>
</tr>
<tr>
<td>204：</td>
<td>请求被受理但没有资源可以返回</td>
</tr>
<tr>
<td>206：</td>
<td>客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</td>
</tr>
<tr>
<td>301：</td>
<td>永久性重定向</td>
</tr>
<tr>
<td>302：</td>
<td>临时重定向</td>
</tr>
<tr>
<td>303：</td>
<td>与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</td>
</tr>
<tr>
<td>304：</td>
<td>发送附带条件的请求时，条件不满足时返回，与重定向无关</td>
</tr>
<tr>
<td>307：</td>
<td>临时重定向，与302类似，只是强制要求使用POST方法</td>
</tr>
<tr>
<td>400：</td>
<td>请求报文语法有误，服务器无法识别</td>
</tr>
<tr>
<td>401：</td>
<td>请求需要认证</td>
</tr>
<tr>
<td>403：</td>
<td>请求的对应资源禁止被访问</td>
</tr>
<tr>
<td>404：</td>
<td>服务器无法找到对应资源</td>
</tr>
<tr>
<td>500：</td>
<td>服务器内部错误</td>
</tr>
<tr>
<td>503：</td>
<td>服务器正忙</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="Http协议中有那些请求方式"><a href="#Http协议中有那些请求方式" class="headerlink" title="Http协议中有那些请求方式"></a>Http协议中有那些请求方式</h4><blockquote>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET：</td>
<td>用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</td>
</tr>
<tr>
<td>POST：</td>
<td>用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</td>
</tr>
<tr>
<td>PUT：</td>
<td>传输文件，报文主体中包含文件内容，保存到对应URI位置。</td>
</tr>
<tr>
<td>HEAD：</td>
<td>获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有 &gt; 效。</td>
</tr>
<tr>
<td>PATCH：</td>
<td>客户端向服务器传送的数据取代指定的文档的内容(部分取代)</td>
</tr>
<tr>
<td>TRACE：</td>
<td>回显客户端请求服务器的原始请求报文，用于”回环”诊断</td>
</tr>
<tr>
<td>DELETE：</td>
<td>删除文件，与PUT方法相反，删除对应URI位置的文件。</td>
</tr>
<tr>
<td>OPTIONS：</td>
<td>查询相应URI支持的HTTP方法。</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="GET方法与POST方法的区别"><a href="#GET方法与POST方法的区别" class="headerlink" title="GET方法与POST方法的区别"></a>GET方法与POST方法的区别</h4><ul>
<li><strong>区别一</strong>： get重点在从服务器上获取资源，post重点在向服务器发送数据；</li>
<li><strong>区别二</strong>： Get传输的数据量小，因为受URL长度限制，但效率较高； Post可以传输大量数据，所以上传文件时只能用Post方式；</li>
<li><strong>区别三</strong>： get是不安全的，因为get请求发送数据是在URL上，是可见的，可能会泄露私密信息，如密码等； post是放在请求头部的，相对比较安全的。</li>
</ul>
<h4 id="http版本的对比"><a href="#http版本的对比" class="headerlink" title="http版本的对比"></a>http版本的对比</h4><ul>
<li>HTTP1.0版本的特性：<ul>
<li>早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。</li>
<li>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</li>
</ul>
</li>
<li>HTTP1.1版本新特性<ul>
<li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</li>
<li>断点续传原理</li>
</ul>
</li>
<li>HTTP2.0版本的特性<ul>
<li>二进制分帧（采用二进制格式的编码将其封装）</li>
<li>首部压缩（设置了专门的首部压缩设计的HPACK算法。）</li>
<li>流量控制（设置了接收某个数据流的多少字节一些流量控制）</li>
<li>多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</li>
<li>请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</li>
<li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））</li>
</ul>
</li>
</ul>
<h4 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h4><ul>
<li>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</li>
<li>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</li>
</ul>
<h4 id="cookie和session对于HTTP有什么用？"><a href="#cookie和session对于HTTP有什么用？" class="headerlink" title="cookie和session对于HTTP有什么用？"></a>cookie和session对于HTTP有什么用？</h4><ul>
<li>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</li>
</ul>
<h5 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h5><ul>
<li>cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</li>
</ul>
<h5 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h5><ul>
<li>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。</li>
<li>服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</li>
</ul>
<h5 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h5><ol>
<li>cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li>
<li>单个cookie保存的数据不能超过4K，session无此限制 信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</li>
</ol>
<h4 id="cookie和session对于HTTP有什么用？-1"><a href="#cookie和session对于HTTP有什么用？-1" class="headerlink" title="cookie和session对于HTTP有什么用？"></a>cookie和session对于HTTP有什么用？</h4><ul>
<li>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</li>
</ul>
<h5 id="什么是cookie-1"><a href="#什么是cookie-1" class="headerlink" title="什么是cookie"></a>什么是cookie</h5><ul>
<li>cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</li>
</ul>
<h5 id="什么是session-1"><a href="#什么是session-1" class="headerlink" title="什么是session"></a>什么是session</h5><ul>
<li>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。</li>
<li>服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</li>
</ul>
<h5 id="cookie与session区别-1"><a href="#cookie与session区别-1" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h5><ol>
<li>cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li>
<li>单个cookie保存的数据不能超过4K，session无此限制</li>
<li>session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-Django</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-Django/</url>
    <content><![CDATA[<h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><h2 id="Django基础"><a href="#Django基础" class="headerlink" title="Django基础"></a>Django基础</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>如何理解设计模式中的MVC模式，你平时怎么使用这种模式？<br>如何理解Django中的MTV模型？<br>介绍一下Django中你熟悉的模块及其作用。<br>如何看待Django自带的admin，并说说你的使用经验。<br>如何理解WSGI的作用？<br>如何自己实现WSGI协议？<br>为什么正式部署不要开启DEBUG=True?</p>
<h3 id="Model层"><a href="#Model层" class="headerlink" title="Model层"></a>Model层</h3><p>如何理解Django migrations的作用？<br>是否有过手动编辑migrations文件的经历？原因是什么？有哪些需要注意的？<br>介绍一下ORM的概念？<br>介绍一下ORM下的N+1问题、发生的原因以及解决方案。<br>介绍一下Django中Model的作用。<br>Model的Meta属性类有哪些可配置项？其作用是什么？日常怎么优化它？<br>介绍一下Queryset的作用以及你常用的QuerySet优化措施？<br>介绍一下Pagination的用法。<br>介绍一下Model中Field的作用。<br>如何定制Manager？什么场景下需要定制？<br>原生SQL的效率跟ORM的效率是否进行过对比？结果如何？如何理解这种差异？<br>Django内置的权限逻辑以及其粒度？</p>
<h3 id="View层"><a href="#View层" class="headerlink" title="View层"></a>View层</h3><p>Django的funtion view和class-based view的差别及适用场景。<br>如何给class-based view添加login required装饰器？<br>middleware在Django系统中的作用。<br>settings中默认配置的MIDDLEWARES有哪些？它们的作用分别是什么？是否可以移除？<br>Django系统如何判断用户是否为登录用户？<br>对于无cookie的浏览器，如何实现用户登录？<br>Django中的request和HttpResponse的作用是什么？<br>如何处理图片上传的逻辑以及展示逻辑？<br>介绍一下用过的Django缓存粒度？</p>
<h3 id="Form层"><a href="#Form层" class="headerlink" title="Form层"></a>Form层</h3><p>介绍一下Django中Form的作用。<br>Form中的Field跟Model中的Field有何关联？<br>如何在Form层实现对某个字段的校验？<br>Template层</p>
<p>如何理解Django模板对设计师友好的说法？<br>日常开发中如何规划Django的模板继承和include？<br>常用的标签(tag)和过滤器(filter)有哪些？<br>在模板中如何处理静态文件？<br>在模板中如何处理系统内定义的URL？<br>如何自定义标签和过滤器？</p>
<h3 id="Django进阶"><a href="#Django进阶" class="headerlink" title="Django进阶"></a>Django进阶</h3><p>如何排查Django项目的性能问题？<br>如何部署Django项目？不同的部署方式之间的差别有哪些？<br>部署时如何处理项目中的静态文件？<br>如何实现自定义的登录认证逻辑？<br>如何理解Django中的Model、Form、ModelForm和Field、widget之间的关系？<br>paginator的原理什么？如何自己实现分页逻辑？<br>Model中的Field的作用是什么？<br>什么是SQL注入？ORM又是如何解决这个问题的？<br>CSRF的全称是什么？Django是如何解决这个问题的？<br>XSS攻击是什么？在开发时应该如何避免这种攻击？<br>signal的作用以及实现逻辑是什么？<br>DATABASE配置中CONN_MAX_AGE参数的作用以及使用场景？<br>CONN_MAX_AGE的实现逻辑是什么？<br>用Django内置的User模型创建用户时，是否可以直接用User(username=’the5fire’, password=’the5fire’).save()？<br>上面的创建方式有什么问题？应该如何处理用户密码？<br>使用django-rest-framework如何实现用户认证登录逻辑？<br>session模块在Django中的作用是什么？<br>如何自定义Django中的权限粒度，实现自己的权限逻辑？<br>如何捕获线上系统的异常？<br>如何分析某个接口响应时间过长的问题？假设响应时间为2S，一次请求会涉及哪些数据库和缓存查询？</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-Redis</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>搬运自掘金用户：<a href="https://juejin.cn/user/2506542243918030/posts">小杰要吃蛋</a> [侵删]</p>
<h4 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h4><ul>
<li>Redis 是一个使用 C 语言写成的，开源的高性能key-value非关系缓存数据库。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。Redis的数据都基于缓存的，所以很快，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis也可以实现数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。</li>
</ul>
<h4 id="Redis有哪些优缺点？"><a href="#Redis有哪些优缺点？" class="headerlink" title="Redis有哪些优缺点？"></a>Redis有哪些优缺点？</h4><ul>
<li>优点<ul>
<li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
</li>
<li>缺点<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
</li>
</ul>
<h4 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h4><ul>
<li>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都很低</li>
<li>(2)支持丰富数据类型，支持string，list，set，sorted set，hash</li>
<li>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>
<li>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li>
</ul>
<h4 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis  / 为什么要用缓存"></a>为什么要用 Redis  / 为什么要用缓存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主要从“高性能”和“高并发”这两点来看待这个问题。</span><br></pre></td></tr></table></figure>
<ul>
<li>高性能：<ul>
<li>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</li>
</ul>
</li>
<li>高并发：<ul>
<li>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li>
</ul>
</li>
</ul>
<h4 id="为什么要用-Redis-而不用-map-guava-做缓存"><a href="#为什么要用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 Redis 而不用 map/guava 做缓存?"></a>为什么要用 Redis 而不用 map/guava 做缓存?</h4><ul>
<li>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</li>
<li>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</li>
</ul>
<h4 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h4><ul>
<li>1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</li>
<li>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li>
<li>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>4、使用多路 I/O 复用模型，非阻塞 IO；</li>
<li>5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ul>
<h4 id="Redis有哪些数据类型"><a href="#Redis有哪些数据类型" class="headerlink" title="Redis有哪些数据类型"></a>Redis有哪些数据类型</h4><ul>
<li>Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作</td>
<td>做简单的键值对缓存</td>
</tr>
<tr>
<td>List</td>
<td>列表</td>
<td>从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素</td>
<td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td>
</tr>
<tr>
<td>Set</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素</td>
<td>交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集</td>
</tr>
<tr>
<td>Hash</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在</td>
<td>结构化的数据，比如一个对象</td>
</tr>
<tr>
<td>ZSet</td>
<td>有序集合</td>
<td>添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名</td>
<td>去重但可以排序，如获取排名前几名的用户</td>
</tr>
</tbody></table>
<h4 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h4><ul>
<li><p>计数器</p>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
</li>
<li><p>缓存</p>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
</li>
<li><p>会话缓存</p>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
</li>
<li><p>全页缓存（FPC）</p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
</li>
<li><p>查找表</p>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
</li>
<li><p>消息队列(发布/订阅功能)</p>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
</li>
<li><p>分布式锁实现</p>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
</li>
<li><p>其它</p>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
</li>
</ul>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><ul>
<li>什么是Redis持久化？ 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</li>
</ul>
<h4 id="Redis-的持久化机制是什么？各自的优缺点？"><a href="#Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis 的持久化机制是什么？各自的优缺点？"></a>Redis 的持久化机制是什么？各自的优缺点？</h4><ul>
<li>Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制:</li>
</ul>
<h5 id="RDB：是Redis-DataBase缩写快照"><a href="#RDB：是Redis-DataBase缩写快照" class="headerlink" title="RDB：是Redis DataBase缩写快照"></a>RDB：是Redis DataBase缩写快照</h5><ul>
<li>RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/1717449419419e78~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><p>优点：</p>
<p>1、只有一个文件 dump.rdb，方便持久化。</p>
<p>2、容灾性好，一个文件可以保存到安全的磁盘。</p>
<p>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p>
<p>4.相对于数据集大时，比 AOF 的启动效率更高。</p>
</li>
<li><p>缺点：</p>
<p>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p>
<p>2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。</p>
</li>
</ul>
<h5 id="AOF：持久化："><a href="#AOF：持久化：" class="headerlink" title="AOF：持久化："></a>AOF：持久化：</h5><ul>
<li>AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</li>
<li>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744941b1f2a80~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><p>优点：</p>
<p>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p>
<p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p>
<p>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p>
</li>
<li><p>缺点：</p>
<p>1、AOF 文件比 RDB 文件大，且恢复速度慢。</p>
<p>2、数据集大的时候，比 rdb 启动效率低。</p>
</li>
<li><p>俩种持久化的优缺点是什么？</p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大</li>
<li>RDB性能比AOF好</li>
<li>如果两个都配了优先加载AOF</li>
</ul>
</li>
</ul>
<h4 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h4><ul>
<li>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</li>
<li>有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h4 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h4><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<h4 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</span><br></pre></td></tr></table></figure>
<ul>
<li>过期策略通常有以下三种：</li>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis中同时使用了惰性过期和定期过期两种过期策略。</span><br></pre></td></tr></table></figure>
<h4 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a>Redis key的过期时间和永久有效分别怎么设置？</h4><ul>
<li>expire和persist命令。</li>
</ul>
<h4 id="我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢"><a href="#我们知道通过expire来设置key-的过期时间，那么对过期的数据怎么处理呢" class="headerlink" title="我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?"></a>我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?</h4><ul>
<li>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<ul>
<li>1、定时去清理过期的缓存；</li>
<li>2、当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</span><br></pre></td></tr></table></figure>
<h4 id="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h4><ul>
<li>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</li>
</ul>
<h4 id="Redis的内存淘汰策略有哪些"><a href="#Redis的内存淘汰策略有哪些" class="headerlink" title="Redis的内存淘汰策略有哪些"></a>Redis的内存淘汰策略有哪些</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</span><br></pre></td></tr></table></figure>
<ul>
<li>全局的键空间选择性移除<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
</li>
<li>设置过期时间的键空间选择性移除<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
</li>
<li>总结</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</span><br></pre></td></tr></table></figure>
<h4 id="Redis主要消耗什么物理资源？"><a href="#Redis主要消耗什么物理资源？" class="headerlink" title="Redis主要消耗什么物理资源？"></a>Redis主要消耗什么物理资源？</h4><ul>
<li>内存。</li>
</ul>
<h4 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h4><ul>
<li>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</li>
</ul>
<h4 id="Redis如何做内存优化？"><a href="#Redis如何做内存优化？" class="headerlink" title="Redis如何做内存优化？"></a>Redis如何做内存优化？</h4><ul>
<li>可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><ul>
<li>Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
<li>总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</li>
</ul>
<h3 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h3><ol>
<li>事务开始 MULTI</li>
<li>命令入队</li>
<li>事务执行 EXEC</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队</span><br></pre></td></tr></table></figure>
<h3 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<p>Redis会将一个事务中的所有命令序列化，然后按顺序执行。</p>
<ol>
<li><strong>redis 不支持回滚</strong>，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li>
<li><strong>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</strong>；</li>
<li><strong>如果在一个事务中出现运行错误，那么正确的命令会被执行</strong>。</li>
</ol>
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li>
<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h3 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h3><ul>
<li>原子性（Atomicity）<br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>
<li>一致性（Consistency）<br> 事务前后数据的完整性必须保持一致。</li>
<li>隔离性（Isolation）<br> 多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li>持久性（Durability）<br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</span><br></pre></td></tr></table></figure>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><ul>
<li>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</li>
</ul>
<h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><ul>
<li>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</li>
</ul>
<h3 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h3><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br> 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li>
</ul>
<h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="1、哨兵模式"><a href="#1、哨兵模式" class="headerlink" title="1、哨兵模式"></a>1、哨兵模式</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744941b28481b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<p><strong>哨兵的介绍</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</span><br></pre></td></tr></table></figure>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 redis 集群的高可用性。</li>
<li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<h3 id="2、官方Redis-Cluster-方案-服务端路由查询"><a href="#2、官方Redis-Cluster-方案-服务端路由查询" class="headerlink" title="2、官方Redis Cluster 方案(服务端路由查询)"></a>2、官方Redis Cluster 方案(服务端路由查询)</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744941e2adfa4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？</li>
</ul>
<p><strong>简介</strong></p>
<ul>
<li>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</li>
</ul>
<p><strong>方案说明</strong></p>
<ol>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时时需要需要把旧节点的数据迁移一部分到新节点</li>
</ol>
<ul>
<li>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。<ul>
<li>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</li>
</ul>
</li>
</ul>
<p><strong>节点间的内部通信机制</strong></p>
<ul>
<li>基本通信原理</li>
<li>集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。</li>
</ul>
<p><strong>分布式寻址算法</strong></p>
<ul>
<li>hash 算法（大量缓存重建）</li>
<li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li>
<li>redis cluster 的 hash slot 算法</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<h3 id="3、基于客户端分配"><a href="#3、基于客户端分配" class="headerlink" title="3、基于客户端分配"></a>3、基于客户端分配</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744941eba6627~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<p><strong>简介</strong></p>
<ul>
<li>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li>
</ul>
<h3 id="4、基于代理服务器分片"><a href="#4、基于代理服务器分片" class="headerlink" title="4、基于代理服务器分片"></a>4、基于代理服务器分片</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744941f4fe2e4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<p><strong>简介</strong></p>
<ul>
<li>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</li>
</ul>
<p><strong>特征</strong></p>
<ul>
<li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li>
<li>Proxy 的逻辑和存储的逻辑是隔离的</li>
<li>代理层多了一次转发，性能有所损耗</li>
</ul>
<p><strong>业界开源方案</strong></p>
<ul>
<li>Twtter开源的Twemproxy</li>
<li>豌豆荚开源的Codis</li>
</ul>
<h3 id="5、Redis-主从架构"><a href="#5、Redis-主从架构" class="headerlink" title="5、Redis 主从架构"></a>5、Redis 主从架构</h3><ul>
<li>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑<strong>读高并发</strong>的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744945c7745d8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</span><br></pre></td></tr></table></figure>
<p><strong>redis replication 的核心机制</strong></p>
<ul>
<li>redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li>
<li>一个 master node 是可以配置多个 slave node 的；</li>
<li>slave node 也可以连接其他的 slave node；</li>
<li>slave node 做复制的时候，不会 block master node 的正常工作；</li>
<li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li>
<li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>如果采用了主从架构，那么建议必须<strong>开启</strong> master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。</li>
<li>另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</li>
</ul>
<p><strong>redis 主从复制的核心原理</strong></p>
<ul>
<li>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</li>
<li>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</li>
<li>同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，</li>
<li>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</li>
<li>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744945c8008f8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<p><strong>过程原理</strong></p>
<ol>
<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li>
<li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li>
<li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li>
</ol>
<p><strong>缺点</strong></p>
<ul>
<li>所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决</li>
</ul>
<h3 id="Redis集群的主从复制模型是怎样的？"><a href="#Redis集群的主从复制模型是怎样的？" class="headerlink" title="Redis集群的主从复制模型是怎样的？"></a>Redis集群的主从复制模型是怎样的？</h3><ul>
<li>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品</li>
</ul>
<h3 id="生产环境中的-redis-是怎么部署的？"><a href="#生产环境中的-redis-是怎么部署的？" class="headerlink" title="生产环境中的 redis 是怎么部署的？"></a>生产环境中的 redis 是怎么部署的？</h3><ul>
<li>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</li>
<li>机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</li>
<li>5 台机器对外提供读写，一共有 50g 内存。</li>
<li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</li>
<li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</span><br></pre></td></tr></table></figure>
<h3 id="说说Redis哈希槽的概念？"><a href="#说说Redis哈希槽的概念？" class="headerlink" title="说说Redis哈希槽的概念？"></a>说说Redis哈希槽的概念？</h3><ul>
<li>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</li>
</ul>
<h3 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h3><ul>
<li>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</li>
</ul>
<h3 id="Redis集群之间是如何复制的？"><a href="#Redis集群之间是如何复制的？" class="headerlink" title="Redis集群之间是如何复制的？"></a>Redis集群之间是如何复制的？</h3><ul>
<li>异步复制</li>
</ul>
<h3 id="Redis集群最大节点个数是多少？"><a href="#Redis集群最大节点个数是多少？" class="headerlink" title="Redis集群最大节点个数是多少？"></a>Redis集群最大节点个数是多少？</h3><ul>
<li>16384个</li>
</ul>
<h3 id="Redis集群如何选择数据库？"><a href="#Redis集群如何选择数据库？" class="headerlink" title="Redis集群如何选择数据库？"></a>Redis集群如何选择数据库？</h3><ul>
<li>Redis集群目前无法做数据库选择，默认在0数据库。</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="Redis是单线程的，如何提高多核CPU的利用率？"><a href="#Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="Redis是单线程的，如何提高多核CPU的利用率？"></a>Redis是单线程的，如何提高多核CPU的利用率？</h3><ul>
<li>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</li>
</ul>
<h3 id="为什么要做Redis分区？"><a href="#为什么要做Redis分区？" class="headerlink" title="为什么要做Redis分区？"></a>为什么要做Redis分区？</h3><ul>
<li>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</li>
</ul>
<h3 id="你知道有哪些Redis分区实现方案？"><a href="#你知道有哪些Redis分区实现方案？" class="headerlink" title="你知道有哪些Redis分区实现方案？"></a>你知道有哪些Redis分区实现方案？</h3><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<h3 id="Redis分区有什么缺点？"><a href="#Redis分区有什么缺点？" class="headerlink" title="Redis分区有什么缺点？"></a>Redis分区有什么缺点？</h3><ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><ul>
<li>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用setNx命令实现分布式锁。</li>
<li>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 setNx不做任何动作</li>
<li>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</li>
<li>返回值：设置成功，返回 1 。设置失败，返回 0 。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/1717449461a98262~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>使用setNx完成同步锁的流程及事项如下：</li>
<li>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</li>
<li>为了防止获取锁后程序出现异常，导致其他线程/进程调用setNx命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间释放锁，使用DEL命令将锁数据删除</li>
</ul>
<h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><ul>
<li>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</li>
<li>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</li>
<li>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在实践中，当然是从以可靠性为主。所以首推Zookeeper。</span><br></pre></td></tr></table></figure>
<h3 id="分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><ul>
<li>既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</li>
<li>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</li>
<li>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</li>
</ul>
<h3 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h3><ul>
<li><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 </p>
<p>Redlock</p>
<p>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
</li>
</ul>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h4 id="什么是redis穿透？"><a href="#什么是redis穿透？" class="headerlink" title="什么是redis穿透？"></a>什么是redis穿透？</h4><ul>
<li>就是用户请求透过redis去请求mysql服务器，导致mysql压力过载。但一个web服务里，极容易出现瓶颈的就是mysql，所以才让redis去分担mysql 的压力，所以这种问题是万万要避免的</li>
<li>解决方法：<ol>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
</li>
</ul>
<h4 id="什么是redis雪崩？"><a href="#什么是redis雪崩？" class="headerlink" title="什么是redis雪崩？"></a>什么是redis雪崩？</h4><ul>
<li>就是redis服务由于负载过大而宕机，导致mysql的负载过大也宕机，最终整个系统瘫痪</li>
<li>解决方法：<ol>
<li>redis集群，将原来一个人干的工作，分发给多个人干</li>
<li>缓存预热（关闭外网访问，先开启mysql，通过预热脚本将热点数据写入缓存中，启动缓存。开启外网服务）</li>
<li>数据不要设置相同的生存时间，不然过期时，redis压力会大 </li>
</ol>
</li>
</ul>
<h4 id="什么是redis穿透？-1"><a href="#什么是redis穿透？-1" class="headerlink" title="什么是redis穿透？"></a>什么是redis穿透？</h4><ul>
<li>高并发下，由于一个key失效，而导致多个线程去mysql查同一业务数据并存到redis（并发下，存了多份数据），而一段时间后，多份数据同时失效。导致压力骤增</li>
<li>解决方法：<ol>
<li>分级缓存（缓存两份数据，第二份数据生存时间长一点作为备份，第一份数据用于被请求命中，如果第二份数据被命中说明第一份数据已经过期，要去mysql请求数据重新缓存两份数据）</li>
<li>计划任务（假如数据生存时间为30分钟，计划任务就20分钟执行一次更新缓存数据）</li>
</ol>
</li>
</ul>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><ul>
<li><strong>缓存预热</strong>就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li>
<li><strong>解决方案</strong><ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
</li>
</ul>
<h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><ul>
<li>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</li>
<li><strong>缓存降级</strong>的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</li>
<li>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
</li>
<li>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</li>
</ul>
<h3 id="热点数据和冷数据"><a href="#热点数据和冷数据" class="headerlink" title="热点数据和冷数据"></a>热点数据和冷数据</h3><ul>
<li>热点数据，缓存才有价值</li>
<li>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</li>
<li>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</li>
<li>数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</li>
<li>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</li>
</ul>
<h3 id="缓存热点key"><a href="#缓存热点key" class="headerlink" title="缓存热点key"></a>缓存热点key</h3><ul>
<li>缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询</li>
</ul>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐用哪个？</h3><ul>
<li>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</li>
</ul>
<h3 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h3><ul>
<li>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</li>
</ul>
<h3 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h3><ul>
<li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Redis与Memcached的区别"><a href="#Redis与Memcached的区别" class="headerlink" title="Redis与Memcached的区别"></a>Redis与Memcached的区别</h3><ul>
<li>两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同：</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>对比参数</th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>1. 支持内存 2. 非关系型数据库</td>
<td>1. 支持内存 2. 键值对形式 3. 缓存形式</td>
</tr>
<tr>
<td>数据存储类型</td>
<td>1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td>
<td>1. 文本型 2. 二进制类型</td>
</tr>
<tr>
<td>查询【操作】类型</td>
<td>1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td>
<td>1.常用的CRUD 2. 少量的其他命令</td>
</tr>
<tr>
<td>附加功能</td>
<td>1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td>
<td>1. 多线程服务支持</td>
</tr>
<tr>
<td>网络IO模型</td>
<td>1. 单线程的多路 IO 复用模型</td>
<td>1. 多线程，非阻塞IO模式</td>
</tr>
<tr>
<td>事件库</td>
<td>自封转简易事件库AeEvent</td>
<td>贵族血统的LibEvent事件库</td>
</tr>
<tr>
<td>持久化支持</td>
<td>1. RDB 2. AOF</td>
<td>不支持</td>
</tr>
<tr>
<td>集群模式</td>
<td>原生支持 cluster 模式，可以实现主从复制，读写分离</td>
<td>没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td>内存管理机制</td>
<td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td>
<td>Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</td>
</tr>
<tr>
<td>适用场景</td>
<td>复杂数据结构，有持久化，高可用需求，value存储内容较大</td>
<td>纯key-value，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
</blockquote>
<ol>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li>
<li>redis的速度比memcached快很多</li>
<li>redis可以持久化其数据</li>
</ol>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><ul>
<li>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</li>
<li>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</li>
<li>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</li>
<li>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>问题场景</th>
<th>描述</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td>
<td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td>
</tr>
<tr>
<td>先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td>
<td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td>需要缓存异步刷新</td>
<td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候</td>
<td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td>
</tr>
</tbody></table>
<h3 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h3><ol>
<li>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库</li>
<li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li>
<li>为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。</li>
</ol>
<h3 id="Redis官方为什么不提供Windows版本？"><a href="#Redis官方为什么不提供Windows版本？" class="headerlink" title="Redis官方为什么不提供Windows版本？"></a>Redis官方为什么不提供Windows版本？</h3><ul>
<li>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</li>
</ul>
<h3 id="一个字符串类型的值能存储最大容量是多少？"><a href="#一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="一个字符串类型的值能存储最大容量是多少？"></a>一个字符串类型的值能存储最大容量是多少？</h3><ul>
<li>512M</li>
</ul>
<h3 id="Redis如何做大量数据插入？"><a href="#Redis如何做大量数据插入？" class="headerlink" title="Redis如何做大量数据插入？"></a>Redis如何做大量数据插入？</h3><ul>
<li>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</li>
</ul>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><ul>
<li>使用keys指令可以扫出指定模式的key列表。</li>
<li>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br> 这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</li>
</ul>
<h3 id="使用Redis做过异步队列吗，是如何实现的"><a href="#使用Redis做过异步队列吗，是如何实现的" class="headerlink" title="使用Redis做过异步队列吗，是如何实现的"></a>使用Redis做过异步队列吗，是如何实现的</h3><ul>
<li>使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</li>
</ul>
<h3 id="Redis如何实现延时队列"><a href="#Redis如何实现延时队列" class="headerlink" title="Redis如何实现延时队列"></a>Redis如何实现延时队列</h3><ul>
<li>使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。</li>
</ul>
<h3 id="Redis回收进程如何工作的？"><a href="#Redis回收进程如何工作的？" class="headerlink" title="Redis回收进程如何工作的？"></a>Redis回收进程如何工作的？</h3><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</span><br></pre></td></tr></table></figure>
<h3 id="Redis回收使用的是什么算法？"><a href="#Redis回收使用的是什么算法？" class="headerlink" title="Redis回收使用的是什么算法？"></a>Redis回收使用的是什么算法？</h3><ul>
<li>LRU算法</li>
</ul>
<p>作者：小杰要吃蛋<br>链接：<a href="https://juejin.cn/post/6844904127055527950">https://juejin.cn/post/6844904127055527950</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试-MySQL</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95-MySQL/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>搬运自掘金用户：<a href="https://juejin.cn/user/2506542243918030/posts">小杰要吃蛋</a> [侵删]</p>
<h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h2><h3 id="MySQL的基础架构"><a href="#MySQL的基础架构" class="headerlink" title="MySQL的基础架构"></a>MySQL的基础架构</h3><p><img src="https://origin.chaizz.com/tc/1b6231d5b2c743578011db68868dd051.png" alt="img"></p>
<h3 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h3><ul>
<li><strong>数据保存在内存</strong><ul>
<li>优点： 存取速度快</li>
<li>缺点： 数据不能永久保存</li>
</ul>
</li>
<li><strong>数据保存在文件</strong><ul>
<li>优点： 数据永久保存</li>
<li>缺点：1、速度比内存操作慢，频繁的IO操作。2、查询数据不方便</li>
</ul>
</li>
<li><strong>数据保存在数据库</strong><ul>
<li>数据永久保存</li>
<li>使用SQL语句，查询方便效率高。</li>
<li>管理数据方便</li>
</ul>
</li>
</ul>
<h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h3><ul>
<li>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用：用于存取数据、查询、更新和管理关系数据库系统。</span><br></pre></td></tr></table></figure>
<h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h3><ul>
<li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</li>
</ul>
<h3 id="MySql-Oracle，Sql-Service的区别"><a href="#MySql-Oracle，Sql-Service的区别" class="headerlink" title="MySql, Oracle，Sql Service的区别"></a>MySql, Oracle，Sql Service的区别</h3><ol>
<li>Sql Service只能在Windows上使用，而MySql和Oracle可以在其他系统上使用，    而且可以支持数据库不同系统之间的移植</li>
<li>MySql开源免费的，Sql Service和Oracle要钱。</li>
<li>我从小到大排序哈，MySql很小，Sql Service居中，Oracle最大</li>
<li>Oracle支持大并发量，大访问量，Sql Service还行，而MySql的话压力没这么大，因此现在的MySql的话最好是要使用集群或者缓存来搭配使用</li>
<li>Oracle支持多用户不同权限来进行操作，而MySql只要有登录权限就可操作全部数据库</li>
<li>安装所用的空间差别也是很大的，Mysql安装完后才几百M而Oracle有几G左右，且使用的时候Oracle占用特别大的内存空间和其他机器性能。</li>
<li>做分页的话，MySql使用Limit，Sql Service使用top，Oracle使用row</li>
<li>Oracle没有自动增长类型，Mysql和Sql Service一般使用自动增长类型</li>
</ol>
<h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h3><ul>
<li>第一范式：每个列都不可以再拆分。</li>
<li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li>
<li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</span><br></pre></td></tr></table></figure>
<h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql\_install\_db脚本初始化。这些权限表分别user，db，table\_priv，columns\_priv和host。下面分别介绍一下这些表的结构和内容：</span><br></pre></td></tr></table></figure>
<ul>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv权限表：记录数据表级的操作权限。</li>
<li>columns_priv权限表：记录数据列级的操作权限。</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ul>
<h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有三种格式，statement，row和mixed。</span><br></pre></td></tr></table></figure>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</span><br></pre></td></tr></table></figure>
<h3 id="数据库经常使用的函数"><a href="#数据库经常使用的函数" class="headerlink" title="数据库经常使用的函数"></a>数据库经常使用的函数</h3><ul>
<li>count(*/column)：返回行数</li>
<li>sum(column)： 返回指定列中唯一值的和</li>
<li>max(column)：返回指定列或表达式中的数值最大值</li>
<li>min(column)：返回指定列或表达式中的数值最小值</li>
<li>avg(column)：返回指定列或表达式中的数值平均值</li>
<li>date（Expression）: 返回指定表达式代表的日期值</li>
</ul>
<p>……</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h3><blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>类型名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>tinyInt</td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td>整数类型</td>
<td>smallint</td>
<td>小的整数(16位二进制)</td>
</tr>
<tr>
<td>整数类型</td>
<td>mediumint</td>
<td>中等大小的整数(24位二进制)</td>
</tr>
<tr>
<td>整数类型</td>
<td>int(integer)</td>
<td>普通大小的整数(32位二进制)</td>
</tr>
<tr>
<td>小数类型</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>小数类型</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>小数类型</td>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td>日期类型</td>
<td>year</td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td>日期类型</td>
<td>time</td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td>日期类型</td>
<td>date</td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td>日期类型</td>
<td>datetime</td>
<td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td>日期类型</td>
<td>timestamp</td>
<td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>CHAR(M)</td>
<td>M为0~255之间的整数</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>VARCHAR(M)</td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>TINYBLOB</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>BLOB</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>MEDIUMBLOB</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>LONGBLOB</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>TINYTEXT</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>TEXT</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>MEDIUMTEXT</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>LONGTEXT</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>VARBINARY(M)</td>
<td>允许长度0~M个字节的变长字节字符串</td>
</tr>
<tr>
<td>文本、二进制类型</td>
<td>BINARY(M)</td>
<td>允许长度0~M个字节的定长字节字符串</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li><p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br> <code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br> <code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
</li>
<li><p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。<br> DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br> 而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br> 计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
</li>
<li><p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB<br> VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br> VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br> VARCHAR存储的内容超出设置的长度时，内容会被截断。<br> CHAR是定长的，根据定义的字符串长度分配足够的空间。<br> CHAR会根据需要使用空格进行填充方便比较。<br> CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br> CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>
<p><strong>使用策略：</strong><br> 对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br> 对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br> 使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br> 尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
</li>
<li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br> 有时可以使用ENUM代替常用的字符串类型。<br> ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br> ENUM在内部存储时，其实存的是整数。<br> 尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br> 排序是按照内部存储的整数</p>
</li>
<li><p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime，<br> 用整数保存时间戳通常不方便处理。<br> 如果需要存储微妙，可以使用bigint存储。<br> 看到这里，这道真题是不是就比较容易回答了。</p>
</li>
</ul>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><ul>
<li>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</li>
<li>常用的存储引擎有以下：<ul>
<li><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
</li>
</ul>
<p><strong>MyISAM与InnoDB区别</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th>比较</th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td>数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM更优</td>
<td>–</td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td>–</td>
<td>InnoDB更优</td>
</tr>
<tr>
<td>select count(*)</td>
<td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam 是堆表</td>
<td>B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><ul>
<li>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</li>
<li>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</li>
<li>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><ul>
<li>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</li>
<li>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</li>
</ul>
<h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><p><strong>索引的优点</strong></p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p><strong>索引的缺点</strong></p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3 id="怎么创建索引的，有什么好处，有哪些分类"><a href="#怎么创建索引的，有什么好处，有哪些分类" class="headerlink" title="怎么创建索引的，有什么好处，有哪些分类"></a>怎么创建索引的，有什么好处，有哪些分类</h3><ol>
<li>创建索引的语法：create index depe_unique_ide on depe(dept_no) tablespace idx_</li>
<li>创建索引可以增加查询速度，唯一索引可以保证数据库列的一致性，可以确定表与表之间的连接</li>
<li>索引的分类：             逻辑分类：单列索引，复合索引，唯一索引，非唯一索引，函数索引             物理分类：B数索引，反向键索引，位图索引</li>
</ol>
<h3 id="简述有哪些索引和作用"><a href="#简述有哪些索引和作用" class="headerlink" title="简述有哪些索引和作用"></a>简述有哪些索引和作用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引的作用：通过索引可以大大的提高数据库的检索速度，改善数据库性能</span><br></pre></td></tr></table></figure>
<ol>
<li>唯一索引：不允许有俩行具有相同的值</li>
<li>主键索引：为了保持数据库表与表之间的关系</li>
<li>聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。</li>
<li>非聚集索引：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致</li>
<li>复合索引：在创建索引时，并不是只能对一列进行创建索引，可以与主键一样，讲多个组合为索引</li>
<li>全文索引： 全文索引为在字符串数据中进行复杂的词搜索提供有效支持</li>
</ol>
<h3 id="索引使用场景"><a href="#索引使用场景" class="headerlink" title="索引使用场景"></a>索引使用场景</h3><ol>
<li>当数据多且字段值有相同的值得时候用普通索引。</li>
<li>当字段多且字段值没有重复的时候用唯一索引。</li>
<li>当有多个字段名都经常被查询的话用复合索引。</li>
<li>普通索引不支持空值，唯一索引支持空值。</li>
<li>但是，若是这张表增删改多而查询较少的话，就不要创建索引了，因为如果你给一列创建了索引，那么对该列进行增删改的时候，都会先访问这一列的索引，</li>
<li>若是增，则在这一列的索引内以新填入的这个字段名的值为名创建索引的子集，</li>
<li>若是改，则会把原来的删掉，再添入一个以这个字段名的新值为名创建索引的子集，</li>
<li>若是删，则会把索引中以这个字段为名的索引的子集删掉。</li>
<li>所以，会对增删改的执行减缓速度，</li>
<li>所以，若是这张表增删改多而查询较少的话，就不要创建索引了。</li>
<li>更新太频繁地字段不适合创建索引。</li>
<li>不会出现在where条件中的字段不该建立索引。</li>
</ol>
<h3 id="主键索引与唯一索引的区别"><a href="#主键索引与唯一索引的区别" class="headerlink" title="主键索引与唯一索引的区别"></a>主键索引与唯一索引的区别</h3><ol>
<li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li>
<li>主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。</li>
<li>唯一性索引列允许空值，而主键列不允许为空值。</li>
<li>主键列在创建时，已经默认为空值 ++    唯一索引了。</li>
<li>一个表最多只能创建一个主键，但可以创建多个唯一索引。</li>
<li>主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。</li>
<li>主键可以被其他表引用为外键，而唯一索引不能。   ？</li>
</ol>
<h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li>
</ul>
<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li>
</ul>
<h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a>索引的数据结构（b树，hash）</h3><ul>
<li>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
</ul>
<p><strong>1、B树索引</strong></p>
<ul>
<li>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6ee6f5752~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>查询方式：<ul>
<li>主键索引区:PI(关联保存的时数据的地址)按主键查询,</li>
<li>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</li>
</ul>
</li>
<li>B+tree性质：<ol>
<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>
</ol>
</li>
</ul>
<p><strong>2、哈希索引</strong></p>
<ul>
<li>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6ef9cb120~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ul>
<li>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</li>
<li>索引的原理很简单，就是把无序的数据变成有序的查询<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
</li>
</ul>
<h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a>索引算法有哪些？</h3><ul>
<li>索引算法有 BTree算法和Hash算法</li>
</ul>
<p><strong>1、BTree算法</strong></p>
<ul>
<li><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码-- 只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">select * from user where name like &#39;jack%&#39;; </span><br><span class="line">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like &#39;%jack&#39;; </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2、Hash算法</strong></p>
<ul>
<li>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</li>
</ul>
<h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a>索引设计的原则？</h3><ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ul>
<li>索引虽好，但也不是无限制的使用，最好符合一下几个原则</li>
</ul>
<ol>
<li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>较频繁作为查询条件的字段才去创建索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ol>
<h3 id="创建索引的三种方式"><a href="#创建索引的三种方式" class="headerlink" title="创建索引的三种方式"></a>创建索引的三种方式</h3><ul>
<li><p>第一种方式：在执行CREATE TABLE时创建索引</p>
<p>CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );</p>
</li>
<li><p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br></pre></td></tr></table></figure>
<ul>
<li>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</li>
<li>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</li>
<li>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</li>
</ul>
</li>
<li><p>第三种方式：使用CREATE INDEX命令创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码CREATE INDEX index_name ON table_name (column_list);</span><br></pre></td></tr></table></figure>
<ul>
<li>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</li>
</ul>
</li>
</ul>
<h3 id="如何删除索引"><a href="#如何删除索引" class="headerlink" title="如何删除索引"></a>如何删除索引</h3><ul>
<li><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码alter table user_index drop KEY name;</span><br><span class="line">alter table user_index drop KEY id_card;</span><br><span class="line">alter table user_index drop KEY information;</span><br></pre></td></tr></table></figure></li>
<li><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6ef8bc6a4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><p>需要取消自增长再行删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码alter table user_index</span><br><span class="line">-- 重新定义字段</span><br><span class="line">MODIFY id int,</span><br><span class="line">drop PRIMARY KEY</span><br></pre></td></tr></table></figure></li>
<li><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
</li>
</ul>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</span><br></pre></td></tr></table></figure>
<ul>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><ul>
<li>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</li>
</ul>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul>
<li>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</li>
<li>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</li>
<li>实操的难度：在于前缀截取的长度。</li>
<li>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</li>
</ul>
<h3 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a>什么是最左前缀原则？什么是最左匹配原则</h3><ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h3><ul>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6efdfc051~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h3><ul>
<li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</li>
</ul>
<h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a>使用B+树的好处</h3><ul>
<li>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</li>
</ul>
<h3 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h3><ul>
<li>首先要知道Hash索引和B+树索引的底层实现原理：</li>
<li>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</li>
</ul>
<p><strong>那么可以看出他们有以下的不同：</strong></p>
<ul>
<li><p>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</p>
</li>
<li><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
</li>
<li><p>hash索引不支持使用索引进行排序，原理同上。</p>
</li>
<li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</p>
</li>
<li><p>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</p>
</li>
<li><p>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</p>
</li>
<li><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>
</li>
</ul>
<h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h3><ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h3 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3><ul>
<li>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</span><br></pre></td></tr></table></figure>
<h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3><ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">何时使用聚簇索引与非聚簇索引</span><br></pre></td></tr></table></figure>


<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6f013b994~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><ul>
<li>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</li>
<li>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</li>
</ul>
<h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><ul>
<li>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</li>
</ul>
<p><strong>具体原因为:</strong></p>
<ul>
<li>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</li>
<li>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><ul>
<li>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</li>
<li>事务最经典也经常被拿出来说例子就是转账了。</li>
<li>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</li>
</ul>
<h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a>事物的四大特性(ACID)介绍一下?</h3><ul>
<li>关系性数据库需要遵循ACID规则，具体内容如下：</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c6f098cc5d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="事务的ACID是如何实现的？"><a href="#事务的ACID是如何实现的？" class="headerlink" title="事务的ACID是如何实现的？"></a>事务的ACID是如何实现的？</h3><p>原子性：是由 undo log 日志实现的，记录了回滚所需要的日志信息。</p>
<p>一致性：通过其他的三大特性来实现的。</p>
<p>隔离性：是通过 mvcc 实现的。</p>
<p>持久性：由 redo log 来实现的。</p>
<h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。**(读到了另一个事务未提交的事务， 针对的是同一列数据)**</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 <strong>(在同一个事务中， 针对的是同一列数据，两次或者多次读取数据不一致)</strong></li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。<strong>（在同一个事务中的两次查询中。读取到了新增（insert）的数据）</strong></li>
</ul>
<h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED (MVCC实现) 能够读取到最新的，read view (是MVCC的当前读)</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ (MVCC实现) (是MVCC的快照读)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</li>
<li>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</li>
<li>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</li>
<li>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</li>
</ul>
<h3 id="InnoDB是如何实现事务的？"><a href="#InnoDB是如何实现事务的？" class="headerlink" title="InnoDB是如何实现事务的？"></a>InnoDB是如何实现事务的？</h3><p>InnoDB 是通过 Buffer Pool、LogBuffer、Redo log、Undo log 来实现事务的，比如以一个update为例；</p>
<ol>
<li>首先会根据条件查找到数据所在的页，并将该页缓存到 Buffer Pool 中。</li>
<li>执行update语句，在修改 Buffer Pool 中的数据，也就是内存中的数据。</li>
<li>针对 Update 语句生成一个 Redo log 对象，并存入 LogBuffer 中。</li>
<li>在针对 Update 语句生成一个 Undo log 对象， 用于事务额度回滚。</li>
<li>如果是事务提交，那么把  Redo log 对象 持久化，然后再把 Buffer Pool 中 中修改的数据持久化。</li>
<li>如果是事务回滚，则使用 Undo log 对象进行回滚。</li>
</ol>
<h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>多版本并发控制，读取数据时通过类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务会看到特定版本的数据称为版本链。MVCC只在 RC 和 RR 的隔离级别下工作。因为读未提交总是读取最新的数据行，而不是符合当前事务版本的数据行，串行化则是对所有读取的都加锁。 </p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a>对MySQL的锁了解吗</h3><ul>
<li>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</li>
<li>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</li>
</ul>
<h3 id="MySQL-不同维度下的锁"><a href="#MySQL-不同维度下的锁" class="headerlink" title="MySQL 不同维度下的锁"></a>MySQL 不同维度下的锁</h3><ol>
<li><p>基于锁的类别：</p>
<ol>
<li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁就是让多个线程同时获取一个锁。</li>
<li>排他锁：又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排它锁也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li>
</ol>
</li>
<li><p>基于锁的粒度：</p>
<ol>
<li><p><strong>表锁</strong> （Innodb 和 myisam 以及 BDB 引擎都会有）：锁住的是整个表， 必须等前一个锁释放了，才可以对整个表进行操作。不会有死锁。</p>
<ol>
<li>特点：粒度大、加锁简单、开销较小、但是容易冲突，并发度低。</li>
<li>加锁方式：myisam 执行查询会自动加读锁，执行DML语句时会自动加写锁。</li>
</ol>
</li>
<li><p><strong>行锁</strong> （Innodb 引擎才会有的）：锁住的事一行或者多行记录，被锁住的记录不能被访问。特点：力度小，加锁必表锁麻烦，开销略大、不容易冲突，并发度必表锁高。会有死锁。</p>
</li>
<li><p><strong>页锁</strong> （BDB 引擎才会有）：锁住的粒度介于表锁和行锁之间。一次锁定一个数据页的记录。特点：页的大小可以通过mysql的 innodb_page_size 去设置。开销和加锁时间介于表锁和行锁之间，会出现死锁，并发度也介于表锁和行锁之间。</p>
</li>
<li><p><strong>记录锁（Record Lock）</strong>：也行锁的一种，但是记录锁的范围是一行记录，精准命中，命中的条件字段是唯一索引。特点：可以避免在查询的时候产生重复读的问题，也避免了在修改的事务未提交前被其他的事务读取的脏数据的问题。</p>
</li>
<li><p><strong>间隙锁（Gap lock）</strong>：属于行锁的一种，锁住的是表记录的一个区间，当表的ID之间出现间隙则会形成一个区间，遵循左开右开原则。</p>
<p>范围查询切查询未命中记录，查询条件必须命中索引、间隙锁只会出现在 可重复度的事务隔离界别中，</p>
<p>触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会在一个事务里两次查询得到的结果不一致。</p>
<p>例如：表里面的数据ID为1、4、5、7、10，那么会形成一下的几个间隙区间， -n-1、1-4、4-7、7-10、10-n (-n:达标负无穷大，n:代表无穷大)</p>
</li>
<li><p><strong>临键锁（Next-key Lock）</strong>：也是行锁的一种，是InnoDB的锁默认算法。是记录锁和间隙锁的一种组合，临建锁会把查询出来的记录锁上，也会把其中的间隙锁上。再之也会把相邻的下一个区间也锁住。在范围区间内数据不允许被修改和插入。遵循左开右闭原则。</p>
</li>
</ol>
</li>
<li><p>基于锁的状态</p>
<p>当已经有事务在表中的记录上加上排他锁以后，会在表上也添加一个意向排他锁，告诉其他的事务不能对这个表加排他锁或者共享锁了。这样可以避免其他的事务需要遍历这个表中的锁。这个表上的锁就是意向锁。</p>
<ol>
<li>意向共享锁：当一个事务对整个表添加共享锁之前，需要获取当前这个表的意向共享锁。</li>
<li>意向排他锁：当一个事务对整个表添加排他锁之前，需要获取当前这个表的意向排他锁。</li>
</ol>
</li>
</ol>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ul>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li>
<li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li>
</ul>
<h3 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><ul>
<li>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</li>
<li><strong>MyISAM和InnoDB存储引擎使用的锁：</strong><ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>
</ul>
</li>
</ul>
<p><strong>行级锁，表级锁和页级锁对比</strong></p>
<ul>
<li><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。<ul>
<li>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
</li>
<li><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<ul>
<li>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li>
</ul>
</li>
<li><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<ul>
<li>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
</li>
</ul>
<h3 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><ul>
<li>InnoDB是基于索引来完成行锁</li>
<li>例: select * from tab_with_index where id = 1 for update;</li>
<li>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</li>
</ul>
<h3 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a>InnoDB存储引擎的锁的算法有三种</h3><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p><strong>相关知识点：</strong></p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</li>
<li>常见的解决死锁的方法<ul>
<li>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果业务不好处理,可以用分布式事务锁或者使用乐观锁</span><br></pre></td></tr></table></figure>
<h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><ul>
<li><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
</li>
<li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码&#x2F;&#x2F;核心SQL,主要靠for update</span><br><span class="line">select status from t_goods where id&#x3D;1 for update;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码&#x2F;&#x2F;核心SQL</span><br><span class="line">update table set x&#x3D;x+1, version&#x3D;version+1 where id&#x3D;#&#123;id&#125; and version&#x3D;#&#123;version&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>两种锁的使用场景</strong></p>
<ul>
<li>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li>
<li>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h3><ul>
<li>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</li>
<li>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</li>
</ul>
<h3 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a>视图有哪些特点？</h3><p><strong>视图的特点如下:</strong></p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h3 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a>视图的使用场景有哪些？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</span><br></pre></td></tr></table></figure>
<p><strong>下面是视图的常见使用场景：</strong></p>
<ul>
<li>重用SQL语句；</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a>视图的缺点</h3><ol>
<li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
<li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p>
<p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p>
</li>
</ol>
<h3 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a>什么是游标？</h3><ul>
<li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</li>
</ul>
<h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><ul>
<li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li>
</ul>
<p><strong>优点</strong></p>
<ol>
<li>存储过程是预编译过的，执行效率高。</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
<li>安全性高，执行存储过程需要有一定权限的用户。</li>
<li>存储过程可以重复使用，减少数据库开发人员的工作量。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</li>
<li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li>
<li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li>
<li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li>
</ol>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a>什么是触发器？触发器的使用场景有哪些？</h3><ul>
<li>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>
</ul>
<h3 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h3><p><strong>在MySQL数据库中有如下六种触发器：</strong></p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h3><ul>
<li><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
</li>
<li><p>数据查询语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
</li>
<li><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
</li>
<li><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
</li>
</ul>
<h3 id="SQL语句的语法顺序："><a href="#SQL语句的语法顺序：" class="headerlink" title="SQL语句的语法顺序："></a>SQL语句的语法顺序：</h3><ol>
<li>SELECT</li>
<li>FROM</li>
<li>JOIN</li>
<li>ON</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li>ORDER BY</li>
<li>LIMIT</li>
</ol>
<h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h3><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><blockquote>
<p>SQL 约束有哪几种？</p>
</blockquote>
<ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h3><ul>
<li><p>交叉连接（CROSS JOIN）</p>
</li>
<li><p>内连接（INNER JOIN）</p>
</li>
<li><p>外连接（LEFT JOIN/RIGHT JOIN）</p>
</li>
<li><p>联合查询（UNION与UNION ALL）</p>
</li>
<li><p>全连接（FULL JOIN）</p>
</li>
<li><p>交叉连接（CROSS JOIN）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id&#x3D;B.id或者SELECT * FROM A INNER JOIN B ON A.id&#x3D;B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>内连接分为三类</strong></p>
<ul>
<li>等值连接：ON A.id=B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p>
<ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p><strong>联合查询（UNION与UNION ALL）</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">复制代码<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure>
<ul>
<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<p><strong>全连接（FULL JOIN）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码SELECT * FROM A LEFT JOIN B ON A.id&#x3D;B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id&#x3D;B.id</span><br></pre></td></tr></table></figure>
<ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<h4 id="表连接面试题"><a href="#表连接面试题" class="headerlink" title="表连接面试题"></a>表连接面试题</h4><h5 id="有2张表。"><a href="#有2张表。" class="headerlink" title="有2张表。"></a>有2张表。</h5><ul>
<li>1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录</li>
</ul>
<p><strong>R表</strong></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p><strong>S表</strong></p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h5 id="1、交叉连接-笛卡尔积"><a href="#1、交叉连接-笛卡尔积" class="headerlink" title="1、交叉连接(笛卡尔积)"></a>1、交叉连接(笛卡尔积)</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select r.*,s.* from r,s</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h5 id="2、内连接结果"><a href="#2、内连接结果" class="headerlink" title="2、内连接结果"></a>2、内连接结果</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select r.*,s.* from r inner join s on r.c&#x3D;s.c</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<h5 id="3、左连接结果"><a href="#3、左连接结果" class="headerlink" title="3、左连接结果"></a>3、左连接结果</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select r.*,s.* from r left join s on r.c&#x3D;s.c</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="4、右连接结果"><a href="#4、右连接结果" class="headerlink" title="4、右连接结果"></a>4、右连接结果</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select r.*,s.* from r right join s on r.c&#x3D;s.c</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h5 id="5、全表连接的结果（MySql不支持，Oracle支持）"><a href="#5、全表连接的结果（MySql不支持，Oracle支持）" class="headerlink" title="5、全表连接的结果（MySql不支持，Oracle支持）"></a>5、全表连接的结果（MySql不支持，Oracle支持）</h5><ul>
<li>SQL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select r.*,s.* from r full join s on r.c&#x3D;s.c</span><br></pre></td></tr></table></figure>
<ul>
<li>结果</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a>什么是子查询</h3><ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
<h3 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a>mysql中 in 和 exists 区别</h3><ul>
<li>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。<ol>
<li>如果查询的两个表大小相当，那么用in和exists差别不大。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>
<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>
</ol>
</li>
</ul>
<h3 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p>
<ul>
<li>char表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p><strong>varchar的特点</strong></p>
<ul>
<li>varchar表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</span><br></pre></td></tr></table></figure>
<h3 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a>varchar(50)中50的涵义</h3><ul>
<li>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</li>
</ul>
<h3 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a>int(20)中20的涵义</h3><ul>
<li>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</li>
<li>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</li>
</ul>
<h3 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a>mysql为什么这么设计</h3><ul>
<li>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</li>
</ul>
<h3 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul>
<li>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</li>
<li>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</li>
<li>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</li>
</ul>
<h3 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a>FLOAT和DOUBLE的区别是什么？</h3><ul>
<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>
<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>
</ul>
<h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h3><ul>
<li>三者都表示删除，但是三者有一些差别：</li>
</ul>
<table>
<thead>
<tr>
<th>比较</th>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody></table>
<ul>
<li>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</li>
</ul>
<h3 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h3><ul>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="说出一些数据库优化方面的经验"><a href="#说出一些数据库优化方面的经验" class="headerlink" title="说出一些数据库优化方面的经验?"></a>说出一些数据库优化方面的经验?</h3><ol>
<li>有外键约束的话会影响增删改的性能，如果应用程序可以保证数据库的完整性那就去除外键</li>
<li>Sql语句全部大写，特别是列名大写，因为数据库的机制是这样的，sql语句发送到数据库服务器，数据库首先就会把sql编译成大写在执行，如果一开始就编译成大写就不需要了把sql编译成大写这个步骤了</li>
<li>如果应用程序可以保证数据库的完整性，可以不需要按照三大范式来设计数据库</li>
<li>其实可以不必要创建很多索引，索引可以加快查询速度，但是索引会消耗磁盘空间</li>
<li>如果是jdbc的话，使用PreparedStatement不使用Statement，来创建SQl，PreparedStatement的性能比Statement的速度要快，使用PreparedStatement对象SQL语句会预编译在此对象中，PreparedStatement对象可以多次高效的执行</li>
</ol>
<h3 id="怎么优化SQL查询语句吗"><a href="#怎么优化SQL查询语句吗" class="headerlink" title="怎么优化SQL查询语句吗"></a>怎么优化SQL查询语句吗</h3><ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li>
<li>用索引可以提高查询</li>
<li>SELECT子句中避免使用*号，尽量全部大写SQL</li>
<li>应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL</li>
<li>where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描</li>
</ol>
<h3 id="你怎么知道SQL语句性能是高还是低"><a href="#你怎么知道SQL语句性能是高还是低" class="headerlink" title="你怎么知道SQL语句性能是高还是低"></a>你怎么知道SQL语句性能是高还是低</h3><ol>
<li>查看SQL的执行时间</li>
<li>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</li>
</ol>
<h3 id="SQL的执行顺序"><a href="#SQL的执行顺序" class="headerlink" title="SQL的执行顺序"></a>SQL的执行顺序</h3><ol>
<li>FROM：将数据从硬盘加载到数据缓冲区，方便对接下来的数据进行操作。</li>
<li>WHERE：从基表或视图中选择满足条件的元组。（不能使用聚合函数）</li>
<li>JOIN（如right left 右连接——-从右边表中读取某个元组，并且找到该元组在左边表中对应的元组或元组集）</li>
<li>ON：join on实现多表连接查询，推荐该种方式进行多表查询，不使用子查询。</li>
<li>GROUP BY：分组，一般和聚合函数一起使用。</li>
<li>HAVING：在元组的基础上进行筛选，选出符合条件的元组。（一般与GROUP BY进行连用）</li>
<li>SELECT：查询到得所有元组需要罗列的哪些列。</li>
<li>DISTINCT：去重的功能。</li>
<li>UNION：将多个查询结果合并（默认去掉重复的记录）。</li>
<li>ORDER BY：进行相应的排序。</li>
<li>LIMIT 1：显示输出一条数据记录（元组）</li>
</ol>
<h3 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><ul>
<li>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c720eda1ef~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><p>执行计划包含的信息 </p>
<p>id</p>
<p> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>不包含任何子查询或union等查询</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td>3</td>
<td>SUBQUERY</td>
<td>在select或 where字句中包含的查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td>from字句中包含的查询</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>出现在union后的查询语句中</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从UNION中获取结果集，例如上文的第三个例子</td>
</tr>
</tbody></table>
<ul>
<li><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码create table tmp (</span><br><span class="line">    id int unsigned not null AUTO_INCREMENT,</span><br><span class="line">    name varchar(255),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) engine &#x3D; innodb</span><br><span class="line">partition by key (id) partitions 5;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对Null进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>
</ul>
</li>
<li><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</li>
<li><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</li>
<li><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</li>
<li><strong>key_length</strong> 索引长度</li>
<li><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</li>
<li><strong>extra</strong> 的信息非常丰富，常见的有：<ol>
<li>Using index 使用覆盖索引</li>
<li>Using where 使用了用where子句来过滤结果集</li>
<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li>
<li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 </span><br><span class="line">说明： </span><br><span class="line">1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 </span><br><span class="line">2） ref 指的是使用普通的索引（normal index）。 </span><br><span class="line">3） range 对索引进行范围检索。 </span><br><span class="line">反例：explain表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</span><br></pre></td></tr></table></figure>
<h3 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h3><ol>
<li>应用服务器与数据库服务器建立一个连接</li>
<li>数据库进程拿到请求sql</li>
<li>解析并生成执行计划，执行</li>
<li>读取数据到内存并进行逻辑处理</li>
<li>通过步骤一的连接，发送结果到客户端</li>
<li>关掉连接，释放资源</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7211423d0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h3><ol>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>
</ol>
<h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><p><strong>超大的分页一般从两个方向上来解决.</strong></p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p><strong>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可</strong></p>
<h3 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a>mysql 分页</h3><ul>
<li><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>
<p>SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</p>
</li>
<li><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>
<p>SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</p>
</li>
<li><p>如果只给定一个参数，它表示返回最大的记录行数目：</p>
<p>SELECT * FROM table LIMIT 5; //检索前 5 个记录行</p>
</li>
<li><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p>
</li>
</ul>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote>
<p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p>
</blockquote>
<ul>
<li>开启慢查询日志</li>
<li>配置项：<code>slow_query_log</code></li>
<li>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</li>
<li>设置临界时间</li>
<li>配置项：<code>long_query_time</code></li>
<li>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</li>
<li>设置：<code>set long_query_time=0.5</code></li>
<li>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</li>
<li>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</li>
</ul>
<h3 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><ul>
<li>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</li>
<li>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</li>
</ul>
<p><strong>所以优化也是针对这三个方向来的，</strong></p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a>为什么要尽量设定一个主键？</h3><ul>
<li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li>
</ul>
<h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a>主键使用自增ID还是UUID？</h3><ul>
<li>推荐使用自增ID，不要使用UUID。</li>
<li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总之，在数据量大一些的情况下，用自增主键性能会好一些。</span><br><span class="line">关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</span><br></pre></td></tr></table></figure>
<h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><ul>
<li>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</li>
</ul>
<h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><ul>
<li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li>
</ul>
<h3 id="如何优化查询过程中的数据访问"><a href="#如何优化查询过程中的数据访问" class="headerlink" title="如何优化查询过程中的数据访问"></a>如何优化查询过程中的数据访问</h3><ul>
<li>访问数据太多导致查询性能下降</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
<li>避免犯如下SQL语句错误</li>
<li>避免查询不需要的数据。解决办法：使用limit解决</li>
<li>多表关联返回全部列。解决办法：指定列名</li>
<li>总是返回全部列。解决办法：避免使用SELECT *</li>
<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>
<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>
<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>
</ul>
<h3 id="如何优化长难的查询语句"><a href="#如何优化长难的查询语句" class="headerlink" title="如何优化长难的查询语句"></a>如何优化长难的查询语句</h3><ul>
<li>分析是一个复杂查询还是多个简单查询速度快</li>
<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>
<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>
<li>将一个大的查询分为多个小的相同的查询</li>
<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>
<li>分解关联查询，让缓存的效率更高。</li>
<li>执行单个查询可以减少锁的竞争。</li>
<li>在应用层做关联更容易对数据库进行拆分。</li>
<li>查询效率会有大幅提升。</li>
<li>较少冗余记录的查询。</li>
</ul>
<h3 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h3><ul>
<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>
<li>MyISAM中，没有任何where条件的count(*)非常快。</li>
<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>
<li>可以使用explain查询近似值，用近似值替代count(*)</li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h3><ul>
<li>确定ON或者USING子句中是否有索引。</li>
<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>
</ul>
<h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h3><ul>
<li>用关联查询替代</li>
<li>优化GROUP BY和DISTINCT</li>
<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>
<li>关联查询中，使用标识列分组的效率更高</li>
<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>
<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>
</ul>
<h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><ul>
<li>LIMIT偏移量大的时候，查询效率较低</li>
<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>
</ul>
<h3 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h3><ul>
<li>UNION ALL的效率高于UNION</li>
</ul>
<h3 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a>优化WHERE子句</h3><ul>
<li>多数数据库都是从左往右的顺序处理条件的，把能够过滤更多数据的条件放到前面，把过滤少的条件放在后面</li>
</ul>
<h3 id="SQL语句优化的一些方法"><a href="#SQL语句优化的一些方法" class="headerlink" title="SQL语句优化的一些方法"></a>SQL语句优化的一些方法</h3><ul>
<li><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select id from t where num is null</span><br><span class="line">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span><br><span class="line">select id from t where num&#x3D;0</span><br></pre></td></tr></table></figure></li>
<li><p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
</li>
<li><p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select id from t where num&#x3D;10 or num&#x3D;20</span><br><span class="line">-- 可以这样查询：</span><br><span class="line">select id from t where num&#x3D;10 union all select id from t where num&#x3D;20</span><br></pre></td></tr></table></figure></li>
<li><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select id from t where num in(1,2,3) </span><br><span class="line">-- 对于连续的数值，能用 between 就不要用 in 了：</span><br><span class="line">select id from t where num between 1 and 3</span><br></pre></td></tr></table></figure></li>
<li><p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select id from t where num&#x3D;@num</span><br><span class="line">-- 可以改为强制查询使用索引：</span><br><span class="line">select id from t with(index(索引名)) where num&#x3D;@num</span><br></pre></td></tr></table></figure></li>
<li><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select id from t where num&#x2F;2&#x3D;100</span><br><span class="line">-- 应改为:</span><br><span class="line">select id from t where num&#x3D;100*2</span><br></pre></td></tr></table></figure></li>
<li><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码select id from t where substring(name,1,3)&#x3D;’abc’</span><br><span class="line">-- name以abc开头的id应改为:</span><br><span class="line">select id from t where name like ‘abc%’</span><br></pre></td></tr></table></figure></li>
<li><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
</ul>
<h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><h3 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h3><ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</span><br></pre></td></tr></table></figure>
<h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul>
<li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li>
<li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li>
</ul>
<p><strong>将字段很多的表分解成多个表</strong></p>
<ul>
<li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</li>
<li>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
</ul>
<p><strong>增加中间表</strong></p>
<ul>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li>
<li>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li>
</ul>
<p><strong>增加冗余字段</strong></p>
<ul>
<li>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</li>
<li>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li>
</ul>
<p><strong>注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</span><br></pre></td></tr></table></figure>
<h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul>
<li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li>
<li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li>
<li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li>
<li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</li>
</ul>
<h3 id="大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a>大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p><strong>还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表</strong></p>
<h4 id="1、垂直分区"><a href="#1、垂直分区" class="headerlink" title="1、垂直分区"></a>1、垂直分区</h4><ul>
<li><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</li>
<li><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7259992ab~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h4 id="2、垂直分表"><a href="#2、垂直分表" class="headerlink" title="2、垂直分表"></a>2、垂直分表</h4><ul>
<li>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c725b21e8e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<p><strong>适用场景</strong></p>
<ul>
<li>1、如果一个表中某些列常用，另外一些列不常用</li>
<li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li>
<li>对于应用层来说，逻辑算法增加开发成本</li>
<li>管理冗余列，查询所有数据需要join操作</li>
</ul>
<h4 id="3、水平分区"><a href="#3、水平分区" class="headerlink" title="3、水平分区"></a>3、水平分区</h4><ul>
<li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></li>
<li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7300b465e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</li>
<li>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。</span><br></pre></td></tr></table></figure>
<h4 id="4、水平分表："><a href="#4、水平分表：" class="headerlink" title="4、水平分表："></a>4、水平分表：</h4><ul>
<li>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c744498a9a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<p><strong>适用场景</strong></p>
<ul>
<li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>
<li>2、需要把数据存放在多个介质上。</li>
</ul>
<p><strong>水平切分的缺点</strong></p>
<ul>
<li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li>
<li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>
</ul>
<h4 id="数据库分片的两种常见方案："><a href="#数据库分片的两种常见方案：" class="headerlink" title="数据库分片的两种常见方案："></a>数据库分片的两种常见方案：</h4><ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h4 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h4><ul>
<li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
</li>
<li><p><strong>跨库join</strong></p>
<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p>
</li>
<li><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
</li>
<li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p>
</li>
<li><p><strong>ID问题</strong></p>
</li>
<li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p>
<ul>
<li>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</li>
</ul>
</li>
<li><p><strong>跨分片的排序分页问题</strong></p>
<p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c750f5b2cc~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a>MySQL的复制原理以及流程</h3><ul>
<li>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</li>
</ul>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<h4 id="MySQL主从复制解决的问题"><a href="#MySQL主从复制解决的问题" class="headerlink" title="MySQL主从复制解决的问题"></a>MySQL主从复制解决的问题</h4><ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h4 id="MySQL主从复制工作原理"><a href="#MySQL主从复制工作原理" class="headerlink" title="MySQL主从复制工作原理"></a>MySQL主从复制工作原理</h4><ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中</li>
</ul>
<h4 id="基本原理流程，3个线程以及之间的关联"><a href="#基本原理流程，3个线程以及之间的关联" class="headerlink" title="基本原理流程，3个线程以及之间的关联"></a>基本原理流程，3个线程以及之间的关联</h4><ul>
<li><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</li>
<li><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</li>
<li><strong>从</strong>：sql执行线程——执行relay log中的语句；</li>
</ul>
<h4 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c75eb7e749~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>Binary log：主数据库的二进制日志</li>
<li>Relay log：从服务器的中继日志</li>
</ul>
<ol>
<li>master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</li>
<li>salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</li>
<li>SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</li>
</ol>
<h3 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a>读写分离有哪些解决方案？</h3><ul>
<li>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</li>
</ul>
<p><strong>方案一</strong></p>
<ul>
<li>使用mysql-proxy代理</li>
<li>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</li>
<li>缺点：降低性能， 不支持事务</li>
</ul>
<p><strong>方案二</strong></p>
<ul>
<li>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。</li>
<li>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</li>
</ul>
<p><strong>方案三</strong></p>
<ul>
<li>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</li>
<li>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</li>
</ul>
<h3 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><ul>
<li><strong>(1)备份计划</strong><ul>
<li>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</li>
<li>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</li>
</ul>
</li>
<li><strong>(2)备份恢复时间</strong><ul>
<li>物理备份恢复快，逻辑备份恢复慢</li>
<li>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</li>
<li>20G的2分钟（mysqldump）</li>
<li>80G的30分钟(mysqldump)</li>
<li>111G的30分钟（mysqldump)</li>
<li>288G的3小时（xtra)</li>
<li>3T的4小时（xtra)</li>
<li>逻辑导入时间一般是备份时间的5倍以上</li>
</ul>
</li>
<li><strong>(3)备份恢复失败如何处理</strong><ul>
<li>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</li>
</ul>
</li>
</ul>
<p><strong>(4)mysqldump和xtrabackup实现原理</strong></p>
<ul>
<li><p>mysqldump</p>
<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
</li>
<li><p>Xtrabackup:</p>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>
</li>
<li><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>
</li>
</ul>
<h3 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p>
<ul>
<li>1 修复前将mysql服务停止。</li>
<li>2 打开命令行方式，然后进入到mysql的/bin目录。</li>
<li>3 执行myisamchk –recover 数据库所在路径/*.MYI</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table\_name 修复表 OPTIMIZE TABLE table\_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL性能优化总结</title>
    <url>/2021/11/13/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<h1 id="Mysql-性能优化总结"><a href="#Mysql-性能优化总结" class="headerlink" title="Mysql 性能优化总结"></a>Mysql 性能优化总结</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv8YPTrg9lpFjt5WmnTicwibMbFhqkh287yQXUbdAeBficySb7mroxZiaeWbQdZLpF5T8mCNUC3OibbxJw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="1-客户端方向："><a href="#1-客户端方向：" class="headerlink" title="1 客户端方向："></a>1 客户端方向：</h2><h3 id="1-1、客户端使用连接池，"><a href="#1-1、客户端使用连接池，" class="headerlink" title="1.1、客户端使用连接池，"></a>1.1、客户端使用连接池，</h3><h2 id="2-服务器端方向："><a href="#2-服务器端方向：" class="headerlink" title="2 服务器端方向："></a>2 服务器端方向：</h2><ul>
<li>服务端连接数改大。</li>
<li>使用缓存组件：例如redis等。 </li>
<li>基于主从复制的读写分离。</li>
<li>垂直分库，水平分库分表。</li>
<li>开启慢查询日志</li>
<li>SQL和索引的优化</li>
</ul>
<p>需要在mysql的配置文件中去开启</p>
<p>查看是否开启：<code>show variables like &#39;slow_query%&#39;;</code></p>
<p>查看多久算是慢查询语句：<code>show variables like &#39;long_query_time&#39;;</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv8YPTrg9lpFjt5WmnTicwibMibRnvc7Dw7ZG6hx9hvAtQ5jYicsAAibaQDR7qvRsuRvZj4U09NudwYXoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="3-多张表联合查询，是先查小表还是大表？"><a href="#3-多张表联合查询，是先查小表还是大表？" class="headerlink" title="3 多张表联合查询，是先查小表还是大表？"></a>3 多张表联合查询，是先查小表还是大表？</h2><p>小表驱动大表的思想：两表查询结果的笛卡尔乘积，越小越好，它的中间结果就会小一些，减少内存的消耗。所以在连接查询的时候左表建议是小表。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引原理</title>
    <url>/2021/11/13/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<blockquote>
<p>索引是帮助MySQL高效获取数据的排好序的数据结构。</p>
</blockquote>
<p><strong>在MySQL的InnoDB和MyISAM存储引擎中索引的数据结构都是B+树和HASH。</strong></p>
<p><strong>首先说数据结构中的一些树，比较常见的有二叉树、二叉查找树、平衡二叉树、红黑树、B树、B+树等。</strong></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>定义：是N（N&gt;=0）个节点的有限集合。该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。</p>
<p><img src="https://origin.chaizz.com/f387e3b8447411ec9d7c5254006b8f1d.png" alt="图片"></p>
<center> 普通二叉树（图源网络）</center>

<p>特点：</p>
<ul>
<li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li>
</ul>
<p>二叉树又有满二叉树和完全二叉树，在此不做详解。</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>定义：二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。是数据结构中的一类。在一般情况下，查询效率比链表结构要高。</p>
<p>特点</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的结点。</li>
</ul>
<p><img src="https://origin.chaizz.com/09ef2b34447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>二叉查找树（图源网络）</center>



<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>定义：平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p>
<p>特点：</p>
<ul>
<li>非叶子节点最多拥有两个子节点；</li>
<li>非叶子节点值大于左边子节点、小于右边子节点；</li>
<li>树的左右两边的层级数相差不会大于1;</li>
<li>没有值相等重复的节点;</li>
</ul>
<p><img src="https://origin.chaizz.com/1d670808447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>平衡二叉树（图源网络）</center>





<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>定义：红黑树是一种含有红黑结点并能<strong>自平衡</strong>的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个为NIL叶子节点是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li>
<li>如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</li>
</ul>
<p>红黑树通过三种操作实现自平衡：左旋、右旋、变色。</p>
<p>左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如下图所示。</p>
<p><img src="https://origin.chaizz.com/4b99132e447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>左旋（图源网络）</center>



<p>右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如下图所示。</p>
<p><img src="https://origin.chaizz.com/5da9ea52447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>右旋（图源网络）</center>

<h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>定义：是一种多路平衡查找树（不是二叉树），是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。</p>
<p>特点：</p>
<ul>
<li>根结点至少有两个子节点。</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 。</li>
<li>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 。</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</li>
</ul>
<p><img src="https://origin.chaizz.com/7a76deec447511ec9d7c5254006b8f1d.jpeg" alt="图片"></p>
<center>B 树（图源网络）</center>





<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>定义：B+树是B树的变种，在b树特点的基础上修改了一些特点。</p>
<p>B+树的特点:</p>
<ol>
<li>拥有B树的特点.。</li>
<li>叶子结点之间有指针连接。</li>
<li>非叶子节点不存储数据。</li>
<li>非叶子节点的元素,在叶子节点上都冗余了,也就是叶子结点存储了所有的元素,并且已经排好序。</li>
</ol>
<p><img src="https://origin.chaizz.com/8e88e36c447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>B+树（图源网络）</center>



<blockquote>
<p>Mysql 的索引使用的是B+树,因为索引是用来加速查询的，而B+树通过对数据进行排序,是可以提高查询速度的,然后通过一个节点中可以存储多个元素，从而使得B+树的高度不会太高,在Mysql中的一个innodb页就是一个B+树节点,一个innodb页默认为16kb，所以一般情况下B+树可以存大概两千多万行的数据,然后通过利用B+数叶子结点存储了所有的数据并且进行了排序,并且叶子结点之间有指针，可以很好的支持全表扫描,范 围查询等SQL语句。</p>
</blockquote>
<p>MyISAM 引擎的<strong>主键</strong>索引实现是B+树，存放在.myi 文件中。索引文件和数据文件是分开存储的。（非聚集索引）</p>
<p><img src="https://origin.chaizz.com/9a83ff08447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p>InnoDB 引擎<strong>主键</strong>索引实现（聚集索引）。</p>
<p>表数据文件本身就是按照一个B+树组织的一个索引文件结构，存储在 .idb 文件中。</p>
<p><img src="https://origin.chaizz.com/a92ff2a0447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p><strong>引出的问题：</strong></p>
<p><strong>1、MyISAM 和 InnoDB 都是B+树结构他们的区别在哪里？</strong></p>
<ul>
<li>myisam 索引文件和数据文件是分开存储的，即非聚集索引，所以B+树的叶子结点存储的数据文件的指针。</li>
<li>innodb 索引文件和数据文件存储在一个文件中，即聚集索引，该文件结构是按照一个B+树组织的一个索引文件结构。所以叶子节点直接存储的就是数据。</li>
</ul>
<p><strong>2、为什么建议InnoDB引擎的表必须设置主键，并且推荐使用自增主键？</strong></p>
<ul>
<li>因为Mysql的索引就是一个B+树组织的文件，如果没有设置主键，Mysql 会主动找表里面唯一的列，如果没有则会自己创建一个虚拟列，来维护B+树的索引值。在B+树的同一层节点中节点值是连续的从左到右增大。使用自增主键在B+树中进行对比查找效率更高，存储空间更小。如果使用UUID，判断连续需要占用大量的计算。</li>
</ul>
<p><strong>3、为什么非主键索引结构叶子结点存储的是主键值？</strong></p>
<ul>
<li>因为B+树的节点都是有序的，如果是非自增的主键，在插入的时候会导致性能下降。</li>
</ul>
<h2 id="Hash-索引结构"><a href="#Hash-索引结构" class="headerlink" title="Hash 索引结构"></a>Hash 索引结构</h2><p>定义：Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中。hash索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。Memory引擎默认使用的是此种索引。</p>
<p>特点：</p>
<ul>
<li>hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。</li>
</ul>
<ul>
<li>Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</li>
</ul>
<ul>
<li>Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</li>
</ul>
<ul>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li>
</ul>
<p><img src="https://origin.chaizz.com/b71e58b6447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p>Hash 索引结构和B+树索引结构的区别就是 hash索引结构的特点。</p>
<p>联合索引结构：</p>
<ul>
<li>命名规则：表名_字段</li>
<li>需要加索引的字段，要在where条件中</li>
<li>数据量少的字段不需要加索引</li>
<li>如果where条件中是OR关系，加索引不起作用</li>
<li>符合最左前缀原则</li>
</ul>
<p>联合索引又叫复合索引。对于复合索引:MySQL从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a |  a,b | a,b,c 3种组合进行查找，但不支持 b,c进行查找 ，当最左侧字段是常量引用时，索引就十分有效。</p>
<p><img src="https://origin.chaizz.com/tc/640" alt="图片"></p>
<h2 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h2><ul>
<li>大大的加快数据查询速度。</li>
</ul>
<h2 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h2><ul>
<li>索引文件需要维护，消耗数据库资源。</li>
<li>可能会占用大量磁盘空间。</li>
<li>当对表的数据进行修改/删除时，会影响效率。（数据库需要对索引结构进行维护）</li>
</ul>
<h2 id="索引的分类："><a href="#索引的分类：" class="headerlink" title="索引的分类："></a>索引的分类：</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul>
<li><p>设定主键后数据库会自动设置索引，无需手动创建。innodb为聚集索引。</p>
</li>
<li><p>如果不指定主键，数据库会自动查找一列非空的列，设置为主键索引，如果没有唯一数据，数据库则会自动创建一个类似于row_id 来当做主键 索引。</p>
</li>
<li><p>唯一且非空。</p>
</li>
</ul>
<h3 id="单列索引（单值索引、普通索引）"><a href="#单列索引（单值索引、普通索引）" class="headerlink" title="单列索引（单值索引、普通索引）"></a>单列索引（单值索引、普通索引）</h3><ul>
<li>即一个索引只包含一个列，一个表可以有多个单列索引。</li>
</ul>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul>
<li>索引的值必须是唯一的，但是允许为空，只允许一个空值。</li>
</ul>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul>
<li>即一个索引包含多个列。</li>
<li>遵循最左前缀原则。但是数据库也会自适应最左前缀。</li>
</ul>
<h3 id="Full-Text-（全文索引，只能用于MyISAM-）"><a href="#Full-Text-（全文索引，只能用于MyISAM-）" class="headerlink" title="Full Text （全文索引，只能用于MyISAM ）"></a>Full Text （全文索引，只能用于MyISAM ）</h3><ul>
<li>全文索引类型为Full Text ,在定义的索引的列上支持全文查找，允许在这些列上插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型上创建。</li>
</ul>
<ol>
<li><h2 id="索引的基本操作"><a href="#索引的基本操作" class="headerlink" title="索引的基本操作"></a><strong>索引的基本操作</strong></h2></li>
</ol>
<h3 id="创建普通索引的方式："><a href="#创建普通索引的方式：" class="headerlink" title="创建普通索引的方式："></a>创建普通索引的方式：</h3><ol>
<li><p>建表之后创建：</p>
</li>
<li><p>```sql</p>
<h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><p>create table index_user ( </p>
<pre><code>id INT PRIMARY KEY, NAME VARCHAR ( 20 ) 
</code></pre>
<p>);</p>
<h1 id="为表的某个字段创建索引格式："><a href="#为表的某个字段创建索引格式：" class="headerlink" title="为表的某个字段创建索引格式："></a>为表的某个字段创建索引格式：</h1><p>create index 索引名 on 表名（表的某一列）</p>
<p>create index name_index on index_user(name);</p>
<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><p>show index from index_user;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;origin.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 建表时创建索引：</span><br><span class="line">6. 创建表无法指定索引名字，索引名默认为列名。</span><br><span class="line"></span><br><span class="line">7. &#96;&#96;&#96;sql</span><br><span class="line">   CREATE TABLE index_user_1 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), KEY ( NAME ) );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://origin.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
</ol>
<h3 id="创建唯一索引的方式："><a href="#创建唯一索引的方式：" class="headerlink" title="创建唯一索引的方式："></a>创建唯一索引的方式：</h3><ol>
<li><p>建表之后创建索</p>
</li>
<li><p>```sql<br>CREATE UNIQUE INDEX id_card_index ON index_user_2 ( id_card );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;origin.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 建表时创建索引</span><br><span class="line">6. &#96;&#96;&#96;sql</span><br><span class="line">   CREATE TABLE index_user_2 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), id_card VARCHAR ( 18 ), UNIQUE ( NAME ) );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://origin.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
</ol>
<h3 id="创建复合索引的方式："><a href="#创建复合索引的方式：" class="headerlink" title="创建复合索引的方式："></a>创建复合索引的方式：</h3><ol>
<li><p>创建表时创建：</p>
</li>
<li><p>```sql<br>CREATE TABLE index_user_3 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), id_card VARCHAR ( 18 ), KEY ( NAME, id_card ) );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;origin.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 创建表后创建索引</span><br><span class="line">6. &#96;&#96;&#96;</span><br><span class="line">   CREATE INDEX name_idcard_index ON index_user_3 ( NAME, id_card );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://origin.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
<li><p><strong>复合索引的最左前缀原则：如果索引不包括第一顺序的索引，数据库则不会使用索引查询。MySQL为了更好的利用索引，在查询过程中，回动态的调整索引的顺序，索引当最左的索引不在第一顺序是数据库也能自动的调整顺序。</strong></p>
</li>
</ol>
<h2 id="聚集索引非聚集索引知识点："><a href="#聚集索引非聚集索引知识点：" class="headerlink" title="聚集索引非聚集索引知识点："></a><strong>聚集索引非聚集索引知识点：</strong></h2><p><strong>聚集索引：</strong>将数据存储与索引放在一起，索引结构的叶子结点保存了行数据。</p>
<p><strong>非聚集索引：</strong>将数据与索引分开，索引结构的叶子结点存储的是指向数据文件的指针。</p>
<p>==<strong>注意：在innodb 中，在聚集索引上创建的索引为辅助索引，非聚集索引都是f辅助索引，像复合索引、普通索引、唯一索引。辅助索引叶子结点保存的不是数据行的物理位置 而是主键的值，辅助索引访问数据都是二次查找。</strong>==</p>
<p><strong>InnoDB中使用的是聚集索引，将主键组织到一个B+树中，而行数据就存储在叶子结点上，若使用where id= 1 这样的条件查找主键则按照B+树的检索算法即可快算找到对应的的叶子结点之后获得行数据。</strong></p>
<p><strong>若是对name列进行查找，则需要两个步骤，第一步在辅助索引B+树中检索name，到达辅助索引的叶子结点获得主键索引的ID，第二步在主键索引B+树上根据主键ID进行查找，到达叶子结点节课获取数据行。</strong></p>
<p><img src="https://origin.chaizz.com/tc/640" alt="图片"></p>
<p><strong>MyISAM 使用的是非聚集索引，B+树结构没什么不同只不过叶子节点上存储的内容不同，主键索引存储了主键，辅助索引存储了辅助键，表数据存储在了独立的地方。以下图中B+树的叶子结点都使用一个内存指针指==向了真正的数据，对于表数据来说，这两个键没有任何差别。由于索引是独立的，通过辅助索引检索无需访问主键索引树。==（索引MyISAM 引擎用来做只含有大量的找找的功能比较合适。）</strong></p>
<p><img src="https://origin.chaizz.com/tc/640" alt="图片"></p>
<h3 id="聚集索引的优势："><a href="#聚集索引的优势：" class="headerlink" title="聚集索引的优势："></a><strong>聚集索引的优势：</strong></h3><p><strong>每次使用辅助索引都要经过两次B+树查找，看上去聚集索引的效率要低于非聚集索引，这不是多此一举吗，聚集索引的优势在哪里？</strong></p>
<ul>
<li>由于行数据和聚集索引的叶子结点存储在一起，同一页中会有多条行数据，访问同一页数据的不同行数据时，已经把叶加载到了缓存中，再次访问时会在内存中完成访问，不需要再次访问磁盘，这样主键荷航数据是一起被到渠道内存中的，找到叶子结点就可以直接将数据返回。如果按照主键ID寻找数据则会更快。</li>
<li>辅助索引的叶子结点存储的是主键值，而不是数据的，好处是当行数据发生改变时索引树的节点也要分裂变化（对索引进行重新排序），或者是我们需要查找的数据在上一次IO读写的时在缓存中没有，需要在发生一次IO操作，可以避免辅助索引的维护工作，另一个好处是辅助索引存储的是主键的值，减少了辅助索引占用的空间的大小。</li>
</ul>
<h3 id="聚集索引需要注意什么？"><a href="#聚集索引需要注意什么？" class="headerlink" title="聚集索引需要注意什么？"></a><strong>聚集索引需要注意什么？</strong></h3><p>使用主键为聚集索引时，最好不要用UUID，因为UUID太过离散，不适合排序，而且可能出现新增记录的UUID会插入到索引树的中间位置，导致索引树的调整复杂度变大，消耗时间和资源。</p>
<p>建议使用Int类型的自增，方便排序并且会在索引树的末尾增加主键值，对索引树的结构影响最小，而且主键占用的存储空间越大，辅助索引中保存的主键值也会变大占用存储空间，也会影响IO操作读取的数据量。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="什么时候无法使用索引？"><a href="#什么时候无法使用索引？" class="headerlink" title="什么时候无法使用索引？"></a>什么时候无法使用索引？</h3><ul>
<li><p>在查询语句中使用like关键字，如果匹配的第一个字符为“%”，索引不会被使用，如果“%”不是在第一个位置，索引就会被使用。</p>
</li>
<li><p>查询的索引字段类型不一致。（隐式类型转换，但不全部都无法使用索引）<strong>可以理解为对字段进行操作的都会失效</strong>。</p>
<p>在Mysql中会自动进行类型转换具体分多种情况：  </p>
<p>1、如果查询条件为单纯的字符串怎MySQL会自动转化为数字 0。  </p>
<p><code>select 0 = &#39;aasd&#39; </code> 结果为 1 代表相等  <code>select 1 = &#39;aasd&#39; </code> 结果为 0 代表不相等<code> select 1 = &#39;1&#39;</code> 结果为 1 代表相等   。</p>
<p>2、如果条件包含带数字和字母的字符串则会转化为该字符串中的数字的值。  <code>select 1 = &#39;1aasd&#39; </code> 结果为 1 代表相等  <code>select 12 = &#39;12aasd&#39; </code> 结果为1 代表相等。</p>
</li>
<li><p>查询中使用多列索引，查询条件不符合最左原则。（不包括最左前缀字段）。</p>
</li>
<li><p>查询语句中使用or 关键字，如果or前后两个都有索引会使用索引，如果有一个没有索引，就不会去使用索引查询。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL索引原理</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务与锁机制</title>
    <url>/2021/10/08/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p><strong>MySQL支持事务的储引擎：InnoDB</strong></p>
<blockquote>
<p>事务是一条或者一组SQL操作语句。</p>
</blockquote>
<p>事务的四大特性：A （atomicity）、C（consistency）、I（isolation）、D（durability）。</p>
<p>满足以上特性的事务操作，才能被称作完整的事务。</p>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>A（atomicity）原子性 ：指一个事务中的所有的操作，要么全部完成，要么全部失败回滚。即像化学中的原子一样是最小单位，不能被分割 。在数据库中是由undo Log（回滚日志） 来实现的。</p>
<p>D（Durability）持久性：事务结束之后对数据的改变是永久的，不会因为外界的干扰而导致数据更改。在数据库中是由redo Log 来实现的。</p>
<p>I（Isolation）隔离性：数据库允许多个事务并发的对数据库同时操作，隔离性可以防止多个事务并发执行而导致的数据不一致。隔离又分为多个隔离级别。在数据库中是由即基于锁的并发控制LBCC（Lock-Based Concurrent Control）+ 多版本并发控制（MVCC）实现的。</p>
<p>C（Consistency）一致性：事务开始前后没数据没有被破坏，开始前后的数据符合预期。</p>
<p>原子性、持久性、隔离性都是为了保证数据的一致性。</p>
<h2 id="事务并发会出现的问题"><a href="#事务并发会出现的问题" class="headerlink" title="事务并发会出现的问题"></a>事务并发会出现的问题</h2><p>事务的并发在没有隔离性控制的情况下会出现<strong>读一致性</strong>的问题</p>
<p>1、脏读：在一个事务中<strong>前后两次查询（针对同一条记录）</strong>得到的不一样的结果是由于其读取到其他的事务<strong>未提交</strong>的数据，这种情况叫做脏读。（未在磁盘中持久化，未提交的数据称为脏数据，所以称为脏读。）</p>
<p>2、不可重复读：在一个事务中<strong>前后两次查询（针对同一条记录）</strong>得到的不一样的结果是由于其读取到其他的事务<strong>已经提交</strong>的数据，这种情况叫不可重复读。</p>
<p>3、幻读：在一个事务中<strong>前后两次查询</strong>得到了不一样的结果数，是由于其读取到其他的事务<strong>已经提交</strong>的<strong>新的（新插入的）</strong>数据，这种情况叫幻读。</p>
<h2 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h2><p><strong>针对以上的事务的并发出现的问题，MySQL给出了四种隔离级别：</strong></p>
<p>1、Read Uncommitted (读未提交) ：未解决事务的并发问题，事务提交的数据对于其他事务也是可见的会出现脏读。</p>
<p>2、Read Committed （读已提交）：解决了脏读的问题，一个事务开始之后只能看到已提交的事务的所做的修改，但是会出现不可重复读的问题。 </p>
<p>3、Repeatable Read（可重复读）：解决不可重复读问题，在同一个事务中，多次读取同样的数据结果是一样的，这种隔离级别解决幻读的问题。</p>
<p>4、Serializable（串行化）：解决所有的问题，最高的隔离级别，让事务强制串行化执行。</p>
<p>在MySQL的InnoDB的存储引擎中实现的隔离级别如下图所示：(全部解决)</p>
<p><img src="https://origin.chaizz.com/640.jpg" alt="图片"></p>
<h2 id="以上隔离级别是如何实现？"><a href="#以上隔离级别是如何实现？" class="headerlink" title="以上隔离级别是如何实现？"></a>以上隔离级别是如何实现？</h2><p>第一种方案：</p>
<p>加锁。在读取数据前，对数据进行加锁，阻止其他的事务对其进行操作。（LBCC：Lock Based Concurrency Control）</p>
<p>第二种方案：</p>
<p>生成一个数据请求时间点的一致性数据快照（snapshot），并用这个快照来提供一定级别的（语句级或者事务级）的一致性读取。（MVCC：Multi Version Concurrency Control） 这种方案只在RC和RR 中使用。</p>
<p><strong>首先MVCC 的大致实现原理：</strong></p>
<p>他的宗旨就是创建多个版本的数据，然后对多个版本的数据进行修改查询，从而实现事务的隔离性。</p>
<p><strong>实现MVCC需要的条件：</strong></p>
<ul>
<li>事务需要被记录版本号（即事务的ID：DB_TRX_ID）在数据库表中以隐藏列的形式存在。</li>
<li>数据库表的聚集索引列ID（<strong>DB_ROW_ID</strong>）。</li>
<li>数据库表中另外的隐藏列：<strong>DB_ROLL_PTR</strong> 是指向undo Log的指针。</li>
<li>undo Log（记录数据被修改之前的日志，数据被修改时会把之前的数据拷贝到undolog，当数据进行回滚时，就根据undolog中的数据进行回滚）。</li>
<li>Read View（可以理解为维护的一个活跃事务ID的列表）。</li>
</ul>
<p>开启一个事务A：会产生一个事务的ID号，同时会在readview中维护当前活跃事务的ID，DB_ROLL_PTR 指针指向事务开启之前的数据的undo Log的地址，事务A的操作始终是在当前记录的undo Log 的那些数据中记性操作，如果有其他的事务对数据操作也会指向一个undo Log的指针，操作他的undo Log的数据，所以事务之间的操作并不会影响。</p>
<h1 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h1><blockquote>
<p>锁是计算机协调多个进程和线程并发访问某一资源的一种机制，锁使用独占的方式来保证在只有一个版本的情况下事务之间的隔离，所以锁可以理解为单版本控制。</p>
</blockquote>
<blockquote>
<p>引入锁之后就可以支持并行处理事务，如果事务之间涉及到相同的数据时，会使用排它锁，或者叫互斥锁，先进入的事务独占数据之后，其他的事务被阻塞，等待前面的事务被释放。</p>
</blockquote>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>  mysql的存储引擎 <strong>InnoDB</strong> 既支持<strong>行锁</strong>也支持<strong>表锁</strong>，<strong>MyISAM 只支持表锁。</strong></p>
<h3 id="从锁的粒度分：表级锁、行级锁、页级锁。"><a href="#从锁的粒度分：表级锁、行级锁、页级锁。" class="headerlink" title="从锁的粒度分：表级锁、行级锁、页级锁。"></a>从锁的<strong>粒度</strong>分：表级锁、行级锁、页级锁。</h3><p>MyISAm引擎在执行查询语句之前，会自动给涉及的表加上读锁，在执行增删改之前会自动给表加上写锁。</p>
<p><strong>简而言之读锁会阻塞写而不会阻塞读，而写锁会将读和写全部阻塞。</strong></p>
<p>行锁与表锁的区别：</p>
<p>锁定的粒度：表锁 &gt; 行锁</p>
<p>加锁的效率：表锁 &gt; 行锁</p>
<p>冲突的概率：表锁 &gt; 行锁</p>
<p>并发的性能：表锁 &lt; 行锁</p>
<p><strong>表级锁：</strong></p>
<p>应用在MyISAM、InnoDB 存储引擎中，但偏向MyISAM引擎，开销小，加锁快，无死锁，锁定的粒度大，发生锁冲突的概率大，并发度比较低。偏向于读操作</p>
<p>MySQL的表级锁有两种，一种是表锁，一种是元数据锁。</p>
<ul>
<li><p>表锁 （手动加锁）</p>
<ul>
<li>Read Lock  （加读锁后可以在加读锁，不能加写锁）</li>
<li>Write Lock （加写锁后不能加读锁和写锁）</li>
</ul>
</li>
<li><p>元数据锁 （自动加锁）</p>
<p>当对表记录进行操作的时候（增删改查），MySQL会自动给表加上一个元数据读锁。即不能对表结构进行修改。</p>
<ul>
<li>DML（对表记录进行操作：增删改）加读锁</li>
<li>DDL （对表结构进行修改） 加写锁</li>
</ul>
</li>
<li><p>意向锁：当为行添加一个共享锁的时候，存储引擎会自动在表上加一个意向共享锁，意向排它锁也是一样。他的作用是提升加表锁的效率。</p>
<ul>
<li>意向共享读锁 </li>
<li>意向排他写锁</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 给book添加写锁 </span><br><span class="line">lock table book write;</span><br><span class="line"></span><br><span class="line"># 给book添加读锁 </span><br><span class="line">lock table &lt;table_name&gt; read;</span><br></pre></td></tr></table></figure>
<p>表锁分析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br><span class="line">In_use 为<span class="number">1</span> 代表该表被锁定</span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/254cc64a420c11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;tables%&#x27;</span>;</span><br></pre></td></tr></table></figure>


<p><img src="https://origin.chaizz.com/ab54b6ee420c11ec9d7c5254006b8f1d.png"></p>
<p>这里有两个状态变量记录MySQL表锁定的情况：</p>
<p>Table_locks_immediate：产生表级锁定的次数。</p>
<p><strong>Table_locks_waited：出现表级锁争用二发生的等待的次数。此值越高说明存在着大量的报表级锁竞争情况。</strong></p>
<p>此外MyISAM引擎，的读写锁调度是写优先，这也是MyISAM引擎不适合用作写操作比较多的情况，因为写锁后，其他的线程不能做任何操作，只能被阻塞。</p>
<p><strong>行级别锁：</strong></p>
<p>是由存储引擎InnoDB实现，行级锁，每次锁住一行数据，锁定的粒度最小，发生锁冲突的概率比较小，并发度比较高。</p>
<p>行级锁从锁定的力度上分为：</p>
<p>Record Lock：（记录锁）锁定单个行记录，对精确匹配或者范围匹配在范围内的数据加锁。RC、RR隔离级别都支持。</p>
<p>Gap Lock：（间隙锁）锁定索引记录间隙，确保索引记录的间隙不变。对范围匹配且符合范围条件但不在范围内的数据也进行加锁。RR隔离级别支持。（防止insert）</p>
<p>Next-key Lock：（临建锁）行锁和间隙锁的组合，同时锁住记录和索引间隙。RR隔离级别支持。 </p>
<ul>
<li>共享锁（又称为读锁，S锁） （手动加锁）<ul>
<li><code>select ... lock in sare mode</code></li>
</ul>
</li>
<li>排他锁（又称为写锁，X锁） <ul>
<li>DML（对表记录进行操作：增删改） delete/update/insert 默认加排它锁</li>
<li><code>select ... for update</code>  （当前读）</li>
</ul>
</li>
</ul>
<p>行锁分析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://origin.chaizz.com/15c2bdb2421411ec9d7c5254006b8f1d.png"></p>
<p><strong>Innodb_row_lock_current_waits：当前正在等待锁定的数量 （比较重要）</strong></p>
<p>Innodb_row_lock_time：从系统启动到现在锁定的总时间长度</p>
<p>Innodb_row_lock_time_avg：每次等待所花的平均时间</p>
<p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p>
<p><strong>Innodb_row_lock_waits：系统启动后到现在总共等待的次数（比较重要）</strong></p>
<p><strong>页级别锁：</strong></p>
<p>开销和加锁时间介于表锁与行锁之间，会出现死锁，锁定的粒度也是介于表锁与行锁之间，并发度一般。</p>
<h3 id="从锁的操作上来说分为读锁和写锁。"><a href="#从锁的操作上来说分为读锁和写锁。" class="headerlink" title="从锁的操作上来说分为读锁和写锁。"></a>从锁的<strong>操作</strong>上来说分为读锁和写锁。</h3><ul>
<li>读锁：针对同一份数据，多个读操作可以同时进行而不会互相影响。所以也叫作共享锁。</li>
<li>写锁：针对同一份数据，当前写操作没有释放锁之前，其他的事务无法对数据进行加锁操作，不管是读锁还是写锁。所以也叫排它锁。</li>
</ul>
<p>读锁可以让读和读并行，而读和写、写和读、写和写要加排它锁。</p>
<h3 id="从实现方式上分为乐观锁和悲观锁。"><a href="#从实现方式上分为乐观锁和悲观锁。" class="headerlink" title="从实现方式上分为乐观锁和悲观锁。"></a>从<strong>实现方式</strong>上分为乐观锁和悲观锁。</h3><h2 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景"></a>锁的使用场景</h2><p>修改数据库表结构会自动加表级锁。</p>
<p>更新数据未使用索引，行锁会上升到表锁。</p>
<p>更新数据使用索引会使用行锁。</p>
<p><code>select ... for update </code> 会使用行级别锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL事物与锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQLMVCC机制</title>
    <url>/2021/10/08/MySQL%E7%9A%84MVCC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<blockquote>
<p>数据库事务的四大特性：</p>
<p>原子性：atomicity 是通过undo log 来实现的。</p>
<p>一致性：consistency  原子性、隔离性、持久性来共同保持一致性。</p>
<p>隔离性：isolation 通过加锁以及MVCC来实现的。</p>
<p>持久性：durability 是通过redo log 实现的。</p>
</blockquote>
<h1 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h1><p>MVCC（Multi - Version - Concurrency - Control）全称是<strong>多版本并发控制</strong>。主要是为了提高数据库的并发性能。MVCC只在<strong>读已提交</strong>和<strong>可重复读</strong>的两个事务级别下有效。主要是用于处理读请求。</p>
<h1 id="MySQL的快照读和当前读是什么？"><a href="#MySQL的快照读和当前读是什么？" class="headerlink" title="MySQL的快照读和当前读是什么？"></a>MySQL的快照读和当前读是什么？</h1><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>他读取数据库记录都是当前最新的版本，会对当前读取的数据进行加锁，防止其他的事务对数据修改，属于悲观锁的一种。</p>
<p>以下操作都是当前读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select lock in share mode # (共享锁)</span><br><span class="line"></span><br><span class="line">select for update  #(排他锁)</span><br><span class="line"></span><br><span class="line">update # (排他锁)</span><br><span class="line"></span><br><span class="line">insert #(排它锁)</span><br><span class="line"></span><br><span class="line">delete  #(排它锁)</span><br><span class="line"></span><br><span class="line"># 串行化事务隔离级别</span><br></pre></td></tr></table></figure>


<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>快照读是基于和 undo log 来实现的，适用于简单 select 语句。           </p>
<p>首先MySQL一条记录里面包含三个隐藏列：<strong>row_id</strong>、<strong>trx_id</strong>、<strong>roll_pointer</strong>以及<strong>ReadView</strong>。</p>
<ul>
<li>row_id ：MySQL的B+树索引特性要求每个表必须要有一个主键。如果没有设置的话，会自动寻找第一个不包含NULL的唯一索引列作为主键。如果还是找不到，就会在这个DB_ROW_ID上自动生成一个唯一值，以此来当作主键。</li>
<li>trx_id：自增的事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID（DELETE语句被当做是UPDATE语句的特殊情况，后面会进行说明）</li>
<li>roll_pointer：回滚指针，通过它可以将不同的版本串联起来，形成版本链。相当于链表的next指针。</li>
</ul>
<h3 id="一张图理解undo-log"><a href="#一张图理解undo-log" class="headerlink" title="一张图理解undo log"></a>一张图理解undo log</h3><p><img src="https://origin.chaizz.com/tc/Snipaste_2021-10-08_22-43-53.png"></p>
<p>以上图中最新的记录name为赵六，他指向前一个版本name为王五，依次类推，王五的上一个版本是李四，李四的上一版本是张三。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p><strong>ReadView的作用？</strong></p>
<p>就是根据事务ID查找对应的数据。那些事务应该读取到那些数据。</p>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2021-10-08_22-56-42.png"></p>
<p>m_ids ：当前MySQL中所有的<strong>活跃</strong>（<strong>指未提交的</strong>）的事务的ID。</p>
<p>min_trx_id：表示m_ids 中最小的事务ID。、</p>
<p>max_trx_id：表示生成ReadView时系统应该分配给下一个事物的ID。、</p>
<p>creator_trx_id：生成该ReadView的ID。</p>
<p><strong>ReadView如何判断哪个版本可用？</strong></p>
<ul>
<li>trx_id == creator_trx_id    如果事务ID等于当前生成ReadView的vreator_trx_id ，那么可以访问这个版本。</li>
<li>trx_id  &lt; mix_trx_id 事务ID小于当前ReadView中的最小的活跃事务的ID，说明该事务是已经提交的了事务。那么可以访问。</li>
<li>trx_id  &gt; max_trx_id 事务ID大于当前ReadView中的要分配的事务的ID，说明max_trx_id  是创建ReadView之后生成的ID，已经超出版本链的事务的ID，所以无法读取。</li>
<li>min_trx_id  &lt;=  trx_id  &lt;= max_trx_id 分两种情况：<ul>
<li>① 当trx_id   在min_trx_id   中，说明是活跃的事务的ID，未提交的事务，那么不能访问当前版本。</li>
<li>②当trx_id  不在min_trx_id   中，说明不是活跃的事务的ID，而且小于系统下一个事务的ID，那么可以访问当前版本。</li>
</ul>
</li>
</ul>
<h2 id="MVCC如何实现RR-（可重复读）和RC（读已提交）的？"><a href="#MVCC如何实现RR-（可重复读）和RC（读已提交）的？" class="headerlink" title="MVCC如何实现RR （可重复读）和RC（读已提交）的？"></a>MVCC如何实现RR （可重复读）和RC（读已提交）的？</h2><p><strong>实现RC</strong></p>
<p>RC生成ReadView的时间是每次select查询的时候就会生成一个ReadView，他是以每个select查询为单位的，比如一个事务中有两个select语句，那么这两个select就会生成两个ReadView，所以在一个事务中就可以读取到其他事务已经提交的数据，就会产生不可重复读的问题。</p>
<p><strong>实现RR</strong></p>
<p>RR 生成ReadView 是根据事务来生成，他是以每个事务为单位生成的。在一个事务中不管有多少查询语句，查询的ReadView还是同一个，所以只能读取到当前版本的数据，就可以解决不可重复读的问题。</p>
<p>InndDB 解决幻读：是通过间隙锁+锁住本身的数据（next-key），间隙锁锁住一段范围，所以其他事务无法对这段范围的数据进行插入删除等操作，所以就不存在幻读的问题。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQLMVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerSwarm理解</title>
    <url>/2021/09/29/DockerSwarm%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、DockerSwarm理解"><a href="#一、DockerSwarm理解" class="headerlink" title="一、DockerSwarm理解"></a>一、DockerSwarm理解</h1><blockquote>
<p>官网解释：</p>
<p>Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.</p>
<p>Docker Engine 1.12 引入了 swarm 模式，使您能够创建一个由一个或多个 Docker 引擎组成的集群，称为 swarm。 swarm 由一个或多个节点组成：在 swarm 模式下运行 Docker Engine 1.12 或更高版本的物理或虚拟机。</p>
</blockquote>
<a id="more"></a>

<p><a href="https://docs.docker.com/engine/swarm/">官网地址</a></p>
<p><img src="https://origin.chaizz.com/tc/swarm-diagram.png"></p>
<h2 id="1、Swarm-中有两种类型的节点："><a href="#1、Swarm-中有两种类型的节点：" class="headerlink" title="1、Swarm 中有两种类型的节点："></a>1、Swarm 中有两种类型的节点：</h2><h3 id="1-1、managers-的作用"><a href="#1-1、managers-的作用" class="headerlink" title="1.1、managers 的作用"></a>1.1、managers 的作用</h3><ul>
<li>维护集群状态</li>
<li>集群调度</li>
<li>给集群提供API</li>
</ul>
<p>Swarm 使用Raft来保证分布式一致性。</p>
<blockquote>
<p><a href="https://raft.github.io/">Raft </a>是一种更为简单方便易于理解的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/1372646">分布式算法</a>，主要解决了分布式中的一致性问题。相比传统的<a href="https://baike.baidu.com/item/Paxos%E7%AE%97%E6%B3%95/6632960">Paxos算法</a>，Raft将大量的计算问题分解成为了一些简单的相对<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%AB%8B/3259">独立</a>的子问题。</p>
<p>相比于传统的一致性算法Paxos，Raft有一些自己的独特的特性。比如增加了强领导性，优化了领导的选举过程，在成员发生变化之后依然能够很好的进行工作。</p>
</blockquote>
<p>三个管理器的群体最多可以容忍一个管理器的损失。<br>一个五管理器群可以容忍最大同时丢失两个管理器节点。<br>N 个管理器集群最多可以容忍 (N-1)/2 个管理器的丢失。<br>Docker 建议一个集群最多有七个管理器节点。</p>
<p>在一些分布式任务重，节点个数往往是奇数。是为了能够成功选举出领导，如果是偶数肯能会有得票一致的情况。</p>
<h3 id="1-2、workers"><a href="#1-2、workers" class="headerlink" title="1.2、workers"></a>1.2、workers</h3><p>worker 节点 就是docekr引擎的实例，他的唯一的目的就是执行容器。worker节点不参与 Raft 分布式状态，不做出调度决策，也不为群模式 HTTP API 提供服务。</p>
<h1 id="二、创建集群"><a href="#二、创建集群" class="headerlink" title="二、创建集群"></a>二、创建集群</h1><h2 id="1、初始化集群"><a href="#1、初始化集群" class="headerlink" title="1、初始化集群"></a>1、初始化集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化主节点，使用主节点创建不同类型的节点令牌</span></span><br><span class="line">docker swarm init --advertise-addr 内网地址</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建manager令牌</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建worker令牌</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入一个节点</span></span><br><span class="line">docker swarm join ---token 令牌</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看节点名称</span></span><br><span class="line">docker node ls</span><br></pre></td></tr></table></figure>


<h1 id="三、Docker-服务弹性扩容"><a href="#三、Docker-服务弹性扩容" class="headerlink" title="三、Docker 服务弹性扩容"></a>三、Docker 服务弹性扩容</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Swarm manager 节点下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个服务，具备扩缩容的功能</span></span><br><span class="line">docker service create -p 8888:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接启动三个副本。</span></span><br><span class="line">docker service update --replicas 3 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerCompose知识总结</title>
    <url>/2021/09/29/DockerCompose%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​     </p>
<a id="more"></a>

<h1 id="一、DockerCompose理解"><a href="#一、DockerCompose理解" class="headerlink" title="一、DockerCompose理解"></a>一、DockerCompose理解</h1><blockquote>
<p><a href="https://docs.docker.com/compose/">Docker Compose</a> is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.</p>
<p>The <em>big</em> advantage of using Compose is you can define your application stack in a file, keep it at the root of your project repo (it’s now version controlled), and easily enable someone else to contribute to your project. Someone would only need to clone your repo and start the compose app. In fact, you might see quite a few projects on GitHub/GitLab doing exactly this now.</p>
</blockquote>
<p>Docker compose 是来管理多个容器的一个工具。</p>
<h2 id="1、安装Docker-Compose"><a href="#1、安装Docker-Compose" class="headerlink" title="1、安装Docker Compose"></a>1、安装Docker Compose</h2><p><a href="https://github.com/docker/compose/releases/download/v2.0.0/docker-compose-linux-amd64">Docker-compose地址</a></p>
<h3 id="1-1-创建cli-plugins-目录"><a href="#1-1-创建cli-plugins-目录" class="headerlink" title="1.1 创建cli-plugins 目录"></a>1.1 创建cli-plugins 目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在github上下载最新版docker-compose ,放在 docker安装用户家目录下 ：root/.docker/cli-plugins</span></span><br><span class="line"></span><br><span class="line">cd .docker</span><br><span class="line">mkdir cli-plugins</span><br></pre></td></tr></table></figure>
<h3 id="1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose"><a href="#1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose" class="headerlink" title="1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose"></a>1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在root/.docker/cli-plugins 目录下</span></span><br><span class="line">mv docker-compose-linux-amd64 docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-3-添加执行权限"><a href="#1-3-添加执行权限" class="headerlink" title="1.3 添加执行权限"></a>1.3 添加执行权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x root/.docker/cli-plugins/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-4-安装低版本"><a href="#1-4-安装低版本" class="headerlink" title="1.4 安装低版本"></a>1.4 安装低版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> docker-compose --version</span><br></pre></td></tr></table></figure>


<p><strong>v2.0.0版本命令为 <code>docker compose </code>中间没有横杠</strong></p>
<h2 id="2、Docker-Componse-官网示例（创建一个Python-web应用）："><a href="#2、Docker-Componse-官网示例（创建一个Python-web应用）：" class="headerlink" title="2、Docker Componse 官网示例（创建一个Python web应用）："></a>2、Docker Componse 官网示例（创建一个Python web应用）：</h2><h3 id="2-1、创建app-py"><a href="#2-1、创建app-py" class="headerlink" title="2.1、创建app.py"></a>2.1、创建<code>app.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span>():</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure>


<h3 id="2-2、创建包文件夹-requirements-txt："><a href="#2-2、创建包文件夹-requirements-txt：" class="headerlink" title="2.2、创建包文件夹 requirements.txt："></a>2.2、创建包文件夹 <code>requirements.txt</code>：</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建Dockerfile文件"><a href="#2-3-创建Dockerfile文件" class="headerlink" title="2.3 创建Dockerfile文件"></a>2.3 创建<code>Dockerfile</code>文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建-docker-compose-yml文件-："><a href="#2-4-创建-docker-compose-yml文件-：" class="headerlink" title="2.4 创建 docker-compose.yml文件 ："></a>2.4 创建 <code>docker-compose.yml</code>文件 ：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-5-在-docker-compose-yml-目录下运行命令"><a href="#2-5-在-docker-compose-yml-目录下运行命令" class="headerlink" title="2.5 在 docker-compose.yml 目录下运行命令"></a>2.5 在 <code>docker-compose.yml</code> 目录下运行命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose up	</span><br></pre></td></tr></table></figure>


<p>出现错误 ：</p>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2021-09-29_19-51-36.png"></p>
<p>解决：在Dockerfile中添加下面这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完整的Dockerfile：</span></span><br><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-5-运行成功"><a href="#2-5-运行成功" class="headerlink" title="2.5 运行成功"></a>2.5 运行成功</h3><p><img src="https://origin.chaizz.com/tc/Snipaste_2021-09-29_20-48-16.png"></p>
<h1 id="二、docker-compose-命令详解"><a href="#二、docker-compose-命令详解" class="headerlink" title="二、docker compose 命令详解"></a>二、docker compose 命令详解</h1><p>结合docker compose 部署多个服务</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line"><span class="comment">#  web:</span></span><br><span class="line"><span class="comment">#    # 用来使用自定义的Dockerfile ，</span></span><br><span class="line"><span class="comment">#    # 使用自己构建的镜像，然后在运行容器</span></span><br><span class="line"><span class="comment">#    build:</span></span><br><span class="line"><span class="comment">#      # 启动服务是先将制定的Dockerfile 构建一个镜像。</span></span><br><span class="line"><span class="comment">#      context: .   #这个路径可以是相对的或者绝对的。一般是dockercompose.yml的当前路径</span></span><br><span class="line"><span class="comment">#      dockerfile:</span></span><br><span class="line"><span class="comment">#    expose: # 对外暴露端口</span></span><br><span class="line"><span class="comment">#      - &quot;8000&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    depends_on:  # 代表这个容器必须依赖其他的容器才能启动（服务名）</span></span><br><span class="line"><span class="comment">#      - my_tomcat2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - &quot;8000:8000&quot;   # 制定映射容器内端口</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    networks:</span></span><br><span class="line"><span class="comment">#      - hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_tomcat2: <span class="comment"># 服务器名称</span></span><br><span class="line">    container_name: tomcat2   <span class="comment"># 自定义容器名称  docker run --name</span></span><br><span class="line">    image: tomcat   <span class="comment"># 镜像名称</span></span><br><span class="line">    restart: always</span><br><span class="line">    ports: <span class="comment">#  端口建议使用字符串    docker run -p</span></span><br><span class="line">      - <span class="string">&quot;8082:8080&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment">#      - /opt/webapps:/usr/local/tomcat/webapps # 自定义路径映射</span></span><br><span class="line">      - <span class="string">&quot;./env/webapps:/usr/local/tomcat/webapps&quot;</span> <span class="comment">#使用数据库名映射</span></span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    depends_on: <span class="comment"># 代表这个容器必须依赖其他的容器才能启动（服务名）</span></span><br><span class="line">      - my_mysql</span><br><span class="line">      - my_redis</span><br><span class="line"></span><br><span class="line">    <span class="keyword">healthcheck</span><span class="bash">: <span class="comment"># 通过命令检测容器是否正常运行</span></span></span><br><span class="line">      test: [ <span class="string">&quot;CMD&quot;</span>,<span class="string">&quot;curl&quot;</span>,<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;http://localhost&quot;</span> ]</span><br><span class="line">      interval: <span class="number">1</span>m30s</span><br><span class="line">      timeout: <span class="number">10</span>s</span><br><span class="line">      retries: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    ulimits:   # 用来修改容器内部的最大进程数</span></span><br><span class="line"><span class="comment">#      nproc: 65535</span></span><br><span class="line"><span class="comment">#      nofile:</span></span><br><span class="line"><span class="comment">#        soft: 20000</span></span><br><span class="line"><span class="comment">#        hard: 40000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    sysctls:   # 用来修改容器内部内核参数，并不是必须的，有些容器启动收到操作系统参数限制需要用到这个命令</span></span><br><span class="line"><span class="comment">#      - net.core.somaxconn=1024</span></span><br><span class="line"><span class="comment">#      - net.ipv4.tcp_syncookies=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_mysql:</span><br><span class="line">    image: mysql:<span class="number">5.7</span></span><br><span class="line">    container_name: mysql</span><br><span class="line">    privileged: true</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./env/mysql/conf.d:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      - <span class="string">&quot;./env/mysql/mysqldata:/var/lib/mysql&quot;</span></span><br><span class="line">      - <span class="string">&quot;./env/mysql/mysqllogs:/logs&quot;</span></span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#      MYSQL_ROOT_PASSWORD: &quot;123456&quot;</span></span><br><span class="line"><span class="comment">#      TZ: Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">    env_file:  <span class="comment"># 将环境变量中的值设置在文件中  必须是以.env 结尾的文件   必须要是键值对的形式或者A=B的形式</span></span><br><span class="line">      - ./<span class="keyword">env</span>/mysql/mysql.<span class="keyword">env</span>    <span class="comment"># 这个文件中就写   MYSQL_ROOT_PASSWORD: &quot;123456&quot;就可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># environment和env_file 写一个就可以</span></span><br><span class="line"></span><br><span class="line">    command:</span><br><span class="line">      --wait_timeout=<span class="number">31536000</span></span><br><span class="line">      --interactive_timeout=<span class="number">31536000</span></span><br><span class="line">      --max_connections=<span class="number">1000</span></span><br><span class="line">      --default-authentication-plugin=mysql_native_password</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_redis:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;6379&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/data:/data</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/conf:/usr/local/etc/redis</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/logs:/logs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意 redis.conf 中的 daemonize no   要设置为前台运行。</span></span><br><span class="line">    <span class="comment">#要不然运行了docker compose up , redis自动关闭</span></span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  nginx:</span><br><span class="line">    container_name: nginx</span><br><span class="line">    restart: always</span><br><span class="line">    image: nginx:<span class="number">1.11</span>.<span class="number">6</span>-alpine</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/logs:/var/log/nginx</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/www:/var/www</span><br><span class="line">      - /etc/letsencrypt:/etc/letsencrypt</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># compose 中运行 portainer</span></span><br><span class="line">  portainer:</span><br><span class="line">    image: portainer/portainer</span><br><span class="line">    container_name: portainer</span><br><span class="line">    volumes:</span><br><span class="line">      - /var/<span class="keyword">run</span><span class="bash">/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      - /opt/portainer/data:/data</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">8000</span>:<span class="number">8000</span></span><br><span class="line">      - <span class="number">9000</span>:<span class="number">9000</span></span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#volumes:</span></span><br><span class="line"><span class="comment">#  tomcat1webapps:   # 声明指定的卷名，compose会自动加上docker-compose.yml 的外层目录名</span></span><br><span class="line"><span class="comment">#    external:   # 使用自定义的卷名，前提必须存在：需要手动执行docker volume create tomcatwebapps</span></span><br><span class="line"><span class="comment">#      false</span></span><br><span class="line"><span class="comment">#  webapps:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">networks:   <span class="comment"># 声明上面创建的 hello 网桥</span></span><br><span class="line">  hello:</span><br><span class="line">    external:   <span class="comment"># 使用自定义的网桥，前提必须存在 ：需要手动执行docker networks create -d bridge hello</span></span><br><span class="line">      false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker compose up                ：启动所有服务</span></span><br><span class="line">    <span class="comment">#   -f  ：指定dockercompose.yml 文件</span></span><br><span class="line">    <span class="comment">#   -p  ：指项目名称</span></span><br><span class="line">    <span class="comment">#   -d  ：设置所有服务后台运行</span></span><br><span class="line"><span class="comment">#   docker compose down         ：关闭dcokercompose所有服务，会移除网络，不会移除数据卷</span></span><br><span class="line"><span class="comment">#   docker compose exec  [服务名]  ：进入服务对应的容器</span></span><br><span class="line"><span class="comment">#   docker compose ps           ：列出所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose restart   [服务名]  ：列出所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose rm   [服务名]  ：列出所有的容器</span></span><br><span class="line">    <span class="comment"># -f 强制删除</span></span><br><span class="line">    <span class="comment"># -v 删除服务对应容器挂载的数据卷</span></span><br><span class="line"><span class="comment">#   docker compose start   [服务名]  ：启动所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose stop   [服务名]  ：停止所有的容器 （不会移除网络）</span></span><br><span class="line"><span class="comment">#   docker compose top   [服务名]  ：查看所有容器内运行的进程</span></span><br><span class="line"><span class="comment">#   docker compose unpause   [服务名]  ：将挂起的服务恢复</span></span><br><span class="line"><span class="comment">#   docker compose pause   [服务名]  ：挂起某一个服务</span></span><br><span class="line"><span class="comment">#   docker compose logs   [服务名]  ：查看所有服务的日志</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="三、安装Portainer是Docker可视化软件"><a href="#三、安装Portainer是Docker可视化软件" class="headerlink" title="三、安装Portainer是Docker可视化软件"></a>三、安装Portainer是Docker可视化软件</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">docker pull portainer/portainer</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 9000:9000 --name=portainer --restart=always -v /opt/portainer/data:/data -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载汉化版  指定汉化版镜像</span></span><br><span class="line"></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --name=portainer -p 9000:9000 --restart=always -d  --rm  -v /var/run/docker.sock:/var/run/docker.sock -v /opt/portainer/data:/data registry.cn-shenzhen.aliyuncs.com/infrastlabs/portainer-cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问公网IP <span class="doctag">xxx:</span>9000   设置默认密码 ：至少八位</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker知识总结</title>
    <url>/2021/09/27/Docker%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<blockquote>
<p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production.</p>
</blockquote>
<h1 id="一、Docker-是什么"><a href="#一、Docker-是什么" class="headerlink" title="一、Docker 是什么"></a>一、Docker 是什么</h1><h2 id="1、Docker-简介"><a href="#1、Docker-简介" class="headerlink" title="1、Docker 简介"></a>1、Docker 简介</h2><p> Docker 是一个用于开发、传送和运行应用程序的开放平台。Docker 使您能够将应用程序与基础设施分开，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产中运行代码之间的延迟。</p>
<p>Docker是基于Google的Go语言开发的。</p>
<h2 id="2、Dcoker-能干什么？"><a href="#2、Dcoker-能干什么？" class="headerlink" title="2、Dcoker 能干什么？"></a>2、Dcoker 能干什么？</h2><p>Docker 能方便的将开发环境打包起来，包括Python、Nginx 、Redis、Mysql、Tomcat等等的开发环境只需要一次部署，然后将他们打包为镜像，接下来只需要拿着这个镜像在不同的服务器中的docker中运行即可得到一个全新的与之前部署的环境完全一样的环境。有点类似于布尔玛的万能胶囊，只是有点..</p>
<h1 id="二、Docker与虚拟机的区别"><a href="#二、Docker与虚拟机的区别" class="headerlink" title="二、Docker与虚拟机的区别"></a>二、Docker与虚拟机的区别</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/271846374">https://zhuanlan.zhihu.com/p/271846374</a></p>
</blockquote>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2021-09-27_16-03-32.png"></p>
<p>传统的虚拟机技术：由于虚拟机是把这个系统内核、系统依赖、硬件资源配置全部打包，组成一个新的系统。他是在硬件的基础上实现虚拟化。所以虚拟机占用的资源比较大，切换比较耗时。</p>
<p>Docker技术：它是直接运行在宿主机上，是系统层面的虚拟化，他不需要自己拥有单独的内核，也没有打包硬件资源，所以他是很轻便的，而且每个容器之间是相互隔离的，类似于一个沙箱。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级·</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘空间</td>
<td>一般为几十MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>操作系统</td>
<td>与宿主机共享OS</td>
<td>在宿主机上运行虚拟机的OS</td>
</tr>
</tbody></table>
<p>Docker的优点：</p>
<ul>
<li>对系统资源能够更高效的利用。</li>
<li>启动速度更快。</li>
<li>一致的运行环境。</li>
<li>维护和扩展更加的容易。</li>
<li>应用更快的交付与部署</li>
</ul>
<h1 id="三、Docker-的基本组成"><a href="#三、Docker-的基本组成" class="headerlink" title="三、Docker 的基本组成"></a>三、Docker 的基本组成</h1><p><img src="https://origin.chaizz.com/tc/Snipaste_2021-09-27_16-23-06.png"></p>
<h2 id="Docker的三大组件："><a href="#Docker的三大组件：" class="headerlink" title="Docker的三大组件："></a>Docker的三大组件：</h2><h3 id="1、镜像："><a href="#1、镜像：" class="headerlink" title="1、镜像："></a>1、镜像：</h3><p>Docker的镜像好比一个文件模板（分层的），有各种各样的模板，这个模板就是一些具体的应用以及对应的资源。比如说一个Nginx 镜像 就是一个包含Nginx的模板。他需要在一个Ubuntu或者其他系统镜像上安装那么就是一个可运行的Nginx镜像。</p>
<h3 id="2、容器："><a href="#2、容器：" class="headerlink" title="2、容器："></a>2、容器：</h3><p>容器类似于一个沙箱，是基于镜像来创建的，多个镜像可以组成一个容器，他是独立运行的，可以启动、暂停、删除容器等操作。</p>
<h3 id="3、仓库："><a href="#3、仓库：" class="headerlink" title="3、仓库："></a>3、仓库：</h3><p>仓库就是用来存放镜像的地方，这个概念和git是一样的，有共有仓库和私有仓库。</p>
<h1 id="四、Dcoker的安装与卸载"><a href="#四、Dcoker的安装与卸载" class="headerlink" title="四、Dcoker的安装与卸载"></a>四、Dcoker的安装与卸载</h1><h2 id="1、Ubuntu-18-04-手动安装下安装"><a href="#1、Ubuntu-18-04-手动安装下安装" class="headerlink" title="1、Ubuntu 18.04 手动安装下安装"></a>1、Ubuntu 18.04 手动安装下安装</h2><blockquote>
<p>安装前提：</p>
<p>系统：Ubuntu 18.04 LTS   </p>
<p>系统内核 ：4.15.0-136-generic</p>
</blockquote>
<p>具体的操作系统根据Docker的<a href="https://docs.docker.com/engine/install/ubuntu/">官网</a>来选择不同的安装方法。</p>
<h3 id="1、卸载旧版本"><a href="#1、卸载旧版本" class="headerlink" title="1、卸载旧版本"></a>1、卸载旧版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
<h3 id="2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库"><a href="#2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库" class="headerlink" title="2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库"></a>2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>
<h3 id="3、添加Docker官方的GPG密钥"><a href="#3、添加Docker官方的GPG密钥" class="headerlink" title="3、添加Docker官方的GPG密钥"></a>3、添加Docker官方的GPG密钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>
<h3 id="4、设置稳定存储库"><a href="#4、设置稳定存储库" class="headerlink" title="4、设置稳定存储库"></a>4、设置稳定存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h3 id="5、安装Docker"><a href="#5、安装Docker" class="headerlink" title="5、安装Docker"></a>5、安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<h3 id="6、验证是否安装成功"><a href="#6、验证是否安装成功" class="headerlink" title="6、验证是否安装成功"></a>6、验证是否安装成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<h3 id="7、卸载Docker"><a href="#7、卸载Docker" class="headerlink" title="7、卸载Docker"></a>7、卸载Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>
<h3 id="8、配置阿里云镜像加速"><a href="#8、配置阿里云镜像加速" class="headerlink" title="8、配置阿里云镜像加速"></a>8、配置阿里云镜像加速</h3><p>直接在阿里云首页搜索<strong>容器镜像服务</strong>，登录注册后 –&gt; 进入镜像工具 –&gt; 镜像加速器。具体页面如下：</p>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2021-09-27_17-03-26.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://1xxxxxx5.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="2、官网也提供了一种方便的脚本安装方法："><a href="#2、官网也提供了一种方便的脚本安装方法：" class="headerlink" title="2、官网也提供了一种方便的脚本安装方法："></a>2、官网也提供了一种方便的脚本安装方法：</h2><h3 id="1、只需要两条命令："><a href="#1、只需要两条命令：" class="headerlink" title="1、只需要两条命令："></a>1、只需要两条命令：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line"></span><br><span class="line">sudo sh test-docker.sh</span><br></pre></td></tr></table></figure>
<p>运行第一条命令后可能会出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to get.docker.com:443</span><br></pre></td></tr></table></figure>
<p>原因大概就是无法访问外国的网站，加个提子就行。</p>
<p>接下来运行 执行脚本命令。即可等待自动安装。</p>
<p>使用以下命令可查看 在执行命令过程中运行了那些命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DRY_RUN=1 sh ./get-docker.sh</span><br></pre></td></tr></table></figure>
<h3 id="2、安装完毕后检查docker是否启动"><a href="#2、安装完毕后检查docker是否启动" class="headerlink" title="2、安装完毕后检查docker是否启动"></a>2、安装完毕后检查docker是否启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<h3 id="3、启动docker"><a href="#3、启动docker" class="headerlink" title="3、启动docker"></a>3、启动docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="4、安装完毕后查看是否正确安装：-提示docker的一些信息"><a href="#4、安装完毕后查看是否正确安装：-提示docker的一些信息" class="headerlink" title="4、安装完毕后查看是否正确安装：(提示docker的一些信息)"></a>4、安装完毕后查看是否正确安装：(提示docker的一些信息)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info </span><br></pre></td></tr></table></figure>
<h3 id="5、设置docker开机自动启动"><a href="#5、设置docker开机自动启动" class="headerlink" title="5、设置docker开机自动启动"></a>5、设置docker开机自动启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure>
<h3 id="6、建立docker组-将root用户加入docker组-（此步骤可做可不做）"><a href="#6、建立docker组-将root用户加入docker组-（此步骤可做可不做）" class="headerlink" title="6、建立docker组 将root用户加入docker组 （此步骤可做可不做）"></a>6、建立docker组 将root用户加入docker组 （此步骤可做可不做）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd docker</span><br><span class="line"></span><br><span class="line">usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<h3 id="7、重启docker"><a href="#7、重启docker" class="headerlink" title="7、重启docker"></a>7、重启docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="8、配置镜像加速与上面一致"><a href="#8、配置镜像加速与上面一致" class="headerlink" title="8、配置镜像加速与上面一致"></a>8、配置镜像加速与上面一致</h3><h3 id="9、安装docker-compose-v2"><a href="#9、安装docker-compose-v2" class="headerlink" title="9、安装docker-compose v2"></a>9、安装docker-compose v2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录  针对所有用户</span></span><br><span class="line">mkdir -p /usr/local/lib/docker/cli-plugins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者在家目录下创建  针对当前用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /.docker/cli-plugins</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载二进制版本文件 地址：https://github.com/docker/compose/releases</span></span><br><span class="line">wget https://github.com/docker/compose/releases/download/v2.1.1/docker-compose-linux-x86_64 -O docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为可执行文件</span></span><br><span class="line">chmod +x /usr/local/lib/docker/cli-plugins/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否安装成功</span></span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure>
<h1 id="五、Docker-基本命令"><a href="#五、Docker-基本命令" class="headerlink" title="五、Docker 基本命令"></a>五、Docker 基本命令</h1><p><a href="https://docs.docker.com/reference/">Docker 官网文档命令</a></p>
<h2 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示docker版本</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助信息</span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h2 id="2、镜像基础命令"><a href="#2、镜像基础命令" class="headerlink" title="2、镜像基础命令"></a>2、镜像基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker img</span><br><span class="line"></span><br><span class="line">-a   显示全部的镜像</span><br><span class="line">-q   只显示全部的镜像ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索镜像</span></span><br><span class="line">docker search &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line">--filter=starts==300   根据镜像starts搜索，大于3000的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像，如果不写版本默认拉取最新版</span></span><br><span class="line">docker pull &lt;镜像名&gt;[:tag]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定镜像版本</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的镜像  （可删除多个镜像）</span></span><br><span class="line">docker rmi &lt;镜像ID&gt;   &lt;镜像ID&gt;   &lt;镜像ID&gt; </span><br><span class="line">-f  强制删除</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除全部的镜像</span></span><br><span class="line">docker rmi -f $(docker img -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过Dockerfile 构建镜像   myimage：镜像名  0.0.1：镜像名标签</span></span><br><span class="line">docker build -t myimage:0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="3、容器基础命令"><a href="#3、容器基础命令" class="headerlink" title="3、容器基础命令"></a>3、容器基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建容器并启动</span></span><br><span class="line">docker run [--options] img</span><br><span class="line"></span><br><span class="line">--name=&quot;Name&quot;   给容器起别名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过后台的方式启动的时候，在使用docker ps 发现没有正在运行的容器，是因为docker发现前台没有使用当前容器就会自动杀死当前容器。</span> </span><br><span class="line">-d             后台方式启动 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-it            使用交互方式运行，进入容器查看内容</span><br><span class="line">-p             指定容器的端口    8080:8080</span><br><span class="line">    -p IP:主机端口：容器端口 (常用)</span><br><span class="line">    -p 主机端口：容器端口 (常用)</span><br><span class="line">    -p 容器端口</span><br><span class="line"></span><br><span class="line">-P             随机指定端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前所有正在运行的容器</span></span><br><span class="line">dcoker ps</span><br><span class="line"></span><br><span class="line">-a             列出当前所有正在运行的容器和历史运行的容器</span><br><span class="line">-n=?           列出最近运行的容器</span><br><span class="line">-q             只显示容器的ID</span><br><span class="line"></span><br><span class="line">-v </span><br><span class="line">--rm            容器退出升级删除挂载的数据卷  （在调试时使用）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">直接停止容器并退出容器</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">不停止容器并退出容器</span></span><br><span class="line">ctrl + p + q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定容器</span></span><br><span class="line">dcoker rm 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除所有容器</span></span><br><span class="line">dcoker rm -f  %(dcoker ps -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">docker start 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器</span></span><br><span class="line">docker restart 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制停止容器</span></span><br><span class="line">docker kill 容器ID</span><br></pre></td></tr></table></figure>
<h2 id="4、其他常用命令"><a href="#4、其他常用命令" class="headerlink" title="4、其他常用命令"></a>4、其他常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看docker日志</span></span><br><span class="line">docker logs  -tf --tail 10 容器ID</span><br><span class="line"></span><br><span class="line">-t            显示时间戳</span><br><span class="line">-f            跟踪日志输出</span><br><span class="line">--tail 10     输出指定行数       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器进程信息</span></span><br><span class="line">docker top 容器ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器的元数据</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (以交互式，进入容器开启一个新的终端)</span></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (进入正在运行的命令终端，如果没有进入默认终端)</span></span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从容器内拷贝文件到宿主机上</span></span><br><span class="line">docker cp 容器Id:文件路径  目的主机路径 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看数据卷的信息 xxx:数据卷名</span></span><br><span class="line">docker inspect xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除挂载的数据卷   xxx:数据卷名</span></span><br><span class="line">docker volume rm xxx</span><br></pre></td></tr></table></figure>
<h1 id="六、运行常见服务容器"><a href="#六、运行常见服务容器" class="headerlink" title="六、运行常见服务容器"></a>六、运行常见服务容器</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建MySQL配制间文件以及数据文件挂载目录</span></span></span><br><span class="line">mkdir /opt/mysqldata</span><br><span class="line">mkdir /opt/mysqlconf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取指定版本镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行容器</span></span><br><span class="line">docker run --name mysql-name -p 3307:3306 --restart=always -v /opt/mysql_volume/mysqldata:/var/lib/mysql -v /opt/mysql_volume/mysqllogs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 --character-set-server=utf8mb4</span><br></pre></td></tr></table></figure>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建Redis配制间文件以及数据文件挂载目录</span></span></span><br><span class="line">mkdir /opt/redisdata    存放redis rdb 持久化的数据</span><br><span class="line">mkdir /opt/redisconf   # 存放redis 的配置文件 redis.conf  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取指定版本镜像</span></span><br><span class="line">docker pull redis:5.0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis 配置文件</span> </span><br><span class="line"></span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 6388</span><br><span class="line">appendonly yes</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定配置文件启动</span></span><br><span class="line">docker run -d --name redis-name -p 6388:6388 --restart=always -v /opt/redis_volume/redisdata:/data -v /opt/redis_volume/redisconf:/usr/local/etc/redis -e TZ=Asia/Shanghai redis:5.0.1 redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<h2 id="Elasticsearch-、Kibana"><a href="#Elasticsearch-、Kibana" class="headerlink" title="Elasticsearch 、Kibana"></a>Elasticsearch 、Kibana</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建网桥 ， 可以不用。</span></span><br><span class="line">docker network create somenetwork</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  -e <span class="string">&quot;discovery.type=single-node&quot;</span>   以单节点的形式启动 ， 可以不加</span></span><br><span class="line">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag</span><br></pre></td></tr></table></figure>
<p>使用docker ps 查看，发现elasticsearch没有正在运行， 使用docker logs -f  容器ID 提示一下错误：大致就是没有足够的内存供 Java 运行时环境继续使用。</p>
<p><img src="https://origin.chaizz.com/497261de494511ec9d7c5254006b8f1d.png"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开文件</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在末尾加上  值为262144或者更大。</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存 启用</span></span><br><span class="line">sysctl -p </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂在数据和配置文件  （单节点启动）</span></span><br><span class="line"></span><br><span class="line">docker pull elasticsearch:7.14.2</span><br><span class="line"></span><br><span class="line">docker run -d --restart=always --name elasticsearch -p 9200:9200 -p 9300:9300  -v esdata:/usr/share/elasticsearch/data -v esconfig:/usr/share/elasticsearch/config -v esplugins:/usr/share/elasticsearch/plugins -e &quot;discovery.type=single-node&quot; elasticsearch:7.14.2</span><br></pre></td></tr></table></figure>
<p>下载 Kibana </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.14.2</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name kibana -p 5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://101.35.188.40:9200&quot; -e &quot;I18N_LOCALE=zh-CN&quot; kibana:7.14.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将kibana的配置文件挂载出来，在配置文件中连接elasticsearch</span></span><br><span class="line">docker run -d --restart=always --name kibana -p 5601:5601 -v kibanaconf:/usr/share/kibana/config -e &quot;I18N_LOCALE=zh-CN&quot; kibana:7.14.2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora设置七牛云图床</title>
    <url>/2021/09/26/Typora%E8%AE%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>Markdown是一种<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/52671915">轻量级标记语言</a>，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的<a href="https://baike.baidu.com/item/%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/9862288">纯文本格式</a>编写文档，然后转换成有效的<a href="https://baike.baidu.com/item/XHTML/316621">XHTML</a>（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
<p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如<a href="https://baike.baidu.com/item/GitHub/10145341">GitHub</a>、<a href="https://baike.baidu.com/item/Reddit/1272010">Reddit</a>、<a href="https://baike.baidu.com/item/Diaspora/10726893">Diaspora</a>、[Stack Exchange](<a href="https://baike.baidu.com/item/Stack">https://baike.baidu.com/item/Stack</a> Exchange/13777796)、<a href="https://baike.baidu.com/item/OpenStreetMap/3171606">OpenStreetMap</a> 、<a href="https://baike.baidu.com/item/SourceForge/6562141">SourceForge</a>、<a href="https://baike.baidu.com/item/%E7%AE%80%E4%B9%A6/5782216">简书</a>等，甚至还能被使用来撰写<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E4%B9%A6/346054">电子书</a>。</p>
</blockquote>
<a id="more"></a>


<h1 id="一、设置前提："><a href="#一、设置前提：" class="headerlink" title="一、设置前提："></a>一、设置前提：</h1><p>Typora 版本：0.11.8|<br>已注册七牛云账号：</p>
<ul>
<li>秘钥AK ：virqOxxxxxxxxxxxxxxxxxxxxxxxxMnNIK</li>
<li>秘钥SK：dDFGSasdfxxxxxxxxxxxxxxxxxxxiZiOVu</li>
<li>存储空间名称：cz-tuchuang</li>
<li>自定义域名：<a href="https://origin.chaizz.com/">https://origin.chaizz.com</a></li>
<li>存储区域代码：我的是华北  所以就是 ：z1<br><img src="https://origin.chaizz.com/tc/Snipaste_2021-09-26_19-22-09.png"></li>
</ul>
<h1 id="二、开始设置"><a href="#二、开始设置" class="headerlink" title="二、开始设置"></a>二、开始设置</h1><p>打开Typora  偏好设置–&gt; 图像 –&gt;插入图片时… –&gt; 上传服务 –&gt; 选择 上传图片。</p>
<p>打开Typora  偏好设置–&gt; 图像 –&gt;上传服务设定 –&gt; 上传服务 –&gt; 选择 PicGo-Core (command line)。</p>
<p>点击<strong>下载或更新</strong>按钮，会提示下载一个PicGo插件，等待下载完成点击<strong>打开配置文件</strong>，打开以后默认是空的。复制下面代码覆盖打开的文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;qiniu&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;qiniu&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;accessKey&quot;</span>: <span class="string">&quot;virqOxxxxxxxxxxxxxxxxxIK&quot;</span>,  <span class="comment">// 你的七牛云AK</span></span><br><span class="line">			<span class="attr">&quot;secretKey&quot;</span>: <span class="string">&quot;dDFGSxxxxxxxxxxxxxxxxxVu&quot;</span>,  <span class="comment">// 你的七牛云SK</span></span><br><span class="line">			<span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;cz-tuchuang&quot;</span>,                  <span class="comment">// 你的七牛云存储空间名</span></span><br><span class="line">			<span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://origin.chaizz.com&quot;</span>,           <span class="comment">// 你的七牛云自定义域名</span></span><br><span class="line">			<span class="attr">&quot;area&quot;</span>: <span class="string">&quot;z1&quot;</span>,                             <span class="comment">// 存储区域编号</span></span><br><span class="line">			<span class="attr">&quot;options&quot;</span>: <span class="string">&quot;&quot;</span>,                            <span class="comment">// 网址后缀,可不填</span></span><br><span class="line">			<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;tc/&quot;</span>,                            <span class="comment">// 自定义存储路径，比如 img/ 可不填</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	<span class="attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来点击 <strong>验证图片上传选项</strong> 按钮。上传成功会提示图下图所示：</p>
<p><img src="https://origin.chaizz.com/tc/Snipaste_2021-09-26_19-35-24.png"></p>
<p>点击OK ，重启Typora上传图片即可上传到七牛云了。</p>
]]></content>
      <categories>
        <category>写作</category>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识巩固</title>
    <url>/2021/09/26/Redis%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
</blockquote>
<h1 id="一、Redis-安装"><a href="#一、Redis-安装" class="headerlink" title="一、Redis 安装"></a>一、Redis 安装</h1><p>安装前提：Linux 系统 ubuntu 18.04  / Redis 版本：<a href="https://download.redis.io/releases/redis-6.2.5.tar.gz">6.2.5</a><br>1、检查系统是否安装了gcc 编译器。如果已经安装了 则会显示gcc 的版本号信息，如果没有安装，则使用系统的包管理器安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 gcc</span></span><br><span class="line">sudo apt-get install gcc </span><br></pre></td></tr></table></figure>

<p>2、在Redis官网下载Redis压缩包并解压。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.5.tar.gz</span><br><span class="line">tar -zxvf redis-6.2.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、进入解压后的Redis目录，编译安装Redis。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.5</span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>

<p>4、Redis 默认安装在Linux的usr/local/bin 目录下。</p>
<p>5、启动Redis 。（这种方式是在前台运行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line">    # 后台运行 ，首先更改Redis的配置文件（redis.conf），找到daemonize no 将 no 改为yes 。然后再启动Redis 即可在后台运行。</span><br></pre></td></tr></table></figure>


<h1 id="二、Redis-基础命令"><a href="#二、Redis-基础命令" class="headerlink" title="二、Redis 基础命令"></a>二、Redis 基础命令</h1><p>Redis<a href="http://redis.cn/commands.html">的命令文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择Redis数据库 一共0到15 16个数据库，默认使用0数据库。</span></span><br><span class="line">select 0-15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前库所有的key</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断key是否存在</span></span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的类型</span></span><br><span class="line">type key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除key</span></span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据value选择非阻塞删除（异步删除）</span></span><br><span class="line">unlink key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为给定的key 设置超时时间 （以秒为单位）</span></span><br><span class="line">expire key 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的过期时间 （获取的值为-1:代表永不过期，-2：已经过期）</span></span><br><span class="line">ttl key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看库中的key的数量</span></span><br><span class="line">dbsise</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空当前库</span></span><br><span class="line">flushdb </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通杀全部库</span></span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>

<h1 id="三、Redis-五大常用数据类型"><a href="#三、Redis-五大常用数据类型" class="headerlink" title="三、Redis 五大常用数据类型"></a>三、Redis 五大常用数据类型</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h2><p>String是Redis常用的基本类型，对应的格式是一个key对应一个value，String是二进制安全的，意味着string可以存储任意的类型，包括图片或者序列化的对象。一个Redis中String类型value的值最多可以是512M。</p>
<h3 id="1-1-String-的基本命令"><a href="#1-1-String-的基本命令" class="headerlink" title="1.1 String 的基本命令"></a>1.1 String 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置key value</span></span><br><span class="line">set &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的值</span></span><br><span class="line">get &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的长度</span></span><br><span class="line">strlen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key value   只有key不存在时 设置key的值</span></span><br><span class="line">setnx &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增1</span></span><br><span class="line">incr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增自定义的大小（值为负数则相反）</span></span><br><span class="line">incrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减1</span></span><br><span class="line">decr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减自定义大小 （值为负数则相反）</span></span><br><span class="line">decrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value</span></span><br><span class="line">mset &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value  (当且仅当所有的key都不存在，才能设置成功)</span></span><br><span class="line">msetnx &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取值的范围  （起始位置，结束位置 都包括在内）</span></span><br><span class="line">getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用新的value覆盖key存储的value,索引从0开始</span></span><br><span class="line">setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key的过期时间 ,单位是秒</span></span><br><span class="line">setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以新换旧，设置了新的值，同时获得旧值</span></span><br><span class="line">getset &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-String-的数据结构"><a href="#1-2-String-的数据结构" class="headerlink" title="1.2 String 的数据结构"></a>1.2 String 的数据结构</h3><p>String 的数据结构为简单的动态的字符串（Simple Dynamic String 缩写SDS），是可以修改的字符串，采用预分配冗余空间的方式，来减少内存的频繁分配。<br><img src="https://origin.chaizz.com/44e5fba2450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h2><p>List 是简单的字符串列表，按照插入的顺序排序，可以添加一个元素到字符串的头部或者尾部。他的底层实际上十个双向链表，对两端的操作性能很高，通过索引下标操作中间的节点性能比较差。</p>
<h3 id="2-1-List的基本命令"><a href="#2-1-List的基本命令" class="headerlink" title="2.1 List的基本命令"></a>2.1 List的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从左边插入一个或者多个值， 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">lpush &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右边插入一个或者多个值 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">rpush  &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值  值在键在 ，值光键亡</span></span><br><span class="line">lpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值 值在键在 ，值光键亡</span></span><br><span class="line">rpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key1列表右边取一个值，放到key2左边</span></span><br><span class="line">rpoplpush &lt;key1&gt; &lt;key2&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照索引下标获取元素 （从左到右）  0 -1 ：代表获取所有的值</span></span><br><span class="line">lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据索引下标获取元素，</span>    </span><br><span class="line">lindex &lt;key&gt; &lt;index&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表长度</span></span><br><span class="line">llen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在value的前/后面插入新的value</span></span><br><span class="line">linsert &lt;key&gt; before/after &lt;value&gt; &lt;new value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边删除第n个value   (从左到右)</span></span><br><span class="line">lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将列表key 下标为index的值替换为value</span></span><br><span class="line">lset &lt;key&gt;  &lt;index&gt;  &lt;value&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-List-的数据结构"><a href="#2-2-List-的数据结构" class="headerlink" title="2.2 List 的数据结构"></a>2.2 List 的数据结构</h3><p>List 的数据结构为quicklist。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。他将所有的元素紧挨着一块存储，分配的是一块连续的内存。<br>当数据量比较多的时候，才会改为quicklist，因为普通的链表需要的附加的指针空间更大，会比较浪费空间。<br>比如列表里面存储的只是Int的类型的数据，结构上还需要两个额外的指针：prev和next。<br><img src="https://origin.chaizz.com/4e0057b4450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist 使用双向指针串起来，这样既满足了插入删除性能，又不会出现太大的空间冗余。如上图所示。</p>
<h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h2><h3 id="3-1-Set的基本命令"><a href="#3-1-Set的基本命令" class="headerlink" title="3.1  Set的基本命令"></a>3.1  Set的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素添加到集合key中，已经存在的member元素将会被忽略</span></span><br><span class="line">sadd &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出该集合的所有值</span></span><br><span class="line">smembers &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断集合key是否有该value值，存在为1 不存在为0</span></span><br><span class="line">sismember &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该集合的元素个数</span></span><br><span class="line">scard &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合的某些个元素</span></span><br><span class="line">srem &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  随机丛集中吐出一个值，会从该集合中删除</span></span><br><span class="line">spop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 随机从该集合中取出n个值, 不会从该集合中删除</span></span><br><span class="line">srandmember &lt;key&gt; &lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把集合中一个值移动到另一个集合中</span></span><br><span class="line">smove &lt;key1&gt; &lt;key2&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的交集元素</span></span><br><span class="line">sinter &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的并集元素</span></span><br><span class="line">sunion &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  返回两个集合的差集元素（key1 中的 不包括Key2中的）</span></span><br><span class="line">sdiff &lt;key1&gt; &lt;key2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Set-的数据结构"><a href="#3-2-Set-的数据结构" class="headerlink" title="3.2 Set 的数据结构"></a>3.2 Set 的数据结构</h3><p>Set 的数据结构是dict字典，字典是使用哈希表实现的。所有的value 都指向同一个内部的值。</p>
<h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4 Hash"></a>4 Hash</h2><h3 id="4-1-Hash的基本命令"><a href="#4-1-Hash的基本命令" class="headerlink" title="4.1 Hash的基本命令"></a>4.1 Hash的基本命令</h3><p>Redis 的Hash是一个键值对集合，是一个String类型的field和value 的映射表，Hash特别适合存储对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给key集合中的field 键赋值value</span></span><br><span class="line">hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key集合field中取出value</span></span><br><span class="line">hget &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置<span class="built_in">hash</span>的值</span></span><br><span class="line">hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; &lt;field3&gt; &lt;value3&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看<span class="built_in">hash</span>表key中,给定域field 是否存在 ，存在返回1 不存在返回0</span></span><br><span class="line">hxists &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的field</span></span><br><span class="line">hkeys &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的value</span></span><br><span class="line">hvals &lt;keys&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值加上增量1 -1</span> </span><br><span class="line">hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值设置为value 当且仅当该域不存在</span></span><br><span class="line">hsetnx  &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-Hsh-的数据结构"><a href="#4-2-Hsh-的数据结构" class="headerlink" title="4.2 Hsh 的数据结构"></a>4.2 Hsh 的数据结构</h3><p>Hash 类型对应的数据机构有两种：ziplist （压缩列表） 和 hashlist（哈希列表） ，当field-value 的长度较短且个数较少的时候，使用ziplist，否则使用hashlist。</p>
<h2 id="5-ZSet"><a href="#5-ZSet" class="headerlink" title="5 ZSet"></a>5 ZSet</h2><p>Redis的有序集合和Set 类似，是一个没有重复元素的字符串集合，不同之处是有序集合的每个成员都关联了一个<strong>评分</strong>，这个<strong>评分</strong>被用来按照从最低到最高的方式排序集合中的成员，<strong>集合的成员是唯一的，但是评分可以重复。</strong></p>
<p>因为元素是有序的，所以可以很快的根据评分或者次序来获得一个范围的元素。</p>
<p>访问集合中的元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="5-1-ZSet-的基命令"><a href="#5-1-ZSet-的基命令" class="headerlink" title="5.1 ZSet 的基命令"></a>5.1 ZSet 的基命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素及其其score值加入到有序集key当中</span></span><br><span class="line">zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，下标在 &lt;start&gt; &lt;stop&gt; 之间的元素, 带 withscores可以让分数一起和值返回到结果集</span></span><br><span class="line">zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，所有的score值介于min 和max 之间 （包括min 或者 max）的成员，有序集成员按照score值递增(从小到大依次排列)</span></span><br><span class="line">zrangebyscore &lt;key &gt; &lt;min&gt; &lt;max&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，改为由大到小排列</span></span><br><span class="line">zrangebyscore &lt;key&gt; &lt;max&gt; &lt;min&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为元素的score加上增量</span></span><br><span class="line">zinceby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除该集合下 指定值的元素</span></span><br><span class="line">zrem &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计该集合，分数区间的元素个数</span></span><br><span class="line">zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该值在集合中的排名， 从0开始</span></span><br><span class="line">zrank &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Zset-的数据结构"><a href="#5-2-Zset-的数据结构" class="headerlink" title="5.2 Zset 的数据结构"></a>5.2 Zset 的数据结构</h3><p>SortedSet 是Redis的一个特别的数据结构，他的底层使用了两个数据结构。</p>
<ol>
<li>hash，hash 的作用就是关联元素value和权重score，保障元素value的唯一性们可以通过元素value找到相应的score。</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素的列表。</li>
</ol>
<h2 id="6-Bitmaps"><a href="#6-Bitmaps" class="headerlink" title="6  Bitmaps"></a>6  Bitmaps</h2><p>BItmaps 本身并不是一种数据类型，实际上他就是字符串，key-value ,但是他可以对字符串进行位操作。<br>Bitmaps 单独提供了一套目命令，所以在Redis 中使用Bitmaps和使用字符串方法不一样，可以吧Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1数组的下标在Bitmaps中叫偏移量。</p>
<h3 id="6-1-Bitmaps-的基本命令"><a href="#6-1-Bitmaps-的基本命令" class="headerlink" title="6.1  Bitmaps 的基本命令"></a>6.1  Bitmaps 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  设置Bitmaps 中某个偏移量的值 0 或 1， offset的偏移量从0开始</span></span><br><span class="line">setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取Bitmaps中某个偏移量的值</span></span><br><span class="line">getbit &lt;key&gt; &lt;offset&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计字符串被设置为1的Bit数,一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start end 参数，可以让计数只在特定的位上进行，start和end都可以使用负值，比如-1表示最后一位,-2表示倒数第二个，start 和end是指bit组的字节下标数，二者皆包含。</span></span><br><span class="line">bitcount &lt;key&gt; &lt;start&gt; &lt;end&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> bitop  是一个复合操作，他可以做多个bitmaps的and （交集）、or（并集）、not (非)、xor（异或）操作，并将结果保存在destkey中。</span></span><br><span class="line">bitop  and/or/not/xor &lt;destkey&gt; &lt;key&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7  HyperLogLog"></a>7  HyperLogLog</h2><h3 id="7-1-HyperLogLog-的基本命令"><a href="#7-1-HyperLogLog-的基本命令" class="headerlink" title="7.1 HyperLogLog 的基本命令"></a>7.1 HyperLogLog 的基本命令</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常大的时候计算基数所需要空间总是固定的，并且是很小的。<br>在Redis里面每个HyperLogLog 键只需要花费12KB内存，就可以计算接近2^64个不同的基数，这和计算基数时元素越多消耗内存就越多的集合形成鲜明对比。<br>但是HyperLogLog 只会根据输入元素计算基数，而不会存储输入数据本身，所以HyperLogLog并不能像集合那样返回输入的各个元素。<br>什么是基数？<br>比如数据集：{1、3、5、7、5、7、9} 那么这个数据集的基数就是：{1、3、5、7、9} 基数（不重复元素）为5。基数估计 就是在误差可以收的范围内快速计算基数。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定元素到 HyperLogLog  中</span></span><br><span class="line">pfadd &lt;key&gt; &lt;element&gt; &lt;element&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的近似基数  可以计算多个key，</span></span><br><span class="line">pfcount &lt;key&gt;  [key key ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个key合并后的结果存储在另一个key中。</span></span><br><span class="line">pfmerge &lt;key&gt;  &lt;key1&gt;  &lt;key2&gt;</span><br></pre></td></tr></table></figure>



<h2 id="8-Geospatial"><a href="#8-Geospatial" class="headerlink" title="8 Geospatial"></a>8 Geospatial</h2><p>Redis 3.2 中增加对GEO类型的支持，GEO是Geographic地理信息的缩写。该类型就是元素的二维坐标，在地图上就是经纬度，Redis基于该类型提供了经纬度设置，范围查询。距离查询。经纬度Hash等操作。</p>
<h3 id="8-1-Geospatial的基本命令"><a href="#8-1-Geospatial的基本命令" class="headerlink" title="8.1 Geospatial的基本命令"></a>8.1 Geospatial的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加地理位置 经度 纬度 名称, 两级无法添加，一般会下载城市经纬度数据，直接导入。有效的经度从-180 到180 纬度 -85.05112878 到 85.05112878 ,超出范围会返回错误。</span></span><br><span class="line">geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;  &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取指定地区的坐标值</span></span><br><span class="line">geopos &lt;key&gt; &lt;member&gt; [member]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取两个位置的直线距离，单位有 m km ft(英尺) mi (英里) ，不指定为单位 默认是 m (米)</span></span><br><span class="line">geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; m/km/ft/mi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以给定的经纬度为中心，找出某一半径内的元素</span></span><br><span class="line">georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius m/km/ft/mi</span><br></pre></td></tr></table></figure>

<h1 id="四、Redis-的事务操作"><a href="#四、Redis-的事务操作" class="headerlink" title="四、Redis 的事务操作"></a>四、Redis 的事务操作</h1><p>Redis 的事务 是一个单独的隔离的操作，事务中所有的命令都会序列化、按顺序的执行，事务在执行过程中，不会被其他的客户端发送过来的命令请求打断。<br>Redis的事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p>
<p>从输入Multi 开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过Discard来放弃组队。</p>
<p><img src="https://origin.chaizz.com/5c2866ec450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="1-Redis-事务的错误处理"><a href="#1-Redis-事务的错误处理" class="headerlink" title="1  Redis 事务的错误处理"></a>1  Redis 事务的错误处理</h2><h3 id="1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"><a href="#1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。" class="headerlink" title="1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"></a>1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。</h3><p><strong><img src="https://origin.chaizz.com/62e8c936450e11ec9d7c5254006b8f1d.png"></strong></p>
<h3 id="1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"><a href="#1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。" class="headerlink" title="1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"></a>1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。</h3><p><img src="https://origin.chaizz.com/6a3b5302450e11ec9d7c5254006b8f1d.png"> </p>
<h3 id="1-3-Redis的事务冲突，以及解决办法。"><a href="#1-3-Redis的事务冲突，以及解决办法。" class="headerlink" title="1.3 Redis的事务冲突，以及解决办法。"></a>1.3 Redis的事务冲突，以及解决办法。</h3><h4 id="1-3-1-悲观锁"><a href="#1-3-1-悲观锁" class="headerlink" title="1.3.1 悲观锁"></a>1.3.1 悲观锁</h4><p>每次去获取数据都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人就只能等到锁释放才能能拿到数据。传统的关系型数据库很多地方都用到了悲观锁：比如行锁、表锁、读锁、写锁等。</p>
<p><img src="https://origin.chaizz.com/751786ec450e11ec9d7c5254006b8f1d.png"></p>
<h4 id="1-3-2-乐观锁"><a href="#1-3-2-乐观锁" class="headerlink" title="1.3.2 乐观锁"></a>1.3.2 乐观锁</h4><p>每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有更新这数据，可以使用版本号等机制。乐观锁适用于多读的场景，这样可以以高吞吐量，Redis 就是利用这用check-and-set的机制实现事务的。实际应用场景：例如买票，很多人都可以抢到，但是付款只有一个人可以付款成功。</p>
<p><img src="https://origin.chaizz.com/7bd4e6be450e11ec9d7c5254006b8f1d.png"></p>
<p>在Redis 中使用乐观锁<br>在执行Multi 之前先执行 watch key 可以监听一个或者多个key，如果事务执行之前这个key被其他的命令所修改，那么事务将会被打断。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给Redis加乐观锁</span></span><br><span class="line">watch key </span><br></pre></td></tr></table></figure>
<h3 id="1-4-Redis-事务的三特性"><a href="#1-4-Redis-事务的三特性" class="headerlink" title="1.4 Redis 事务的三特性"></a>1.4 Redis 事务的三特性</h3><h4 id="1-4-1单独的隔离操作"><a href="#1-4-1单独的隔离操作" class="headerlink" title="1.4.1单独的隔离操作"></a>1.4.1单独的隔离操作</h4><p>事务中所有的命令都会序列化，按照顺序执行，事务在执行过程中没不会被其他的可短短发送来的命令请求打断。</p>
<h4 id="1-4-2-没有隔离级别的概念"><a href="#1-4-2-没有隔离级别的概念" class="headerlink" title="1.4.2 没有隔离级别的概念"></a>1.4.2 没有隔离级别的概念</h4><p>队列中的命令没有提交之前都不会被实际的执行，因为事务提交之前（exec）任何指令都不会被执行。</p>
<h4 id="1-4-3-不保证原子性"><a href="#1-4-3-不保证原子性" class="headerlink" title="1.4.3 不保证原子性"></a>1.4.3 不保证原子性</h4><p>事务中如果有一天命令执行失败，其他的命令仍然会被执行，不会回滚。</p>
<h1 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h1><h2 id="1-RDB-（Redis-Database）-方式"><a href="#1-RDB-（Redis-Database）-方式" class="headerlink" title="1  RDB （Redis Database） 方式"></a>1  RDB （Redis Database） 方式</h2><p>在指定<strong>时间间隔内</strong>将内存中的<strong>数据集快照</strong>写入磁盘，也就是快照，它恢复是将快照文件直接读到内存里面。（在Redis 的配置文件内设置时间间隔）<strong>RDB 默认开启。</strong></p>
<p>备份是如何执行的：<br>Redis 会单独的创建一个fork子进程来持久化，会先将数据写入一个临时文件中，等持久化过程都结束了，在用这个临时文件替换上次持久化的文件，整个过程主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据的恢复，且对于数据的完整性要求不那么敏感，那么RDB的方式要比AOF的方式更加的额高效，RDB的缺点就是<strong>最后一次持久化的数据可能会丢失。</strong></p>
<p>fork的作用就是复制一个与当前进程一样的进程，新的进程的所有的数据（变量，程序计数器等）都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件解释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查数据完整性、默认值 yes 在存储跨照后让Redis 使用CRC64算法来对数据进行校验。但是这样做会损失大约10%的性能。推荐开启。</span></span><br><span class="line">rdbchecksum  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis 无法写入磁盘的时候，直接关掉Redis的写操作，推荐yes</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 压缩文件</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将数据写入磁盘的时间间隔， 默认 六十分钟1次、五分钟一百次、一分钟一万次</span></span><br><span class="line">save 300 100</span><br></pre></td></tr></table></figure>



<p>RDB的优势：</p>
<ul>
<li>适合大规模数据的恢复。</li>
<li>对数据完整性和一致性要求不高时使用。</li>
<li>节省磁盘空间。</li>
<li>回恢复度快。</li>
</ul>
<p>RDB的劣势：</p>
<ul>
<li>在写入临时快照的时候，数据被克隆了一份，大致两倍的膨胀性需要考虑。</li>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据量庞大还是比较消耗性能。</li>
<li>在备份周期在一定时间间隔内做一次备份，所以如果Redis以外关掉，就会丢失最后一次快照的修改。</li>
</ul>
<p>RDB的备份恢复：<br>默认Redis启动会自动将Redis的快照文件（dump.rdb）读取到内存中。手动恢复的话只需要将快照文件复制到Redis启动目录下。</p>
<h2 id="2-AOF（Append-Only-File）方式"><a href="#2-AOF（Append-Only-File）方式" class="headerlink" title="2  AOF（Append Only File）方式"></a>2  AOF（Append Only File）方式</h2><p>以日志的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的所有<strong>写/修改/删除指令记录下来（读操作不记录）</strong>，只许追加文件但是不可以改文件，Redis启动之初，会自动读取范围见重新构建数据，换言之Redis重启的话就会根据日志文件的内容将写指令重头到尾在执行一遍，以完成数据的恢复工作。<strong>AOF默认不开启。</strong></p>
<p>开启AOF：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认为no 不开启， 将其改为yes 开启。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果RDB和AOF同时开启，Redis 默认会读取AOF的配置文件来恢复数据。</strong> </p>
<p>AOF 异常修复：<br>如果遇到AOF文件损坏，通过 redis-check-aof   –fix  appendonly.aof 进行恢复。</p>
<p>AOF的同步频率设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置AOF的同步频率 。</span></span><br><span class="line">	always：始终同步。</span><br><span class="line">	everysec ：每秒同步，每秒记入日志一次，如果宕机当前秒的数据可能会丢失。</span><br><span class="line">	no：redis 不主动同步，把同步的时机交给操作系统。</span><br><span class="line">appendfsync always   </span><br></pre></td></tr></table></figure>

<p>Rewrite 压缩<br>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过设置的阈值时，Redis回启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p>重写的原理：<br>AOF文件持续增长而过大时， 会fork 出一条新的进程将文件重写（也是先写临时文件最后在rename）Redis4.0后的版本重写，实际上就是把RDB的快照，以二进制的形式附在新的aof的头部，作为已有的历史数据，替换掉原来的流水操作。</p>
<p>AOF持久化的流程：</p>
<ul>
<li>客户端的请求命令会被append追加到AOF的缓冲区内。</li>
<li>AOF缓冲区根据AOF持久化策略（always/everysec/no）将操作sync同步到磁盘中的.aof文件中去。</li>
<li>AOF文件大小超过重写策略或者手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。</li>
</ul>
<h1 id="六、Redis主从复制"><a href="#六、Redis主从复制" class="headerlink" title="六、Redis主从复制"></a>六、Redis主从复制</h1><p><img src="https://origin.chaizz.com/84964932450e11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Redis 主从复制配置文件设置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 丛机配置文件主要用户读操作，所以 aof 以及edb配置相关关掉即可。</span></span><br><span class="line"></span><br><span class="line">requirepass  &quot;admin.123&quot;  　　#设置redis登录密码</span><br><span class="line"></span><br><span class="line">masterauth  &quot;admin.123&quot; 　　#主从认证密码，否则主从不能同步</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在某个从机中配置为从机：这种设置从服务器是暂时的，重启之后就又会变成主服务器。</span></span><br><span class="line">slaveof ip port</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在主服务器中使用命令查看主从信息：</span></span><br><span class="line">info relication</span><br></pre></td></tr></table></figure>

<p><img src="https://origin.chaizz.com/9167c1cc450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="1-主从复制的原理："><a href="#1-主从复制的原理：" class="headerlink" title="1 主从复制的原理："></a>1 主从复制的原理：</h2><ul>
<li>当从服务器连接上主服务器上以后，从服务器向主服务器发送数据同步消息即一个sync命令。</li>
<li>主服务器接到从服务器送过来的同步消息，把主服务器的数据进行持久化，把RDB文件发送到从服务器，从服务器拿到RDB进行读取。（从服务器主动请求同步）</li>
<li>全量复制：从服务器在接受数据库数据后将其存盘并加载到内存中。</li>
<li>增量复制：主服务器将新的所有收集到的修改的命令依次传输给从服务器完成同步。</li>
</ul>
<h2 id="2-主从复制之薪火相传"><a href="#2-主从复制之薪火相传" class="headerlink" title="2 主从复制之薪火相传"></a>2 主从复制之薪火相传</h2><p>Redis 主从模式为 一个主，其他的为从。其中第三个从为第二个从的主，类似于排队的节点，每一节点都是前面的从。也可以多个从节点。 </p>
<p><img src="https://origin.chaizz.com/9c1ab480450e11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置方法：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在从服务器中配置他的从服务器</span></span><br><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure>
<h2 id="3-Redis主从之反客为主"><a href="#3-Redis主从之反客为主" class="headerlink" title="3  Redis主从之反客为主"></a>3  Redis主从之反客为主</h2><p>反客为主在薪火相传的基础上给某个从服务器加上能够变为主服务器的命令。使其能够在主服务器挂掉的时候充当主服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若果想让从服务器在主服务器挂掉之后自动变为主服务器设置方法： 需要手动操作，全自动实现 需要使用哨兵模式</span></span><br><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>


<h2 id="4-Redis主从之哨兵模式"><a href="#4-Redis主从之哨兵模式" class="headerlink" title="4 Redis主从之哨兵模式"></a>4 Redis主从之哨兵模式</h2><p>配置哨兵模式：<br><strong>定义配置文件 senttinel.conf   （文件名不能错） 文件内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mymaster 是为监控对象起的名称， 1 代表至少有多少个哨兵同意迁徙的数量。</span></span><br><span class="line">sentinel monitor mymaster IP PORT 1</span><br></pre></td></tr></table></figure>
<p>哨兵故障恢复：<br>从下线的主服务器的从服务器中挑选一个将其转成主服务器。选择的条件依次为：1. 优先级最靠前的。2. 选择偏移量最大的，3. 选择runid 最小的。</p>
<p>挑选出新的主服务器后sentinel 向原先的主服务器的从服务器发送slaveof 命令，复制新的master，当已经下线的主服务器上线时，sentinel 向其发送slaveof 命令让其成为新主的从。</p>
<p>优先级在Redis.conf 中默认：replica-priority 100 值越小 优先级越高。<br>偏移量是指获取原主机数据最全的。<br>每个Redis示例启动后都会随机生成一个40位runid。</p>
<h1 id="七、Redis-集群"><a href="#七、Redis-集群" class="headerlink" title="七、Redis 集群"></a>七、Redis 集群</h1><p>Redis 的主从模式，薪火相传。主机宕机，会导致IP的地址变化，应用程序中配置需要修改对应主机啊的地址没端口等信息。之前通过代理主机来解决，Redis 3.0 提供了解决方案，就是无中心化集群方案。</p>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个Redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区，来提供一定程度的可用性，：即使集群中有部分节点失效或者无法进行通讯，集群也能够继续处理命令请求。</p>
<h2 id="1-Redis-集群配置"><a href="#1-Redis-集群配置" class="headerlink" title="1 Redis 集群配置"></a>1 Redis 集群配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 包含redis主配置文件</span></span><br><span class="line">include /myredis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置pid文件位置 (注意区别每个节点文件名要不一致)</span></span><br><span class="line">pidfile /var/run/redis-6379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置持久化文件名  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群配置</span></span><br><span class="line">cluster-enabled  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置当前节点的配置文件的名字  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置失联时间</span>   </span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保集群配置文件没有出错，查看Redis 服务是否正常启动，以及Redis对应的几点文件是否生成。</span></span><br></pre></td></tr></table></figure>
<p><strong><img src="https://origin.chaizz.com/a51f728c450e11ec9d7c5254006b8f1d.png"></strong></p>
<p>以上配置生成了Redis的集群节点，但是还没有将每个节点相结合。以下操作将各个节点结合配置为集群。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果是低版本Redis需要安装ruby环境，此版本不需要安装。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先进入到解压后Redis目录中</span></span><br><span class="line">cd /opt/redis-6.2.5/src</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行合并集群命令。</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处使用本机地址 生产环境使用本机IP地址</span></span><br><span class="line">1： 表示一个主节点对应一个从节点 </span><br><span class="line"></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6389 127.0.0.1:6390 127.0.0.1:6391</span><br></pre></td></tr></table></figure>
<p>设置成功如下图所示：<br><img src="https://origin.chaizz.com/abdb9a88450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="2-Redis-集群连接"><a href="#2-Redis-集群连接" class="headerlink" title="2 Redis 集群连接"></a>2 Redis 集群连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 集群连接</span> </span><br><span class="line">redis-cli -c -p 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群节点信息</span></span><br><span class="line">cluster nodes </span><br></pre></td></tr></table></figure>

<p><img src="https://origin.chaizz.com/b7277e5c450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 如何分配至少三个主节点？</p>
<p>首先分配原则尽量保证，每个主数据库运行在不同的IP地址中，每个从库和主库不在同一个IP地址中。</p>
<p>什么是slots？</p>
<p>当Redis集群设置成功后会提示 ： <code>All 16384 slots covered</code>，代表一个集群包含16384个插槽，数据库的每个键都会存储到这些个插槽中去，集群使用公式 CRC16(key)%16384 来计算key属于那个插槽，其中CRC16(key) 用于计算key的CRC16校验和。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算集群的中的key的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的插槽值</span></span><br><span class="line">cluster keyslot &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算插槽值里面有多少个key ,只能查看自己插槽中的key值</span></span><br><span class="line">cluster countkeysinslot &lt;slot&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回count个slot中的键 ,返回插槽中的键的数量。</span></span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt; </span><br></pre></td></tr></table></figure>

<h2 id="3-故障恢复"><a href="#3-故障恢复" class="headerlink" title="3 故障恢复"></a>3 故障恢复</h2><p>Redis 集群中的某个主服务宕机，他的从服务器会直接成为主服务器，来保持运行。（通过配置文件的失联时间来判断是和否能够正常使用：cluster-node-timeout 15000）<br>如果Redis的集群中的某个节点的主从全部挂掉，他的情况 需要根据配置文件来说明：</p>
<ul>
<li>如果配置文件中的<code>cluster-require-full-coverage</code> 的值为 <code>yes</code> ， 则整个集群都挂掉。</li>
<li>如果值为 <code>no</code> 则该插槽服务挂掉，无法写入读取数据，但是不会影响其他的集群节点。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>部署YoloV5</title>
    <url>/2021/07/10/%E9%83%A8%E7%BD%B2YoloV5/</url>
    <content><![CDATA[<p>​                                    </p>
<a id="more"></a>

<p>一、安装Ubuntu 20.04 系统。</p>
<p>二、更换Ubuntu 源为国内源。（尽量不要用阿里源）</p>
<p>三、升级包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update    </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>四、下载Nvidia 驱动。<a href="https://www.nvidia.cn/content/DriverDownload-March2009/confirmation.php?url=/XFree86/Linux-x86_64/460.84/NVIDIA-Linux-x86_64-460.84.run&lang=cn&type=TITAN">下载地址</a>。根据自己的显卡查找驱动。</p>
<ul>
<li><p>禁用nouveau驱动</p>
<ul>
<li><p>编辑 /etc/modprobe.d/blacklist-nouveau.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>提示gcc 问题：</p>
</li>
</ul>
</li>
<li><p>直接安装  <code>sudo apt-get install gcc g++</code></p>
</li>
</ul>
<p>提示make问题：</p>
<ul>
<li>直接安装 <code>sudo apt-get install  make</code></li>
</ul>
<p>五、安装CUDA。（需要根据pytorch 的版本选择CUDA版本。这里选择的是CUDA 11.1）  下载地址：<a href="https://developer.nvidia.com/cuda-11.1.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=2004&target_type=runfilelocal">CUDA地址</a>。</p>
<p>官网安装步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run</span><br><span class="line">sudo sh cuda_11.1.0_455.23.05_linux.run</span><br></pre></td></tr></table></figure>
<p>接下来按照提示输入。</p>
<p>选择安装界面：因为上面已经安装过驱动，所以取消选择第一个 driver ，然后选中 按下回车。</p>
<p>配置CUDA环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.1/lib64</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-11.1/bin</span><br><span class="line">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda-11.1</span><br><span class="line">source  ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>验证是CUDA否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line">输出CUDA版本即安装成功</span><br></pre></td></tr></table></figure>
<p>六、安装CUDNN。 下载地址：<a href>CUDNN</a> 。 需要登录账户 。</p>
<p>七、配置Python 虚拟环境 （Pyenv）</p>
<ul>
<li><p>安装步骤</p>
<ul>
<li><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git    </span><br><span class="line">git clone https://github.com/yyuu/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">输入以下内容：</span></span><br><span class="line">export PATH=~/.pyenv/bin:$PATH</span><br><span class="line">export PYENV_ROOT=~/.pyenv</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">刷新环境变量</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看可安装的Python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装指定版本的Python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.8.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xxx表示要切换的版本</span><br><span class="line">**有三种切换方式 glocal local shell**</span><br><span class="line">　　1. glocal 全局环境,在未再次使用 glocal切换环境之前，一直使用此环境。</span><br><span class="line">　　2. local 本次登录环境。重启后，则环境失效，并返回当前glocal的环境。</span><br><span class="line">　　3. shell 局部（临时）环境。关闭命令行窗口，则环境失效，并返回当前glocal的环境。</span><br><span class="line">pyenv glocal xxx  </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装virtualenv   创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-virtualenv.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-virtualenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cho &#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.7.0 yolo385</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;.pyenv&#x2F;versions&#x2F;env370</span><br></pre></td></tr></table></figure>
<p>八、安装pytorch</p>
</li>
</ul>
</li>
</ul>
<p>torch 官网 ：<a href="https://pytorch.org/">torch</a></p>
<p>按照自己的配置选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install torch&#x3D;&#x3D;1.9.0+cu111 torchvision&#x3D;&#x3D;0.10.0+cu111 torchaudio&#x3D;&#x3D;0.9.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</span><br></pre></td></tr></table></figure>
<p>出现 not import _lzma :</p>
<p>解决办法 ：重新安装pandas</p>
]]></content>
      <categories>
        <category>YoloV5</category>
      </categories>
      <tags>
        <tag>YoloV5</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装RabbitMQ</title>
    <url>/2021/07/10/Ubuntu%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<p>​        </p>
<a id="more"></a>

<blockquote>
<p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>均有与代理接口通讯的<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>库。</p>
</blockquote>
<p>安装前提：首先需要安装Erlang</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install erlang-nox</span><br></pre></td></tr></table></figure>
<p>1、 使用apt-get 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>2、安装完毕配置文件默认在：/etc/rabbitmq/ 下。</p>
<p><strong>如果已经安装了redis ,再启动之前现将redis 启动。</strong></p>
<p>操作命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-server start</span><br><span class="line">sudo rabbitmq-server stop</span><br><span class="line">sudo rabbitmq-server restart</span><br><span class="line">sudo rabbitmqctl status</span><br></pre></td></tr></table></figure>
<p>3、创建用户</p>
<p>创建用户名为： admin  密码：admin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl add_user  admin  admin  </span><br></pre></td></tr></table></figure>
<p>设置用户标签 为：administrator  （添加远程访问必须为 ：administrator  ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
<p>设置当前 / 虚拟主机下的权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一个“.*”用于配置资产实体的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第二个“.*”表示对实体的写权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第三个“.*” 用于读取物理的权限</span></span><br><span class="line">sudo rabbitmqctl  set_permissions -p / admin &#x27;.*&#x27; &#x27;.*&#x27; &#x27;.*&#x27;</span><br></pre></td></tr></table></figure>
<p>4、列出集群中的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>
<p>5、删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_user &#39;用户名&#39;</span><br></pre></td></tr></table></figure>
<p>6、撤销用户在虚拟主机中的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl clear_permissions -p &quot;custom-vhost&quot;  &quot;用户名&quot;</span><br></pre></td></tr></table></figure>
<p>7、看虚拟主机列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_vhosts</span><br></pre></td></tr></table></figure>
<p>8、每个rabbitmqctl权限管理操作的范围仅限于单个虚拟主机。</p>
<p>授予用户对所有虚拟主机的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for v in $(rabbitmqctl list_vhosts --silent); do rabbitmqctl set_permissions -p $v &quot;a-user&quot; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;; done</span><br></pre></td></tr></table></figure>


<p>设置RabbitMQ可以远程访问</p>
<p>在/etc/rabbitmq/rabbitmq-env.conf 中添加以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">loopback_users=none</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
        <category>安装RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>obsdian插件推荐</title>
    <url>/2021/07/10/obsdian%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>​        </p>
<a id="more"></a>

<h1 id="Obsdian插件"><a href="#Obsdian插件" class="headerlink" title="Obsdian插件"></a>Obsdian插件</h1><p>直接在obsdian的插件面板直接搜索想要的插件相关关键字。</p>
<blockquote>
<p>s在插件面板中搜索 markdown转化为world文件类型。</p>
</blockquote>
<p>插件推荐：</p>
<ol>
<li><p>统计笔记的数量：File Explorer Note Count</p>
</li>
<li><p> 最近访问的笔记：Recent File</p>
</li>
<li><p>Markdown 转化为 World 文件类型：Pandoc</p>
</li>
<li><p>将大纲内容转化为思维导图形式： Mindmap</p>
</li>
<li><p>绘制手绘风格流程图：Excaldraw</p>
</li>
</ol>
]]></content>
      <categories>
        <category>写作</category>
        <category>Obsdian</category>
      </categories>
      <tags>
        <tag>Obsdian</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda3安装虚拟环境</title>
    <url>/2021/05/09/Miniconda3%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>​                   </p>
<a id="more"></a>

<p>创建虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n [name] python=版本 -y </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 激活环境</span></span><br><span class="line">conda activate name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭环境</span></span><br><span class="line">deactivate </span><br></pre></td></tr></table></figure>
<p>在对应的环境中安装包 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install xxx</span><br><span class="line">conda install xxx</span><br></pre></td></tr></table></figure>
<p>运行jupyter notebook 遇到错误 </p>
<ul>
<li>提示无法导入某个包</li>
</ul>
<p>问题原因：</p>
<p>jupyter notebook 使用的还是原来的python 包，无法使用新的虚拟环境的包。</p>
<p>点击 jupyter notebook 的new 查看是否能够找到新创建的环境。</p>
<p><img src="https://origin.chaizz.com/Snipaste_2021-05-08_18-59-42.png"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipykernel在虚拟环境下安装 ipykernel。</span></span><br><span class="line">conda install -n 环境名称 ipykernel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将创建的新的虚拟环境，添加到核心。</span></span><br><span class="line">python -m ipykernel install --user --name 环境名称 --display-name &quot;环境名称&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来重新打开 jupyter notebook即可。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行代码时提示：内核似乎已经死了 . 它会自动重启 。</li>
</ul>
<p>问题原因：</p>
<p>再学习DIVE INTO DEEP LEARNING 这本书中的代码时，运行某一段输出图表的内容的时候，提示内核似乎已经死了 . 它会自动重启 。 无法输出图表。</p>
<p>在Pycharm 上提示的错误为 ：</p>
<p><img src="https://origin.chaizz.com/Snipaste_2021-05-08_19-10-19.png"></p>
<p>解决办法：</p>
<p>在代码前导入以下代码即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;KMP_DUPLICATE_LIB_OK&#x27;</span>] = <span class="string">&#x27;TRUE&#x27;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p><a href="https://blog.csdn.net/qq_43382616/article/details/108642590">jupyter notebook无法使用conda环境的模块</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/scar2016/article/details/115710308">jupyter notebook内核挂掉了，需要重启</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Miniconda库</category>
      </categories>
      <tags>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 部署YoloV5</title>
    <url>/2021/05/09/Ubuntu%20%E9%83%A8%E7%BD%B2YoloV5/</url>
    <content><![CDATA[<p>​                   </p>
<a id="more"></a>

<h2 id="Ubuntu-部署YoloV5"><a href="#Ubuntu-部署YoloV5" class="headerlink" title="Ubuntu 部署YoloV5"></a>Ubuntu 部署YoloV5</h2><p>一、安装Ubuntu 20.04 系统。</p>
<p>二、更换Ubuntu 源为国内源。（尽量不要用阿里源）</p>
<p>三、升级包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update	</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>四、下载Nvidia 驱动。<a href="https://www.nvidia.cn/content/DriverDownload-March2009/confirmation.php?url=/XFree86/Linux-x86_64/460.84/NVIDIA-Linux-x86_64-460.84.run&lang=cn&type=TITAN">下载地址</a>。根据自己的显卡查找驱动。</p>
<ul>
<li><p>禁用nouveau驱动</p>
<ul>
<li><p>编辑 /etc/modprobe.d/blacklist-nouveau.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure></li>
<li><p>接下来然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</span><br></pre></td></tr></table></figure></li>
<li><p>然后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>提示gcc 问题：</p>
</li>
</ul>
</li>
<li><p>直接安装  <code>sudo apt-get install gcc g++</code></p>
</li>
</ul>
<p>提示make问题：</p>
<ul>
<li>直接安装 <code>sudo apt-get install  make</code></li>
</ul>
<p>五、安装CUDA。（需要根据pytorch 的版本选择CUDA版本。这里选择的是CUDA 11.1）  下载地址：<a href="https://developer.nvidia.com/cuda-11.1.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=2004&target_type=runfilelocal">CUDA地址</a>。</p>
<p>官网安装步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run</span><br><span class="line">sudo sh cuda_11.1.0_455.23.05_linux.run</span><br></pre></td></tr></table></figure>
<p>接下来按照提示输入。</p>
<p>选择安装界面：因为上面已经安装过驱动，所以取消选择第一个 driver ，然后选中 按下回车。</p>
<p>配置CUDA环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.1/lib64</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-11.1/bin</span><br><span class="line">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda-11.1</span><br><span class="line">source  ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>验证是CUDA否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line">输出CUDA版本即安装成功</span><br></pre></td></tr></table></figure>
<p>六、安装CUDNN。 下载地址：<a href>CUDNN</a> 。 需要登录账户 。</p>
<p>七、配置Python 虚拟环境 （Pyenv）</p>
<ul>
<li><p>安装步骤</p>
<ul>
<li><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git	</span><br><span class="line">git clone https://github.com/yyuu/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure></li>
<li><p>打开环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">输入以下内容：</span></span><br><span class="line">export PATH=~/.pyenv/bin:$PATH</span><br><span class="line">export PYENV_ROOT=~/.pyenv</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">刷新环境变量</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>查看可安装的Python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure></li>
<li><p>安装指定版本的Python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.8.5</span><br></pre></td></tr></table></figure></li>
<li><p>更新数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure></li>
<li><p>切换python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xxx表示要切换的版本</span><br><span class="line">**有三种切换方式 glocal local shell**</span><br><span class="line">　　1. glocal 全局环境,在未再次使用 glocal切换环境之前，一直使用此环境。</span><br><span class="line">　　2. local 本次登录环境。重启后，则环境失效，并返回当前glocal的环境。</span><br><span class="line">　　3. shell 局部（临时）环境。关闭命令行窗口，则环境失效，并返回当前glocal的环境。</span><br><span class="line">pyenv glocal xxx  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>卸载已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall xxx</span><br></pre></td></tr></table></figure></li>
<li><p>安装virtualenv   创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-virtualenv.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-virtualenv</span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cho &#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.7.0 yolo385</span><br></pre></td></tr></table></figure></li>
<li><p>删除虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;.pyenv&#x2F;versions&#x2F;env370</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p>八、安装pytorch</p>
<p>torch 官网 ：<a href="https://pytorch.org/">torch</a></p>
<p>按照自己的配置选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install torch&#x3D;&#x3D;1.9.0+cu111 torchvision&#x3D;&#x3D;0.10.0+cu111 torchaudio&#x3D;&#x3D;0.9.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</span><br></pre></td></tr></table></figure>
<p>出现 not import _lzma :</p>
<p>解决办法 ：重新安装pandas</p>
<p>项目运行：</p>
<ul>
<li><p>进入虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv activate yolo3v385</span><br></pre></td></tr></table></figure></li>
<li><p>进入项目目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;hziwei&#x2F;yoloapp</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>YoloV5</category>
      </categories>
      <tags>
        <tag>YoloV5</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat连接Oracle数据库</title>
    <url>/2021/05/09/%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<p>Navicat连接Oracle出现错误信息 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">oracle library is not loaded</span><br></pre></td></tr></table></figure>
<p>Navicat版本 ：12.1.11</p>
<p>Navicat 连接Oracle数据库需要配下载Oracle 官方提供的插件 ：<a href="https://www.oracle.com/database/technologies/instant-client/downloads.html">instantclient_19_9</a>，选择自己的系统（我的是windows），将此文件下载解压后放在Navicat安装文件路径下。</p>
<p>然后打开Navicat 的 ：工具-&gt;选项-&gt;环境-&gt;OCI 如下图所示。</p>
<p><img src="https://origin.chaizz.com/3b0b7af0e15211eb9d7c5254006b8f1d.png"></p>
<p>将instantclient_19_9 路径下的oci.dll 文件路径复制到此路径下。</p>
<p>接下来重启Navicat 即可。</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Navicat</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装Apex</title>
    <url>/2021/04/24/Centos7%E5%AE%89%E8%A3%85Apex/</url>
    <content><![CDATA[<p>封面图片由<a href="https://pixabay.com/zh/users/khirulislam898-12875647/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">MD KHIRUL ISLAM</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">Pixabay</a>上发布。</p>
<a id="more"></a>

<h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><blockquote>
<p>系统：Centos 7.6</p>
<p>所需 文件：java jdk  、 tomcat9 、Oracle 19c、   Ords 20.4 、 apex 20.2</p>
</blockquote>
<p>安装高版本的JDK和Tomcat会导致出现下面这个问题。建议选择低版本进行安装，低版本和高版本安装大致方法一直，或者采用以下脚本执行。</p>
<p><img src="https://origin.chaizz.com/%E6%89%93%E5%BC%80ords%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98.png"></p>
<h3 id="一、脚本文件方式安装JDK和tomcat"><a href="#一、脚本文件方式安装JDK和tomcat" class="headerlink" title="一、脚本文件方式安装JDK和tomcat"></a>一、脚本文件方式安装JDK和tomcat</h3><p>该脚本文件来自 ：<a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用于安装tomcat</span></span><br><span class="line">JAVA_VER=271</span><br><span class="line">JAVA_DIR=/usr/local/jdk</span><br><span class="line">TOMCAT_VER=9.0.45</span><br><span class="line">Pro=tomcat</span><br><span class="line">CATALINA_HOME=/usr/local/$Pro</span><br><span class="line">[ ! -d /software/ ] &amp;&amp; mkdir /software</span><br><span class="line"><span class="meta">#</span><span class="bash">安装依赖包</span></span><br><span class="line">install_java()&#123;</span><br><span class="line">    cd /software</span><br><span class="line">    #卸载openjdk</span><br><span class="line">    m=`rpm -qa |grep openjdk |wc -l`</span><br><span class="line">    [ $m -ne 0 ] &amp;&amp; rpm -qa |grep openjdk |xargs rpm -e</span><br><span class="line">    #安装java</span><br><span class="line">    if [ ! -f jdk-8u$JAVA_VER-linux-x64.tar.gz ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[31m请手动下载jdk到/software\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    else</span><br><span class="line">        tar xf jdk-8u$JAVA_VER-linux-x64.tar.gz</span><br><span class="line">        [ ! -d $JAVA_DIR ] &amp;&amp; mv jdk1.8.0_$JAVA_VER $JAVA_DIR</span><br><span class="line">        n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; /etc/profile |wc -l`</span><br><span class="line">        if [ $n -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo &quot;JAVA_HOME=$JAVA_DIR&quot; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/jre/lib&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;export JAVA_HOME PATH CLASSPATH&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            source /etc/profile</span><br><span class="line">        else</span><br><span class="line">            source /etc/profile</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">    java -version</span><br><span class="line">    if [ $? -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[36mjdk安装完成\033[0m&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\033[31mjdk安装失败\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装tomcat</span></span><br><span class="line">install_tomcat()&#123;</span><br><span class="line">    #下载tomcat</span><br><span class="line">    [ ! -f apache-tomcat-$TOMCAT_VER.tar.gz ] &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v$TOMCAT_VER/bin/apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    #解压</span><br><span class="line">    [ ! -d apache-tomcat-$TOMCAT_VER ] &amp;&amp; tar xf apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    [ ! -d $CATALINA_HOME ] &amp;&amp; mv apache-tomcat-$TOMCAT_VER $CATALINA_HOME</span><br><span class="line">    #设置环境变量</span><br><span class="line">    n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; $CATALINA_HOME/bin/catalina.sh |wc -l`</span><br><span class="line">    if [ $n -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        sed -i &quot;124a JAVA_HOME=$&#123;JAVA_DIR&#125;&quot; $CATALINA_HOME/bin/catalina.sh</span><br><span class="line">    fi</span><br><span class="line">    #配置启动脚本</span><br><span class="line">    cat &gt; /etc/systemd/system/$Pro\.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Apache Tomcat 9 Servlet Container</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Type=forking</span><br><span class="line">LimitNOFILE=131070</span><br><span class="line">Environment=CATALINA_PID=$&#123;CATALINA_HOME&#125;/bin/tomcat.pid</span><br><span class="line">Environment=CATALINA_HOME=$&#123;CATALINA_HOME&#125;</span><br><span class="line">Environment=CATALINA_BASE=$&#123;CATALINA_HOME&#125;</span><br><span class="line">ExecStart=$&#123;CATALINA_HOME&#125;/bin/startup.sh</span><br><span class="line">ExecStop=$&#123;CATALINA_HOME&#125;/bin/shutdown.sh</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    #tomcat开机启动</span><br><span class="line">    systemctl daemon-reload &amp;&amp; systemctl enable $Pro</span><br><span class="line"></span><br><span class="line">    if [ `systemctl status $Pro | grep &#x27;running&#x27;| wc -l` -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        systemctl start $Pro</span><br><span class="line">        if [ $? -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo -e &quot;\033[36m$Pro安装完毕\033[0m&quot;</span><br><span class="line">        else</span><br><span class="line">            echo -e &quot;\03331m$Pro安装失败\033[0m&quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_java</span><br><span class="line">install_tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将此脚本复制到系统制定目录下，在根目录下创建/software 。并将JDK 和 tomcat 包放在/software下。</p>
<p>将此脚本文件设置为可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 filename.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后执行此文件</span></span><br><span class="line">sh filename.sh </span><br></pre></td></tr></table></figure>
<p>如果显示以下错误：则表示脚本文件中存在乱码。</p>
<p><img src="https://ae01.alicdn.com/kf/U42528946957d48ff8d31a1fd8b4a3034I.jpg"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 vim -b  模式打开文件</span></span><br><span class="line">vim -b filename.sh</span><br></pre></td></tr></table></figure>
<p>打开发现如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U3b6e1138b0b742eea8f46daa886d3296w.jpg"></p>
<p>快速处理办法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\r//g&#x27; filename.sh</span><br></pre></td></tr></table></figure>
<p>接下来再打开就可以执行了。</p>
<p>等待程序运行完毕即可。</p>
<h3 id="一、安装java和tomcat环境。"><a href="#一、安装java和tomcat环境。" class="headerlink" title="一、安装java和tomcat环境。"></a>一、安装java和tomcat环境。</h3><p>1、下载java SE <a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html">文件下载地址</a>，本次选择的是java SE 16 版本。tomcat 版本10.0.5<a href="https://tomcat.apache.org/download-10.cgi">文件下载地址</a>。</p>
<p>将下载的压缩包挤压到指定文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压文件</span></span><br><span class="line">tar -zxvf jdk-16_linux-x64_bin.tar</span><br></pre></td></tr></table></figure>
<p>2、设置环境变量</p>
<p>以下是<em>错误的配置</em>：（在终端输入java -version 没有问题 但是运行tomcat 会出现提示启动成功，但是后台服务不启动。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/var/oracle/jdk-16</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>原因： 因为是使用JDK16，是新版的JDK，网上查找的答案，说是从11开始就不会自动生成jre文件了。</p>
<p>可用的java 环境变量配置如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/var/oracle/jdk-16/</span><br><span class="line">JRE_HOME=$JAVA_HOME</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib</span><br><span class="line">PATH=$JRE_HOME/bin:$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>
<p>将JRE_HOME的路径设置为 JAVA_HOME的路径，即可解决。但是启动tomcat的时候，日志文件会打印一些列NOTE。如下图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U0185a411b5804effb0c78bcf086a09b2g.jpg"></p>
<p>此问题不影响tomcat使用，目前未解决。</p>
<p>3、测试是否安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在终端输入以下命令，测试java是否安装成功，如提示java 版本信息，代表已经安装成功。</span></span><br><span class="line">java -version </span><br></pre></td></tr></table></figure>
<p>4、安装tomcat。</p>
<p>将tomcat 解压至指定文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf  apache-tomcat-10.0.5.tar</span><br><span class="line">mv /apache-tomcat-10.0.5  /var/oracle/tomcat</span><br></pre></td></tr></table></figure>
<p>配置tomcat 环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CATALINA_BASE=/var/oracle/tomcat</span><br><span class="line">PATH=$CATALINA_BASE/bin:$PATH</span><br><span class="line">export PATH CATALINA_BASE</span><br></pre></td></tr></table></figure>
<p>tomcat 的启动命令在 /tomcat/bin/start.sh 可直接启动即可。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./start.sh </span><br></pre></td></tr></table></figure>
<p>查看tomcat是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat</span><br></pre></td></tr></table></figure>
<p>启动成功如下图所示</p>
<p><img src="https://ae01.alicdn.com/kf/Ud8527b3539e34383867eff8fd2b89cb3E.jpg"></p>
<p>如果以上java 的环境变量设置不对的话，会导致tomcat 无法启动。虽然提示tomcat启动成功，但是后并没有该服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">此时终端输入验证是否启动成功</span></span><br><span class="line">curl http://ip:8080</span><br></pre></td></tr></table></figure>
<p>如未显示tomcat启动页面HTML，可排查防火墙，是否开启了8080端口 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查防火墙是否启动</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如未开启 则开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查80端口 是否被开启，如开启 则提示  “8080/tcp”</span> </span><br><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如未开启 则需要开启，开启成功会提示 “success”</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证开启的8080端口是否生效， 如果生效则提示 “yes”</span></span><br><span class="line">firewall-cmd --zone=public --query-port=8080/tcp</span><br></pre></td></tr></table></figure>
<p>8080端口开放，再次访问 IP:8080  即可看到tomcat访问成功信息。 </p>
<h3 id="二、安装oracle"><a href="#二、安装oracle" class="headerlink" title="二、安装oracle"></a>二、安装oracle</h3><p>1、以上Java jdk 和 tomcat 安装完毕以后安装 oracle 。</p>
<p>2、在根目录下创建oracle 安装文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;oracle  </span><br></pre></td></tr></table></figure>
<p>3、切换到该目录下执行以下安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先执行</span> </span><br><span class="line">yum localinstall  oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">等待执行结束，在执行</span></span><br><span class="line">yum localinstall oracle-database-ee-19c-1.0-1.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>中途卡断 可重新安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用yum命令 查询更刚刚安装的包, 找到Oracle的包名</span></span><br><span class="line">yum list installed shell</span><br><span class="line"><span class="meta">#</span><span class="bash">先使用以下命令卸载已安装的包。</span></span><br><span class="line">yum remove oracle-database-preinstall-19c-1.0-1.el7.x86_64</span><br><span class="line">yum remove oracle-database-ee-19c-1.0-1.x86_64</span><br></pre></td></tr></table></figure>
<p>4、过一段时间安装完毕成功会提示如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/Ua0442ba6df124404871dd091810d949e2.jpg"></p>
<p>oracle 的安装文件地址为：/opt/oracle   默认配置文件路径为：/etc/sysconfig/oracledb_ORCLCDB-19c.conf</p>
<p>5、接下来初始化数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c configure</span><br></pre></td></tr></table></figure>
<p>等待数据库初始化。过程中切记不用中断操作。初始化时间可能会很长。只要后台服务还在就说明没问题。</p>
<p>6、切换至Oracle 用户 修改数据库系统账户密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su oracle </span><br><span class="line"><span class="meta">#</span><span class="bash">登录数据库</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#修改sys 和 <span class="keyword">system</span> 的密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> sys identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">system</span> identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line">shutdown immediate;</span><br><span class="line"></span><br><span class="line">startup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;</span><br><span class="line"></span><br><span class="line">startup;</span><br></pre></td></tr></table></figure>
<p>7、配置数据库的环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">在最下面添加以下内容：</span></span><br><span class="line">export ORACLE_HOME=/opt/oracle/product/19c/dbhome_1</span><br><span class="line">export ORACLE_SID=ORCLCDB</span><br><span class="line">export PATH=$PATH:/opt/oracle/product/19c/dbhome_1/bin</span><br><span class="line">export NLS_LANG=American_America.AL32UTF8</span><br></pre></td></tr></table></figure>
<p>8、启动停止oracle</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c start</span><br><span class="line"></span><br><span class="line">/etc/init.d/oracledb_ORCLCDB-19c stop</span><br></pre></td></tr></table></figure>


<h3 id="三、安装apex"><a href="#三、安装apex" class="headerlink" title="三、安装apex"></a>三、安装apex</h3><p>1、解压apex的压缩包</p>
<p>使用oracle 用户需要将 apex保存的文件富裕oracle 权限。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R oracle:dba /var/oracle/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压到当前文件夹下</span></span><br><span class="line">unzip -q apex_20.2.zip </span><br></pre></td></tr></table></figure>
<p>2、进入oracle数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、登录数据库</span></span><br><span class="line">sqlplus / as sysdba  </span><br></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按顺序执行以下代码</span></span><br><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;   </span><br><span class="line"></span><br><span class="line"><span class="comment">--3、设置系统默认表空间</span></span><br><span class="line"><span class="variable">@apexins</span>.<span class="keyword">sql</span> APEX APEX TEMP <span class="operator">/</span>i<span class="operator">/</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">--接下来等待安装 ，会持续一段时间....。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--4、创建 apex 实例管理员</span></span><br><span class="line"><span class="variable">@apxchpwd</span>.<span class="keyword">sql</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码必须包含：(!&quot;#$%&amp;()``*+,-/:;?_) 和 至少一个大写字母。</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">--5、 修改APEX_PUBLIC_USER 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> APEX_PUBLIC_USER ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -6、 修改flows_files 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> flows_files ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"><span class="variable">@apex</span>_rest_config.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10       </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_LISTENER <span class="keyword">user</span>: Test123_</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11        </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_REST_PUBLIC_USER <span class="keyword">user</span>: Test123_</span><br><span class="line">            </span><br></pre></td></tr></table></figure>


<p>3、汉化apex </p>
<p>切换到，apex/builder/zh-cn/ 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、 登录sql</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、设置CURRENT_SCHEMA </span></span><br><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> <span class="built_in">CURRENT_SCHEMA</span> <span class="operator">=</span> APEX_200200;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、加载sql</span></span><br><span class="line"><span class="variable">@load</span>_zh<span class="operator">-</span>cn.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等待一段时间即可...</span></span><br></pre></td></tr></table></figure>


<h3 id="四、安装ords"><a href="#四、安装ords" class="headerlink" title="四、安装ords"></a>四、安装ords</h3><p>1、解压文件到当前目录下</p>
<p>2、执行ords安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ords.war install advanced</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来选择会提示输入：</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">This Oracle REST Data Services instance has not yet been configured.</span><br><span class="line">Please complete the following prompts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter the location to store configuration data: /opt/ords/config  # 配置存储路径</span><br><span class="line">Specify the database connection type to use.</span><br><span class="line">Enter number for [1] Basic  [2] TNS  [3] Custom URL [1]:1    </span><br><span class="line">Enter the name of the database server [localhost]:localhost  </span><br><span class="line">Enter the database listen port [1521]:1520                   </span><br><span class="line">Enter 1 to specify the database service name, or 2 to specify the database SID [1]:1</span><br><span class="line">Enter the database service name:ORCLPDB1</span><br><span class="line">Enter 1 if you want to verify/install Oracle REST Data Services schema or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for ORDS_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Xisland2020</span><br><span class="line">Requires to login with administrator privileges to verify Oracle REST Data Services schema.</span><br><span class="line"></span><br><span class="line">Enter the administrator username:SYS                #oracle数据库账号</span><br><span class="line">Enter the database password for SYS AS SYSDBA:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Connecting to database user: SYS AS SYSDBA url: jdbc:oracle:thin:@//localhost:1521/ORCLPDB1</span><br><span class="line"></span><br><span class="line">Retrieving information.</span><br><span class="line">Enter 1 if you want to install ORDS or 2 to skip this step [1]:1</span><br><span class="line">Enter the default tablespace for ORDS_METADATA [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_METADATA [TEMP]:TEMP</span><br><span class="line">Enter the default tablespace for ORDS_PUBLIC_USER [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_PUBLIC_USER [TEMP]:TEMP</span><br><span class="line">Enter 1 if you want to use PL/SQL Gateway or 2 to skip this step.</span><br><span class="line">If using Oracle Application Express or migrating from mod_plsql then you must enter 1 [1]:1</span><br><span class="line">Enter the PL/SQL Gateway database user name [APEX_PUBLIC_USER]:APEX_PUBLIC_USER</span><br><span class="line">Enter the database password for APEX_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter 1 to specify passwords for Application Express RESTful Services database users (APEX_LISTENER, APEX_REST_PUBLIC_USER) or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for APEX_LISTENER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter the database password for APEX_REST_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter a number to select a feature to enable:</span><br><span class="line">   [1] SQL Developer Web  (Enables all features)</span><br><span class="line">   [2] REST Enabled SQL</span><br><span class="line">   [3] Database API</span><br><span class="line">   [4] REST Enabled SQL and Database API</span><br><span class="line">   [5] None</span><br><span class="line">Choose [1]:1</span><br><span class="line">2021-02-02T08:45:42.287Z INFO        reloaded pools: []</span><br><span class="line">Installing Oracle REST Data Services version 20.4.1.r0131644</span><br><span class="line">... Log file written to /root/ords_install_core_2021-02-02_164542_00395.log</span><br><span class="line">... Verified database prerequisites</span><br><span class="line">... Created Oracle REST Data Services proxy user</span><br><span class="line">... Created Oracle REST Data Services schema</span><br><span class="line">... Granted privileges to Oracle REST Data Services</span><br><span class="line">... Created Oracle REST Data Services database objects</span><br><span class="line">... Log file written to /root/ords_install_datamodel_2021-02-02_164559_00321.log</span><br><span class="line">... Log file written to /root/ords_install_apex_2021-02-02_164600_00696.log</span><br><span class="line">Completed installation for Oracle REST Data Services version 20.4.1.r0131644. Elapsed time: 00:00:19.722 </span><br><span class="line"></span><br><span class="line">Enter 1 if you wish to start in standalone mode or 2 to exit [1]:2</span><br></pre></td></tr></table></figure>
<p>至此ords安装配置结束。</p>
<h3 id="五、部署到tomcat-上"><a href="#五、部署到tomcat-上" class="headerlink" title="五、部署到tomcat 上"></a>五、部署到tomcat 上</h3><p>1、将apex 的静态文件放到tomcat的webapps 下。 路径为你的apex 安装路径：/var/oracle/apex/images</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -a /var/oracle/apex/img/* /var/oracle/apache-tomcat-10.0.5/webapps/apex</span><br></pre></td></tr></table></figure>
<p>2、将ords.war 包 复制到tomcat 的web apｐｓ下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;var&#x2F;oracle&#x2F;ords&#x2F;ords.war &#x2F;var&#x2F;oracle&#x2F;apache-tomcat-10.0.5&#x2F;webapps&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="六、使用nginx-代理"><a href="#六、使用nginx-代理" class="headerlink" title="六、使用nginx 代理"></a>六、使用nginx 代理</h3><p>Nginx 的server配置文件为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 域名;</span><br><span class="line">    </span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Origin &quot;&quot; ;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_connect_timeout 120s;</span><br><span class="line">        proxy_read_timeout    120s;</span><br><span class="line">        proxy_send_timeout    120s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重启nginx 即可。</p>
<h3 id="七、完成"><a href="#七、完成" class="headerlink" title="七、完成"></a>七、完成</h3><p>浏览器输入域名即可打开APEX登录页面。</p>
<p>创建的密码相关：</p>
<ul>
<li><p>apex 创建实例 用户名：admin</p>
</li>
<li><p>密码：Test123_</p>
</li>
<li><p>APEX_LISTENER  user：Test1123_</p>
</li>
<li><p>数据库用户sys密码：test12</p>
</li>
<li><p>数据库用户system密码：test123</p>
</li>
</ul>
<p>参考文章：</p>
<blockquote>
<p><a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_41092687/article/details/89879061">https://blog.csdn.net/weixin_41092687/article/details/89879061</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_39400984/article/details/98104599">https://blog.csdn.net/qq_39400984/article/details/98104599</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/xzm5708796/article/details/88344074">https://blog.csdn.net/xzm5708796/article/details/88344074</a></p>
</blockquote>
]]></content>
      <categories>
        <category>CentOS</category>
        <category>安装ORACLE-APEX</category>
      </categories>
      <tags>
        <tag>ORACLE-APEX</tag>
      </tags>
  </entry>
  <entry>
    <title>Python代码规范（pep8/Google-style）</title>
    <url>/2021/03/19/Python%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88pep8-Google-style%EF%BC%89/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<blockquote>
<p>Guido van Rossum（吉多·范罗苏姆，Python 创始人 ）说过，代码的阅读频率远高于编写代码的频率。</p>
</blockquote>
<p>毕竟，即使是在编写代码的时候，你也需要对代码进行反复阅读和调试，来确认代码能够按照期望运行。</p>
<p>本文来自极客时间规范篇学习总结。</p>
<h2 id="PEP8规范："><a href="#PEP8规范：" class="headerlink" title="PEP8规范："></a>PEP8规范：</h2><p>PEP 是 Python Enhancement Proposal 的缩写，翻译过来叫“Python 增强规范”。正如我们写文章，会有句式、标点、段落格式、开头缩进等标准的规范一样，Python 书写自然也有一套较为官方的规范。PEP 8 就是这样一种规范，它存在的意义，就是让 Python 更易阅读，换句话，增强代码可读性。</p>
<h3 id="缩进规范"><a href="#缩进规范" class="headerlink" title="缩进规范"></a>缩进规范</h3><p>Python 和 C++ / Java 最大的不同在于，后者完全使用大括号来区分代码块，而前者依靠不同行和不同的缩进来进行分块。</p>
<p>Python 的缩进其实可以写成很多种，Tab、双空格、四空格、空格和 Tab 混合等。而 PEP 8 规范告诉我们，<strong>请选择四个空格的缩进，不要使用 Tab，更不要 Tab 和空格混着用。</strong></p>
<p>第二个要注意的是，<strong>每行最大长度请限制在 79 个字符</strong>。</p>
<p>这个原则主要有两个优点：</p>
<ol>
<li>很多工程师在编程的时候，习惯一个屏幕并列竖排展示多个源代码。如果某个源代码的某些行过长，你就需要拖动横向滚动条来阅读，或者需要软回车将本行内容放入下一行，这就极大地影响了编码和阅读效率。</li>
<li>需要有一定经验的编程经验后更容易理解：因为当代码的嵌套层数过高，比如超过三层之后，一行的内容就很容易超过 79 个字符了。所以，这条规定另一方面也在制约着程序员，不要写迭代过深的代码，而是要思考继续把代码分解成其他函数或逻辑块，来优化自己的代码结构。</li>
</ol>
<h3 id="空行规范"><a href="#空行规范" class="headerlink" title="空行规范"></a>空行规范</h3><p>Python 中的空行对 Python 解释器的执行没有影响，但对阅读体验有很深刻的影响。</p>
<p>PEP 8 规定，<strong>全局的类和函数的上方需要空两个空行，而类的函数之间需要空一个空行。</strong>当然，函数内部也可以使用空行，和英语的段落一样，用来区分不同意群之间的代码块。但是记住最多空一行，千万不要滥用。</p>
<p>另外，Python 本身允许把多行合并为一行，使用分号隔开，但这是 PEP 8 不推荐的做法。所以，即使是使用控制语句 if / while / for，你的执行语句哪怕只有一行命令，也请另起一行，这样可以更大程度提升阅读效率。至于代码的尾部，每个代码文件的最后一行为空行，并且只有这一个空行。</p>
<h3 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h3><p>我们再来看一下，代码块中，每行语句中空格的使用。函数的参数列表中，调用函数的参数列表中会出现逗号，请注意逗号后要跟一个空格，这是英语的使用习惯，也能让每个参数独立阅读，更清晰。同理，冒号经常被用来初始化字典，冒号后面也要跟一个空格。另外，Python 中我们可以使用#进行单独注释，请记得要在#后、注释前加一个空格。对于操作符，例如+，-，*，/，&amp;，|，=，==，!=，请在两边都保留空格。不过与此对应，括号内的两端并不需要空格。</p>
<h3 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h3><p>接下来我们说说文档规范。先来看看最常用的 import 函数。</p>
<p>首先，所有 import 尽量放在开头，这个没什么说的，毕竟到处 import 会让人很难看清楚文件之间的依赖关系，运行时 import 也可能会导致潜在的效率问题和其他风险。</p>
<p>其次，不要使用 import 一次导入多个模块。虽然我们可以在一行中 import 多个模块，并用逗号分隔，但请不要这么做。import time, os 是 PEP 8 不推荐的做法。</p>
<p>如果你采用 <code>from module import func</code> 这样的语句，请确保 func 在本文件中不会出现命名冲突。不过，你其实可以通过<code> from module import func as new_func</code> 来进行重命名，从而避免冲突。</p>
<h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>有句话这么说：错误的注释，不如没有注释。所以，当你改动代码的时候，一定要注意检查周围的注释是否需要更新。</p>
<p>对于大的逻辑块，我们可以在最开始相同的缩进处以 # 开始写注释。即使是注释，你也应该把它当成完整的文章来书写。如果英文注释，请注意开头大写及结尾标点，注意避免语法错误和逻辑错误，同时精简要表达的意思。中文注释也是同样的要求。一份优秀的代码，离不开优秀的注释。</p>
<p>至于行注释，如空格规范中所讲，我们可以在一行后面跟两个空格，然后以 # 开头加入注释。不过，请注意，行注释并不是很推荐的方式。</p>
<h3 id="文档描述"><a href="#文档描述" class="headerlink" title="文档描述"></a>文档描述</h3><p>docstring 的写法，它是用三个双引号开始、三个双引号结尾。我们首先用一句话简单说明这个函数做什么，然后跟一段话来详细解释；再往后是参数列表、参数格式、返回值格式。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>“计算机科学的两件难事：缓存失效和命名。”命名对程序员来说，是一个不算省心的事。</p>
<ol>
<li>变量命名。变量名请拒绝使用 a b c d 这样毫无意义的单字符，我们应该使用能够代表其意思的变量名。一般来说，变量使用小写，通过下划线串联起来，例如：data_format、input_spec、image_data_set。唯一可以使用单字符的地方是迭代，比如 for i in range(n) 这种，为了精简可以使用。如果是类的私有变量，请记得前面增加两个下划线。</li>
<li>常量命名，最好的做法是全部大写，并通过下划线连接，例如：WAIT_TIME、SERVER_ADDRESS、PORT_NUMBER。</li>
<li>函数名，也使用小写的方式，通过下划线连接起来，例如：launch_nuclear_missile()、check_input_validation()。</li>
<li>类名，则应该首字母大写，然后合并起来，例如：class SpatialDropout2D()、class FeatureSet()。</li>
</ol>
<p>总之，不要过于吝啬一个变量名的长度。当然，在合理描述这个变量背后代表的对象后，一定的精简能力也是必要的。</p>
<h3 id="代码分解技巧"><a href="#代码分解技巧" class="headerlink" title="代码分解技巧"></a>代码分解技巧</h3><p>编程中一个核心思想是，不写重复代码。重复代码大概率可以通过使用条件、循环、构造函数和类来解决。而另一个核心思想则是，减少迭代层数，尽可能让 Python 代码扁平化，毕竟，人的大脑无法处理过多的栈操作。</p>
<p>一个函数的粒度应该尽可能细，不要让一个函数做太多的事情。所以，对待一个复杂的函数，我们需要尽可能地把它拆分成几个功能简单的函数，然后合并起来。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>PEP8</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter-notebook的安装与基本使用</title>
    <url>/2021/03/13/Jupyter-notebook%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​              </p>
<a id="more"></a>

<blockquote>
<h4 id="The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more"><a href="#The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more" class="headerlink" title="The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more."></a>The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.</h4></blockquote>
<p>以上为Jupyter notebook 的官方解释。</p>
<blockquote>
<p>Jupyter Notebook是一个开源Web应用程序，可让您创建和共享包含实时代码，方程式，可视化效果和叙述文本的文档。 用途包括：数据清理和转换，数值模拟，统计建模，数据可视化，机器学习等.</p>
</blockquote>
<h2 id="一、windows下安装Jupyter-notebook"><a href="#一、windows下安装Jupyter-notebook" class="headerlink" title="一、windows下安装Jupyter notebook"></a>一、windows下安装Jupyter notebook</h2><p>Jupyter notebook 是基于Python 的首先要安装Python环境，或者直接安装Anaconda（直接包含Python和Jupyter notebook）。以上环境省略自行安装。</p>
<h3 id="在Python环境下直接安装。（最好是新版本Python）"><a href="#在Python环境下直接安装。（最好是新版本Python）" class="headerlink" title="在Python环境下直接安装。（最好是新版本Python）"></a>在Python环境下直接安装。（最好是新版本Python）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>
<p>等待命令安装完毕，如果比较慢的话，建议更换Python的源为清华或者淘宝网易的源下载安装速度会快很多。</p>
<h3 id="启动Jupyter-notebook"><a href="#启动Jupyter-notebook" class="headerlink" title="启动Jupyter notebook"></a>启动Jupyter notebook</h3><p>系统会自动启动浏览器，打开本地的8888端口。（端口没有被占用的情况下。如果被占用端口号会自动加一，启动多个Jupyter notebook应用，端口号也会自动向后加一来启动多个应用。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook </span><br></pre></td></tr></table></figure>
<p>如果在使用过程中关闭了当前终端，应用也会随之无法连接，无法使用Jupyter notebook应用。</p>
<p>如果要以不同的端口号启动Jupyter notebook应用，使用一下的方式启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook --port 8899</span><br></pre></td></tr></table></figure>
<h2 id="二、Jupyter-notebook-界面"><a href="#二、Jupyter-notebook-界面" class="headerlink" title="二、Jupyter notebook 界面"></a>二、Jupyter notebook 界面</h2><p>Jupyter notebook 的默认存储文件的地址为当前用户的文件路径。每个人里面的文件都不太一样。</p>
<h3 id="更改默认的存储路径。"><a href="#更改默认的存储路径。" class="headerlink" title="更改默认的存储路径。"></a>更改默认的存储路径。</h3><p>Jupyter notebook  的默认的配置文件在当前用户下的一个隐藏文件（以.jupyter开头的文件）文件下名为jupyter_notebook_config.py 即为jupyter notebook 的配置文件。</p>
<p>打开文件搜索找到 <code>c.NotebookApp.notebook_dir</code> 开头的配置，即是存储文件路径的配置。只需要将你想要修改的路径添加并取消注释即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir &#x3D; &#39;C:&#x2F;Users&#x2F;xxx&#x2F;Desktop&#x2F;Project&#x2F;Jupyter Notebook&#39;</span><br></pre></td></tr></table></figure>
<p>重启启动 Jupyter notebook。此时页面文件目录是空的。</p>
<h2 id="三、使用-Jupyter-notebook"><a href="#三、使用-Jupyter-notebook" class="headerlink" title="三、使用 Jupyter notebook"></a>三、使用 Jupyter notebook</h2><p>新建一个页面。 点击右上角的 new 按钮可以新建一个工程文件或者文本文件或者文件夹。</p>
<p><img src="https://origin.chaizz.com/717fe24c4ade11ec9d7c5254006b8f1d.png"></p>
<p>例如 新建一个python3文件。新页面样式如图所示。</p>
<p><img src="https://origin.chaizz.com/7fcf69304ade11ec9d7c5254006b8f1d.png"></p>
<p>可在单元格（cell）中输入代码并执行。</p>
<h2 id="四、Jupyter-notebook-快捷键"><a href="#四、Jupyter-notebook-快捷键" class="headerlink" title="四、Jupyter notebook 快捷键"></a>四、Jupyter notebook 快捷键</h2><p>A：在当前单元格的上方添加一行单元格</p>
<p>B：在当前单元格的下方添加一行单元格</p>
<p>M：选中单元格将单元格代码格式改为Markdown格式</p>
<p>Y：选中单元格将单元格代码格式改为代码格式</p>
<p>X：剪切当前单元格</p>
<p>V：在当前单元格下方粘贴复制或者剪切的单元格</p>
<p>Enter：在当前单元格换行</p>
<p>Shift+Enter：代码模式下执行当前单元格代码</p>
<p>shift+V：在当前单元格上方粘贴复制或者剪切的单元格</p>
<p>D D ：连续两个D 删除当前单元格</p>
<p>Z：撤销删除单元格</p>
<p>还有很多快捷键按H都可以找到。</p>
<h2 id="五、Jupyter-notebook-插件"><a href="#五、Jupyter-notebook-插件" class="headerlink" title="五、Jupyter notebook 插件"></a>五、Jupyter notebook 插件</h2><p>在安装插件之前首先需要安装<strong>jupyter_contrib_nbextensions</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用 jupyter_contrib_nbextensions</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure>
<p>此时 Jupyter notebook 界面就会出现一个新的菜单栏。</p>
<p><img src="https://origin.chaizz.com/8a881e4e4ade11ec9d7c5254006b8f1d.png"></p>
<p>选中此按钮进入配置插件的页面。</p>
<p>取消勾选此按钮。否则无法选择插件。</p>
<p><img src="https://origin.chaizz.com/941816a84ade11ec9d7c5254006b8f1d.png"></p>
<p>推荐插件：</p>
<ul>
<li><strong>Notify</strong> ：能在任务处理完后及时向你发送通知</li>
<li><strong>Hinterland</strong> ：自动补全代码</li>
<li><strong>Codefolding</strong>  ：折叠代码</li>
<li><strong>Table of Contents(2)</strong>  ：自动生成导航目录</li>
<li><strong>Autopep8</strong> ：自动格式化代码。（需要安装python库：autopep8）</li>
<li><strong>ExecuteTime</strong> ：显示单元格的运行时间和耗时 </li>
<li><strong>Split Cells Notebook</strong> ：类似于多窗口编辑，将单行排列的单元格放置为多行排列。</li>
<li><strong>Collapsible Headings</strong> ：折叠单元格</li>
</ul>
]]></content>
      <categories>
        <category>Jupyter-notebook</category>
      </categories>
      <tags>
        <tag>Jupyter-notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代思维与MVP产品的规划方法</title>
    <url>/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>​              </p>
<a id="more"></a>

<h3 id="快速迭代的价值与挑战"><a href="#快速迭代的价值与挑战" class="headerlink" title="快速迭代的价值与挑战"></a>快速迭代的价值与挑战</h3><p>快速迭代：以天或者小时为单位，持续的完善产品，交付到用户的循环过程</p>
<h4 id="快速迭代的价值："><a href="#快速迭代的价值：" class="headerlink" title="快速迭代的价值："></a>快速迭代的价值：</h4><ul>
<li>时间是最大的成本，机会转瞬即逝，赢得市场先机。</li>
<li>快速验证需求，减少不对用户产生价值的投入（Fail fast, Fail better）。</li>
<li>快速验证方案，提高研发效率。</li>
<li>加速反馈回路，给到团队和自己及时的激励。</li>
</ul>
<h4 id="快速迭代的挑战："><a href="#快速迭代的挑战：" class="headerlink" title="快速迭代的挑战："></a>快速迭代的挑战：</h4><ul>
<li>产品设计者：能梳理清楚业务流程，抓住用户的重点需求，能把客户需求转换为系统的需求。</li>
<li>开发者：充分理解用户需求，有足够的能力，能用简洁的方案来设计出易维护的系统。</li>
</ul>
<h4 id="根本挑战："><a href="#根本挑战：" class="headerlink" title="根本挑战："></a>根本挑战：</h4><ul>
<li><p>市场、用户、技术、环境变化太快，产品开发跟不上节奏。</p>
</li>
<li><p>几乎不能从一开始就设计一个完美的，能够使用未来长时间变化的方案</p>
</li>
<li><p>几乎没有人愿意承认，自己没有足够的力（或条件）设计一个完美的产品（系统）。</p>
</li>
</ul>
<h3 id="OOPD-方法识别产品的核心功能"><a href="#OOPD-方法识别产品的核心功能" class="headerlink" title="OOPD 方法识别产品的核心功能"></a>OOPD 方法识别产品的核心功能</h3><p>OOPD：Online and Offline integrated Product Development  </p>
<p><img src="/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/OOPD.png"></p>
<p>OOPD迭代的原则：</p>
<ul>
<li>自助原则：做自己的产品，自己用自己的产品，吃自己的狗食。</li>
<li>0day：找到明确的核心问题，拆解目标，抓住核心的问题，忽略掉一切细节，0day发布。</li>
<li>时限原则：设定时限，挑战自我，不给自己写BUG的时间。</li>
<li>不完美原则：不做完美的产品。（没有完美的产品，不去为了完美而浪费宝贵的资源）</li>
<li>谦卑原则：能够看到自己的局限性，获取用户反馈，持续迭代，听取用户的声音。</li>
</ul>
<p>MVP：minimum viable product 最小可用产品</p>
<ul>
<li>内裤原则 ： MVP 包括了产品的轮廓，核心的功能，让业务可以运转。</li>
<li>优先线下：能够走线下的 优先走线下的流程，让核心的功能先跑起来，快速的做用户验证和方案验证。</li>
<li>MVP的核心：忽略掉一切技术的细枝末节，做最合适的假设和简化，使用最短的时间开发出来。</li>
</ul>
<p>迭代思维最强大的是产品思维逻辑，互联网唯快不破的秘诀。</p>
<h3 id="如何做好技术方案设计与工作拆解"><a href="#如何做好技术方案设计与工作拆解" class="headerlink" title="如何做好技术方案设计与工作拆解"></a>如何做好技术方案设计与工作拆解</h3><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h4><ul>
<li>做技术方案设计的前提条件<ul>
<li>有明确的的用户场景，用户如何和产品进行交互，期望拿到什么预期结果。</li>
<li>有清晰定义的业务流程</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li><p>用什么工具设计？</p>
<ul>
<li>Visual Paradigm</li>
<li>Lucid Chart</li>
<li>Visio</li>
<li>Gliffy</li>
<li>Draw.io</li>
<li>Astash</li>
<li>StarUML</li>
<li>…..</li>
</ul>
<p>推荐使用<strong>白纸</strong>，不用工具就是最好的工具。</p>
</li>
<li><p>产出的技术方案文档要素</p>
<ul>
<li>产品背景（用户场景、产品目标、引用到的业务流畅、产品需求文档）</li>
<li>要解决的问题列表，系统不解决的问题列表，系统的限制。</li>
<li>对于问题的不同的解决方案的对比，阐述各个主要的问题如何被解决。</li>
<li>所选的整体的流程图（序列图），模块关系图，重要的接口，实体的概念定义。</li>
<li>除了功能之外的其他方面的设计，包括安全、性能、可维护性、稳定性、监控、扩展性、易用性等。</li>
</ul>
</li>
</ul>
<h4 id="工作拆解"><a href="#工作拆解" class="headerlink" title="工作拆解"></a>工作拆解</h4><p>​    任何事情，只要把它拆解的够细，都能够完成它。</p>
<ul>
<li>工作拆解的原则：<ul>
<li>优先级：主流程上，不确定的工作先完成（建议提前一个迭代做调研）。</li>
<li>核心流程优先：核心工作优先，先把主流程跑通。</li>
<li>依赖：减少不同人之间的工作依赖，并且保持团队工作拆解的透明，预留20%Buffer。</li>
<li>拆解粒度：拆解到每项子任务0.5-1天的粒度，最长不要超过两天。</li>
</ul>
</li>
</ul>
<h3 id="如何保证交付质量和可持续迭代"><a href="#如何保证交付质量和可持续迭代" class="headerlink" title="如何保证交付质量和可持续迭代"></a>如何保证交付质量和可持续迭代</h3><p>定义好产品需求，产品需求从根本上决定了产品的质量。</p>
<p>系统上有整体架构方案的设计，评估，评审，系统决定了软件实现的质量。</p>
<p>工程的角度持续交付的最佳实践推荐：</p>
<ul>
<li> Code Review：每一次提交都有CR，每次commit 代码量控制在200行y以内。尽量频繁的commit。</li>
<li>单元集成：项目开始简历单元测试的机制，在持续集成中自动运行。</li>
<li>自动化回归：对预发/线上系统做KPI/页面自动化测试（Postman/Robot Framework）</li>
<li>使用CICD机制对心痛进行自动化的打包，测试，部署，线上验证。</li>
<li>发布过程做到可监控，可回滚。</li>
<li>对于大量用户使用的产品，使用灰度机制。</li>
<li>架构上对于意外的并发访问，进行限流，降级。</li>
<li>架构上使用配置开关，对系统功能能提供实时的开启/关闭的服务。</li>
<li>对产品简历A/B Test 机制，通过数据快速对比不同的版本，不同的方案。</li>
<li>自动化所有的事情，代码化所有过程：代码化配置，代码化部署流程，代码化基础设置。<ul>
<li>声明式API，CICD Pipeline，K8S，Helm , Terraform</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>产品</category>
        <category>敏捷开发</category>
      </categories>
      <tags>
        <tag>OOPD</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件目录</title>
    <url>/2021/02/02/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<a id="more"></a>



<p><img src="/2021/02/02/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/linuxfile.jpg"></p>
<ul>
<li><p><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</li>
<li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装mysql-python插件</title>
    <url>/2021/02/02/Ubuntu%E5%AE%89%E8%A3%85mysql-python%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>​      </p>
<a id="more"></a>

<blockquote>
<p>运行FLASK 提示 ：ERROR:flask.app:No module named MySQLdb</p>
</blockquote>
<h3 id="安装-mysql-python"><a href="#安装-mysql-python" class="headerlink" title="安装 mysql-python"></a>安装 mysql-python</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install mysql-python</span><br></pre></td></tr></table></figure>
<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p><img src="/2021/02/02/Ubuntu%E5%AE%89%E8%A3%85mysql-python%E6%8F%92%E4%BB%B6/snipaste_20190917_205355.jpg" alt="snipaste_20190917_205355"></p>
<h3 id="接下来安装依赖包"><a href="#接下来安装依赖包" class="headerlink" title="接下来安装依赖包"></a>接下来安装依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
<h3 id="如果还是不行安装依赖"><a href="#如果还是不行安装依赖" class="headerlink" title="如果还是不行安装依赖"></a>如果还是不行安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install python-MySQLdb</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
        <category>MySQL-Python</category>
      </categories>
      <tags>
        <tag>MySQL-Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pip安装mysqlclient时出现问题汇总</title>
    <url>/2021/02/02/%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85mysqlclient%E6%97%B6%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="使用pip安装mysqlclient时出现问题汇总"><a href="#使用pip安装mysqlclient时出现问题汇总" class="headerlink" title="使用pip安装mysqlclient时出现问题汇总"></a>使用pip安装mysqlclient时出现问题汇总</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><p>System: WSL Ubuntu 22.04 LTS</p>
</li>
<li><p>Python Version： 3.8</p>
</li>
<li><p>Pip Version: 23.2.1</p>
</li>
<li><p>待安装的mysqlclient Version: 2.2.0</p>
</li>
</ul>
<h2 id="问题一、OSError-mysql-config-not-found"><a href="#问题一、OSError-mysql-config-not-found" class="headerlink" title="问题一、OSError: mysql_config not found"></a>问题一、OSError: mysql_config not found</h2><p><img src="/2021/02/02/%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85mysqlclient%E6%97%B6%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/Users\LHKJ0\AppData\Roaming\Typora\typora-user-images\image-20230731172048442.png" alt="image-20230731172048442"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
<h2 id="问题二、-error-command-‘gcc’-failed-No-such-file-or-directory"><a href="#问题二、-error-command-‘gcc’-failed-No-such-file-or-directory" class="headerlink" title="问题二、 error: command ‘gcc’ failed: No such file or directory"></a>问题二、 error: command ‘gcc’ failed: No such file or directory</h2><p><img src="https://origin.chaizz.com/tc/image-20230731171601684.png" alt="image-20230731171601684"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install gcc</span><br></pre></td></tr></table></figure>


<h2 id="问题三、Exception-Can-not-find-valid-pkg-config-name"><a href="#问题三、Exception-Can-not-find-valid-pkg-config-name" class="headerlink" title="问题三、Exception: Can not find valid pkg-config name"></a>问题三、Exception: Can not find valid pkg-config name</h2><p><img src="https://origin.chaizz.com/tc/image-20230731171818939.png" alt="image-20230731171818939"></p>
<p>查找资料地址：<a href="https://github.com/PyMySQL/mysqlclient/issues/620">github issues</a></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install pkg-config</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pypi</category>
        <category>mysqlclient</category>
      </categories>
      <tags>
        <tag>mysqlclient</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.5源码安装postgresql-12</title>
    <url>/2021/02/02/Centos7-5%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85postgresql-12/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><ol>
<li><p>首先安装readline 和readline-devel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install readline </span><br><span class="line">yum install readline-devel</span><br></pre></td></tr></table></figure>
<p>虽然已经安装了readline，但是不安装readlene-devel 在执行 <code>./configure --prefix=/opt/postgresql</code> 的时候会提示，<code>configure: error: readline library not found</code>。</p>
</li>
<li><p>接下来在执行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/postgresql</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li><p>将postgresql 加入环境变量，打开文件 /etc/profile  在末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PG_HOME=/opt/postgresql  #为安装postgresql的地址</span><br><span class="line">export PATH=$PG_HOME/bin:$PATH</span><br><span class="line">source /etc/profile    #更新环境变量</span><br></pre></td></tr></table></figure></li>
<li><p>创建postgresql 的用户以及用户组 可创建可不创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd postgresql   #创建用户组</span><br><span class="line">useradd -G postgresql postgresql   #创建用户</span><br><span class="line">passwd ********    #设置密码  </span><br></pre></td></tr></table></figure>
</li>
<li><p>初始数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl -D /opt/postgresdata initdb&#x27; #初始化数据库</span><br><span class="line">su postgresql   ：使用这个用户进行操作</span><br><span class="line">/opt/postgresdata：地址为存放初始化的文件路径可自定义，   这个文件的用户权限要为 postgresql可操作</span><br><span class="line">pg_ctl  ：postgresql 的控制器，可以对postgresql 进行启动停止等操作</span><br></pre></td></tr></table></figure>
<p>执行以上语句后会再  /opt/postgresdata 路径下生成一些文件</p>
<p><img src="/2021/02/02/Centos7-5%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85postgresql-12/postgresql0.jpg"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>postmaster.pid</td>
<td>首行记录了进程PID</td>
</tr>
<tr>
<td>serverlog</td>
<td>数据库日志</td>
</tr>
<tr>
<td>postgresql.conf</td>
<td>主配置文件(可做定制</td>
</tr>
<tr>
<td>pg_hba.conf</td>
<td>鉴权相关文件</td>
</tr>
<tr>
<td>PG_VERSION</td>
<td>当前主版本号</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>启动数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl start -D /opt/postgredata -l serverlog&#x27;</span><br></pre></td></tr></table></figure>

</li>
<li><p>设置远程访问,在 pg_hba.conf文文件末尾加上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">host all all 0.0.0.0/0 md5</span><br></pre></td></tr></table></figure></li>
<li><p>为了让 postgresql用户可以远程访问，可以通过 psql 设置密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user postgresql with password &#39;*********&#39;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="9">
<li><p>开启远程访问，默认情况下 postgresql 仅仅监听本机的端口，需要编辑 <strong>/opt/postgredata/ postgresql.conf</strong> 文件开启远程IP的访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_addresses &#x3D; &#39;*&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果需要定制端口，可以执行脚本：</span></span><br><span class="line">postgres -p 5430 -D /opt/postgredata &gt;serverlog 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">检查进程是否存活：</span></span><br><span class="line">netstat -nlp |grep `head -1 /opt/postgredata/postmaster.pid`</span><br><span class="line"><span class="meta">#</span><span class="bash">停止数据库进程</span></span><br><span class="line">kill -INT `head -1 /opt/postgredata/postmaster.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>配置自启动</p>
<p>找到源码目录中 <strong><em>contrib/start-scripts/linux\</em></strong>脚本文件，拷贝为 <strong>/etc/init.d/postgressql</strong>。修改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序所在目录</span></span><br><span class="line">prefix=/opt/postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据目录</span></span><br><span class="line">PGDATA=&quot;/opt/postgredata&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行用户</span></span><br><span class="line">PGUSER=postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">PGLOG=&quot;$PGDATA/serverlog&quot;</span><br></pre></td></tr></table></figure>
<p>设置执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/init.d/postgressql		</span><br></pre></td></tr></table></figure>

<p>此后，执行以下命令可以方便的启停服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//手动启动服务</span><br><span class="line">service postgressql start</span><br><span class="line"></span><br><span class="line">//查看服务状态</span><br><span class="line">service postgressql status</span><br><span class="line"></span><br><span class="line">//手动停止服务</span><br><span class="line">service postgressql stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机启动 ,执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add postgressql</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p> <a href="https://www.postgresql.org/download/linux/redhat/">官网安装教程地址</a></p>
<p>安装完成会自动创建一个用户为：postgres  </p>
<p>首先使用管理员用户修改密码，然后登录以后，运行psql 即可使用，</p>
<p>允许远程访问，yum安装的ppostgresql 的配置文件在<code>/var/lib/pgsql/12/data</code> 目录下</p>
<p>修改配置文件 <code>postgresql.conf</code> 将 <code>listen_addresses = &#39;localhost&#39; </code>改为 <code>listen_addresses = &#39;*&#39; </code></p>
<p>然后在修改 <code>pg_hba_conf</code> 在最后一行添加 <code>host all  all  0.0.0.0/0  md5</code>  允许所有IIP访问， 如果限定IP,将0.0.0.0 改为指定IP。</p>
<p>重启命令postgresql  ：<code>systemctl restart postgresql-12</code></p>
<p>参考材料：<a href> https://www.cnblogs.com/littleatp/p/10542137.html </a></p>
]]></content>
      <categories>
        <category>CentOS</category>
        <category>安装PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python压缩图片作为缩略图</title>
    <url>/2021/02/02/Python%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<p>​           </p>
<a id="more"></a>

<p>将图片压缩，作为缩略图，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFile</span><br><span class="line">ImageFile.LOAD_TRUNCATED_IMAGES = <span class="literal">True</span>    <span class="comment">#   OSError: image file is truncated   图像被截断错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize_by_size</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;按照生成图片文件大小进行处理(单位KB)&quot;&quot;&quot;</span></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">        im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">        size_tmp = os.path.getsize(infile)</span><br><span class="line">        q = <span class="number">100</span></span><br><span class="line">        <span class="keyword">while</span> size_tmp &gt; <span class="number">10240</span> <span class="keyword">and</span> q &gt; <span class="number">0</span>:</span><br><span class="line">            out = im.resize(im.size, Image.ANTIALIAS)</span><br><span class="line">            out.save(outfile, quality=q)</span><br><span class="line">            size_tmp = os.path.getsize(outfile)</span><br><span class="line">            q -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> q == <span class="number">100</span>:</span><br><span class="line">            shutil.copy(infile,outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equal_img</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    修改大小</span></span><br><span class="line"><span class="string">    :param cls:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.startswith(<span class="string">&#x27;thumbnail&#x27;</span>) <span class="keyword">or</span> file_name.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 判断是不是图片。不是的话，忽略</span></span><br><span class="line">        <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>,<span class="string">&#x27;JPEG&#x27;</span>]:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&#x27;file_name：&#x27;,outfilename)</span></span><br><span class="line">            outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">            <span class="comment"># print(u&#x27;path：&#x27;,outfile)</span></span><br><span class="line">            im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">            width = im.size[<span class="number">0</span>]   <span class="comment"># 获取宽度</span></span><br><span class="line">            height = im.size[<span class="number">1</span>]   <span class="comment"># 获取高度</span></span><br><span class="line">            print(<span class="string">u&#x27;width：height：&#x27;</span>,width,height)</span><br><span class="line">            <span class="keyword">if</span> width &lt;= <span class="number">200</span>:</span><br><span class="line">                shutil.copy(infile,outfile)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coe = <span class="built_in">float</span>(<span class="string">&#x27;%.2f&#x27;</span>%(<span class="number">200</span>/width))   <span class="comment">#保留两位小数可能是0.00，</span></span><br><span class="line">                print(<span class="string">u&#x27;coe：&#x27;</span>,coe)</span><br><span class="line">                <span class="keyword">if</span> coe &lt;= <span class="number">0</span>:</span><br><span class="line">                    coe = <span class="number">0.15</span></span><br><span class="line">                <span class="keyword">if</span> im.mode == <span class="string">&quot;P&quot;</span>:</span><br><span class="line">                    im = im.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">                out = im.resize((<span class="built_in">int</span>(width*coe), <span class="built_in">int</span>(height*coe)), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">                out.save(outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gci</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="comment">#遍历filepath下所有文件，包括子目录</span></span><br><span class="line">    files = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> fi <span class="keyword">in</span> files:</span><br><span class="line">        fi_d = os.path.join(filepath,fi)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(fi_d):</span><br><span class="line">            gci(fi_d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># resize_by_size(os.path.join(filepath,fi_d))</span></span><br><span class="line">            equal_img(os.path.join(filepath,fi_d))</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归遍历/root目录下所有文件</span></span><br><span class="line"><span class="comment"># gci(&#x27;/var/local/www/edu_online1/media/works&#x27;)</span></span><br><span class="line"><span class="comment"># gci(&#x27;/root/www/edu_online1/media/works/13360067818/tradition&#x27;)  #正式</span></span><br><span class="line">gci(<span class="string">&#x27;/root/www/edu_online1/media/works/13265647342/udict/1552525240000/䤋&#x27;</span>)  <span class="comment">#正式</span></span><br><span class="line"><span class="comment"># gci(r&#x27;F:\desktop\䤋&#x27;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>Pillow</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>flaskshell创建索引出错</title>
    <url>/2021/02/02/flaskshell%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>​    </p>
<a id="more"></a>

<p>遇到的问题：flask 环境中使用 flask shell  使用flask Whoosh 创建索引失败</p>
<h3 id="解决办法-："><a href="#解决办法-：" class="headerlink" title="解决办法 ："></a>解决办法 ：</h3><pre><code>export FLASK_APP=manage.py
flask shell 
</code></pre>
<p>然后导出 flask 创建的whoosh的whoosh对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 项目内的文件 import whoosh</span><br><span class="line">whoosh.create_index()</span><br></pre></td></tr></table></figure>

<p>​    </p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Python + Elestatcsearch</title>
    <url>/2021/02/02/Python-Elestatcsearch/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<blockquote>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p> ElasticSearch是一个基于<a href="https://baike.baidu.com/item/Lucene/6753302">Lucene</a>的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353">云计算</a>中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。 </p>
<h2 id="有关概念"><a href="#有关概念" class="headerlink" title="有关概念"></a>有关概念</h2><p>cluster：代表一个<a href="https://baike.baidu.com/item/%E9%9B%86%E7%BE%A4">集群</a>，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</p>
<p>shards：代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</p>
<p>replicas：代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的<a href="https://baike.baidu.com/item/%E5%AE%B9%E9%94%99%E6%80%A7">容错性</a>，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</p>
<p>recovery：代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</p>
<p>river：代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。</p>
<p>gateway：代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分布式文件系统</a>，Hadoop的HDFS和amazon的s3<a href="https://baike.baidu.com/item/%E4%BA%91%E5%AD%98%E5%82%A8">云存储</a>服务。</p>
<p>discovery.zen：代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%92%AD">多播</a>协议来进行节点之间的通信，同时也支持<a href="https://baike.baidu.com/item/%E7%82%B9%E5%AF%B9%E7%82%B9">点对点</a>的交互。</p>
<p>Transport：代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、<a href="https://baike.baidu.com/item/thrift">thrift</a>、servlet、memcached、zeroMQ等的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">传输协议</a>（通过<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6">插件</a>方式集成）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Elestaticsearch</category>
      </categories>
      <tags>
        <tag>Elestaticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Aarch64架构-Linux-编译安装rocketmq-client-cpp</title>
    <url>/2021/02/02/aarch64%E6%9E%B6%E6%9E%84-Linux-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85rocketmq-client-cpp%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85Python3.8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>​      </p>
<a id="more"></a>

<h1 id="Aarch64架构-Linux-编译安装rocketmq-client-cpp"><a href="#Aarch64架构-Linux-编译安装rocketmq-client-cpp" class="headerlink" title="Aarch64架构-Linux-编译安装rocketmq-client-cpp"></a>Aarch64架构-Linux-编译安装rocketmq-client-cpp</h1><h2 id="1、安装-Rocketmq-client-cpp-所需工具"><a href="#1、安装-Rocketmq-client-cpp-所需工具" class="headerlink" title="1、安装 Rocketmq-client-cpp 所需工具"></a>1、安装 Rocketmq-client-cpp 所需工具</h2><ul>
<li>gcc-c++ 4.8.2: c++ compiler while need support C++11</li>
<li>cmake 2.8.0: build jsoncpp require it</li>
<li>automake 1.11.1: build libevent require it</li>
<li>autoconf 2.65: build libevent require it</li>
<li>libtool 2.2.6: build libevent require it</li>
</ul>
<h3 id="1-1-检查各项工具是否可用"><a href="#1-1-检查各项工具是否可用" class="headerlink" title="1.1 检查各项工具是否可用"></a>1.1 检查各项工具是否可用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如下提示代表已经安装， 需要指定gcc 版本为 4.8.2 (4.8.5 也可以安装成功)</span></span><br><span class="line">gcc version 10.2.1 20210110 (Raspbian 10.2.1-6+rpi1) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake  -version</span><br><span class="line"></span><br><span class="line">安装地址：https://zhuanlan.zhihu.com/p/110793004</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">automake --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如下提示代表已经安装</span></span><br><span class="line">automake (GNU automake) 1.16.1</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">automake --version</span><br><span class="line"></span><br><span class="line">autoconf (GNU Autoconf) 2.69</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">libtool --version</span><br><span class="line"></span><br><span class="line">libtool (GNU libtool) 2.4.6</span><br></pre></td></tr></table></figure>


<h3 id="1-2-命令行安装-cmake、automake-、autoconf-、libtool-推荐apt-get-安装"><a href="#1-2-命令行安装-cmake、automake-、autoconf-、libtool-推荐apt-get-安装" class="headerlink" title="1.2 命令行安装 cmake、automake 、autoconf 、libtool  (推荐apt-get 安装)"></a>1.2 命令行安装 cmake、automake 、autoconf 、libtool  (推荐apt-get 安装)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake, aotumake, autoconf, libtool, libtool-bin</span><br></pre></td></tr></table></figure>


<h3 id="1-3-源码安装-gcc、cmake、automake-、autoconf-、libtool"><a href="#1-3-源码安装-gcc、cmake、automake-、autoconf-、libtool" class="headerlink" title="1.3 源码安装 gcc、cmake、automake 、autoconf 、libtool"></a>1.3 源码安装 gcc、cmake、automake 、autoconf 、libtool</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mi shellrrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-4.8.2/gcc-4.8.2.tar.gz</span><br><span class="line">tar zxvf  gcc-4.8.2.tar.gz</span><br><span class="line"></span><br><span class="line">configure --prefix=/home/share/tools/usr/gcc-4.8.2 --enable-threads=posix --disable-checking --disable-multilib --enable-languages=c,c+</span><br><span class="line"></span><br><span class="line">make  &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -OL https://github.com/Kitware/CMake/releases/download/v3.23.1/cmake-3.23.1.tar.gz</span><br><span class="line">tar zxvf cmake-3.22.4.tar.gz</span><br><span class="line">cd cmake-3.22.4</span><br><span class="line">./configure --prefix=/home/share/tools/usr/cmake-3.22.4 &amp;&amp; make  &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -OL http://ftpmirror.gnu.org/automake/automake-1.11.1.tar.gz</span><br><span class="line">tar -xzf automake-1.11.1.tar.gz</span><br><span class="line">cd automake-1.11.1</span><br><span class="line">./configure --prefix=/home/share/tools/usr/automake-1.11.1 &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -OL http://ftpmirror.gnu.org/autoconf/autoconf-2.65.tar.gz</span><br><span class="line">tar -xzf autoconf-2.65.tar.gz </span><br><span class="line">cd autoconf-2.65</span><br><span class="line">./configure --prefix=/home/share/tools/us/autoconf &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">curl -OL http://ftpmirror.gnu.org/libtool/libtool-2.2.6.tar.gz</span><br><span class="line">tar -xzf libtool-2.2.6.tar.gz</span><br><span class="line">cd libtool-2.2.6</span><br><span class="line">./configure --prefix=/home/share/tools/usr/libtool-2.2.6 &amp;&amp; make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="2、安装-Rocketma-client-cpp-所需依赖"><a href="#2、安装-Rocketma-client-cpp-所需依赖" class="headerlink" title="2、安装 Rocketma-client-cpp 所需依赖"></a>2、安装 Rocketma-client-cpp 所需依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bzip2-devel</span> </span><br><span class="line"></span><br><span class="line">sudo apt-get install zlib1g</span><br><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zlib-devel</span></span><br><span class="line">sudo apt-get install libbz2-dev</span><br></pre></td></tr></table></figure>

<h2 id="3、安装rocketmq-cpp"><a href="#3、安装rocketmq-cpp" class="headerlink" title="3、安装rocketmq-cpp"></a>3、安装rocketmq-cpp</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd rocketmq-client-cpp-2.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行安装命令， 等待安装。</span></span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure>


<h2 id="4、将编译安装好的so文件建立连接"><a href="#4、将编译安装好的so文件建立连接" class="headerlink" title="4、将编译安装好的so文件建立连接"></a>4、将编译安装好的so文件建立连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /home/zjj/rocketmq/librocketmq.so /usr/lib/librocketmq.so</span><br></pre></td></tr></table></figure>




<h1 id="安装python3-8"><a href="#安装python3-8" class="headerlink" title="安装python3.8"></a>安装python3.8</h1><h2 id="1、下载安装Python"><a href="#1、下载安装Python" class="headerlink" title="1、下载安装Python"></a>1、下载安装Python</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf Python-3.8.13.tgz</span><br><span class="line">cd Python-3.8.13</span><br><span class="line">sudo ./configure </span><br><span class="line">sudo make &amp;&amp; makeinstall</span><br></pre></td></tr></table></figure>
<h2 id="2、设置软连接"><a href="#2、设置软连接" class="headerlink" title="2、设置软连接"></a>2、设置软连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /usr/bin/python3.8/python 编译后的文件地址</span></span><br><span class="line">sudo ln -s /usr/bin/python3.8/python /usr/bin/python38</span><br></pre></td></tr></table></figure>
<h2 id="3、安装-pip"><a href="#3、安装-pip" class="headerlink" title="3、安装 pip"></a>3、安装 pip</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py --no-check-certificate</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>




<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unable to locally verify the issuer&#x27;s authority.</span><br><span class="line">To connect to github.com insecurely, use `--no-check-certificate&#x27;.</span><br></pre></td></tr></table></figure>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p><a href="https://blog.csdn.net/iMatt/article/details/109570935">https://blog.csdn.net/iMatt/article/details/109570935</a></p>
<h2 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unable to resolve host topeet: Name or service not knowncd</span><br></pre></td></tr></table></figure>
<h2 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h2><p><a href="https://blog.csdn.net/ichuzhen/article/details/8241847">https://blog.csdn.net/ichuzhen/article/details/8241847</a></p>
<h2 id="问题3："><a href="#问题3：" class="headerlink" title="问题3："></a>问题3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装libevent提示：</span><br><span class="line">openssl is a must but can not be found.</span><br></pre></td></tr></table></figure>
<h2 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure>


<h2 id="问题4："><a href="#问题4：" class="headerlink" title="问题4："></a>问题4：</h2><p>安装gcc 缺少依赖：GMP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gnu&#x2F;gmp&#x2F;gmp-4.2.tar.gz</span><br><span class="line">tar -zxvf gmp-4.2.tar.gz</span><br><span class="line">cd gmp-4.2</span><br><span class="line">configure --prefix&#x3D;&#x2F;home&#x2F;share&#x2F;tools&#x2F;usr&#x2F;gmp-4.2</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>遇到问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure: error: cannot guess build type; you must specify one</span><br></pre></td></tr></table></figure>
<h2 id="解决：-3"><a href="#解决：-3" class="headerlink" title="解决："></a>解决：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前系统的型号</span></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据钱型号测试</span></span><br><span class="line">configure --prefix=/home/share/tools/usr/gmp-4.2 --build=aarch64-linnx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示错误</span></span><br><span class="line">Invalid configuration `aarch64-linux&#x27;: machine `aarch64&#x27; not recognize</span><br></pre></td></tr></table></figure>
<p>查阅资料：<a href="https://blog.csdn.net/lile777/article/details/81389098">解决</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 gmp-4.2 目录下，根据文章方法下载 config.guess 和 config.sub 文件， 然后替换掉原来的同名文件</span></span><br><span class="line">wget -O config.guess &#x27;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget -O config.sub &#x27;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD&#x27;</span><br></pre></td></tr></table></figure>
<p>再重新配置编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure --prefix=/home/share/tools/usr/gmp-4.2</span><br></pre></td></tr></table></figure>
<p>GMP 安装成功</p>
<h2 id="问题5："><a href="#问题5：" class="headerlink" title="问题5："></a>问题5：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找不到 jsoncpp.a 文件</span><br></pre></td></tr></table></figure>
<h2 id="解决：-4"><a href="#解决：-4" class="headerlink" title="解决："></a>解决：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将  &#x2F;bin&#x2F;aarch64-linux  目录下的jsoncpp.a 文件移动到 &#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>


<h2 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/var/local/mq/producer.py&quot;, line 12, in &lt;module&gt;</span><br><span class="line">    from rocketmq.client import Producer, Message</span><br><span class="line">  File &quot;/usr/local/lib64/python3.8/site-packages/rocketmq/client.py&quot;, line 24, in &lt;module&gt;</span><br><span class="line">    from .ffi import (</span><br><span class="line">  File &quot;/usr/local/lib64/python3.8/site-packages/rocketmq/ffi.py&quot;, line 42, in &lt;module&gt;</span><br><span class="line">    dll = ctypes.cdll.LoadLibrary(_DYLIB_PATH)</span><br><span class="line">  File &quot;/usr/lib64/python3.8/ctypes/__init__.py&quot;, line 451, in LoadLibrary</span><br><span class="line">    return self._dlltype(name)</span><br><span class="line">  File &quot;/usr/lib64/python3.8/ctypes/__init__.py&quot;, line 373, in __init__</span><br><span class="line">    self._handle = _dlopen(self._name, mode)</span><br><span class="line">OSError: librocketmq.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>


<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将librocketmq.so 文件软连接到/usr/lib/librocketmq.so</span> </span><br><span class="line"></span><br><span class="line">ln -s /usr/local/lib/librocketmq.so /usr/lib</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ldconfig </span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h2><p><a href="https://blog.csdn.net/qq_34174198/article/details/120663608">https://blog.csdn.net/qq_34174198/article/details/120663608</a></p>
]]></content>
      <categories>
        <category>编译安装RocketMQ</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>两台linux 互相传输文件</title>
    <url>/2021/02/02/%E4%B8%A4%E5%8F%B0linux-%E4%BA%92%E7%9B%B8%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<blockquote>
<h4 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h4><h6 id="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"><a href="#rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。" class="headerlink" title="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"></a>rsync是linux系统下的数据<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a><a href="https://baike.baidu.com/item/%E5%A4%87%E4%BB%BD">备份</a>工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。</h6><h5 id="它的特性如下："><a href="#它的特性如下：" class="headerlink" title="它的特性如下："></a>它的特性如下：</h5><ul>
<li><p>可以<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a>保存整个目录树和文件系统。</p>
</li>
<li><p>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</p>
</li>
<li><p>无须特殊权限即可安装。</p>
</li>
<li><p>快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync 在传输数据的过程中可以实行压缩及<a href="https://baike.baidu.com/item/%E8%A7%A3%E5%8E%8B%E7%BC%A9">解压缩</a>操作，因此可以使用更少的带宽。</p>
</li>
<li><p>安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。</p>
</li>
<li><p>支持匿名传输，以方便进行网站镜像。 </p>
</li>
</ul>
</blockquote>
<h4 id="1、Rsync参数说明"><a href="#1、Rsync参数说明" class="headerlink" title="1、Rsync参数说明"></a>1、Rsync参数说明</h4><ol>
<li><p>使用 rsync + ssh 进行加密传输  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh /home/ubuntu/remote_test ubuntu@193.112.102.63:/home/ubuntu/remote_test</span><br></pre></td></tr></table></figure></li>
<li><p>参数设置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v, --verbose 详细模式输出</span><br><span class="line">   -q, --quiet 精简输出模式</span><br><span class="line">   -c, --checksum 打开校验开关，强制对文件传输进行校验</span><br><span class="line">   -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span><br><span class="line">   -r, --recursive 对子目录以递归模式处理</span><br><span class="line">   -R, --relative 使用相对路径信息</span><br><span class="line">   -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">   --backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">   -suffix&#x3D;SUFFIX 定义备份文件前缀</span><br><span class="line">   -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)</span><br><span class="line">   -l, --links 保留软链结</span><br><span class="line">   -L, --copy-links 像对待常规文件一样处理软链接</span><br><span class="line">   --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链接</span><br><span class="line">   --safe-links 忽略指向SRC路径目录树以外的链接</span><br><span class="line">   -H, --hard-links 保留硬链接</span><br><span class="line">   -p, --perms 保持文件权限</span><br><span class="line">   -o, --owner 保持文件属主信息</span><br><span class="line">   -g, --group 保持文件属组信息</span><br><span class="line">   -D, --devices 保持设备文件信息</span><br><span class="line">   -t, --times 保持文件时间信息</span><br><span class="line">   -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间</span><br><span class="line">   -n, --dry-run显示哪些文件将被传输</span><br><span class="line">   -W, --whole-file 拷贝文件，不进行增量检测</span><br><span class="line">   -x, --one-file-system 不要跨越文件系统边界</span><br><span class="line">   -B, --block-size&#x3D;SIZE 检验算法使用的块尺寸，默认是700字节</span><br><span class="line">   -e, --rsh&#x3D;COMMAND 指定使用rsh、ssh方式进行数据同步</span><br><span class="line">   --rsync-path&#x3D;PATH 指定远程服务器上的rsync命令所在路径信息</span><br><span class="line">   -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件</span><br><span class="line">   --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件</span><br><span class="line">   --delete 删除那些DST中SRC没有的文件</span><br><span class="line">   --delete-excluded 同样删除接收端那些被该选项指定排除的文件</span><br><span class="line">   --delete-after 传输结束以后再删除</span><br><span class="line">   --ignore-errors 即使出现IO错误也进行删除</span><br><span class="line">   --max-delete&#x3D;NUM 最多删除NUM个文件</span><br><span class="line">   --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span><br><span class="line">   --force 强制删除目录，即使不为空</span><br><span class="line">   --numeric-ids 不将数字的用户和组ID匹配为用户名和组名</span><br><span class="line">   --timeout&#x3D;TIME IP超时时间，单位为秒</span><br><span class="line">   -I, --ignore-times 不跳过那些有同样的时间和长度的文件</span><br><span class="line">   --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间</span><br><span class="line">   --modify-window&#x3D;NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0</span><br><span class="line">   -T --temp-dir&#x3D;DIR 在DIR中创建临时文件</span><br><span class="line">   --compare-dest&#x3D;DIR 同样比较DIR中的文件来决定是否需要备份</span><br><span class="line">   -P 等同于 --partial</span><br><span class="line">   --progress 显示备份过程</span><br><span class="line">   -z, --compress 对备份的文件在传输时进行压缩处理</span><br><span class="line">   --exclude&#x3D;PATTERN 指定排除不需要传输的文件模式</span><br><span class="line">   --include&#x3D;PATTERN 指定不排除而需要传输的文件模式</span><br><span class="line">   --exclude-from&#x3D;FILE 排除FILE中指定模式的文件</span><br><span class="line">   --include-from&#x3D;FILE 不排除FILE指定模式匹配的文件</span><br><span class="line">   --version 打印版本信息</span><br><span class="line">   --address 绑定到特定的地址</span><br><span class="line">   --config&#x3D;FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件</span><br><span class="line">   --port&#x3D;PORT 指定其他的rsync服务端口</span><br><span class="line">   --blocking-io 对远程shell使用阻塞IO</span><br><span class="line">   -stats 给出某些文件的传输状态</span><br><span class="line">   --progress 在传输时显示传输过程</span><br><span class="line">   --log-format&#x3D;formAT 指定日志文件格式</span><br><span class="line">   --password-file&#x3D;FILE 从FILE中得到密码</span><br><span class="line">   --bwlimit&#x3D;KBPS 限制I&#x2F;O带宽，KBytes per second</span><br><span class="line">   -h, --help 显示帮助信息</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2、目的"><a href="#2、目的" class="headerlink" title="2、目的"></a>2、目的</h4><ul>
<li><p>实现两台服务器之间做增量备份。A服务器作为服务端，B服务器作为客户端。</p>
</li>
<li><p>B服务器每天定时将某个目录下产生的文件发送到A服务器中。</p>
</li>
</ul>
<h4 id="3、操作方法"><a href="#3、操作方法" class="headerlink" title="3、操作方法"></a>3、操作方法</h4><p>在A服务器中安装 rsync ，查看服务器是否安装rsync。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync --version</span><br><span class="line">#显示如下  代表已经安装  版本为：3.1.1  (确保两台服务器之前安装的版本的一致，不一致可能造成无法同步数据)</span><br><span class="line">rsync  version 3.1.2  protocol version 31</span><br><span class="line">Copyright (C) 1996-2015 by Andrew Tridgell, Wayne Davison, and others.</span><br><span class="line">Web site: http:&#x2F;&#x2F;rsync.samba.org&#x2F;</span><br><span class="line">Capabilities:</span><br><span class="line">    64-bit files, 64-bit inums, 64-bit timestamps, 64-bit long ints,</span><br><span class="line">    socketpairs, hardlinks, symlinks, IPv6, batchfiles, inplace,</span><br><span class="line">    append, ACLs, xattrs, iconv, symtimes, prealloc</span><br><span class="line"></span><br><span class="line">rsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you</span><br><span class="line">are welcome to redistribute it under certain conditions.  See the GNU</span><br><span class="line">General Public Licence for details.</span><br></pre></td></tr></table></figure>
<p>两边都安装完成了以后，就可以使用了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh 001 ubuntu@193.112.102.63:/home/ubuntu/remote_test   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ssh模式连接 需要输入密码</span></span><br></pre></td></tr></table></figure>
<h5 id="1-将A服务器作为服务端"><a href="#1-将A服务器作为服务端" class="headerlink" title="1. 将A服务器作为服务端"></a>1. 将A服务器作为服务端</h5><p>编辑文件 <code>/etc/vi /etc/rsyncd.conf</code>默认不存在， 直接创建 。编辑输入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务端配置文件 (和上面一样)</span></span><br><span class="line">motd file = /etc/rsyncd.motd</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsyncd.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line">[workspace]  #模块名 在客户端需要用到</span><br><span class="line">path = /devdata/backres   #需要备份的路径</span><br><span class="line">comment = Test</span><br><span class="line">uid = root   #使用的用户</span><br><span class="line">gid = root   #同上 </span><br><span class="line">read only = false   #是否可写</span><br><span class="line">auth users = root   #验证的用户</span><br><span class="line">secrets file = /etc/rsyncd.pass   #密码文件  文件的权限：600</span><br><span class="line">transfer logging = yes   #日志输出</span><br><span class="line">hosts allow=123.207.165.19   #允许的可短的IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建密码文件 在上述的conf文件中，倒数第三行。内容为当前用户名以及密码 。格式：user：password。密码文件拥有用户必须为当前用户 ubuntu 且权限必须为 600</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu:123456</span><br></pre></td></tr></table></figure>
<p>查看rsync 状态 ： <code>service rsync status</code>。 重启rsync服务： <code>service rsync restart</code></p>
<h5 id="2-将b服务器作为客户端"><a href="#2-将b服务器作为客户端" class="headerlink" title="2. 将b服务器作为客户端"></a>2. 将b服务器作为客户端</h5><p>客户端不需要设置太多内容可直接运行命令，不过需要手动输入密码，可将密码存在一个文件内，使用<code>--password-file=FILE</code> 进行从文件中读取密码。这个文件路径任意。文件内容只包含服务端密码即可。但是必须为root用户拥有且权限为600。</p>
<p>使用命令 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rsync -aqr --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数解释：</span></span><br><span class="line">-a：--archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，</span><br><span class="line">-q：--quiet 精简输出模式</span><br><span class="line">-r：--recursive 对子目录以递归模式处理</span><br><span class="line">workspace：即服务端的模块名</span><br></pre></td></tr></table></figure>
<h5 id="3-设置定时任务"><a href="#3-设置定时任务" class="headerlink" title="3. 设置定时任务"></a>3. 设置定时任务</h5><p>使用ubuntu 的crontab </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>第一次打开会选择的编辑器，一般选择vim,输入数字即可。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Select an editor.  To change later, run &#x27;select-editor&#x27;.</span><br><span class="line">  1. /bin/ed</span><br><span class="line">  2. /bin/nano        &lt;---- easiest</span><br><span class="line">  3. /usr/bin/vim.basic</span><br><span class="line">  4. /usr/bin/vim.tiny</span><br></pre></td></tr></table></figure>
<p>定时任务格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* * * * * command    </span><br><span class="line">用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</span><br><span class="line">minute hour day month week command</span><br><span class="line">其中：</span><br><span class="line">minute：表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</span><br><span class="line">/ 斜杠代表频率 例如：</span><br><span class="line">如果想每分钟都执行一次的话就采用默认的 * * * * *</span><br><span class="line">如果想每五分钟执行一次可以 */5 * * * * </span><br><span class="line">如果是每两个小时执行一次的话 那就是 *  */2 * * *来设置;</span><br></pre></td></tr></table></figure>
<p>在定时任务中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">30 23 * * * sudo rsync -r --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br><span class="line"><span class="meta">#</span><span class="bash">表示 在每天的23:30 进行数据备份</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN的工作原理</title>
    <url>/2021/02/01/CDN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="CDN访问的两个阶段"><a href="#CDN访问的两个阶段" class="headerlink" title="CDN访问的两个阶段"></a>CDN访问的两个阶段</h3><ul>
<li>1.域名解析</li>
<li>2.内容请求</li>
</ul>
<a id="more"></a>

<h3 id="使用CDN得两种方式："><a href="#使用CDN得两种方式：" class="headerlink" title="使用CDN得两种方式："></a>使用CDN得两种方式：</h3><ul>
<li>手工上传静态资源文件到CDN</li>
<li>tongguo Tengine 把本机的静态资源开放发哦web上，CDN自动回流到Tengine。</li>
</ul>
<h4 id="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"><a href="#以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。" class="headerlink" title="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"></a>以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。</h4><ul>
<li>生成静态文件上传到阿里元OSS。</li>
<li>配置CDN域名，回源地址指向OSS Bucket，配置Referer 防盗链的白名单。</li>
<li>配置OSS Buket 的匿名可以读。</li>
<li>设置STATIC_URL， 直接指向CDN地址，同时注释掉 OssStaticStorage。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>CDN</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之美：dajngo的常用插件</title>
    <url>/2021/02/01/Django%E4%B9%8B%E7%BE%8E%EF%BC%9Adajngo%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<h1 id="Djgnao-常用扩展"><a href="#Djgnao-常用扩展" class="headerlink" title="Djgnao 常用扩展"></a>Djgnao 常用扩展</h1><ul>
<li><p><a href="https://django-debug-toolbar.readthedocs.io/en/latest/">django_debug_toolbar </a>：提供一个可以查看debug信息的面板（包括SQL执行时间，页面耗时）</p>
</li>
<li><p><a href="https://github.com/jazzband/django-silk">django-silk</a>：django性能瓶颈分析</p>
</li>
<li><p><a href="https://simpleui.72wo.com/docs/simpleui/doc.html">Simple-UI</a> ：于Element UI 和 VUE 的django admin 主题。</p>
</li>
<li><p><a href="https://django-haystack.readthedocs.io/en/master/">haystack django</a> ：模块化搜索方案</p>
</li>
<li><p><a href="https://github.com/django-notifications/django-notifications">django-notifications</a>：发送消息通知插件</p>
</li>
<li><p><a href="https://github.com/agusmakmun/django-markdown-editor">django markdown editor</a> ：Markdown 编辑器</p>
</li>
<li><p><a href="https://github.com/django-crispy-forms/django-crispy-forms">django-crispy-forms</a>：Crispy 表单，以一种非常优雅的、干净的方式来创建表单。</p>
</li>
<li><p><a href="https://github.com/mbi/django-simple-captcha">django-simple-captcha</a>：Django验证码</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL8连接数据库错误</title>
    <url>/2021/02/01/MySQL8%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<p>MySQl 8.0 连接数据库出现以下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The user specified as a definer (‘mysql.infoschema‘@‘localhost‘) does not exist</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ol>
<li>重新创建该用户（mysql.infoschema）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;mysql.infoschema&#x27;</span> @ <span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>给用户赋予权限</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;mysql.infoschema&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>刷新数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
