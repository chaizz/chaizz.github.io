<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>迭代思维与MVP产品的规划方法</title>
    <url>/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>​            </p>
<a id="more"></a>

<h3 id="快速迭代的价值与挑战"><a href="#快速迭代的价值与挑战" class="headerlink" title="快速迭代的价值与挑战"></a>快速迭代的价值与挑战</h3><p>快速迭代：以天或者小时为单位，持续的完善产品，交付到用户的循环过程</p>
<h4 id="快速迭代的价值："><a href="#快速迭代的价值：" class="headerlink" title="快速迭代的价值："></a>快速迭代的价值：</h4><ul>
<li>时间是最大的成本，机会转瞬即逝，赢得市场先机。</li>
<li>快速验证需求，减少不对用户产生价值的投入（Fail fast, Fail better）。</li>
<li>快速验证方案，提高研发效率。</li>
<li>加速反馈回路，给到团队和自己及时的激励。</li>
</ul>
<h4 id="快速迭代的挑战："><a href="#快速迭代的挑战：" class="headerlink" title="快速迭代的挑战："></a>快速迭代的挑战：</h4><ul>
<li>产品设计者：能梳理清楚业务流程，抓住用户的重点需求，能把客户需求转换为系统的需求。</li>
<li>开发者：充分理解用户需求，有足够的能力，能用简洁的方案来设计出易维护的系统。</li>
</ul>
<h4 id="根本挑战："><a href="#根本挑战：" class="headerlink" title="根本挑战："></a>根本挑战：</h4><ul>
<li><p>市场、用户、技术、环境变化太快，产品开发跟不上节奏。</p>
</li>
<li><p>几乎不能从一开始就设计一个完美的，能够使用未来长时间变化的方案</p>
</li>
<li><p>几乎没有人愿意承认，自己没有足够的力（或条件）设计一个完美的产品（系统）。</p>
</li>
</ul>
<h3 id="OOPD-方法识别产品的核心功能"><a href="#OOPD-方法识别产品的核心功能" class="headerlink" title="OOPD 方法识别产品的核心功能"></a>OOPD 方法识别产品的核心功能</h3><p>OOPD：Online and Offline integrated Product Development  </p>
<p><img src="/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/OOPD.png"></p>
<p>OOPD迭代的原则：</p>
<ul>
<li>自助原则：做自己的产品，自己用自己的产品，吃自己的狗食。</li>
<li>0day：找到明确的核心问题，拆解目标，抓住核心的问题，忽略掉一切细节，0day发布。</li>
<li>时限原则：设定时限，挑战自我，不给自己写BUG的时间。</li>
<li>不完美原则：不做完美的产品。（没有完美的产品，不去为了完美而浪费宝贵的资源）</li>
<li>谦卑原则：能够看到自己的局限性，获取用户反馈，持续迭代，听取用户的声音。</li>
</ul>
<p>MVP：minimum viable product 最小可用产品</p>
<ul>
<li>内裤原则 ： MVP 包括了产品的轮廓，核心的功能，让业务可以运转。</li>
<li>优先线下：能够走线下的 优先走线下的流程，让核心的功能先跑起来，快速的做用户验证和方案验证。</li>
<li>MVP的核心：忽略掉一切技术的细枝末节，做最合适的假设和简化，使用最短的时间开发出来。</li>
</ul>
<p>迭代思维最强大的是产品思维逻辑，互联网唯快不破的秘诀。</p>
<h3 id="如何做好技术方案设计与工作拆解"><a href="#如何做好技术方案设计与工作拆解" class="headerlink" title="如何做好技术方案设计与工作拆解"></a>如何做好技术方案设计与工作拆解</h3><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h4><ul>
<li>做技术方案设计的前提条件<ul>
<li>有明确的的用户场景，用户如何和产品进行交互，期望拿到什么预期结果。</li>
<li>有清晰定义的业务流程</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li><p>用什么工具设计？</p>
<ul>
<li>Visual Paradigm</li>
<li>Lucid Chart</li>
<li>Visio</li>
<li>Gliffy</li>
<li>Draw.io</li>
<li>Astash</li>
<li>StarUML</li>
<li>…..</li>
</ul>
<p>推荐使用<strong>白纸</strong>，不用工具就是最好的工具。</p>
</li>
<li><p>产出的技术方案文档要素</p>
<ul>
<li>产品背景（用户场景、产品目标、引用到的业务流畅、产品需求文档）</li>
<li>要解决的问题列表，系统不解决的问题列表，系统的限制。</li>
<li>对于问题的不同的解决方案的对比，阐述各个主要的问题如何被解决。</li>
<li>所选的整体的流程图（序列图），模块关系图，重要的接口，实体的概念定义。</li>
<li>除了功能之外的其他方面的设计，包括安全、性能、可维护性、稳定性、监控、扩展性、易用性等。</li>
</ul>
</li>
</ul>
<h4 id="工作拆解"><a href="#工作拆解" class="headerlink" title="工作拆解"></a>工作拆解</h4><p>​    任何事情，只要把它拆解的够细，都能够完成它。</p>
<ul>
<li>工作拆解的原则：<ul>
<li>优先级：主流程上，不确定的工作先完成（建议提前一个迭代做调研）。</li>
<li>核心流程优先：核心工作优先，先把主流程跑通。</li>
<li>依赖：减少不同人之间的工作依赖，并且保持团队工作拆解的透明，预留20%Buffer。</li>
<li>拆解粒度：拆解到每项子任务0.5-1天的粒度，最长不要超过两天。</li>
</ul>
</li>
</ul>
<h3 id="如何保证交付质量和可持续迭代"><a href="#如何保证交付质量和可持续迭代" class="headerlink" title="如何保证交付质量和可持续迭代"></a>如何保证交付质量和可持续迭代</h3><p>定义好产品需求，产品需求从根本上决定了产品的质量。</p>
<p>系统上有整体架构方案的设计，评估，评审，系统决定了软件实现的质量。</p>
<p>工程的角度持续交付的最佳实践推荐：</p>
<ul>
<li> Code Review：每一次提交都有CR，每次commit 代码量控制在200行y以内。尽量频繁的commit。</li>
<li>单元集成：项目开始简历单元测试的机制，在持续集成中自动运行。</li>
<li>自动化回归：对预发/线上系统做KPI/页面自动化测试（Postman/Robot Framework）</li>
<li>使用CICD机制对心痛进行自动化的打包，测试，部署，线上验证。</li>
<li>发布过程做到可监控，可回滚。</li>
<li>对于大量用户使用的产品，使用灰度机制。</li>
<li>架构上对于意外的并发访问，进行限流，降级。</li>
<li>架构上使用配置开关，对系统功能能提供实时的开启/关闭的服务。</li>
<li>对产品简历A/B Test 机制，通过数据快速对比不同的版本，不同的方案。</li>
<li>自动化所有的事情，代码化所有过程：代码化配置，代码化部署流程，代码化基础设置。<ul>
<li>声明式API，CICD Pipeline，K8S，Helm , Terraform</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>敏捷开发</category>
      </categories>
      <tags>
        <tag>快速迭代、OOPD</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Kuboard</title>
    <url>/2022/07/30/%E9%83%A8%E7%BD%B2Kuboard/</url>
    <content><![CDATA[<a id="more"></a>

<!--more-->

<!--more-->

<p>参考链接</p>
<blockquote>
<p><a href="https://www.kuboard.cn/install/v3/install-built-in.html">安装 Kuboard v3 - 内建用户库 | Kuboard</a></p>
</blockquote>
<blockquote>
<p>Kuboard 是一款专为 Kubernetes 设计的免费管理界面，兼容 Kubernetes 版本 1.13 及以上。Kuboard 每周发布一个 beta 版本，最长每月发布一个正式版本，经过两年的不断迭代和优化，已经具备多集群管理、权限管理、监控套件、日志套件等丰富的功能，并且有 1000+ 的企业将 Kuboard 应用于其生产环境。</p>
</blockquote>
<p>一、前期准备</p>
<ul>
<li>搭建完成Kubernetes 集群。</li>
<li>Docker 安装完毕</li>
</ul>
<p>二、安装Kuboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard \</span><br><span class="line">  -p 80:80/tcp \</span><br><span class="line">  -p 10081:10081/tcp \</span><br><span class="line">  -e KUBOARD_ENDPOINT=&quot;http://192.158.59.130:80&quot; \</span><br><span class="line">  -e KUBOARD_AGENT_SERVER_TCP_PORT=&quot;10081&quot; \</span><br><span class="line">  -v /root/kuboard-data:/data \</span><br><span class="line">  eipwork/kuboard:v3</span><br></pre></td></tr></table></figure>
<p>三、访问 Kuboard</p>
<p>在浏览器输入 <code>http://your-host-ip:80</code> 即可访问 Kuboard v3.x 的界面，登录方式：</p>
<ul>
<li>用户名： <code>admin</code></li>
<li>密 码： <code>Kuboard123</code></li>
</ul>
]]></content>
      <tags>
        <tag>Kuboard</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机K8s集群搭建</title>
    <url>/2022/07/30/%E9%83%A8%E7%BD%B2k8S%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<a id="more"></a>

<!--more-->

<p>参考链接</p>
<blockquote>
<p><a href="https://www.kuboard.cn/install/v3/install.html">安装 Kubernetes 多集群管理工具 - Kuboard v3 | Kuboard</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/Sunzz/p/15184167.html">安装Kubernetes(k8s)保姆级教程—无坑版 - Sunzz - 博客园</a></p>
</blockquote>
<h1 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h1><h2 id="1-1-系统环境"><a href="#1-1-系统环境" class="headerlink" title="1.1 系统环境"></a>1.1 系统环境</h2><p>VMware 虚拟机环境下</p>
<p>系统：Ubuntu 22.04 LTS</p>
<p>CPU：2核 | 内存：4G | 硬盘：50G</p>
<h2 id="1-2-节点信息"><a href="#1-2-节点信息" class="headerlink" title="1.2 节点信息"></a>1.2 节点信息</h2><p><strong>master：</strong> 192.168.59.130</p>
<p><strong>node01：</strong> 192.168.59.131</p>
<p><strong>node02：</strong> 192.168.59.132</p>
<p>确保每个虚拟机唯一节点、网络通畅、开放端口：6443，禁用Swap</p>
<h2 id="1-3-关闭防火墙"><a href="#1-3-关闭防火墙" class="headerlink" title="1.3 关闭防火墙"></a>1.3 关闭防火墙</h2><p>根据使用的网络模式选择，此处关闭。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld &amp;&amp; systemctl disable firewalld &amp;&amp; iptables -F</span><br></pre></td></tr></table></figure>
<h2 id="1-4-关闭-selinux"><a href="#1-4-关闭-selinux" class="headerlink" title="1.4 关闭 selinux"></a>1.4 关闭 selinux</h2><p>安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统）关闭是因为可能会导致一些不明的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config &amp;&amp; setenforce 0</span><br></pre></td></tr></table></figure>
<h2 id="1-5-关闭Swap"><a href="#1-5-关闭Swap" class="headerlink" title="1.5 关闭Swap"></a>1.5 关闭Swap</h2><p>此操作必须执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>
<h2 id="1-6-修改hosts文件设置主机名"><a href="#1-6-修改hosts文件设置主机名" class="headerlink" title="1.6 修改hosts文件设置主机名"></a>1.6 修改hosts文件设置主机名</h2><p>在每个节点上操作，保证每个虚拟机主机名唯一。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加以下内容</span></span><br><span class="line">192.168.59.130 master.local</span><br><span class="line">192.168.59.131 node01.local</span><br><span class="line">192.168.59.132 node02.local</span><br></pre></td></tr></table></figure>
<p>在对应的节点上设置主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> master 节点</span></span><br><span class="line">hostnamectl set-hostname master.local </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node01</span></span><br><span class="line">hostnamectl set-hostname node01.local </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node02</span></span><br><span class="line">hostnamectl set-hostname node02.local </span><br></pre></td></tr></table></figure>
<h2 id="1-7-允许-iptables-检查桥接流量"><a href="#1-7-允许-iptables-检查桥接流量" class="headerlink" title="1.7 允许 iptables 检查桥接流量"></a>1.7 允许 iptables 检查桥接流量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<p>加载ip_vs内核模块</p>
<p>不清楚什么意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe ip_vs</span><br><span class="line">modprobe ip_vs_rr</span><br><span class="line">modprobe ip_vs_wrr</span><br><span class="line">modprobe ip_vs_sh</span><br><span class="line">modprobe nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>设置开机启动</p>
<p>不清楚什么意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/modules-load.d/ip_vs.conf &lt;&lt; EOF </span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack_ipv4</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h1 id="二、搭建方式"><a href="#二、搭建方式" class="headerlink" title="二、搭建方式"></a>二、搭建方式</h1><p>本次使用命令行方式安装，方面理解各个组件的作用。</p>
<h2 id="2-1-图形化操作"><a href="#2-1-图形化操作" class="headerlink" title="2.1 图形化操作"></a>2.1 图形化操作</h2><p>直接使用[Kuboard-Spray](<a href="https://github.com/eip-work/kuboard-spray">GitHub - eip-work/kuboard-spray: 使用图形化的界面离线安装、维护、升级高可用的 K8S 集群</a>)图形化工具进行搭建。</p>
<h2 id="2-2-命令行安装"><a href="#2-2-命令行安装" class="headerlink" title="2.2 命令行安装"></a>2.2 命令行安装</h2><p><strong>以下操作每个节点都需要执行</strong></p>
<h3 id="2-2-1-安装Docker"><a href="#2-2-1-安装Docker" class="headerlink" title="2.2.1 安装Docker"></a>2.2.1 安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>设置Docker 开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>修改Docker的源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 registry-mirrors 为如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;你的阿里云镜像加速地址&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新加载systemctl配置</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启Docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-配置kubernetes源"><a href="#2-2-2-配置kubernetes源" class="headerlink" title="2.2.2 配置kubernetes源"></a>2.2.2 配置kubernetes源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line"></span><br><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - </span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新apt-get</span></span><br><span class="line">sudo att-get upadte -y </span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-安装kubeadm、kubelet、kubectl"><a href="#2-2-3-安装kubeadm、kubelet、kubectl" class="headerlink" title="2.2.3 安装kubeadm、kubelet、kubectl"></a>2.2.3 安装kubeadm、kubelet、kubectl</h3><p>建议安装1.23.6 或以下版本的软件，安装最新版（1.24.+）会有问题，且下面安装kuboard 兼容性未在最新版（1.24.+）验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y kubelet=1.23.6-00  kubeadm=1.23.6-00 kubectl=1.23.6-00</span><br></pre></td></tr></table></figure>
<p>设置开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>
<p><strong>以下操作在master节点执行</strong></p>
<h3 id="2-2-4-master-节点初始化"><a href="#2-2-4-master-节点初始化" class="headerlink" title="2.2.4 master 节点初始化"></a>2.2.4 master 节点初始化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --kubernetes-version 1.23.6 \</span><br><span class="line">  --apiserver-advertise-address=192.168.59.130 \</span><br><span class="line">  --service-cidr=10.96.0.0/16 \</span><br><span class="line">  --pod-network-cidr=10.245.0.0/16 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubernetes-version 必须与下载的版本一致。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apiserver-advertise-address：API 服务器所公布的其正在监听的 IP 地址（本机内网地址）。如果未设置，则使用默认网络接口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> service-cidr：为服务的虚拟 IP 地址另外指定 IP 地址段， 默认值：10.96.0.0/12。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pod-network-cidr：指明 pod 网络可以使用的 IP 地址段，如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> image-repository：选择用于拉取控制平面镜像的容器仓库，  默认值：k8s.gcr.io。</span></span><br></pre></td></tr></table></figure>
<p>等待拉取镜像，出现以下字样代表master节点初始化成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a Pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  /docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p>记住 <code>kubeadm init</code> 输出的 <code>kubeadm join</code> 命令。 需要使用此命令将子节点加入集群。</p>
<h3 id="2-2-5-配置kubectl"><a href="#2-2-5-配置kubectl" class="headerlink" title="2.2.5 配置kubectl"></a>2.2.5 配置kubectl</h3><p>要使用非 root 用户可以运行 kubectl，请运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p> <code>root</code> 用户，则可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p>使用kubectl 查看节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p>目前是只能看到master节点，状态是NotReady，下面是子节点加入后的状态，且网络集群网络联通后的状态。</p>
<p><img src="https://tc.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png"></p>
<h3 id="2-2-6-子节点加入集群"><a href="#2-2-6-子节点加入集群" class="headerlink" title="2.2.6 子节点加入集群"></a>2.2.6 子节点加入集群</h3><p>使用上面初始化后的提示的指令， 分别在各个子节点上执行指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p>接下来在看看节点状态，下面是子节点加入后的状态，且网络集群网络联通后的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<img title src="https://tc.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png" alt data-align="inline">

<h3 id="2-2-7-安装flannel网络插件"><a href="#2-2-7-安装flannel网络插件" class="headerlink" title="2.2.7 安装flannel网络插件"></a>2.2.7 安装flannel网络插件</h3><p>下载插件，<a href="https://blog.csdn.net/weixin_44293949/article/details/121863559">解决raw.githubusercontent.com无法访问的问题</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>下载到本地后更改第128行，和上文中的 <code>pod-network-cidr</code> 一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;Network&quot;: &quot;10.245.0.0/16&quot;</span><br></pre></td></tr></table></figure>
<p>运行 yaml文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yaml</span><br></pre></td></tr></table></figure>
<p>查看flannel 结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get pods -o wide</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/f296cd5a0e3811ed90590242ac140002.png"></p>
<p>再次查看各个node的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/cc6c5fa20e3611ed90590242ac140002.png"></p>
<p>至此集群方式的Kubernetes 安装完成。</p>
<hr>
<h1 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h1><h2 id="问题一：出现-initial-timeout-of-40s-passed。"><a href="#问题一：出现-initial-timeout-of-40s-passed。" class="headerlink" title="问题一：出现 initial timeout of 40s passed。"></a>问题一：出现 initial timeout of 40s passed。</h2><p>在一开始部署的时候安装：kubelet、kubeadm、kubectl，没有指定版本，直接使用的最新版（1.24.+），在往上查了半天，找到一篇博客后（地址忘记了）提示说可能是由于版本的问题，然后在重新安装指定版本的kubelet、kubeadm、kubectl 工具，接下来一路畅通。</p>
<p>重新初始化是需要执行 <code>kubeadm reset</code> ，此命令是还原由 <code>kubeadm init</code> 或 <code>kubeadm join</code> 所做的更改。</p>
]]></content>
      <tags>
        <tag>Kubernets</tag>
      </tags>
  </entry>
  <entry>
    <title>Python三器一闭</title>
    <url>/2022/04/30/Python%E4%B8%89%E5%99%A8%E4%B8%80%E9%97%AD/</url>
    <content><![CDATA[<p>​                              </p>
<a id="more"></a>



<h1 id="1、迭代器"><a href="#1、迭代器" class="headerlink" title="1、迭代器"></a>1、迭代器</h1><h2 id="什么是迭代？"><a href="#什么是迭代？" class="headerlink" title="什么是迭代？"></a>什么是迭代？</h2><blockquote>
<p> 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。</p>
</blockquote>
<h2 id="什么是可迭代对象？"><a href="#什么是可迭代对象？" class="headerlink" title="什么是可迭代对象？"></a>什么是可迭代对象？</h2><p>Python中的可迭代对象并不是指某一种具体的数据类型，是指存储了若干个元的容器，且这这个容器中的元素可以通过<code>__iter()__</code> 和 <code>__getitem__()</code> 访问。</p>
<p>常用的可迭代对象有：<code>list</code>、<code>tuple</code>，<code>dict</code>，<code>str</code>，<code>set</code>、生成器和带有<code>yield</code>的生成器函数。</p>
<p>判断一个对象是否是可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>([], Iterable)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>


<p>获取可迭代对象的迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">print(<span class="built_in">type</span>(item))  <span class="comment"># &lt;class &#x27;range&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line">print(<span class="built_in">type</span>(iterator)) <span class="comment"># &lt;class &#x27;range_iterator&#x27;&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong><code>iter()</code> 内部做了什么？</strong></p>
<ul>
<li>检查对象内部是否实现了<code>__iter__()</code> 如果实现了， 则调用它，获取一个迭代器。</li>
<li>如果没有实现<code>__iter__()</code>方法，但是 实现了<code>__getitem__()</code>，python内部会实现一个迭代器。</li>
<li>如果 以上都失败，则会抛出异常：说明对象不可迭代。</li>
</ul>
<p><strong><code>for x in range(10): print(x) </code>循环执行了什么？</strong></p>
<p>获取可迭代对象的迭代器， 然后在调用<code>next()</code>方法获取下一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 获取迭代器</span></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line">item = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 获取迭代器</span></span><br><span class="line">iterator = <span class="built_in">iter</span>(item)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 0</span></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 1</span></span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 2</span></span><br><span class="line">...</span><br><span class="line">print(<span class="built_in">next</span>(iterator)) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p><strong>for 循环即先获取可迭代对象的迭代器，然后在调用<code>next()</code>方法，且在超过迭代对象的长度时，自动捕获错误：<code>StopIteration</code>。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>


<p><strong>如何自定义可迭代对象</strong>？</p>
<p>如上文那样，在一个对象中实现这个<code>__iter__()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterator)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>


<p>以上类MyList的对象 实现了<code>__iter__()</code>， 所以他是一个可迭代对象，且 <code>print(isinstance(my_list, Iterable))</code> 判断为True。但是 <code>print(isinstance(my_list, Iterator))</code> 为False</p>
<p><strong>如何实现一个迭代器呢</strong>？</p>
<p>如下面代码所示在可迭代对象中再实现<code>__next__()</code> 方法 即可让改对象成为一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.container = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.container.append(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list= MyList()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterable)) <span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(my_list, Iterator)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>


<p><strong>综上所述：</strong></p>
<p>对一个可迭代对象调用<code>iter()</code> 方法，其实内部就是寻找<code>__iter__()</code>，并调用，返回的对象当做迭代器。</p>
<p>对一个迭代器对象调用<code>next()</code> 方法，其实内部就是寻找<code>__next__()</code>，并调用，返回可迭代对象的下一个元素。</p>
<blockquote>
<p><strong>所以一个迭代器一定是个可迭代对象，但是可迭代对象并不一定是个迭代器。</strong></p>
</blockquote>
<h1 id="2、生成器"><a href="#2、生成器" class="headerlink" title="2、生成器"></a>2、生成器</h1><h2 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h2><p>在python 中通俗的理解：一边循环一边计算的机制成为生成器，生成器是一种特殊的迭代器。</p>
<h1 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h1><h1 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h1>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署MySQL8</title>
    <url>/2022/02/19/Docker%E9%83%A8%E7%BD%B2MySQL8/</url>
    <content><![CDATA[<p>​                         </p>
<a id="more"></a>



<p>使用Docker 安装MySQL8 用于测试开发使用。</p>
<h1 id="1、安装Docker"><a href="#1、安装Docker" class="headerlink" title="1、安装Docker"></a>1、安装Docker</h1><p>略</p>
<h1 id="2、直接运行命令"><a href="#2、直接运行命令" class="headerlink" title="2、直接运行命令"></a>2、直接运行命令</h1><p>后台启动MySQL，然后进入容器中设置MySQL用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name MYSQL8.0 -e MYSQL_ROOT_PASSWORD=123456  mysql:latest</span><br></pre></td></tr></table></figure>
<h1 id="3、设置MySQL远程连接以及密码"><a href="#3、设置MySQL远程连接以及密码" class="headerlink" title="3、设置MySQL远程连接以及密码"></a>3、设置MySQL远程连接以及密码</h1><h2 id="1、进入容器内部"><a href="#1、进入容器内部" class="headerlink" title="1、进入容器内部"></a>1、进入容器内部</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID/容器名 bash</span><br></pre></td></tr></table></figure>
<h2 id="2、登录MySQL"><a href="#2、登录MySQL" class="headerlink" title="2、登录MySQL"></a>2、登录MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>
<h2 id="3、-设置root用户名以及密码规则"><a href="#3、-设置root用户名以及密码规则" class="headerlink" title="3、 设置root用户名以及密码规则"></a>3、 设置root用户名以及密码规则</h2><p>设置密码不过期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39; password expire never;</span><br></pre></td></tr></table></figure>
<p>设置密码规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;123456&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="4、刷新权限"><a href="#4、刷新权限" class="headerlink" title="4、刷新权限"></a>4、刷新权限</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>使用Navicat连接 成功 OK！</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar</title>
    <url>/2022/02/13/Pulasr%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>Dcokerfile</title>
    <url>/2021/11/20/Dockerfile%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​            </p>
<a id="more"></a>



<blockquote>
<p>使用Dockerfile 能够构建一个自定义镜像。通常情况下是将自己的应用打包成镜像，在容器中使用。</p>
</blockquote>
<h2 id="Dockerfile-命令"><a href="#Dockerfile-命令" class="headerlink" title="Dockerfile 命令"></a>Dockerfile 命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>表示当前镜像是基于那个镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像的维护者和邮箱</td>
</tr>
<tr>
<td>RUN</td>
<td>构建镜像的时候需要运行的命令</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>容器内对外暴露的端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定创建容器后默认进入容器的工作目录</td>
</tr>
<tr>
<td>ENV</td>
<td>用来构建镜像过程中设置的环境变量 key=value</td>
</tr>
<tr>
<td>ADD</td>
<td>将宿主机下的文件拷贝到容器中，且会自动处理url和压缩包</td>
</tr>
<tr>
<td>COPY</td>
<td>类似于ADD，将从构建的Dockerfile目录中复制镜像的目录中</td>
</tr>
<tr>
<td>VOLUME</td>
<td>容器数据卷</td>
</tr>
<tr>
<td>CMD</td>
<td>制定一个容器运行的命令，如果有多个命令，只执行最后一个。会被docker run 后面的命令替代</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定一个容器启动时要运行的命令和参数，和CMD一样</td>
</tr>
</tbody></table>
<h3 id="1、FROM-命令语法"><a href="#1、FROM-命令语法" class="headerlink" title="1、FROM 命令语法"></a>1、FROM 命令语法</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;]   <span class="comment"># 设置镜像的版本，不写为最新版本  latest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、RUN-命令"><a href="#2、RUN-命令" class="headerlink" title="2、RUN 命令"></a>2、RUN 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RUN 后面直接写shell命令, RUN 的命令是在构建镜像中执行。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello word</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;yum&quot;</span>,<span class="string">&quot;install&quot;</span>,<span class="string">&quot;-y&quot;</span>,<span class="string">&quot;vim&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="3、EXPOSR-命令"><a href="#3、EXPOSR-命令" class="headerlink" title="3、EXPOSR 命令"></a>3、EXPOSR 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对一些需要端口的服务</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<h3 id="4、WORKDIR-命令"><a href="#4、WORKDIR-命令" class="headerlink" title="4、WORKDIR 命令"></a>4、WORKDIR 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来为Dockerfile中的任何 RUN/CMD/ENTRYPOINT/CPOY/ADD/ 指令设置工作目录，如果WORKDIR  不存在，即使他没有在后续得命令中被使用，也将会被创建。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/myserver</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /aaa</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> bb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR 可以使用多次，如果使用的是相对命令 ，会与上一次的路径相对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如上面的命令:docker会创建/opt/myserve，也会创建/aaa/bb，在进入容器内会进入最后的WORKDIR的路径下即：/aaa/bb</span></span><br></pre></td></tr></table></figure>
<h3 id="5、ADD-命令"><a href="#5、ADD-命令" class="headerlink" title="5、ADD 命令"></a>5、ADD 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来从Dockerfile的当前目录中复制文件，目录，或者下载URL,并将他们添加到位于容器内指定的文件中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> bb.txt /aaa/bb</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> https://tc.chaizz.com/497261de494511ec9d7c5254006b8f1d.png /aaa/bb</span></span><br><span class="line"><span class="comment"># 可以将文件复制到容器中，也可以通过URL下载文件到容器中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 apache-tomcat-8.5.73-src.tar.gz 解压到 /aaa/bb </span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-8.5.73-src.tar.gz /aaa/bb</span></span><br><span class="line"><span class="comment"># 将apache-tomcat-8.5.73-src 改名 为tomcat</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv apache-tomcat-8.5.73-src  tomcat</span></span><br><span class="line"><span class="comment"># 将工作目录改为 tomcat</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> tomcat</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6、COPY-命令"><a href="#6、COPY-命令" class="headerlink" title="6、COPY 命令"></a>6、COPY 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件复制到指定容器内部的目录</span></span><br><span class="line"><span class="comment"># COPY a.txt /aaa/bb</span></span><br></pre></td></tr></table></figure>


<h3 id="7、volume-目录"><a href="#7、volume-目录" class="headerlink" title="7、volume 目录"></a>7、volume 目录</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许在容器运行的时候将目录挂载到宿主机的目录上</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /aaa/bb/tomcat/webapps</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="8、ENV-命令"><a href="#8、ENV-命令" class="headerlink" title="8、ENV 命令"></a>8、ENV 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置当前容器的环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> BASE_DIR</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="9、ENTRYPOINT-命令"><a href="#9、ENTRYPOINT-命令" class="headerlink" title="9、ENTRYPOINT 命令"></a>9、ENTRYPOINT 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器运行的命令和参数  ENTRYPOINT的命令是在容器构建完成之后启动的时候执行,要覆盖ENTRYPOINT  他的指令 需要在docker run 的时候加上 --entrypoint ls </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> ls <span class="variable">$BASE_DIR</span>/tomcat</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;<span class="variable">$BASE_DIR</span>/tomcat&quot;</span>]</span></span><br></pre></td></tr></table></figure>


<h3 id="10、CMD-命令"><a href="#10、CMD-命令" class="headerlink" title="10、CMD 命令"></a>10、CMD 命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只执行最后一个，如果在 docker run 之后指定了命令(不需要参数) 会将CMD的指令覆盖，不再执行CMD的指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> ls <span class="variable">$BASR_DIR</span></span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;<span class="variable">$BASR_DIR</span>&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常 CMD 和 ENTRYPOINT 结合使用 ：ENTRYPOINT作为固定的命令或者参数， CMD 作为可变的参数，附加在ENTRYPOINT命令之后。 然后ENTRYPOINT + CMD 结合为一条命令。  即可实现在docker run 的时候可以指定参数运行同一个容器</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker、Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引问题</title>
    <url>/2021/11/18/MySQL%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>​                      </p>
<a id="more"></a>

<p>针对以上索引问题，首先要知道什么是主键索引、非主键索引、聚簇索引、非聚簇索引。</p>
<p>主键索引：即MySQL的索引，如果没有主键那么MySQl会自动在表中挑选一个唯一且非空的字段来当做主键索引，如果没有的话MySQL内部自己会创建一个ROW_ID来当做主键，也会建立主键索引。主键索引的叶子结点存储的是整行的数据。</p>
<p>非主键索引：即非主键以外的列建立的索引。非主键索引存储的是主键索引的值。</p>
<h3 id="什么是索引回表？"><a href="#什么是索引回表？" class="headerlink" title="什么是索引回表？"></a>什么是索引回表？</h3><p>索引回表指的就是在查询某一列数据是判断条件为非主键索引，name查到这条复合条件的所有记录就需要在根据非主键索引获得的主键索引的值，在取主键索引的B+树中在此查询一次才能获取到全部的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ID 是主键索引 ，只需要一次查询就可以获取符合条件的全部记录。</span><br><span class="line">select * from ex_table where ID&#x3D;1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># n 是非主键索引，查询到的结果是符合条件的主键索引的ID，所以还需要早根据主键的ID,再在主键索引的B+树上查询一次</span><br><span class="line">select * from ex_table where n &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>以上情况就是索引回表。</p>
<h3 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h3><p>如果执行的语句是 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select idfrom T where n between 1 and 10;</span><br></pre></td></tr></table></figure>
<p>现在的SQL只需要得到ID 的值，而 ID 的值已经在 n 索引的B+树上了，因此可以直接获得查询结果，不需要回表。也就是说，在这个查询里面，索引 n已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<h3 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h3><p>索引下推（index condition pushdown ）简称ICP，在MySQL5.6的版本上推出，用于优化查询，默认是开启的，可以通过以下的命令关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set optimizer_switch &#x3D; &#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>
<p>当使用索引下推时如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>索引下推的好处：</p>
<p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</strong></p>
<p>假如有以下MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 索引值为 name age 为组合索引。</span><br><span class="line"></span><br><span class="line">select * from user where name like &#39;张%&#39; and age &#x3D; 20;</span><br></pre></td></tr></table></figure>


<p>在关闭索引下推的时候，InnoDB引擎会根据只name找到复合条件的索引字段，如下图中的左边绿色，然后就将数据返回给MySQL服务器，由MySQL服务器去判断其他的符合条件的数据。MySQL服务器会拿着查到的ID：1、2  在进行回表查询。</p>
<p><img src="https://tc.chaizz.com/161026e0486011ec9d7c5254006b8f1d.png"></p>
<p>在使用索引下推的时候，InnoDB会直接找出符合索引条件的字段的ID，将符合条件的结果发送给MySQL服务器，这个过程只需要回表一次。如下图。</p>
<p><img src="https://tc.chaizz.com/a47dc42c486b11ec9d7c5254006b8f1d.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题汇总</title>
    <url>/2021/11/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<h1 id="一、基础试题"><a href="#一、基础试题" class="headerlink" title="一、基础试题"></a>一、基础试题</h1><h2 id="1、对字典d-39-a-39-24-39-b-39-53-39-d-39-56-39-h-39-7-按照字典中的value值排序。"><a href="#1、对字典d-39-a-39-24-39-b-39-53-39-d-39-56-39-h-39-7-按照字典中的value值排序。" class="headerlink" title="1、对字典d = {&#39;a&#39;: 24, &#39;b&#39;: 53, &#39;d&#39;: 56, &#39;h&#39;: 7} 按照字典中的value值排序。"></a>1、对字典<code>d = &#123;&#39;a&#39;: 24, &#39;b&#39;: 53, &#39;d&#39;: 56, &#39;h&#39;: 7&#125;</code> 按照字典中的value值排序。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照字典中的键排序：</span></span><br><span class="line"><span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照字典中的键排序：</span></span><br><span class="line"><span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在转化为字典 使用dict 函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、反转字符串-“aSter”"><a href="#2、反转字符串-“aSter”" class="headerlink" title="2、反转字符串 “aSter”"></a>2、反转字符串 “aSter”</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;aSter&#x27;</span>[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取头不取尾</span></span><br></pre></td></tr></table></figure>
<h2 id="3、按照list1-中的元素的由从大到小排序"><a href="#3、按照list1-中的元素的由从大到小排序" class="headerlink" title="3、按照list1 中的元素的由从大到小排序"></a>3、按照list1 中的元素的由从大到小排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">50</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(list1, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse=True  由大到小 sorted排序默认由小到大</span></span><br></pre></td></tr></table></figure>
<h2 id="4、常用的字符串格式化有哪些？"><a href="#4、常用的字符串格式化有哪些？" class="headerlink" title="4、常用的字符串格式化有哪些？"></a>4、常用的字符串格式化有哪些？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="comment"># 1.占位符 %s</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;%s，你好!&quot;</span> % name</span><br><span class="line"><span class="comment"># 2. format</span></span><br><span class="line">str2 = <span class="string">&quot;&#123;&#125;， 你好!&quot;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure>
<h2 id="5、下面代码的输出结果是什么-？"><a href="#5、下面代码的输出结果是什么-？" class="headerlink" title="5、下面代码的输出结果是什么 ？"></a>5、下面代码的输出结果是什么 ？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>] </span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>[<span class="number">10</span>:])   </span><br><span class="line"></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>输出结果是空 不会产生IndexError错误，尝试用超出成员个数的Index来获取某个列表的成员。</p>
<h2 id="6、写一个列表生成式产生一个等差为11的等差数列。"><a href="#6、写一个列表生成式产生一个等差为11的等差数列。" class="headerlink" title="6、写一个列表生成式产生一个等差为11的等差数列。"></a>6、写一个列表生成式产生一个等差为11的等差数列。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([x*<span class="number">11</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>
<h2 id="7、给定两个列表怎么找出他们相同的元素和不同的元素"><a href="#7、给定两个列表怎么找出他们相同的元素和不同的元素" class="headerlink" title="7、给定两个列表怎么找出他们相同的元素和不同的元素"></a>7、给定两个列表怎么找出他们相同的元素和不同的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list2 = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">set1 = <span class="built_in">set</span>(list1)</span><br><span class="line">set2 = <span class="built_in">set</span>(list2)</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line">print(set1 ^ set2)</span><br></pre></td></tr></table></figure>
<h2 id="8、python代码实现删除一个list的重复的元素"><a href="#8、python代码实现删除一个list的重复的元素" class="headerlink" title="8、python代码实现删除一个list的重复的元素"></a>8、python代码实现删除一个list的重复的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]</span><br><span class="line">print(<span class="built_in">set</span>(list1))</span><br></pre></td></tr></table></figure>
<h2 id="9、举字符串、列表、元祖、字典的五个常用的用法。"><a href="#9、举字符串、列表、元祖、字典的五个常用的用法。" class="headerlink" title="9、举字符串、列表、元祖、字典的五个常用的用法。"></a>9、举字符串、列表、元祖、字典的五个常用的用法。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串：replace、strip、split、reverse、upper、lower、join</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表：append、pop、insert、remove、count、index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元祖：index、count、len()、dir()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典：get、keys、values、popitems、clear、uodate、items</span></span><br></pre></td></tr></table></figure>


<h2 id="10、什么是反射-？-以及他的应用场景。"><a href="#10、什么是反射-？-以及他的应用场景。" class="headerlink" title="10、什么是反射 ？ 以及他的应用场景。"></a>10、什么是反射 ？ 以及他的应用场景。</h2><p>反射就是通过字符串的形式去对象中访问或操作这个未知的属性或变量，是一种基于字符串的事件驱动。</p>
<p>在面向对象中把对象能够访问、查询、修改自身的状态或者行为称之为反射。</p>
<p>在python中，可以通过字符串的的形式来操作对象的属性。这种行为称之为python中的反射。</p>
<p><strong>python</strong> <strong>实现反射的手段：</strong></p>
<p>是通过四个内置函数来实现：<strong>hasattr(object,name)</strong> <strong>getattr(object,name,default=None) setattr(x,y,v) delattr(x,y)</strong></p>
<p>判断对象中是否有这个方法或变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;%s正在交谈&quot;</span>%self.name)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person(<span class="string">&quot;laowang&quot;</span>)    </span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;talk&quot;</span>))  <span class="comment"># True。因为存在talk方法</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;name&quot;</span>))  <span class="comment"># True。因为存在name变量</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;abc&quot;</span>))   <span class="comment"># False。因为不存在abc方法或变量</span></span><br></pre></td></tr></table></figure>


<p><strong>反射的好处 ：</strong></p>
<p>实现可插拔机制、动态导入模块（基于反射原理，获取当前的模块的成员）</p>
<h2 id="11、简述Python的深浅拷贝-，详细见链接。"><a href="#11、简述Python的深浅拷贝-，详细见链接。" class="headerlink" title="11、简述Python的深浅拷贝 ，详细见链接。"></a>11、简述Python的深浅拷贝 ，详细见<a href="https://zhuanlan.zhihu.com/p/54011712">链接</a>。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy() ： 浅拷贝，仅仅拷贝数据集合的第一层</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deepcopy() : 深拷贝，拷贝数据集合的所有层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="number">1</span>:<span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====赋值=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=a</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====浅拷贝=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=copy.copy(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====深拷贝=====&quot;</span>)</span><br><span class="line"></span><br><span class="line">b=copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"></span><br><span class="line">=====赋值=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line">=====浅拷贝=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919592320</span></span><br><span class="line"></span><br><span class="line">=====深拷贝=====</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"></span><br><span class="line"><span class="number">2145919532928</span></span><br></pre></td></tr></table></figure>
<h2 id="12、Python的垃圾回收机制。网页地址"><a href="#12、Python的垃圾回收机制。网页地址" class="headerlink" title="12、Python的垃圾回收机制。网页地址"></a>12、Python的垃圾回收机制。<a href="https://zhuanlan.zhihu.com/p/83251959">网页地址</a></h2><ol>
<li><strong>引用计数</strong></li>
</ol>
<p>在python中每一个对象的的核心就是一个结构体PyObject，他的内部有一个引用计数器（（ob_refcnt）），程序在运行的过程中他会实时的更新 引用计数器（ob_refcnt）的值，来反映当前对象的名称数量，当某个对象的引用计数为零的时候，那么他的内存就会被释放掉。</p>
<p>导致引用计数加一的情况有 ：对象被创建、对象被引用、对象被作为参数传入一个函数中、对象存储在容器中。</p>
<p>导致引用计数减一的情况有：对象别名被显示销毁 del、对象别名被赋予新的对象、一个对象离开他的作用域、对象所在的容器被销毁或者是从容器中删除对象 。</p>
<p>我们可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数（注意，这里getrefcount()本身会使得引用计数加一）。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<p><strong>引用计数的优点</strong>：</p>
<p>高效、实现逻辑简单、具备实时性，一旦一个对象的引用计数归零，内存就直接释放了。</p>
<p><strong>引用计数的缺点：</strong></p>
<p>逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。</p>
<p>可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。</p>
<p>循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。</p>
<ol start="2">
<li><strong>标记-清除</strong></li>
</ol>
<p>它是解决容器对象（(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)）可能产生的循环引用的问题。不改动真实的而引用计数，而是将引用计数复制一份副本，改动该对象引用的副本，对于副本做得任何改动都不影响生命对象整体的维护。</p>
<p><strong>标记清除的步骤：</strong></p>
<p>标记阶段：GC会把所有活动对象打上标记，这些活动对象就像是一个点，他们之间使用引用关系来连接，最终每个点和边构成了一个有向图。</p>
<p><img src="https://tc.chaizz.com/8d3dc5ea460a11ec9d7c5254006b8f1d.png"></p>
<p>GC从跟对象触发遍历所整个图，如果该对象是可达的（reachable）也就是说还有对象在引用他，那么就标记该对象可达。如上图中从根对象开始遍历1、2、3、4是可达的，5、6、7是不可达的。（整个根对象就是全局对象，调用栈，寄存器）</p>
<p>清除阶段：遍历的对象不可达，就将其回收。通过分代回收来加速清理对象。</p>
<ol start="3">
<li><strong>分代回收</strong></li>
</ol>
<p>在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过**“分代回收”(Generational Collection)**以空间换时间的方法提高垃圾回收效率。</p>
<p>分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</p>
<p>分代回收 根据内存中对象的存活时间将他们分为三代，新生的对象放入0代，如果一个对象能在0代的垃圾回收机制中存活下来，GC就会将它放入1代中，如果1代的对象在1代的垃圾 回收过程中存货下来，则会进入二代。</p>
<p>分代回收的触发机制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果是一个元祖：(700, 10, 10)</p>
<ul>
<li>当分配对象分个数减去释放对象的个数差值大于700时，就会产生一次0代回收。</li>
<li>10次0代回收后进行一次1代回收。</li>
<li>10次1代回收后进行一次2代回收。</li>
</ul>
<p>对于0代的对象他们有可能只会被使用一次，所以需要被经常回收。经过一轮回收之后他们是那些使用比较频繁的对象，而且他们已经存活了很久的时间，大概率还会存活更久，因此二代的会后就不会那么频繁。</p>
<p>可以通过(700, 10, 10) 这三个值进行更改分代回收触发的条件。</p>
<p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
<h2 id="13、如何打乱一个排好序的lisit对象"><a href="#13、如何打乱一个排好序的lisit对象" class="headerlink" title="13、如何打乱一个排好序的lisit对象"></a>13、如何打乱一个排好序的lisit对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">random.shuffle(alist)</span><br><span class="line"></span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h2 id="14、从0-99这100个数中随即取出十个数字-要求不能重复。"><a href="#14、从0-99这100个数中随即取出十个数字-要求不能重复。" class="headerlink" title="14、从0-99这100个数中随即取出十个数字 要求不能重复。"></a>14、从0-99这100个数中随即取出十个数字 要求不能重复。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(random.sample(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">99</span>),k=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>


<h2 id="15、Python如何捕获异常、处理异常-、抛出异常"><a href="#15、Python如何捕获异常、处理异常-、抛出异常" class="headerlink" title="15、Python如何捕获异常、处理异常 、抛出异常"></a>15、Python如何捕获异常、处理异常 、抛出异常</h2><p>捕获异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>处理异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> </span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#else:不发生异常执行的语句</span></span><br><span class="line"><span class="comment">#finally：无论是否发生异常都执行的语句</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># raise Exception  抛出异常</span></span><br></pre></td></tr></table></figure>
<h2 id="16、python递归的大层数"><a href="#16、python递归的大层数" class="headerlink" title="16、python递归的大层数"></a>16、python递归的大层数</h2><p>最大递归为998</p>
<p>修改最大递归值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h2 id="17、列表推导式和生成器表达式-i-2-for-i-in-range-10-和-i-2-for-i-in-range-10-输出的结果分别是什么？"><a href="#17、列表推导式和生成器表达式-i-2-for-i-in-range-10-和-i-2-for-i-in-range-10-输出的结果分别是什么？" class="headerlink" title="17、列表推导式和生成器表达式[i % 2 for i in range(10)] 和 (i % 2 for i in range(10)) 输出的结果分别是什么？"></a>17、列表推导式和生成器表达式<code>[i % 2 for i in range(10)] </code>和 <code>(i % 2 for i in range(10)) </code>输出的结果分别是什么？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print((i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000002AD4E8F09E0</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="18-什么是闭包？"><a href="#18-什么是闭包？" class="headerlink" title="18. 什么是闭包？"></a>18. 什么是闭包？</h2><p>指的是定义在一个函数内部的函数 ，被外层函数包裹着。其特点是可以访问到外层函数的名字。 闭包有两种不同的方式，第一种是在函数内部就直接调用了；第二种是返回一个函数名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种形式 在外层函数中直接调用内层函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mark</span>(<span class="params">name</span>):</span></span><br><span class="line">  num = <span class="number">100</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">weight</span>):</span></span><br><span class="line">​    weight += <span class="number">1</span></span><br><span class="line">​    print(name, weight)</span><br><span class="line">  func(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">mark(<span class="string">&#x27;塞拉斯&#x27;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二种形式:在外层函数中返回内层函数对象    （也就是装饰器）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span>(<span class="params">name</span>):</span></span><br><span class="line">  num = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">height</span>):</span></span><br><span class="line">    height += <span class="number">1</span></span><br><span class="line">    print(name, num, height)</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">a = maker(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">a(<span class="number">999</span>)</span><br></pre></td></tr></table></figure>


<p> “闭包”的作用——保存函数的状态信息，使函数的局部变量信息依然可以保存下来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Maker</span>(<span class="params">step</span>):</span> <span class="comment"># 包装器</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span> <span class="comment"># 内部函数</span></span><br><span class="line">        <span class="comment"># nonlocal关键字的作用和前面的local是一样的，如果不使用该关键字，则不能在中内部函数改变“外部变量”的值</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        <span class="comment"># 改变外部变量的值（如果只是访问外部变量，则不需要适用nonlocal）</span></span><br><span class="line">        num = num + step</span><br><span class="line">        print(num)</span><br><span class="line">    <span class="keyword">return</span> fun1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="comment"># 调用外部包装器</span></span><br><span class="line">func2 = Maker(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 调用内部函数4次 输出的结果是 4、7、10、13</span></span><br><span class="line">    func2() </span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p> 这就是“闭包”的最大的作用——保存局部信息不被销毁。</p>
</blockquote>
<h2 id="19、字典推导式"><a href="#19、字典推导式" class="headerlink" title="19、字典推导式"></a>19、字典推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">d = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(a, b)&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20、python2和python3的差别"><a href="#20、python2和python3的差别" class="headerlink" title="20、python2和python3的差别"></a>20、python2和python3的差别</h2><p>新增的库 asyncio 内置库 asybs/await 原生协程支持异步编程。</p>
<p>Enum(枚举) mock、asyncio、ipaddress</p>
<p>print表达式 改为了方法 print（）</p>
<p>raw_input （） 改为input （）</p>
<p>Python3中的Str类型代表Unicode字符串，Python2中的Str类型代表bytes字节序列。</p>
<p>Python3中的 / 返回浮点数，Python2中根据结果而定，能被整除返回整数，否则返回浮点数</p>
<h2 id="21、文件操作-xreadlines-和Readlines-的区别"><a href="#21、文件操作-xreadlines-和Readlines-的区别" class="headerlink" title="21、文件操作 xreadlines 和Readlines 的区别"></a>21、文件操作 xreadlines 和Readlines 的区别</h2><p>readlines（）是把文件全部读取到内存，并解析成一个list ,当文件体积过大时要占用很多内存。</p>
<p>xreadlines（） 则是返回一个iter() file 迭代器，在python2.3之后，已经不推荐这样使用了，而是直接for循环迭代文件对象。</p>
<p>最好的方式是使用 with open as f，对可迭代对象 f，进行迭代遍历：for line in f，会自动地使用缓冲IO（buffered IO）以及内存管理，而不必担心任何大文件的问题。</p>
<h2 id="22、列举布尔值为False-的常见的值？"><a href="#22、列举布尔值为False-的常见的值？" class="headerlink" title="22、列举布尔值为False 的常见的值？"></a>22、列举布尔值为False 的常见的值？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>、[]、（）、&#123;&#125;、””、<span class="literal">False</span>、 <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<h2 id="23、匿名函数lambda-的用法。"><a href="#23、匿名函数lambda-的用法。" class="headerlink" title="23、匿名函数lambda 的用法。"></a>23、匿名函数lambda 的用法。</h2><p>Lambda 作为一个表达式，定义了一个匿名函数。如果使用lambda，lambda内不要包含循环 。lambda 是为了减少单行函数的定义而存在的。</p>
<h2 id="24、Python类中init-（self）-和-new-cls-的区别："><a href="#24、Python类中init-（self）-和-new-cls-的区别：" class="headerlink" title="24、Python类中init__（self） 和 __new(cls)的区别："></a>24、Python类中<strong>init__（self） 和 __new</strong>(cls)的区别：</h2><p><strong>init</strong>(self) ：负责初始化<strong>new</strong>(cls)创建的对象，是一个对象方法。接受self参数，以及其他初始化的参数 </p>
<p><strong>new</strong>(cls) ：创建<strong>init</strong>(self)初始化的对象。是一个类方法。在调用<strong>new</strong>(cls)之前连对象都没有。只接受一个参数 cls，必须要有返回值，返回实例化的对象。</p>
<h2 id="25、列出5个python标准库"><a href="#25、列出5个python标准库" class="headerlink" title="25、列出5个python标准库"></a>25、列出5个python标准库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准库：sys、os、re、urllib、logging、datetime、random、threading、multiprocessing、base64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三方库：requests、Scrapy、gevent、pygame、pymysql、pymongo、redis-py、Django、Flask、Werkzeug、celery、IPython、pillow</span></span><br></pre></td></tr></table></figure>
<h2 id="26、python中生成随机整数、随机小数、0–1之间小数方法"><a href="#26、python中生成随机整数、随机小数、0–1之间小数方法" class="headerlink" title="26、python中生成随机整数、随机小数、0–1之间小数方法"></a>26、python中生成随机整数、随机小数、0–1之间小数方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机整数</span></span><br><span class="line">print(random.randint(<span class="number">0</span>, <span class="number">99999</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机小数</span></span><br><span class="line">print(np.random.randn())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机 0-1 小数</span></span><br><span class="line">print(random.random())</span><br></pre></td></tr></table></figure>


<h1 id="二、-数据库"><a href="#二、-数据库" class="headerlink" title="二、     数据库"></a>二、     数据库</h1><h2 id="1、什么是事务"><a href="#1、什么是事务" class="headerlink" title="1、什么是事务"></a>1、什么是事务</h2><p><strong>事务</strong>是数据库并发控制的基本单位。相当于对一系列sql语句的集合，事务要么全部执行成功，要么全部失败。</p>
<p>事务的四个特性 ：ACID </p>
<p>A（atomicity）：原子性：一个事务的操作要么全部完成要么全部失败。</p>
<p>C（consistency）：一致性：事务开始前后数据保持完整性没有被破坏。</p>
<p>I（isolation）：隔离性：允许多个事务同时对数据库进行读写和修改。</p>
<p>D（durability）：持久性：事务结束之后，修改是永久的。</p>
<p><strong>事务的并发控制可能产生的问题</strong>：</p>
<p>幻读：一个事务进行第二次查出现第一次没有的结果。</p>
<p>非重复读：一个事务读取两次读到两个不同的结果。</p>
<p>脏读：一个事务读取到另一个事物没有提交的修改。</p>
<p>丢失修改：并发写入导致其中的一些修改丢失。</p>
<p><strong>为了解决并发控制异常，定义了四种事务的隔离级别：</strong></p>
<p>读未提交：别的事务可以读到未提交的改变。</p>
<p>读已提交：只能读到已提交的数据。</p>
<p>可重复读：同一个事务先后读取结果一样。</p>
<p>串行化：事务完全串行化的执行，隔离级别最高，执行效率最低。</p>
<p><strong>解决高并发情况下的插入重复：</strong></p>
<p>   使用数据库的唯一索引。</p>
<p>   使用队列的异步写入。</p>
<p>   使用redis实现分布式锁。</p>
<h2 id="2、Mysql的数据类型："><a href="#2、Mysql的数据类型：" class="headerlink" title="2、Mysql的数据类型："></a>2、Mysql的数据类型：</h2><p>-   Char : 存储定长的字符串。</p>
<p>-   Varchar：存储定长的字符串。</p>
<p>-   Text ：存储文本比较长的类型</p>
<p>-   Tinyint：一个字节，-127 到 255</p>
<p>-   Int：四个字节 （）</p>
<p>-   Datetime：8个字节</p>
<p>-   Timestamp ：四个字节 只能存储到从1970到2038年</p>
<h2 id="3、MYSql-的两个常用的引擎"><a href="#3、MYSql-的两个常用的引擎" class="headerlink" title="3、MYSql 的两个常用的引擎"></a>3、MYSql 的两个常用的引擎</h2><p>Innodb :支持事务，支持外键、支持行锁、支持表锁。不支持全文索引。</p>
<p>Myisam: 不支持事务，不支持外键、只支持表锁 支持全文索引。</p>
<h2 id="4、Mysql-索引的原理以及优化常见的问题"><a href="#4、Mysql-索引的原理以及优化常见的问题" class="headerlink" title="4、Mysql 索引的原理以及优化常见的问题"></a>4、Mysql 索引的原理以及优化常见的问题</h2><p><strong>索引的类型 ：</strong></p>
<p>普通索引 create index</p>
<p>唯一索引 create unique index</p>
<p>多列索引</p>
<p>主键索引 只有一个，全文索引 （innodb 不支持）</p>
<p><strong>那些情况下用索引：</strong></p>
<p>经常用查询需条件的字段去创建索引 （where条件）</p>
<p>经常用坐标链接的字段</p>
<p>经常用在order by group by 后面的字段</p>
<p><strong>创建索引有哪些需要注意的：</strong></p>
<p>不能非空字段上创建索引，</p>
<p>不要在很多字段相同的字段上创建索引</p>
<p>索引的长度不要太长</p>
<p><strong>索引失效的情况：</strong></p>
<ul>
<li><p>对于多列索引，不是使用的第一部分，则不会使用索引（最左匹配原则）</p>
</li>
<li><p>% Like 语句 以%开头索引失效。</p>
</li>
<li><p>如果列类型是字  符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。（隐式转换）</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。</p>
</li>
<li><p> 查询条件使用函数在索引列上，或者 对索引列进行运算， 运算包括(+，-，*，/，! 等) </p>
</li>
<li><p>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。</p>
</li>
</ul>
<p><strong>什么是聚集索引 和非聚集索引：</strong></p>
<p>非聚集索引：数据和索引单独存储。myisam ：使用的是非聚集索引。Innodb 主键索引是聚集索引</p>
<p><strong>如何排查慢查询：</strong></p>
<p>开启慢查询日志 slow_query_log_file</p>
<p>通过 explain 排序索引问题。</p>
<p>调整数据修改索引，是不是有隐式转换。</p>
<h2 id="5、SQL语句的编写问题"><a href="#5、SQL语句的编写问题" class="headerlink" title="5、SQL语句的编写问题"></a>5、SQL语句的编写问题</h2><p><strong>内连接：</strong>（Inner join）将左表和右表关联起来的数据进行返回。类似于求两个表的交集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a inner join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p><strong>外链接：</strong></p>
<p>左连接：返回左表中的所有数据，即使右表没有匹配的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a left join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p>右链接 ：返回右表中的所有数据，即使左表没有匹配的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select * from a right join b on a.id &#x3D; b.id</span><br></pre></td></tr></table></figure>
<p>没有匹配的字段都会自动设置为null。</p>
<h2 id="6、MySQL为什么使用B-树数据结构而不用B树，B-树相对于B树有什么优点"><a href="#6、MySQL为什么使用B-树数据结构而不用B树，B-树相对于B树有什么优点" class="headerlink" title="6、MySQL为什么使用B+树数据结构而不用B树，B+树相对于B树有什么优点"></a>6、MySQL为什么使用B+树数据结构而不用B树，B+树相对于B树有什么优点</h2><p>是因为B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，B+树只要遍历叶子节点就可以实现整棵树的遍历。B+树比B树多了一个双向链表，在进行范围查找的时候有更快的效率，且B+树在叶子节点冗余了上面的根节点。</p>
<h2 id="7、MySQL事务的特性以及隔离级别"><a href="#7、MySQL事务的特性以及隔离级别" class="headerlink" title="7、MySQL事务的特性以及隔离级别"></a>7、MySQL事务的特性以及隔离级别</h2><p><strong>事务的四大特性：</strong></p>
<p>原子性（atomicity）：事务的操作要么全部成功要么全部失败，是通过MySQL的undo log 来实现的。</p>
<p>一致性（consistency）：事务开始和结束之后不会对数据破坏，数据是符合预期的。原子性、隔离性、持久性共同实现一致性。</p>
<p>隔离性（isolation）：数据库允许多个事务对数据进行操作，隔离性可以放置数据库并发操作而导致数据的不一致问题。是通过LBCC+MVCC实现的。</p>
<p>持久性（durability）：事务结束之后对数据的改变是永久的，不会因为外界的干扰而导致数据更改。在数据库中是由redo Log 来实现的。</p>
<p><strong>事务的隔离级别：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv8YPTrg9lpFjt5WmnTicwibMqF5XDaZXJcrF9rCDmNxLp5z0gbHPzT11eQ5EyRtYBVdtkOVRQ5WABw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<h2 id="8、MySQL什么情况下会发生死锁，如何解决死锁"><a href="#8、MySQL什么情况下会发生死锁，如何解决死锁" class="headerlink" title="8、MySQL什么情况下会发生死锁，如何解决死锁"></a>8、MySQL什么情况下会发生死锁，如何解决死锁</h2><p><strong>什么是死锁：</strong>多个事务因竞争锁而造成的一种相互等待的僵局。</p>
<p><strong>出现死锁的情况：</strong></p>
<h2 id="9、简述乐观锁和悲观锁的区别以及使用场景"><a href="#9、简述乐观锁和悲观锁的区别以及使用场景" class="headerlink" title="9、简述乐观锁和悲观锁的区别以及使用场景"></a>9、简述乐观锁和悲观锁的区别以及使用场景</h2><p><strong>乐观锁：</strong>每次获取数据的时候，不会担心数据被修改，所以每次获取数据的时候不会对数据加锁，但是在更新数据的时候会判断数据是否被修改过，如果数据被修改过，则不进行数据更新，如果没有被修改过，则进行数据更新。由于数据没有加锁，所以这期间数据有可能被其他线程进行读写操作。</p>
<p><strong>悲观锁：</strong>每次获取数据的时候都会担心数据被修改，所以每次获取数据的时候都会加锁，确保自己在使用的过程中，数据不会被修改，使用完成后释放锁，由于数据被加锁所以其他的线程多数据进行修改需要进行等待。</p>
<p><strong>使用场景：</strong></p>
<p>悲观锁：比较适合写入的操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会加锁，这样会增加大量的开销，降低系统的吞吐量。</p>
<p>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写操作，数据发生冲突的可能性就会增加，为了保证数据的一致性，底层就会不断的重新获取数据，会增加大量的查询操作，降低了性能。</p>
<h2 id="10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引"><a href="#10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引" class="headerlink" title="10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引"></a>10、聚簇索引和非聚簇索引的区别，什么情况下使用聚簇索引</h2><p><strong>聚簇索引：</strong>将数据和索引存放到一起，找到索引就找到数据了。innodb引擎使用聚簇索引。</p>
<p><strong>非聚簇索引：</strong>将数据和索引分开存放，索引结构的叶子结点存储的是数据的对应地址的指针，Myisam通过key-buffer把索引先缓存到内存中，当需要访问数据时候，在内存中直接搜索索引，然后通过素银找到对应的数据，这也就是索引不在key-buffer命中时，速度慢的原因。</p>
<h2 id="11、脏读和幻读产生的场景，InnoDB是如何解决幻读的"><a href="#11、脏读和幻读产生的场景，InnoDB是如何解决幻读的" class="headerlink" title="11、脏读和幻读产生的场景，InnoDB是如何解决幻读的"></a>11、脏读和幻读产生的场景，InnoDB是如何解决幻读的</h2><p><strong>脏读：</strong>一个事务在前后两次查询过程中得到的结果不一致由因为读取到另一个事务<strong>未提交</strong>的数据叫产生了脏读。它在事务隔离级别为：读未提交的情况下产生。</p>
<p><strong>幻读：</strong>在一个事务中前后两次查询读取到了不一样的结果数，是由于读取到其他的事务已经提交的新的数据。这种情况产生的叫做幻读，读未提交，读已提交这两种事务隔离级别下都会产生。</p>
<p><strong>解决幻读：</strong></p>
<p>是通过间隙锁+锁住本身的数据（next-key），间隙锁锁住一段范围，所以其他事务无法对这段范围的数据进行插入删除等操作，所以就不存在幻读的问题。</p>
<br> 

<p>如果事务隔离级别是 Read Commit ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。</p>
<p>如果事务的隔离级别是可重读，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.</p>
<h2 id="12、MySQL的主从复制的原理"><a href="#12、MySQL的主从复制的原理" class="headerlink" title="12、MySQL的主从复制的原理"></a>12、MySQL的主从复制的原理</h2><p>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点，如下图所示:</p>
<p><img src="https://tc.chaizz.com/69080f8a407611ec9d7c5254006b8f1d.jpeg"></p>
<ul>
<li>从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li>
<li>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</li>
<li>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</li>
</ul>
<h2 id="13、主从复制延迟产生的原因，以及如何解决？"><a href="#13、主从复制延迟产生的原因，以及如何解决？" class="headerlink" title="13、主从复制延迟产生的原因，以及如何解决？"></a>13、主从复制延迟产生的原因，以及如何解决？</h2><p>产生延迟的原因：</p>
<ul>
<li>主从机器性能差异</li>
<li>主机器有大量的写操作，从机器有大量的读操作，从而影响从机器复制的性能。</li>
<li>大事务的执行，本身事物执行消耗了大量时间</li>
</ul>
<h2 id="14、缓存的适用场景？为什么使用缓存？"><a href="#14、缓存的适用场景？为什么使用缓存？" class="headerlink" title="14、缓存的适用场景？为什么使用缓存？"></a>14、缓存的适用场景？为什么使用缓存？</h2><p>-   缓解关系数据库的并发压力，</p>
<p>-   减少响应的时间</p>
<p>-   提升吞吐量</p>
<h2 id="15、Redis-和memcached-的区别："><a href="#15、Redis-和memcached-的区别：" class="headerlink" title="15、Redis 和memcached 的区别："></a>15、Redis 和memcached 的区别：</h2><p><strong>Redis 支持的数据类型：</strong></p>
<p>-   String ： 实现简单的KV键值对存储，计数器</p>
<p>-   List ： 双向链表，实现队列， 用户的的关注或者粉丝表表</p>
<p>-   Hash ： 用来存储彼此相关信息的键值对。</p>
<p>-   Set：存储不重复的元素，例如用户的关注着。</p>
<p>-   Sort set ：有序集合，存储实时信息排行榜</p>
<h2 id="16、Redis实现持久化的方式："><a href="#16、Redis实现持久化的方式：" class="headerlink" title="16、Redis实现持久化的方式："></a>16、<strong>Redis实现持久化的方式：</strong></h2><p>-   快照的方式， 把数据快照放在磁盘二进制文件中，dump.rdb （Redis默认开启）</p>
<p>-   AOF：每写一个命令追加到appendonly.aof 中。</p>
<p>-   修改redis 配置中实现</p>
<h2 id="17、Redis如何实现分布式锁"><a href="#17、Redis如何实现分布式锁" class="headerlink" title="17、Redis如何实现分布式锁"></a>17、<strong>Redis如何实现分布式锁</strong></h2><p>使用setnx 实现加锁，可以同时通过expire 添加超时时间。del删除锁，getset key value 先get在set 先返回key对应的值，如果没有就返回空，然后在将key设置为value。</p>
<ul>
<li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</li>
</ul>
<h2 id="18、缓存的使用模式："><a href="#18、缓存的使用模式：" class="headerlink" title="18、缓存的使用模式："></a>18、<strong>缓存的使用模式：</strong></h2><p>常用的有三种，</p>
<p>cache aside 同时更新缓存和数据库。（数据一致性的问题：解决，都是写入数据库，删除缓存。在更新缓存）Read/write through 先更新缓存。缓存负责同步的更新数据库。</p>
<p>write behind caching 先更新缓存，缓存定期异步更新数据库。</p>
<h2 id="19、如何缓解缓存穿透的问题："><a href="#19、如何缓解缓存穿透的问题：" class="headerlink" title="19、如何缓解缓存穿透的问题："></a>19、<strong>如何缓解缓存穿透的问题：</strong></h2><p><strong>产生的原因一：由于大量的请求查询缓存，查不到就回去数据库去取。数据库也查不到数据。（多数是由于非法攻击）</strong></p>
<p>解决：</p>
<ul>
<li><p>对参数进行合法性校验。</p>
</li>
<li><p>将查不到的数据返回一个none，把none缓存下来，有新的数据插入，在把none 删除，或者设置较短的缓存时间。</p>
</li>
<li><p>使用布隆过滤器</p>
</li>
</ul>
<h3 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个位数组（bitarray），开始所有数据全部置0，当一个元素讲过多个hash函数计算不同的哈希值，并通过哈希值找到对应的bitarray，将值改为1。<strong>（需要说明，布隆过滤器存在误判的可能）数组越长误判率越低，占用的空间也越大。）</strong></p>
<p><img src="https://tc.chaizz.com/128523c846b111ec9d7c5254006b8f1d.png"></p>
<p>以上是一个空的布隆过滤器，现在要插入这个A字段，经过三个hash函数计算得到了2、5、7 所以将将布隆过滤器的相对应的值设置为1。</p>
<p><img src="https://tc.chaizz.com/4c40b08646b211ec9d7c5254006b8f1d.png"></p>
<p>接下来继续插入B字段，计算出来的值为2、4、8，继续往布隆过滤器对相应的位置上设置为1，注意A和B同时hash计算出来的值一致。所以导致了布隆过滤器不能确保某个元素一定存在。</p>
<p><img src="https://tc.chaizz.com/9600ff0a46b211ec9d7c5254006b8f1d.png"></p>
<p>布隆过滤器的查询也很简单，例如我们要找一个字段C，只需要计算出他的hash值，如果该值为2、3、4，那么因为布隆过滤器对应bit位上的数据有一个不为1，所以就断定C不存在，但是如果他计算的值为1、4、8，name就不能确定他一定存在。</p>
<p>因此随着添加的值越来越多，bit位的占用也就就越多，布隆过滤器的误判性也就会越来越高。如果bit位都为1的话，那就是所有的数据都存在 ，这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p>
<h3 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h3><ul>
<li>网页爬虫对URL的去重，避免爬取相同的URL地址</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li>
<li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回，避免缓存及DB挂掉。</li>
<li>黑名单过滤。</li>
</ul>
<h2 id="20、如何缓解缓存击穿的问题"><a href="#20、如何缓解缓存击穿的问题" class="headerlink" title="20、如何缓解缓存击穿的问题"></a>20、如何缓解缓存击穿的问题</h2><p><strong>产生原因一：缓存中没有，数据库中有。</strong>一般是多是出现在数据初始化，以及key过期的情况。他的问题在于重新写入缓存需要一定的时间，如果是在高并发的情况下，过多的请求会打到DB上，给DB造成很大的压力。</p>
<p>解决方案：</p>
<ul>
<li>设置热点的缓存永不过期。要注意永不过期数据一致性会有问题。所以要给value设置一个逻辑过期时间，然后后台再开一个线程，扫描这些key，定期刷新。</li>
</ul>
<p><strong>产生原因二：某些非常热点的数据key 过期，大量的请求打到后端 。</strong></p>
<p>解决：</p>
<ul>
<li><p>分布式锁的线程，从数据库拉数据（允许少数的线程取访问数据库并产生缓存），然后其他的线程等待。</p>
</li>
<li><p>后台任务针对过期的key 自动刷新。（设置随机的过期时间）</p>
</li>
</ul>
<h2 id="21、如何缓解缓存雪崩的问题。"><a href="#21、如何缓解缓存雪崩的问题。" class="headerlink" title="21、如何缓解缓存雪崩的问题。"></a>21、<strong>如何缓解缓存雪崩的问题。</strong></h2><p><strong>产生原因：大量的请求，或者大量的缓存key同时失效，大量的请求同时请求到数据库。</strong></p>
<p>解决：</p>
<ul>
<li><p>多级缓存，不同级别的key设置不同的超时时间。</p>
</li>
<li><p>随机超时，key的超时时间随机设置，防止同时超时</p>
</li>
<li><p>在架构层解决，提升系统可用性，监控，报警完善。</p>
</li>
</ul>
<h2 id="22、如何保证Redis与数据库一致性"><a href="#22、如何保证Redis与数据库一致性" class="headerlink" title="22、如何保证Redis与数据库一致性"></a>22、如何保证Redis与数据库一致性</h2><p>当我们对数据修改的时候，实现删除缓存还是先写入数据库。</p>
<p><strong>操作方式一：先删除缓存，在写数据</strong>。</p>
<p><strong>产生的问题：</strong>在高并发场景下，当第一个线程删除了缓存，还没有来得及写入数据库，第二个线程读取数据时会发现缓存为空，那么就会读取数据库的旧数据，读完之后又会将读取到的结果写入缓存，这样缓存中数据就是脏数据。</p>
<p><strong>解决：</strong> <strong>先操作缓存，但是不删除缓存，将缓存修改为一个特殊值，当客户端读取到这个特殊值时，休眠一会再去查Redis。</strong>（需要注意的问题：①对业务是由侵入的。②：休眠时间对性能有影响）</p>
<p><strong>操作方式二：</strong> <strong>延时双删：先删除缓存，然后再写数据库，休眠一小会在删除缓存。</strong></p>
<p><strong>产生的问题：</strong> 如果过写操作很频繁，同样会有脏数据的的问题。</p>
<p>解决：这种方式主要针对写操作不频繁的场景。</p>
<p><strong>操作方式三： ** **先写数据库，再删除缓存</strong></p>
<p><strong>产生的问题：</strong> 如果数据写完了以后缓存修改失败。数据就会不一致。</p>
<p><strong>解决：</strong></p>
<ul>
<li>给缓存设置过期时间。（在缓存时间内，数据不一致）</li>
<li>引入MQ 保证原子操作。（在MQ重试时间内数据不一致）</li>
</ul>
<h2 id="23、Redis-如何设置key的过期时间。它的键删除策略实现原理是什么"><a href="#23、Redis-如何设置key的过期时间。它的键删除策略实现原理是什么" class="headerlink" title="23、Redis 如何设置key的过期时间。它的键删除策略实现原理是什么"></a>23、Redis 如何设置key的过期时间。它的键删除策略实现原理是什么</h2><p>设置过期时间 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expair key time </span><br><span class="line"></span><br><span class="line">setnx key value time</span><br></pre></td></tr></table></figure>


<p>Redis 过期key删除机制有两种，一种是被动方式，一种是主动方式。</p>
<p>懒汉式式删除（被动）<br>含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步(如果此时还不删除的话，我们就会获取到了已经过期的key了)</p>
<p>定期删除 （主动）<br>含义：每隔一段时间执行一次删除过期key操作</p>
<p>优点：通过平衡控制<strong>执行效率</strong>和<strong>执行时长</strong>，来减少删除操作对CPU时间的占用。</p>
<p>遍历每个database(默认16个)，检查当前库中指定个数的key(默认是20个)，随机抽查这些key，如果有过期的就删除。并且程序中有一个全局变量，用来记录扫描到了哪一个数据库（database）。</p>
<p>Redis 同时使用以上两种删除策略。</p>
<h2 id="24、Redis的RDB和AOF机制"><a href="#24、Redis的RDB和AOF机制" class="headerlink" title="24、Redis的RDB和AOF机制"></a>24、Redis的RDB和AOF机制</h2><p>RDB（redis database）：在指定<strong>时间间隔内</strong>将内存中的<strong>数据集快照</strong>写入磁盘，也就是快照，它恢复是将快照文件直接读到内存里面。（在Redis 的配置文件内设置时间间隔）<strong>RDB 默认开启。</strong></p>
<p>备份是如何执行的：<br>Redis 会单独的创建一个fork子进程来持久化，会先将数据写入一个临时文件中，等持久化过程都结束了，在用这个临时文件替换上次持久化的文件，整个过程主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据的恢复，且对于数据的完整性要求不那么敏感，那么RDB的方式要比AOF的方式更加的额高效，RDB的缺点就是<strong>最后一次持久化的数据可能会丢失。</strong></p>
<p>fork的作用就是复制一个与当前进程一样的进程，新的进程的所有的数据（变量，程序计数器等）都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件解释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查数据完整性、默认值 yes 在存储跨照后让Redis 使用CRC64算法来对数据进行校验。但是这样做会损失大约10%的性能。推荐开启。</span></span><br><span class="line">rdbchecksum  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis 无法写入磁盘的时候，直接关掉Redis的写操作，推荐yes</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 压缩文件</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将数据写入磁盘的时间间隔， 默认 六十分钟1次、五分钟一百次、一分钟一万次</span></span><br><span class="line">save 300 100</span><br></pre></td></tr></table></figure>



<p>RDB的优势：</p>
<ul>
<li>适合大规模数据的恢复。</li>
<li>对数据完整性和一致性要求不高时使用。</li>
<li>节省磁盘空间。</li>
<li>回恢复度快。</li>
</ul>
<p>RDB的劣势：</p>
<ul>
<li>在写入临时快照的时候，数据被克隆了一份，大致两倍的膨胀性需要考虑。</li>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据量庞大还是比较消耗性能。</li>
<li>在备份周期在一定时间间隔内做一次备份，所以如果Redis以外关掉，就会丢失最后一次快照的修改。</li>
</ul>
<p>RDB的备份恢复：<br>默认Redis启动会自动将Redis的快照文件（dump.rdb）读取到内存中。手动恢复的话只需要将快照文件复制到Redis启动目录下。</p>
<p>AOF（Append Only File）：以日志的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的所有<strong>写/修改/删除指令记录下来（读操作不记录）</strong>，只许追加文件但是不可以改文件，Redis启动之初，会自动读取范围见重新构建数据，换言之Redis重启的话就会根据日志文件的内容将写指令重头到尾在执行一遍，以完成数据的恢复工作。<strong>AOF默认不开启。</strong></p>
<p>开启AOF：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认为no 不开启， 将其改为yes 开启。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果RDB和AOF同时开启，Redis 默认会读取AOF的配置文件来恢复数据。</strong> </p>
<p>AOF 异常修复：<br>如果遇到AOF文件损坏，通过 redis-check-aof   –fix  appendonly.aof 进行恢复。</p>
<p>AOF的同步频率设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置AOF的同步频率 。</span></span><br><span class="line">	always：始终同步。</span><br><span class="line">	everysec ：每秒同步，每秒记入日志一次，如果宕机当前秒的数据可能会丢失。</span><br><span class="line">	no：redis 不主动同步，把同步的时机交给操作系统。</span><br><span class="line">appendfsync always   </span><br></pre></td></tr></table></figure>

<p>Rewrite 压缩<br>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过设置的阈值时，Redis回启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p>重写的原理：<br>AOF文件持续增长而过大时， 会fork 出一条新的进程将文件重写（也是先写临时文件最后在rename）Redis4.0后的版本重写，实际上就是把RDB的快照，以二进制的形式附在新的aof的头部，作为已有的历史数据，替换掉原来的流水操作。</p>
<p>AOF持久化的流程：</p>
<ul>
<li>客户端的请求命令会被append追加到AOF的缓冲区内。</li>
<li>AOF缓冲区根据AOF持久化策略（always/everysec/no）将操作sync同步到磁盘中的.aof文件中去。</li>
<li>AOF文件大小超过重写策略或者手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。</li>
</ul>
<h3 id="AOF与RDB对比："><a href="#AOF与RDB对比：" class="headerlink" title="AOF与RDB对比："></a>AOF与RDB对比：</h3><ul>
<li>AOF文件比RDB大，且更安全，但恢复速度慢。</li>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>RDB性能比AOF好。</li>
<li>如果两个都加载了Redis默认优先加载AOF。</li>
</ul>
<h2 id="25、Redis-主从复制核心原理"><a href="#25、Redis-主从复制核心原理" class="headerlink" title="25、Redis 主从复制核心原理"></a>25、Redis 主从复制核心原理</h2><p>主从复制配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">核心原理：通过执行slaveof 命令，让一个服务器复制另一个服务器的数据，主数据库负责写操作，从数据库负责读操作，当写操作导致数据变化时，会自动将数据同步给从数据库。</span><br><span class="line"></span><br><span class="line">全量复制：</span><br><span class="line"></span><br><span class="line">- 主节点通过bgsave命令fork子进程，进行RDB持久化（该过程是非常消耗CPU、内存的、硬盘IOd的）。</span><br><span class="line">- 主节点通过网络将RDB文件发送给从节点，对从节点的带宽会有很大的消耗。</span><br><span class="line">- 从节点清空老数据，载入新的RDB文件是阻塞的，无法响应客户端的命令，如果从节点执行bgrewriteof，也会带来额外的消耗。</span><br><span class="line"></span><br><span class="line">增量复制：</span><br><span class="line"></span><br><span class="line">- 复制偏移量：执行复制的双方主从节点分别会维护一个复制偏移量offset。</span><br><span class="line">- 复制及压缓冲区：主节点内部维护一个固定长度的、先进先出的队列作为复制缓冲区，如果缓冲区超过最大长度，那么只能进行全量复制。</span><br><span class="line">- 每个Redis启动都会产生一个ID， 主节点还会将自己的ID发送给从节点，如果主节点挂掉重新选举，主节点ID不一致那么只能全量复制。如果一致那就继续使用增量复制。</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;2e7fbffc46d411ec9d7c5254006b8f1d.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 26、 索引回表 索引覆盖  索引下推</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">针对以上索引问题，首先要知道什么是主键索引、非主键索引、聚簇索引、非聚簇索引。</span><br><span class="line"></span><br><span class="line">主键索引：即MySQL的索引，如果没有主键那么MySQl会自动在表中挑选一个唯一且非空的字段来当做主键索引，如果没有的话MySQL内部自己会创建一个ROW_ID来当做主键，也会建立主键索引。主键索引的叶子结点存储的是整行的数据。</span><br><span class="line"></span><br><span class="line">非主键索引：即非主键以外的列建立的索引。非主键索引存储的是主键索引的值。</span><br><span class="line"></span><br><span class="line">### 什么是索引回表？</span><br><span class="line"></span><br><span class="line">索引回表指的就是在查询某一列数据是判断条件为非主键索引，name查到这条复合条件的所有记录就需要在根据非主键索引获得的主键索引的值，在取主键索引的B+树中在此查询一次才能获取到全部的数据。例如：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line"># ID 是主键索引 ，只需要一次查询就可以获取符合条件的全部记录。</span><br><span class="line">select * from ex_table where ID&#x3D;1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># n 是非主键索引，查询到的结果是符合条件的主键索引的ID，所以还需要早根据主键的ID,再在主键索引的B+树上查询一次</span><br><span class="line">select * from ex_table where n &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>以上情况就是索引回表。</p>
<h3 id="什么是索引覆盖？"><a href="#什么是索引覆盖？" class="headerlink" title="什么是索引覆盖？"></a>什么是索引覆盖？</h3><p>如果执行的语句是 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select idfrom T where n between 1 and 10;</span><br></pre></td></tr></table></figure>
<p>现在的SQL只需要得到ID 的值，而 ID 的值已经在 n 索引的B+树上了，因此可以直接获得查询结果，不需要回表。也就是说，在这个查询里面，索引 n已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<h3 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h3><p>索引下推（index condition pushdown ）简称ICP，在MySQL5.6的版本上推出，用于优化查询，默认是开启的，可以通过以下的命令关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch &#x3D; &#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure>
<p>当使用索引下推时如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>索引下推的好处：</p>
<p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</strong></p>
<p>假如有以下MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 索引值为 name age 为组合索引。</span><br><span class="line"></span><br><span class="line">select * from user where name like &#39;张%&#39; and age &#x3D; 20;</span><br></pre></td></tr></table></figure>


<p>在关闭索引下推的时候，InnoDB引擎会根据只name找到复合条件的索引字段，如下图中的左边绿色，然后就将数据返回给MySQL服务器，由MySQL服务器去判断其他的符合条件的数据。MySQL服务器会拿着查到的ID：1、2  在进行回表查询。</p>
<p><img src="https://tc.chaizz.com/161026e0486011ec9d7c5254006b8f1d.png"></p>
<p>在使用索引下推的时候，InnoDB会直接找出符合索引条件的字段的ID，将符合条件的结果发送给MySQL服务器，这个过程只需要回表一次。</p>
<h1 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h1><h2 id="1、进程和线程的区别"><a href="#1、进程和线程的区别" class="headerlink" title="1、进程和线程的区别"></a>1、进程和线程的区别</h2><p><strong>CPU密集型计算（CPU-bound）：</strong>Io可以再很短的时间结束 ，而需要CPU进行大量的计算。</p>
<p>比如： 压缩解压缩， 加密解密，正则的表达式搜索</p>
<p><strong>IO密集型计算(I/O-bound)：</strong>指系统大部分时间是在等IO写入读取操作，CPU占用比较低。</p>
<p>比如：文件处理，网络爬虫操作，读写数据</p>
<p><strong>进程</strong>：是对程序运行的封装，是操作系统调度资源的基本单位。进程切换消耗的资源比较大。效率比较低。</p>
<p><strong>线程</strong>：是进程的基本单位，一个进程至少一个线程。可以实现进程的并发（并发是假的并行，相当于来回切换）。线程切换需要的资源一般，效率也一般。（在不考虑GIL的情况下）。</p>
<p>一个进程包括多个线程，线程依赖进程存在，共享进程的内存。</p>
<p>共享数据会导致线程安全。可以使用线程锁。或者在程序设计的时候就避免这种情况出现。</p>
<p><strong>为什么进程切换比线程切换消耗大：</strong></p>
<p>进程切换需要两步：①：切换页目录，使用新的地址空间。②：切换内核和硬件上下文。</p>
<p>对于Linux来说线程和进程最大的区别就是在于虚拟地址空间，每个进程都有自己的虚拟地址空间，而线程是共享进程的地址空间的，因此同一个进程中线程的切换不涉及到虚拟地址空间的转换。把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用TLB(Translation Lookaside Buffer)来缓存页地址，用来加速页表查找。当进程切换后页表也要进行切换，页表切换后TLB就失效了，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快。</p>
<p><strong>保证线程安全的方式：</strong></p>
<ul>
<li><p>互斥锁：通过互斥机制防止多个线程同时访问公共资源。</p>
</li>
<li><p>信号量：控制同一时刻多个线程访问资源的线程数。</p>
</li>
<li><p>事件（信号）：通过通知的方式实现。</p>
</li>
</ul>
<p><strong>进程之间通信的方式：</strong></p>
<ul>
<li><p>匿名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li><p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
</li>
<li><p>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p>消息队列（Queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<ul>
<li>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。</li>
<li>RabbitMQ : 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。</li>
</ul>
</li>
<li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。</p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p>套接字（socket） 用的比较多。套接字（socket）为通信的端点，每个套接字由一个 IP 地址和一个端口号组成。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。</p>
<ul>
<li>服务进程：socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;read()-&gt;write()-&gt;…-&gt;close()</li>
<li>客户进程：socket()-&gt;connect()-&gt;write()-&gt;read()-&gt;…-&gt;close();</li>
</ul>
</li>
</ul>
<p><strong>线程之间的通信方式：</strong></p>
<p>共享变量、共享内存、共享数据库、消息队列</p>
<p>Python中如何使用对进程（在CPU密集型中使用）：</p>
<p>Multiprocessing ：多进程模块  </p>
<h2 id="2、五种IO模型"><a href="#2、五种IO模型" class="headerlink" title="2、五种IO模型"></a>2、五种IO模型</h2><p>阻塞式IO （Blocking IO）</p>
<p>非阻塞式IO （NonBlocking IO）</p>
<p>IO 多路复用 （IO Multiplexing）</p>
<p>信号驱动IO（Signal Driven IO）不常用</p>
<p>异步IO （Asynchronous IO）不常用</p>
<h2 id="3、操作系统实现多路复用的方法"><a href="#3、操作系统实现多路复用的方法" class="headerlink" title="3、操作系统实现多路复用的方法"></a>3、操作系统实现多路复用的方法</h2><p>IO多路复用的本质就是select/poll/epoll 去监听多个socket对象，如果其中的socket对象有变化，只要有变化，用户进程就知道了。</p>
<p>Select 是不断的轮询监听的socket， socket的个数有限制，一般为1024个。</p>
<p>Poll 还是采用轮询的方式监听，之不过没有个数的限制。</p>
<p>Epoll 并不是采用轮训的方式去监听，而是当socket有变化的时候通过回调的方式主动地告知用户进程。</p>
<p>表面上看epoll的性能最好，但是在连接数少，连接数十分活跃的情况下，selecthe poll性能会比epoll好。因为epoll的通知机制需要很多回调函数。</p>
<h2 id="4、Python-实现IO多路复用的方法："><a href="#4、Python-实现IO多路复用的方法：" class="headerlink" title="4、Python 实现IO多路复用的方法："></a>4、Python 实现IO多路复用的方法：</h2><p>也是基于操作系统的select ,poll epoll方法。Pyhon3 中实现了selectors 模块。</p>
<p>事件类型：EVENT_READ 、EVENT_WRITE </p>
<p>DefaultSelector：自动根据系统来选择IO模型。其中的一些方法</p>
<p>a)   register（fileobj events data = none）</p>
<p>b)  unregister（fileobj）</p>
<p>c)   Modifiy(fileobj events data = none)</p>
<p>d)  Select(timeout=none, returns[keys, events])</p>
<p>e)   Close()</p>
<h2 id="5、Python的并发网络库："><a href="#5、Python的并发网络库：" class="headerlink" title="5、Python的并发网络库："></a>5、Python的并发网络库：</h2><p>Gevent 、asyncio、tornado</p>
<p>Tornado：是一个并发网络编程库，也是一个Web框架。</p>
<p>Gevent：基于几个绿色线程实现并发。底层是基于c语言实现的。基于 monkey patch gevent修改了内置的socket 改为非阻塞。 经常配合gunnicorn 部署作为wsgi server 。 </p>
<p>Asyncio ：基于原生的协程实现的。</p>
<h2 id="6、Linux中有哪些调度算法？"><a href="#6、Linux中有哪些调度算法？" class="headerlink" title="6、Linux中有哪些调度算法？"></a>6、Linux中有哪些调度算法？</h2><p>先来先服务调度算法和短作业优先调度算法</p>
<h2 id="7、操作系统如何管理内存的？"><a href="#7、操作系统如何管理内存的？" class="headerlink" title="7、操作系统如何管理内存的？"></a>7、操作系统如何管理内存的？</h2><p>内存又分为虚拟内存和物理内存。</p>
<p>虚拟内存的基本思想就是每个进程都有独立的逻辑地址空间，内存被分为大小相等的块，称为页，每个页都是一段连续的地址，对于进程来看貌似有很多的内存空间，但切实只有一部分是物理内存地址。</p>
<p>缺页中断，</p>
<h2 id="8、LRU-最近最少使用-Least-Recently-Used-算法"><a href="#8、LRU-最近最少使用-Least-Recently-Used-算法" class="headerlink" title="8、LRU:最近最少使用(Least Recently Used)算法"></a>8、LRU:最近最少使用(Least Recently Used)算法</h2><p>基于最近使用的也慢数据在未来一段时间仍有很大可能被使用，已经很久没有使用的数据在未来的很长一段时间内也仍然不会被使用这种思想的一种淘汰机制，它的主要衡量指标是时间，第二衡量指标是次数。利用双向链表来实现。</p>
<h2 id="9、LFU（Least-Frequently-Used）算法"><a href="#9、LFU（Least-Frequently-Used）算法" class="headerlink" title="9、LFU（Least Frequently Used）算法"></a>9、LFU（Least Frequently Used）算法</h2><p>即最少访问算法，根据访问缓存的历史频率来淘汰数据，核心思想是“如果数据在过去一段时间被访问的次数很少，那么将来被访问的概率也会很低”。</p>
<p>数据结构： 一般会维护两个数据结构：</p>
<p>哈希：用来提供对外部的访问，查询效率更高；</p>
<p>双向链表或队列：维护了对元素访问次数的排序</p>
<p><strong>优点：</strong></p>
<p>一般情况下，LFU效率要优于LRU，能够避免周期性或者偶发性的操作导致缓存命中率下降的问题</p>
<p><strong>缺点：</strong></p>
<p>复杂度较高：需要额外维护一个队列或双向链表，复杂度较高</p>
<p>对新缓存不友好：新加入的缓存容易被清理掉，即使可能会被经常访问</p>
<p>缓存污染：一旦缓存的访问模式发生变化，访问记录的历史存量，会导致缓存污染；</p>
<p>内存开销：需要对每一项缓存数据维护一个访问次数，内存成本较大；</p>
<p>处理器开销：需要对访问次数排序，会增加一定的处理器开销</p>
<h1 id="四、网络"><a href="#四、网络" class="headerlink" title="四、网络"></a>四、网络</h1><h2 id="1、Python-底层的网络编程模块有哪些？"><a href="#1、Python-底层的网络编程模块有哪些？" class="headerlink" title="1、Python 底层的网络编程模块有哪些？"></a>1、Python 底层的网络编程模块有哪些？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Socket 、urllib、requests、grab、pycurl</span><br></pre></td></tr></table></figure>


<h2 id="2、简述OSI七层含义"><a href="#2、简述OSI七层含义" class="headerlink" title="2、简述OSI七层含义"></a>2、简述OSI七层含义</h2><p>-   应用层：HTTP、FTP、NFS</p>
<p>-   表示层：Telnet、SNMP</p>
<p>-   会话层：SMTP、DNS</p>
<p>-   传输层：TCP、UDP</p>
<p>-   网络层：IP、TCP、ARP</p>
<p>-   数据链路层：Etherent、PPP、PDN、SLIP、FDDI</p>
<p>-   物理层：TEEE 802.1A、TEEE 802.11</p>
<p>应用层、表示层、会话层 也可以称之为应用层。</p>
<h2 id="3、输入一个URL中间的过程："><a href="#3、输入一个URL中间的过程：" class="headerlink" title="3、输入一个URL中间的过程："></a>3、输入一个URL中间的过程：</h2><ul>
<li>首先首先浏览器会解析域名找到对应的IP地址。<ul>
<li>浏览器会首先搜索浏览器自身的DNS缓存，(缓存时间较短，大概只有一分钟，且只能容纳1000条缓存)，看自身缓存是否有该域名对应的条目，而且没有过期，如果有且没有过期解析到此此结束。</li>
<li>如果浏览器自身的缓存李，没有找到对应的条目，那么浏览器就会搜索系统自身的DNS缓存，如果找到且没有过期，则停止搜索，解析结束。</li>
<li>如果在系统的DNS缓存也没有找到，那么尝试读取hosts文件，看看这里面是否有对应的IP地址，如果有则解析成功。</li>
<li>如果hosts文件也没有，浏览器就是发起一个DNS系统的调用，就会向本地配置的首选DNS服务器(一般是电信运营商提供的)，发起域名解析请求（通过UDP协议向DNS的53端口发期请求，这个请求是递归请求，也就是运行商必须提供给我们该域名的IP地址），运行商的DNS服务器首先查找自身的缓存，找到对应的条目且没有过期，则解析成功，如果没有，则由运营商的DNS代我们我们的浏览器发送迭代DNS解析,首先会找根域的DNS的I地址（这个DNS服务器都内置13台根域的DNS的IP地址），然后进一步请求，一般四部就可以找到域名对应的IP地址的。</li>
</ul>
</li>
<li>浏览器调用socket 函数，发起TCP 请求 （三次握手）与服务器建立连接。</li>
<li>建立连接之后发起应用层http的请求，如果有代理的话 到达nginx 然后再到uwsgi 最后再到web应用响应。</li>
<li>浏览器得到并解析解析html代码。</li>
<li>然后web应用在执行他的逻辑，然后返回response，通过tcp返回给用户，最后就会执行TCP的四次挥手。</li>
</ul>
<h2 id="4、TCP的三次握手四次分手："><a href="#4、TCP的三次握手四次分手：" class="headerlink" title="4、TCP的三次握手四次分手："></a>4、TCP的三次握手四次分手：</h2><p><strong>第一次握手：</strong></p>
<p>客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。</p>
<p><strong>第二次握手：</strong></p>
<p>服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD（同步已发送状态）状态。</p>
<p><strong>第三次握手：</strong></p>
<p>客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED（已建立连接）状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<p>三次握手：<br> “喂，你听得到吗？”<br> “我听得到呀，你听得到我吗？”<br> “我能听到你，今天 balabala……”</p>
<p><strong>TCP的四次挥手</strong>：</p>
<p> <strong>第一次分手：</strong></p>
<p>Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。</p>
<p><strong>第二次分手：</strong></p>
<p>Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。</p>
<p><strong>第三次分手：</strong></p>
<p>Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。</p>
<p><strong>第四次分手 ：</strong></p>
<p>Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</p>
<h2 id="5、为什么TCP需要四次分手呢？"><a href="#5、为什么TCP需要四次分手呢？" class="headerlink" title="5、为什么TCP需要四次分手呢？"></a>5、为什么TCP需要四次分手呢？</h2><p>因为建立连接时ACK和SYN可以放在一个报文里面来发送，而关闭连接时，被动的关闭方，可能还需要发送一些数据，再发送DIN报文确认同意可以关闭连接了，所以这里的ACK和Fin报文是分开发送的。</p>
<h2 id="6、TCP-UDP的区别："><a href="#6、TCP-UDP的区别：" class="headerlink" title="6、TCP/UDP的区别："></a>6、TCP/UDP的区别：</h2><p><strong>相同点：</strong></p>
<p>UDP协议和TCP协议都是传输层协议。</p>
<p><strong>不同点：</strong></p>
<p>-   TCP：面向有连接的（建立之前必选建立连接，结束之后关闭连接），可靠的、 基于字节流的。</p>
<p>-   UDP：无连接的（知道对端的IP和端口号就直接进行传输, 不需要建立连接。）不可靠（没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。）。面向报文的（应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。）。</p>
<p>TCP 只支持点对点的，UD支持一对一，一对多，多对多的交互通信。</p>
<h2 id="7、UDP如何尽量保持可靠"><a href="#7、UDP如何尽量保持可靠" class="headerlink" title="7、UDP如何尽量保持可靠"></a>7、UDP如何尽量保持可靠</h2><p>UDP他不属于连接性协议，因为具有资源消耗小，处理速度快的优点，随意即时通许，音视频数据在传输是使用UDP比较多，因为他们偶尔丢一两个包对数据也不会造成太大的影响，传输层无法保证数据的可靠传输，只能在应用层来实现，实现的方式可以参考TCP的可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>关键在于两点：</p>
<ul>
<li>提供超时重传，能避免数据丢失</li>
<li>提供确认序列号，可以对报文进行确认和排序。</li>
</ul>
<h2 id="8、TCP的keepalive和-http-的keep-alive的区别"><a href="#8、TCP的keepalive和-http-的keep-alive的区别" class="headerlink" title="8、TCP的keepalive和 http 的keep alive的区别"></a>8、TCP的keepalive和 http 的keep alive的区别</h2><p>http的keep-alive是为了让TCP活的更久一点，一边在同一个连接上传送多个http，提供socket效率，而TCP的keep-alicve是TCP的一种检测TCP连接的保鲜机制。检查TCP连接是否活跃。</p>
<h2 id="9、HTTP的1-0-、1-1、2-0-的主要区别"><a href="#9、HTTP的1-0-、1-1、2-0-的主要区别" class="headerlink" title="9、HTTP的1.0 、1.1、2.0 的主要区别"></a>9、HTTP的1.0 、1.1、2.0 的主要区别</h2><p><strong>HTTP1.0：</strong></p>
<ul>
<li>无状态，无连接的</li>
</ul>
<p><strong>HTTP1.1:</strong></p>
<ul>
<li>支持长连接，请求管道化，请求并行发送，响应仍然有序返回</li>
<li>增加缓存的处理，新的字段：cache-control</li>
<li>增加Host字段，适应虚机主机技术发展，即一台服务器支持多台主机。</li>
<li>支持断点传输</li>
</ul>
<p><strong>HTTP2.0</strong>:</p>
<ul>
<li>二进制分帧</li>
<li>多路复用（连接共享）</li>
<li>头部压缩（encoder）</li>
<li>服务器推送</li>
</ul>
<h2 id="10、HTTP请求的组成"><a href="#10、HTTP请求的组成" class="headerlink" title="10、HTTP请求的组成"></a>10、HTTP请求的组成</h2><p>状态行：请求码、请求方法（method）、路径、版本</p>
<p>请求头：HOST，数据类型（content_type），数据长度(content_length)，接收编码（accept-encoding）连接（keep-alive）、user-agent</p>
<p>请求体内容</p>
<h2 id="11、HTTP响应的组成："><a href="#11、HTTP响应的组成：" class="headerlink" title="11、HTTP响应的组成："></a>11、HTTP响应的组成：</h2><p>状态行：响应码、请求方法（method）、路径、版本</p>
<p>响应头：缓存（cache-contral）、数据类型（content_type），数据长度(content_length)、连接（cinnection）、</p>
<p>响应正文：内容</p>
<h2 id="12、HTTP响应的状态码："><a href="#12、HTTP响应的状态码：" class="headerlink" title="12、HTTP响应的状态码："></a>12、HTTP响应的状态码：</h2><p>1xx：服务器已经收到 需要请求者继续操作</p>
<p>2xx：成功，操作成功并接受处理</p>
<p>3xx：重定向 （301：用久重定向，302：临时重定向，304：not modified）</p>
<p>4xx：客户端错误（401：未认证，403：forbidben 没权限，404：not found 405：请求不被允许）</p>
<p>5xx：服务端错误；（500：服务错误，502：对用户访问请求超时）</p>
<h2 id="13、HTTP请求方法"><a href="#13、HTTP请求方法" class="headerlink" title="13、HTTP请求方法"></a>13、HTTP请求方法</h2><p>GET/POST/PUT/DELETE</p>
<h2 id="14、GET-POST的区别："><a href="#14、GET-POST的区别：" class="headerlink" title="14、GET/POST的区别："></a>14、GET/POST的区别：</h2><p>GET的请求参数是放在URL上面的，是明文的（长度是有限的）。POST是放在请求体里面的相对更安全。</p>
<h2 id="15、HTTP长连接："><a href="#15、HTTP长连接：" class="headerlink" title="15、HTTP长连接："></a>15、HTTP长连接：</h2><p>短连接：建立连接，数据传输，关闭连接，（连接建立和关闭的开销大）。</p>
<p>长连接：Connection:keep-alive, 来保持TCP不断开。</p>
<h2 id="16、Cookie-和-Session-的区别："><a href="#16、Cookie-和-Session-的区别：" class="headerlink" title="16、Cookie 和 Session 的区别："></a>16、Cookie 和 Session 的区别：</h2><p>Session 是服务器生成之后返回给客户端，通过URL或者是cookie</p>
<p>Cookie 是实现session的一种机制，通过http cookie 字段实现。</p>
<p>Session 是通过服务器保存session识别用户，cookie保存在客户端。</p>
<h2 id="17、-网络TCP-socket-编程实现原理"><a href="#17、-网络TCP-socket-编程实现原理" class="headerlink" title="17、 网络TCP socket 编程实现原理"></a>17、 网络TCP socket 编程实现原理</h2><p>服务进程：socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;read()-&gt;write()-&gt;…-&gt;close()</p>
<p>客户进程：socket()-&gt;connect()-&gt;write()-&gt;read()-&gt;…-&gt;close();</p>
<p><strong>创建客户端：</strong></p>
<ol>
<li><p>首先创建sokect对象</p>
</li>
<li><p>创建连接 connection </p>
</li>
</ol>
<p><strong>创建服务端</strong></p>
<ol>
<li><p>创建socket 对象。</p>
</li>
<li><p>绑定本地地址</p>
</li>
<li><p>Socket对象监听</p>
</li>
</ol>
<p><strong>使用socket 发送http请求：</strong></p>
<ol>
<li><p>创建socket 对象。</p>
</li>
<li><p>连接http 地址。</p>
</li>
<li><p>发送http请求。</p>
</li>
<li><p>接收返回对像。</p>
</li>
<li><p>关闭请求连接。</p>
</li>
</ol>
<h1 id="五、Python-WSGI-与WEB框架的常考问题"><a href="#五、Python-WSGI-与WEB框架的常考问题" class="headerlink" title="五、Python WSGI 与WEB框架的常考问题"></a>五、Python WSGI 与WEB框架的常考问题</h1><h2 id="1-什么是WSGI：和web框架交互的一个规范。"><a href="#1-什么是WSGI：和web框架交互的一个规范。" class="headerlink" title="1.   什么是WSGI：和web框架交互的一个规范。"></a>1.   什么是WSGI：和web框架交互的一个规范。</h2><p>主要是解决python web server 乱象 mod_python 、CGI、FastCGI 等。描述了 web server (Gunicorn/Uwsgi) 如何与web框架（django/flask）交互，web 框架如何处理请求。</p>
<h2 id="2、django请求的生命周期？"><a href="#2、django请求的生命周期？" class="headerlink" title="2、django请求的生命周期？"></a>2、django请求的生命周期？</h2><p>​    </p>
<p>用户在浏览器输入URL的时候，浏览器会生成请求头，和请求体发送给服务端。请求头he请求体中会包括浏览器的动作（这个动作通常为GET或者POST 体现在URL中）。</p>
<p>URL经过Django的服务器uwsgi,（如果有代理服务器的话，先经过代理服务器在由代理服务器设置的代理，转到uwsgi）然后请求到达django项目的中间件。通过中间件以后在到达路列表，进行匹配，匹配到路由规则，在访问视图层。</p>
<p>视图函数根据客户端的请求查询相应的数据，返回给django，然后django在把获取的序列化的数据返回。</p>
<h2 id="3、列举django中间件的五个方法"><a href="#3、列举django中间件的五个方法" class="headerlink" title="3、列举django中间件的五个方法"></a>3、列举django中间件的五个方法</h2><p>自定义中间件需要继承父类 （MiddlewareMixin）。</p>
<p><strong>process_request(request) ：</strong>此方法是在视图函数执行之前执行的。该方法包含一个参数 request。这个request和视图函数中的request是一样的。返回值可以是NONE 也可以是HttpeRsponse ，如果是none 那就走下一个中间件，如果是HttpeRsponse，django 将不会再走后面的视图函数，那就直接已改中间件为起点，倒序执行中间件，且执行的是视图函数执行之后的方法。该方法的应用场景：可以做认证、权限先关的事情。</p>
<p><strong>process_resopnse（request，response）：</strong>此方法是在视图函数执行之后执行的。该方法 有两个参数，request是请求对象，response是视图函数返回的httpresponse。该方法必须要有返回值，而且必须是response。</p>
<p><strong>process_exception(request, exception) ：</strong>此方法有两个函数，request 是HttpRequest 对象，exception 是视图函数异常产生的 Exception 对象。该方法只有在视图函数中出现异常了才执行，按照 settings 的注册倒序执行。在视图函数之后，在 process_response 方法之前执行。方法的返回值可以是一个 None 也可以是一个 HttpResponse 对象。如果是NONE 则会直接返回一个500的状态码，不会往下执行视图函数，如果是返回HttpResponse ，页面不会报错没返回状态码200，视图函数不执行，该中间件后续的 process_exception 方法也不执行，直接从最后一个中间件的 process_response 方法倒序开始执行。</p>
<p> <strong>process_view(request,view_func, view_args, view_kwargs) ：</strong>此方法是在视图函数之前，process_request 方法之后执行的。该方法有四个参数request 是 HttpRequest 对象；view_func 是 Django 即将使用的视图函数；view_args 是将传递给视图的位置参数的列表；view_kwargs 是将传递给视图的关键字参数的字典。返回值可以是 None、view_func(request) 或 HttpResponse 对象</p>
<p><strong>process_template_responseprocess（）</strong> ：这个渲染模板的时候执行的。</p>
<h2 id="4、简述什么叫FBV和CBV"><a href="#4、简述什么叫FBV和CBV" class="headerlink" title="4、简述什么叫FBV和CBV"></a>4、简述什么叫FBV和CBV</h2><p>FBV 叫做基于函数的视图，CBV是基于类的视图，使用CBV的优点，提高代码的复用性，使用面向对象的技术，可以用不同的函数（get()/post()）针对不同的请求处理，而不是通过if 判断请求方式。</p>
<h2 id="5、Django的内置组件"><a href="#5、Django的内置组件" class="headerlink" title="5、Django的内置组件"></a>5、Django的内置组件</h2><p>admin 是对modle 中的数据记性可视化的增删改查的组件。</p>
<p>model 数据库数据结构的映射对象。</p>
<p>form 生成html的代码，对数据进行检验，校验数据并返回。</p>
<h2 id="6、django的request对象是在什么时候创建的？"><a href="#6、django的request对象是在什么时候创建的？" class="headerlink" title="6、django的request对象是在什么时候创建的？"></a>6、django的request对象是在什么时候创建的？</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIHandler</span>(<span class="params">base.BaseHandler</span>):</span></span><br><span class="line"></span><br><span class="line">    request = self.request_class(environ)</span><br></pre></td></tr></table></figure>
<p>请求走到WSGIHandler类的时候，执行cell方法，将environ封装成了request</p>
<h2 id="7、如何给CBV的程序添加装饰器。"><a href="#7、如何给CBV的程序添加装饰器。" class="headerlink" title="7、如何给CBV的程序添加装饰器。"></a>7、如何给CBV的程序添加装饰器。</h2><p>可以使用method_decorator 在类的get/post方法上添加 例如：@ method_decorator（func）</p>
<p>给类添加在类名上 例如：@ method_decorator（func，name=post）</p>
<h2 id="8、列举django-ORM中方法"><a href="#8、列举django-ORM中方法" class="headerlink" title="8、列举django ORM中方法"></a>8、列举django ORM中方法</h2><p>all():         查询所有结果 </p>
<p>filter(**kwargs):    它包含了与所给筛选条件相匹配的对象。获取不到返回None</p>
<p>get(**kwargs):    返回与所给筛选条件相匹配的对象，返回结果有且只有一个。 如果符合筛选条件的对象超过一个或者没有都会抛出错误。</p>
<p>exclude(**kwargs):   它包含了与所给筛选条件不匹配的对象</p>
<p>order_by(*field):    对查询结果排序</p>
<p>reverse():       对查询结果反向排序 </p>
<p>count():        返回数据库中匹配查询(QuerySet)的对象数量。 </p>
<p>first():        返回第一条记录 </p>
<p>last():        返回最后一条记录 </p>
<p>exists():       如果QuerySet包含数据，就返回True，否则返回False</p>
<p>values(*field):    返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系 model的实例化对象，而是一个可迭代的字典序列。</p>
<p>values_list(*field):  它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列</p>
<p>distinct():      从返回结果中剔除重复纪录</p>
<h2 id="9、select-related和prefetch-related的区别？"><a href="#9、select-related和prefetch-related的区别？" class="headerlink" title="9、select_related和prefetch_related的区别？"></a>9、select_related和prefetch_related的区别？</h2><p>前提：有外键存在时，可以很好的减少数据库请求的次数,提高性能</p>
<p>select_related通过多表join关联查询,一次性获得所有数据,只执行一次SQL查询。（针对于 一对一和一对多）</p>
<p>prefetch_related分别查询每个表,然后根据它们之间的关系进行处理,执行两次查询。（针对多对多）</p>
<p>select_related方法执行一次数据库查询，prefetch_related方法执行两次数据库查询</p>
<h2 id="10、列举django-ORM-中三张能写sql语句的方法。"><a href="#10、列举django-ORM-中三张能写sql语句的方法。" class="headerlink" title="10、列举django ORM 中三张能写sql语句的方法。"></a>10、列举django ORM 中三张能写sql语句的方法。</h2><p>使用execute(sql语句) 类似pymysql的形式。</p>
<p>使用extra() 方法 quersyt.extra(select={“key” ：“原生SQL语句”})</p>
<p>使用raw()方法  对象.objects.raw(sql语句)</p>
<h2 id="11、values和values-list的区别？"><a href="#11、values和values-list的区别？" class="headerlink" title="11、values和values_list的区别？"></a>11、values和values_list的区别？</h2><p>values : queryset类型的列表中是字典</p>
<p>values_list : queryset类型的列表中是元组</p>
<h2 id="12、Django的queryset有哪些特性？"><a href="#12、Django的queryset有哪些特性？" class="headerlink" title="12、Django的queryset有哪些特性？"></a>12、Django的queryset有哪些特性？</h2><p>主要有两个特性，一个是惰性的，另一个是的自带缓存。</p>
<p>惰性：在使用查询语句的时候，Django不会去主动的查询数据库，只有你使用了查询的对象，Django才会去访问数据库。</p>
<p>缓存：第一次访问数据库以后Django会把得到的数据保存在queryset内置的cache中。Django就不需要在进行重复的查询了。</p>
<h2 id="13、Django的模型继承有哪几种方式-它们有什么区别以及何时使用它们"><a href="#13、Django的模型继承有哪几种方式-它们有什么区别以及何时使用它们" class="headerlink" title="13、Django的模型继承有哪几种方式? 它们有什么区别以及何时使用它们?"></a>13、Django的模型继承有哪几种方式? 它们有什么区别以及何时使用它们?</h2><p>Django的模型继承有如下三种：</p>
<p>抽象模型（avstract model）：Django不会为抽象模型在数据库中生成自己的表，父类Meta 中的abstract=True 也不会传递给子类，如果被你发现多模型有很多共同字段的时，需要用抽象模型继承。</p>
<p>多表模型继承（multi-table-inheritance）：多表模型继承与抽象模型继承最大的区别在于Django也会为父类模型建立自己的数据库表。同时隐士的在父类和子类之间建立一个一对一关系。</p>
<p>代理模型（proxy model）：如果我们只改变某个模型的行为方法，而不是添加额外的字段或者创建额外的数据表，我们就可以使用代理模型，设置一个代理模型需要子类模型meta选项中设置proxy=True，django不会为代理模型生成新的数据表。</p>
<h2 id="14、简单说说看-Django的CSRF防御机制。"><a href="#14、简单说说看-Django的CSRF防御机制。" class="headerlink" title="14、简单说说看 Django的CSRF防御机制。"></a>14、简单说说看 Django的CSRF防御机制。</h2><p>Django的CSRF是通过Django的中间件 （django.middleware.csrf.CsrfViewMiddleware）来实现的。主要流程如下：</p>
<p>Django相应来自客户端的请求的时候，会在服务器生成一个csrftoken（一串64位的随机码），把这个token放在请求头的cookie里发给客户端返回给用户。</p>
<p>所有通过POSt提交的额表单，都要携带一个隐藏字段，通过模板文件中的<code>&#123;%csrf_token%&#125;</code>标签生成。</p>
<p>当用户通过提教交POST的时候，django会从请求头cookie中获取这个token的值，与生成的只比较是否一致。</p>
<h2 id="16、如何从数据表中获取一个随机的对象。"><a href="#16、如何从数据表中获取一个随机的对象。" class="headerlink" title="16、如何从数据表中获取一个随机的对象。"></a>16、如何从数据表中获取一个随机的对象。</h2><p>可以使用order_by（”?”）.first()</p>
<h2 id="17、说说aggregate和annotate方法的作用。"><a href="#17、说说aggregate和annotate方法的作用。" class="headerlink" title="17、说说aggregate和annotate方法的作用。"></a>17、说说aggregate和annotate方法的作用。</h2><p>Aggregate 是聚合的意思，是对一组值(比如queryset的某个字段)进行统计计算，并以字典(Dict)格式返回统计计算结果。支持 count（）max(),min()sun()avg()。</p>
<p>Annotate ：可以理解为分组，对数据集先进行分组然后再进行某些聚合操作或排序时，需要使用annotate方法来实现。与aggregate方法不同的是，annotate方法返回结果的不仅仅是含有统计结果的一个字典，而是包含有新增统计字段的查询集(queryset）</p>
<h2 id="18、常用的框架Django-Flask-Tornado-的对比。"><a href="#18、常用的框架Django-Flask-Tornado-的对比。" class="headerlink" title="18、常用的框架Django/Flask/Tornado 的对比。"></a>18、常用的框架Django/Flask/Tornado 的对比。</h2><p>Django ：大而全，内置ORM、Admin, 第三方的插件比较多。</p>
<p>Flask ：微框架、插件机制，比较灵活。</p>
<p>Tornado ：支持异步的微框架，和异步网络库。</p>
<h2 id="19、Django-常用的第三方插件："><a href="#19、Django-常用的第三方插件：" class="headerlink" title="19、Django 常用的第三方插件："></a>19、Django 常用的第三方插件：</h2><p>django-taggit 可以在文章中当作标签使用</p>
<p>django- Celery 异步分布式的队列。</p>
<p>djangorestframework REST API 的框架。可以做 序列化，分页。权限的管理，认证机制。</p>
<p>django-cors-headers ：管理跨域操作的插件。</p>
<p>django-haystack 全文检索引擎 </p>
<p>django -simple 后台UI界面 </p>
<p>django -captcha Django的验证码</p>
<p>django-debug-toolbar debug 调试工具</p>
<h2 id="20、Django中如何使用redis作为缓存"><a href="#20、Django中如何使用redis作为缓存" class="headerlink" title="20、Django中如何使用redis作为缓存"></a>20、Django中如何使用redis作为缓存</h2><p>安装django-redis ，在settings 设置缓存的服务期设置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django_redis.cache.RedisCache&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;redis://your_host_ip:6379&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;OPTIONS&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;CLIENT_CLASS&quot;</span>: <span class="string">&quot;django_redis.client.DefaultClient&quot;</span>,</span><br><span class="line">       <span class="string">&quot;PASSWORD&quot;</span>: <span class="string">&quot;yourpassword&quot;</span>,</span><br><span class="line">    		&#125;,</span><br><span class="line">  		&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p>也可是设置超时时间 ：REDIS_TIMEOUT=7<em>24</em>60*60</p>
<h2 id="21、如何在模板中获取当前访问url地址"><a href="#21、如何在模板中获取当前访问url地址" class="headerlink" title="21、如何在模板中获取当前访问url地址"></a>21、如何在模板中获取当前访问url地址</h2><table>
<thead>
<tr>
<th>Method</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>request.path</td>
<td>/search/</td>
</tr>
<tr>
<td>request.get_full_path</td>
<td>search/?keyword=django</td>
</tr>
<tr>
<td>request.build_absolute_uri</td>
<td><a href="https://jackeygao.io/search/?keyword=django">https://jackeygao.io/search/?keyword=django</a></td>
</tr>
</tbody></table>
<h2 id="22、Django信号-Signals-的工作原理-主要应用场景及内置信号。"><a href="#22、Django信号-Signals-的工作原理-主要应用场景及内置信号。" class="headerlink" title="22、Django信号(Signals)的工作原理, 主要应用场景及内置信号。"></a>22、Django信号(Signals)的工作原理, 主要应用场景及内置信号。</h2><p>Django 提供一个了“信号分发器”机制，允许解耦的应用在框架的其它地方发生操作时会被通知到。通俗而讲Django信号的工作原理就是当某个事件发生的时候会发出一个信号(signals), 而监听这个信号的函数(receivers)就会立即执行。应用场景有很多比如：创建用户的时候在创建一个一对一关系的用户信息的模型对象。或者是用户下订单的时候邮件通知管理员的情况。</p>
<p>Django的内置信号 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django.db.models.signals.pre_save &amp; post_save在数据模型调用 save()方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.pre_init&amp; post_init在模型调用_init_方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.pre_delete &amp; post_delete在模型调用delete()方法或查询集调用delete() 方法之前或之后发送。</span><br><span class="line"></span><br><span class="line">django.db.models.signals.m2m_changed在模型多对多关系改变后发送。</span><br><span class="line"></span><br><span class="line">django.core.signals.request_started &amp; request_finished Django建立或关闭HTTP 请求时发送。</span><br></pre></td></tr></table></figure>


<h2 id="23、什么情况下需要自定义context-processors-上下文处理器"><a href="#23、什么情况下需要自定义context-processors-上下文处理器" class="headerlink" title="23、什么情况下需要自定义context_processors(上下文处理器)"></a>23、什么情况下需要自定义context_processors(上下文处理器)</h2><p>当你需要一个视图函数或者模板提供或设置全局变量的时候，需要用上下文管理器，我们在试图和模板中随意使用request这个变量，就是因为django.core.contenxt_process_request 把request变成了一个全局变量。上下文管理器（content_process）很多地方都有用，例如：一些博客的标签、归档，这些公共的信息，是每个文章都会用的东西，如果存在数据库中，就会每次使用都要从数据库查询回去数据，造成资源浪费，如果通过context_process 设置为全局变量，就不需要再每次都要查询数据库了。</p>
<h2 id="24、Django如何实现高并发？"><a href="#24、Django如何实现高并发？" class="headerlink" title="24、Django如何实现高并发？"></a>24、Django如何实现高并发？</h2><p>使用NGINX进行反向代理。</p>
<p>数据库的分库和读写分离(主从复制)。</p>
<p>使用redis做缓存。</p>
<p>耗时任务(收发邮件/写入文件)使用celery 异步处理。</p>
<p>使用Gzip压缩静态文件。</p>
<p>使用CDN加速静态文件。</p>
<h2 id="25、什么是MVC-："><a href="#25、什么是MVC-：" class="headerlink" title="25、什么是MVC ："></a>25、什么是MVC ：</h2><p>Modle：数据层，数据业务对象和数据库的交互(ORM)。</p>
<p>View：视图层，负责与用户交互和展示。 </p>
<p>Controller ：接收请求参数,调佣模型和视图完成请求。</p>
<h2 id="26、什么是ORM"><a href="#26、什么是ORM" class="headerlink" title="26、什么是ORM"></a>26、什么是ORM</h2><p>对象关系映射，用于实现业务对象与数据库表中字段映射。类似的有sqlalchemy 、Django 的 ORm 还有 Peewee</p>
<p>好处：代码更加的面向对象，代码量更少，灵活性更高，提升代码的开发效率。</p>
<h2 id="27、WEB安全的问题"><a href="#27、WEB安全的问题" class="headerlink" title="27、WEB安全的问题"></a>27、WEB安全的问题</h2><p>什么是SQL 注入：</p>
<p>通过特殊的参数传入web应用，导致后端执行了恶意代码。在动态的拼接SQL的时候产生。</p>
<p>如何防范：</p>
<p>永远不要相信用户的人任何输入</p>
<p>对输入的参数最好检查，过滤和转义特殊字符。</p>
<p>不要直接拼接sql使用ORM可以大大降低sql注入的风险。</p>
<p>数据库层：做好明文管理，不要存储明文敏感信息。</p>
<h2 id="28、什么是XSS"><a href="#28、什么是XSS" class="headerlink" title="28、什么是XSS :"></a>28、什么是XSS :</h2><p>恶意用户将代码植入到提供给其他用户使用的页面中。未经转义的恶意代码输出到其他的用户浏览器被执行。</p>
<p>嵌入到页面中的js脚本被执行，攻击用户。</p>
<h2 id="29、什么是前后端？有哪些优势。"><a href="#29、什么是前后端？有哪些优势。" class="headerlink" title="29、什么是前后端？有哪些优势。"></a>29、什么是前后端？有哪些优势。</h2><p>后端只负责提供数据，不再渲染模板。前端获取接口实现。</p>
<p>好处：前后端解耦，接口复用，减少开发量。提升工作效率。更利于调试，测试和部署。</p>
<p>缺点：动态加载不利于SEO。</p>
<h2 id="30、什么是-RESTful"><a href="#30、什么是-RESTful" class="headerlink" title="30、什么是 RESTful"></a>30、什么是 RESTful</h2><p>是一种以资源为中心的WEB软件架构风格，可以用ajax 和restful web服务架构应用。</p>
<p>设计概念和准则：</p>
<p>所有的事物抽象为资源，资源对应唯一的标识。</p>
<p>资源通过接口进行操作实现状态转移。操作本身是无状态的。</p>
<h1 id="六、数据结构算法"><a href="#六、数据结构算法" class="headerlink" title="六、数据结构算法"></a>六、数据结构算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># n = len(a)  # 获取列表的长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j + <span class="number">1</span>]:</span><br><span class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="keyword">if</span> li[min_index] &gt; li[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            li[i], li[min_index] = li[min_index], li[i]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引原理</title>
    <url>/2021/11/13/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<blockquote>
<p>索引是帮助MySQL高效获取数据的排好序的数据结构。</p>
</blockquote>
<p><strong>在MySQL的InnoDB和MyISAM存储引擎中索引的数据结构都是B+树和HASH。</strong></p>
<p><strong>首先说数据结构中的一些树，比较常见的有二叉树、二叉查找树、平衡二叉树、红黑树、B树、B+树等。</strong></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>定义：是N（N&gt;=0）个节点的有限集合。该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。</p>
<p><img src="https://tc.chaizz.com/f387e3b8447411ec9d7c5254006b8f1d.png" alt="图片"></p>
<center> 普通二叉树（图源网络）</center>

<p>特点：</p>
<ul>
<li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</li>
</ul>
<p>二叉树又有满二叉树和完全二叉树，在此不做详解。</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>定义：二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。是数据结构中的一类。在一般情况下，查询效率比链表结构要高。</p>
<p>特点</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
<li>没有键值相等的结点。</li>
</ul>
<p><img src="https://tc.chaizz.com/09ef2b34447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>二叉查找树（图源网络）</center>



<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>定义：平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p>
<p>特点：</p>
<ul>
<li>非叶子节点最多拥有两个子节点；</li>
<li>非叶子节点值大于左边子节点、小于右边子节点；</li>
<li>树的左右两边的层级数相差不会大于1;</li>
<li>没有值相等重复的节点;</li>
</ul>
<p><img src="https://tc.chaizz.com/1d670808447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>平衡二叉树（图源网络）</center>





<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>定义：红黑树是一种含有红黑结点并能<strong>自平衡</strong>的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个为NIL叶子节点是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</li>
<li>如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</li>
</ul>
<p>红黑树通过三种操作实现自平衡：左旋、右旋、变色。</p>
<p>左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如下图所示。</p>
<p><img src="https://tc.chaizz.com/4b99132e447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>左旋（图源网络）</center>



<p>右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如下图所示。</p>
<p><img src="https://tc.chaizz.com/5da9ea52447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>右旋（图源网络）</center>

<h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>定义：是一种多路平衡查找树（不是二叉树），是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。</p>
<p>特点：</p>
<ul>
<li>根结点至少有两个子节点。</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 。</li>
<li>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 。</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</li>
</ul>
<p><img src="https://tc.chaizz.com/7a76deec447511ec9d7c5254006b8f1d.jpeg" alt="图片"></p>
<center>B 树（图源网络）</center>





<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>定义：B+树是B树的变种，在b树特点的基础上修改了一些特点。</p>
<p>B+树的特点:</p>
<ol>
<li>拥有B树的特点.。</li>
<li>叶子结点之间有指针连接。</li>
<li>非叶子节点不存储数据。</li>
<li>非叶子节点的元素,在叶子节点上都冗余了,也就是叶子结点存储了所有的元素,并且已经排好序。</li>
</ol>
<p><img src="https://tc.chaizz.com/8e88e36c447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<center>B+树（图源网络）</center>



<blockquote>
<p>Mysql 的索引使用的是B+树,因为索引是用来加速查询的，而B+树通过对数据进行排序,是可以提高查询速度的,然后通过一个节点中可以存储多个元素，从而使得B+树的高度不会太高,在Mysql中的一个innodb页就是一个B+树节点,一个innodb页默认为16kb，所以一般情况下B+树可以存大概两千多万行的数据,然后通过利用B+数叶子结点存储了所有的数据并且进行了排序,并且叶子结点之间有指针，可以很好的支持全表扫描,范 围查询等SQL语句。</p>
</blockquote>
<p>MyISAM 引擎的<strong>主键</strong>索引实现是B+树，存放在.myi 文件中。索引文件和数据文件是分开存储的。（非聚集索引）</p>
<p><img src="https://tc.chaizz.com/9a83ff08447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p>InnoDB 引擎<strong>主键</strong>索引实现（聚集索引）。</p>
<p>表数据文件本身就是按照一个B+树组织的一个索引文件结构，存储在 .idb 文件中。</p>
<p><img src="https://tc.chaizz.com/a92ff2a0447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p><strong>引出的问题：</strong></p>
<p><strong>1、MyISAM 和 InnoDB 都是B+树结构他们的区别在哪里？</strong></p>
<ul>
<li>myisam 索引文件和数据文件是分开存储的，即非聚集索引，所以B+树的叶子结点存储的数据文件的指针。</li>
<li>innodb 索引文件和数据文件存储在一个文件中，即聚集索引，该文件结构是按照一个B+树组织的一个索引文件结构。所以叶子节点直接存储的就是数据。</li>
</ul>
<p><strong>2、为什么建议InnoDB引擎的表必须设置主键，并且推荐使用自增主键？</strong></p>
<ul>
<li>因为Mysql的索引就是一个B+树组织的文件，如果没有设置主键，Mysql 会主动找表里面唯一的列，如果没有则会自己创建一个虚拟列，来维护B+树的索引值。在B+树的同一层节点中节点值是连续的从左到右增大。使用自增主键在B+树中进行对比查找效率更高，存储空间更小。如果使用UUID，判断连续需要占用大量的计算。</li>
</ul>
<p><strong>3、为什么非主键索引结构叶子结点存储的是主键值？</strong></p>
<ul>
<li>因为B+树的节点都是有序的，如果是非自增的主键，在插入的时候会导致性能下降。</li>
</ul>
<h2 id="Hash-索引结构"><a href="#Hash-索引结构" class="headerlink" title="Hash 索引结构"></a>Hash 索引结构</h2><p>定义：Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中。hash索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。Memory引擎默认使用的是此种索引。</p>
<p>特点：</p>
<ul>
<li>hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。</li>
</ul>
<ul>
<li>Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</li>
</ul>
<ul>
<li>Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</li>
</ul>
<ul>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li>
</ul>
<p><img src="https://tc.chaizz.com/b71e58b6447511ec9d7c5254006b8f1d.png" alt="图片"></p>
<p>Hash 索引结构和B+树索引结构的区别就是 hash索引结构的特点。</p>
<p>联合索引结构：</p>
<ul>
<li>命名规则：表名_字段</li>
<li>需要加索引的字段，要在where条件中</li>
<li>数据量少的字段不需要加索引</li>
<li>如果where条件中是OR关系，加索引不起作用</li>
<li>符合最左前缀原则</li>
</ul>
<p>联合索引又叫复合索引。对于复合索引:MySQL从左到右的使用索引中的字段，一个查询可以只使用索引中的一部分，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a |  a,b | a,b,c 3种组合进行查找，但不支持 b,c进行查找 ，当最左侧字段是常量引用时，索引就十分有效。</p>
<p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
<h2 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h2><ul>
<li>大大的加快数据查询速度。</li>
</ul>
<h2 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h2><ul>
<li>索引文件需要维护，消耗数据库资源。</li>
<li>可能会占用大量磁盘空间。</li>
<li>当对表的数据进行修改/删除时，会影响效率。（数据库需要对索引结构进行维护）</li>
</ul>
<h2 id="索引的分类："><a href="#索引的分类：" class="headerlink" title="索引的分类："></a>索引的分类：</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ul>
<li><p>设定主键后数据库会自动设置索引，无需手动创建。innodb为聚集索引。</p>
</li>
<li><p>如果不指定主键，数据库会自动查找一列非空的列，设置为主键索引，如果没有唯一数据，数据库则会自动创建一个类似于row_id 来当做主键 索引。</p>
</li>
<li><p>唯一且非空。</p>
</li>
</ul>
<h3 id="单列索引（单值索引、普通索引）"><a href="#单列索引（单值索引、普通索引）" class="headerlink" title="单列索引（单值索引、普通索引）"></a>单列索引（单值索引、普通索引）</h3><ul>
<li>即一个索引只包含一个列，一个表可以有多个单列索引。</li>
</ul>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul>
<li>索引的值必须是唯一的，但是允许为空，只允许一个空值。</li>
</ul>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul>
<li>即一个索引包含多个列。</li>
<li>遵循最左前缀原则。但是数据库也会自适应最左前缀。</li>
</ul>
<h3 id="Full-Text-（全文索引，只能用于MyISAM-）"><a href="#Full-Text-（全文索引，只能用于MyISAM-）" class="headerlink" title="Full Text （全文索引，只能用于MyISAM ）"></a>Full Text （全文索引，只能用于MyISAM ）</h3><ul>
<li>全文索引类型为Full Text ,在定义的索引的列上支持全文查找，允许在这些列上插入重复值和空值。全文索引可以在CHAR、VARCHAR、TEXT类型上创建。</li>
</ul>
<ol>
<li><h2 id="索引的基本操作"><a href="#索引的基本操作" class="headerlink" title="索引的基本操作"></a><strong>索引的基本操作</strong></h2></li>
</ol>
<h3 id="创建普通索引的方式："><a href="#创建普通索引的方式：" class="headerlink" title="创建普通索引的方式："></a>创建普通索引的方式：</h3><ol>
<li><p>建表之后创建：</p>
</li>
<li><p>```sql</p>
<h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><p>create table index_user ( </p>
<pre><code>id INT PRIMARY KEY, NAME VARCHAR ( 20 ) 
</code></pre>
<p>);</p>
<h1 id="为表的某个字段创建索引格式："><a href="#为表的某个字段创建索引格式：" class="headerlink" title="为表的某个字段创建索引格式："></a>为表的某个字段创建索引格式：</h1><p>create index 索引名 on 表名（表的某一列）</p>
<p>create index name_index on index_user(name);</p>
<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><p>show index from index_user;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 建表时创建索引：</span><br><span class="line">6. 创建表无法指定索引名字，索引名默认为列名。</span><br><span class="line"></span><br><span class="line">7. &#96;&#96;&#96;sql</span><br><span class="line">   CREATE TABLE index_user_1 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), KEY ( NAME ) );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
</ol>
<h3 id="创建唯一索引的方式："><a href="#创建唯一索引的方式：" class="headerlink" title="创建唯一索引的方式："></a>创建唯一索引的方式：</h3><ol>
<li><p>建表之后创建索</p>
</li>
<li><p>```sql<br>CREATE UNIQUE INDEX id_card_index ON index_user_2 ( id_card );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 建表时创建索引</span><br><span class="line">6. &#96;&#96;&#96;sql</span><br><span class="line">   CREATE TABLE index_user_2 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), id_card VARCHAR ( 18 ), UNIQUE ( NAME ) );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
</ol>
<h3 id="创建复合索引的方式："><a href="#创建复合索引的方式：" class="headerlink" title="创建复合索引的方式："></a>创建复合索引的方式：</h3><ol>
<li><p>创建表时创建：</p>
</li>
<li><p>```sql<br>CREATE TABLE index_user_3 ( id INT PRIMARY KEY, NAME VARCHAR ( 20 ), id_card VARCHAR ( 18 ), KEY ( NAME, id_card ) );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. ![图片](https:&#x2F;&#x2F;tc.chaizz.com&#x2F;tc&#x2F;640)</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">5. 创建表后创建索引</span><br><span class="line">6. &#96;&#96;&#96;</span><br><span class="line">   CREATE INDEX name_idcard_index ON index_user_3 ( NAME, id_card );</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
</li>
<li></li>
<li><p><strong>复合索引的最左前缀原则：如果索引不包括第一顺序的索引，数据库则不会使用索引查询。MySQL为了更好的利用索引，在查询过程中，回动态的调整索引的顺序，索引当最左的索引不在第一顺序是数据库也能自动的调整顺序。</strong></p>
</li>
</ol>
<h2 id="聚集索引非聚集索引知识点："><a href="#聚集索引非聚集索引知识点：" class="headerlink" title="聚集索引非聚集索引知识点："></a><strong>聚集索引非聚集索引知识点：</strong></h2><p><strong>聚集索引：</strong>将数据存储与索引放在一起，索引结构的叶子结点保存了行数据。</p>
<p><strong>非聚集索引：</strong>将数据与索引分开，索引结构的叶子结点存储的是指向数据文件的指针。</p>
<p>==<strong>注意：在innodb 中，在聚集索引上创建的索引为辅助索引，非聚集索引都是f辅助索引，像复合索引、普通索引、唯一索引。辅助索引叶子结点保存的不是数据行的物理位置 而是主键的值，辅助索引访问数据都是二次查找。</strong>==</p>
<p><strong>InnoDB中使用的是聚集索引，将主键组织到一个B+树中，而行数据就存储在叶子结点上，若使用where id= 1 这样的条件查找主键则按照B+树的检索算法即可快算找到对应的的叶子结点之后获得行数据。</strong></p>
<p><strong>若是对name列进行查找，则需要两个步骤，第一步在辅助索引B+树中检索name，到达辅助索引的叶子结点获得主键索引的ID，第二步在主键索引B+树上根据主键ID进行查找，到达叶子结点节课获取数据行。</strong></p>
<p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
<p><strong>MyISAM 使用的是非聚集索引，B+树结构没什么不同只不过叶子节点上存储的内容不同，主键索引存储了主键，辅助索引存储了辅助键，表数据存储在了独立的地方。以下图中B+树的叶子结点都使用一个内存指针指==向了真正的数据，对于表数据来说，这两个键没有任何差别。由于索引是独立的，通过辅助索引检索无需访问主键索引树。==（索引MyISAM 引擎用来做只含有大量的找找的功能比较合适。）</strong></p>
<p><img src="https://tc.chaizz.com/tc/640" alt="图片"></p>
<h3 id="聚集索引的优势："><a href="#聚集索引的优势：" class="headerlink" title="聚集索引的优势："></a><strong>聚集索引的优势：</strong></h3><p><strong>每次使用辅助索引都要经过两次B+树查找，看上去聚集索引的效率要低于非聚集索引，这不是多此一举吗，聚集索引的优势在哪里？</strong></p>
<ul>
<li>由于行数据和聚集索引的叶子结点存储在一起，同一页中会有多条行数据，访问同一页数据的不同行数据时，已经把叶加载到了缓存中，再次访问时会在内存中完成访问，不需要再次访问磁盘，这样主键荷航数据是一起被到渠道内存中的，找到叶子结点就可以直接将数据返回。如果按照主键ID寻找数据则会更快。</li>
<li>辅助索引的叶子结点存储的是主键值，而不是数据的，好处是当行数据发生改变时索引树的节点也要分裂变化（对索引进行重新排序），或者是我们需要查找的数据在上一次IO读写的时在缓存中没有，需要在发生一次IO操作，可以避免辅助索引的维护工作，另一个好处是辅助索引存储的是主键的值，减少了辅助索引占用的空间的大小。</li>
</ul>
<h3 id="聚集索引需要注意什么？"><a href="#聚集索引需要注意什么？" class="headerlink" title="聚集索引需要注意什么？"></a><strong>聚集索引需要注意什么？</strong></h3><p>使用主键为聚集索引时，最好不要用UUID，因为UUID太过离散，不适合排序，而且可能出现新增记录的UUID会插入到索引树的中间位置，导致索引树的调整复杂度变大，消耗时间和资源。</p>
<p>建议使用Int类型的自增，方便排序并且会在索引树的末尾增加主键值，对索引树的结构影响最小，而且主键占用的存储空间越大，辅助索引中保存的主键值也会变大占用存储空间，也会影响IO操作读取的数据量。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="什么时候无法使用索引？"><a href="#什么时候无法使用索引？" class="headerlink" title="什么时候无法使用索引？"></a>什么时候无法使用索引？</h3><ul>
<li><p>在查询语句中使用like关键字，如果匹配的第一个字符为“%”，索引不会被使用，如果“%”不是在第一个位置，索引就会被使用。</p>
</li>
<li><p>查询的索引字段类型不一致。（隐式类型转换，但不全部都无法使用索引）<strong>可以理解为对字段进行操作的都会失效</strong>。</p>
<p>在Mysql中会自动进行类型转换具体分多种情况：  </p>
<p>1、如果查询条件为单纯的字符串怎MySQL会自动转化为数字 0。  </p>
<p><code>select 0 = &#39;aasd&#39; </code> 结果为 1 代表相等  <code>select 1 = &#39;aasd&#39; </code> 结果为 0 代表不相等<code> select 1 = &#39;1&#39;</code> 结果为 1 代表相等   。</p>
<p>2、如果条件包含带数字和字母的字符串则会转化为该字符串中的数字的值。  <code>select 1 = &#39;1aasd&#39; </code> 结果为 1 代表相等  <code>select 12 = &#39;12aasd&#39; </code> 结果为1 代表相等。</p>
</li>
<li><p>查询中使用多列索引，查询条件不符合最左原则。（不包括最左前缀字段）。</p>
</li>
<li><p>查询语句中使用or 关键字，如果or前后两个都有索引会使用索引，如果有一个没有索引，就不会去使用索引查询。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务与锁机制</title>
    <url>/2021/10/08/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​          </p>
<a id="more"></a>

<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><p><strong>MySQL支持事务的储引擎：InnoDB</strong></p>
<blockquote>
<p>事务是一条或者一组SQL操作语句。</p>
</blockquote>
<p>事务的四大特性：A （atomicity）、C（consistency）、I（isolation）、D（durability）。</p>
<p>满足以上特性的事务操作，才能被称作完整的事务。</p>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>A（atomicity）原子性 ：指一个事务中的所有的操作，要么全部完成，要么全部失败回滚。即像化学中的原子一样是最小单位，不能被分割 。在数据库中是由undo Log（回滚日志） 来实现的。</p>
<p>D（Durability）持久性：事务结束之后对数据的改变是永久的，不会因为外界的干扰而导致数据更改。在数据库中是由redo Log 来实现的。</p>
<p>I（Isolation）隔离性：数据库允许多个事务并发的对数据库同时操作，隔离性可以防止多个事务并发执行而导致的数据不一致。隔离又分为多个隔离级别。在数据库中是由LBCC+MVCC实现的。</p>
<p>C（Consistency）一致性：事务开始前后没数据没有被破坏，开始前后的数据符合预期。</p>
<p>原子性、持久性、隔离性都是为了保证数据的一致性。</p>
<h2 id="事务并发会出现的问题"><a href="#事务并发会出现的问题" class="headerlink" title="事务并发会出现的问题"></a>事务并发会出现的问题</h2><p>事务的并发在没有隔离性控制的情况下会出现<strong>读一致性</strong>的问题</p>
<p>1、脏读：在一个事务中<strong>前后两次查询（针对同一条记录）</strong>得到的不一样的结果是由于其读取到其他的事务<strong>未提交</strong>的数据，这种情况叫做脏读。（未在磁盘中持久化，未提交的数据称为脏数据，所以称为脏读。）</p>
<p>2、不可重复读：在一个事务中<strong>前后两次查询（针对同一条记录）</strong>得到的不一样的结果是由于其读取到其他的事务<strong>已经提交</strong>的数据，这种情况叫不可重复读。</p>
<p>3、幻读：在一个事务中<strong>前后两次查询</strong>得到了不一样的结果数，是由于其读取到其他的事务<strong>已经提交</strong>的<strong>新的（新插入的）</strong>数据，这种情况叫幻读。</p>
<h2 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h2><p><strong>针对以上的事务的并发出现的问题，MySQL给出了四种隔离级别：</strong></p>
<p>1、Read Uncommitted (读未提交) ：未解决事务的并发问题，事务提交的数据对于其他事务也是可见的会出现脏读。</p>
<p>2、Read Committed （读已提交）：解决了脏读的问题，一个事务开始之后只能看到已提交的事务的所做的修改，但是会出现不可重复读的问题。 </p>
<p>3、Repeatable Read（可重复读）：解决不可重复读问题，在同一个事务中，多次读取同样的数据结果是一样的，这种隔离级别解决幻读的问题。</p>
<p>4、Serializable（串行化）：解决所有的问题，最高的隔离级别，让事务强制串行化执行。</p>
<p>在MySQL的InnoDB的存储引擎中实现的隔离级别如下图所示：(全部解决)</p>
<p><img src="https://tc.chaizz.com/640.jpg" alt="图片"></p>
<h2 id="以上隔离级别是如何实现？"><a href="#以上隔离级别是如何实现？" class="headerlink" title="以上隔离级别是如何实现？"></a>以上隔离级别是如何实现？</h2><p>第一种方案：</p>
<p>加锁。在读取数据前，对数据进行加锁，阻止其他的事务对其进行操作。（LBCC：Lock Based Concurrency Control）</p>
<p>第二种方案：</p>
<p>生成一个数据请求时间点的一致性数据快照（snapshot），并用这个快照来提供一定级别的（语句级或者事务级）的一致性读取。（MVCC：Multi Version Concurrency Control） 这种方案只在RC和RR 中使用。</p>
<p><strong>首先MVCC 的大致实现原理：</strong></p>
<p>他的宗旨就是创建多个版本的数据，然后对多个版本的数据进行修改查询，从而实现事务的隔离性。</p>
<p><strong>实现MVCC需要的条件：</strong></p>
<ul>
<li>事务需要被记录版本号（即事务的ID：DB_TRX_ID）在数据库表中以隐藏列的形式存在。</li>
<li>数据库表的聚集索引列ID（<strong>DB_ROW_ID</strong>）。</li>
<li>数据库表中另外的隐藏列：<strong>DB_ROLL_PTR</strong> 是指向undo Log的指针。</li>
<li>undo Log（记录数据被修改之前的日志，数据被修改时会把之前的数据拷贝到undolog，当数据进行回滚时，就根据undolog中的数据进行回滚）。</li>
<li>Read View（可以理解为维护的一个活跃事务ID的列表）。</li>
</ul>
<p>开启一个事务A：会产生一个事务的ID号，同时会在readview中维护当前活跃事务的ID，DB_ROLL_PTR 指针指向事务开启之前的数据的undo Log的地址，事务A的操作始终是在当前记录的undo Log 的那些数据中记性操作，如果有其他的事务对数据操作也会指向一个undo Log的指针，操作他的undo Log的数据，所以事务之间的操作并不会影响。</p>
<h1 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h1><blockquote>
<p>锁是计算机协调多个进程和线程并发访问某一资源的一种机制，锁使用独占的方式来保证在只有一个版本的情况下事务之间的隔离，所以锁可以理解为单版本控制。</p>
</blockquote>
<blockquote>
<p>引入锁之后就可以支持并行处理事务，如果事务之间涉及到相同的数据时，会使用排它锁，或者叫互斥锁，先进入的事务独占数据之后，其他的事务被阻塞，等待前面的事务被释放。</p>
</blockquote>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>  mysql的存储引擎 <strong>InnoDB</strong> 既支持<strong>行锁</strong>也支持<strong>表锁</strong>，<strong>MyISAM 只支持表锁。</strong></p>
<h3 id="从锁的粒度分：表级锁、行级锁、页级锁。"><a href="#从锁的粒度分：表级锁、行级锁、页级锁。" class="headerlink" title="从锁的粒度分：表级锁、行级锁、页级锁。"></a>从锁的<strong>粒度</strong>分：表级锁、行级锁、页级锁。</h3><p>MyISAm引擎在执行查询语句之前，会自动给涉及的表加上读锁，在执行增删改之前会自动给表加上写锁。</p>
<p><strong>简而言之读锁会阻塞写而不会阻塞读，而写锁会将读和写全部阻塞。</strong></p>
<p>行锁与表锁的区别：</p>
<p>锁定的粒度：表锁 &gt; 行锁</p>
<p>加锁的效率：表锁 &gt; 行锁</p>
<p>冲突的概率：表锁 &gt; 行锁</p>
<p>并发的性能：表锁 &lt; 行锁</p>
<p><strong>表级锁：</strong></p>
<p>应用在MyISAM、InnoDB 存储引擎中，但偏向MyISAM引擎，开销小，加锁快，无死锁，锁定的粒度大，发生锁冲突的概率大，并发度比较低。偏向于读操作</p>
<p>MySQL的表级锁有两种，一种是表锁，一种是元数据锁。</p>
<ul>
<li><p>表锁 （手动加锁）</p>
<ul>
<li>Read Lock  （加读锁后可以在加读锁，不能加写锁）</li>
<li>Write Lock （加写锁后不能加读锁和写锁）</li>
</ul>
</li>
<li><p>元数据锁 （自动加锁）</p>
<p>当对表记录进行操作的时候（增删改查），MySQL会自动给表加上一个元数据读锁。即不能对表结构进行修改。</p>
<ul>
<li>DML（对表记录进行操作：增删改）加读锁</li>
<li>DDL （对表结构进行修改） 加写锁</li>
</ul>
</li>
<li><p>意向锁：当为行添加一个共享锁的时候，存储引擎会自动在表上加一个意向共享锁，意向排它锁也是一样。他的作用是提升加表锁的效率。</p>
<ul>
<li>意向共享读锁 </li>
<li>意向排他写锁</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 给book添加写锁 </span><br><span class="line">lock table book write;</span><br><span class="line"></span><br><span class="line"># 给book添加读锁 </span><br><span class="line">lock table &lt;table_name&gt; read;</span><br></pre></td></tr></table></figure>
<p>表锁分析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br><span class="line">In_use 为<span class="number">1</span> 代表该表被锁定</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/254cc64a420c11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;tables%&#x27;</span>;</span><br></pre></td></tr></table></figure>


<p><img src="https://tc.chaizz.com/ab54b6ee420c11ec9d7c5254006b8f1d.png"></p>
<p>这里有两个状态变量记录MySQL表锁定的情况：</p>
<p>Table_locks_immediate：产生表级锁定的次数。</p>
<p><strong>Table_locks_waited：出现表级锁争用二发生的等待的次数。此值越高说明存在着大量的报表级锁竞争情况。</strong></p>
<p>此外MyISAM引擎，的读写锁调度是写优先，这也是MyISAM引擎不适合用作写操作比较多的情况，因为写锁后，其他的线程不能做任何操作，只能被阻塞。</p>
<p><strong>行级别锁：</strong></p>
<p>是由存储引擎InnoDB实现，行级锁，每次锁住一行数据，锁定的粒度最小，发生锁冲突的概率比较小，并发度比较高。</p>
<p>行级锁从锁定的力度上分为：</p>
<p>Record Lock：（记录锁）锁定单个行记录，对精确匹配或者范围匹配在范围内的数据加锁。RC、RR隔离级别都支持。</p>
<p>Gap Lock：（间隙锁）锁定索引记录间隙，确保索引记录的间隙不变。对范围匹配且符合范围条件但不在范围内的数据也进行加锁。RR隔离级别支持。（防止insert）</p>
<p>Next-key Lock：（临建锁）行锁和间隙锁的组合，同时锁住记录和索引间隙。RR隔离级别支持。 </p>
<ul>
<li>共享锁（又称为读锁，S锁） （手动加锁）<ul>
<li><code>select ... lock in sare mode</code></li>
</ul>
</li>
<li>排他锁（又称为写锁，X锁） <ul>
<li>DML（对表记录进行操作：增删改） delete/update/insert 默认加排它锁</li>
<li><code>select ... for update</code>  （当前读）</li>
</ul>
</li>
</ul>
<p>行锁分析：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://tc.chaizz.com/15c2bdb2421411ec9d7c5254006b8f1d.png"></p>
<p><strong>Innodb_row_lock_current_waits：当前正在等待锁定的数量 （比较重要）</strong></p>
<p>Innodb_row_lock_time：从系统启动到现在锁定的总时间长度</p>
<p>Innodb_row_lock_time_avg：每次等待所花的平均时间</p>
<p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p>
<p><strong>Innodb_row_lock_waits：系统启动后到现在总共等待的次数（比较重要）</strong></p>
<p><strong>页级别锁：</strong></p>
<p>开销和加锁时间介于表锁与行锁之间，会出现死锁，锁定的粒度也是介于表锁与行锁之间，并发度一般。</p>
<h3 id="从锁的操作上来说分为读锁和写锁。"><a href="#从锁的操作上来说分为读锁和写锁。" class="headerlink" title="从锁的操作上来说分为读锁和写锁。"></a>从锁的<strong>操作</strong>上来说分为读锁和写锁。</h3><ul>
<li>读锁：针对同一份数据，多个读操作可以同时进行而不会互相影响。所以也叫作共享锁。</li>
<li>写锁：针对同一份数据，当前写操作没有释放锁之前，其他的事务无法对数据进行加锁操作，不管是读锁还是写锁。所以也叫排它锁。</li>
</ul>
<p>读锁可以让读和读并行，而读和写、写和读、写和写要加排它锁。</p>
<h3 id="从实现方式上分为乐观锁和悲观锁。"><a href="#从实现方式上分为乐观锁和悲观锁。" class="headerlink" title="从实现方式上分为乐观锁和悲观锁。"></a>从<strong>实现方式</strong>上分为乐观锁和悲观锁。</h3><h2 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景"></a>锁的使用场景</h2><p>修改数据库表结构会自动加表级锁。</p>
<p>更新数据未使用索引，行锁会上升到表锁。</p>
<p>更新数据使用索引会使用行锁。</p>
<p><code>select ... for update </code> 会使用行级别锁。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQLMVCC机制</title>
    <url>/2021/10/08/MysqlMVCC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<blockquote>
<p>数据库事务的四大特性：</p>
<p>原子性：atomicity 是通过undo log 来实现的。</p>
<p>一致性：consistency  原子性、隔离性、持久性来共同保持一致性。</p>
<p>隔离性：isolation 通过加锁以及MVCC来实现的。</p>
<p>持久性：durability 是通过redo log 实现的。</p>
</blockquote>
<h1 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h1><p>MVCC（Multi - Version - Concurrency - Control）全称是<strong>多版本并发控制</strong>。主要是为了提高数据库的并发性能。MVCC只在<strong>读已提交</strong>和<strong>可重复读</strong>的两个事务级别下有效。主要是用于处理读请求。</p>
<h1 id="MySQL的快照读和当前读是什么？"><a href="#MySQL的快照读和当前读是什么？" class="headerlink" title="MySQL的快照读和当前读是什么？"></a>MySQL的快照读和当前读是什么？</h1><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>他读取数据库记录都是当前最新的版本，会对当前读取的数据进行加锁，防止其他的事务对数据修改，属于悲观锁的一种。</p>
<p>以下操作都是当前读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select lock in share mode # (共享锁)</span><br><span class="line"></span><br><span class="line">select for update  #(排他锁)</span><br><span class="line"></span><br><span class="line">update # (排他锁)</span><br><span class="line"></span><br><span class="line">insert #(排它锁)</span><br><span class="line"></span><br><span class="line">delete  #(排它锁)</span><br><span class="line"></span><br><span class="line"># 串行化事务隔离级别</span><br></pre></td></tr></table></figure>


<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>快照读是基于和 undo log 来实现的，适用于简单 select 语句。           </p>
<p>首先MySQL一条记录里面包含三个隐藏列：<strong>row_id</strong>、<strong>trx_id</strong>、<strong>roll_pointer</strong>以及<strong>ReadView</strong>。</p>
<ul>
<li>row_id ：MySQL的B+树索引特性要求每个表必须要有一个主键。如果没有设置的话，会自动寻找第一个不包含NULL的唯一索引列作为主键。如果还是找不到，就会在这个DB_ROW_ID上自动生成一个唯一值，以此来当作主键。</li>
<li>trx_id：自增的事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID（DELETE语句被当做是UPDATE语句的特殊情况，后面会进行说明）</li>
<li>roll_pointer：回滚指针，通过它可以将不同的版本串联起来，形成版本链。相当于链表的next指针。</li>
</ul>
<h3 id="一张图理解undo-log"><a href="#一张图理解undo-log" class="headerlink" title="一张图理解undo log"></a>一张图理解undo log</h3><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-10-08_22-43-53.png"></p>
<p>以上图中最新的记录name为赵六，他指向前一个版本name为王五，依次类推，王五的上一个版本是李四，李四的上一版本是张三。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p><strong>ReadView的作用？</strong></p>
<p>就是根据事务ID查找对应的数据。那些事务应该读取到那些数据。</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-10-08_22-56-42.png"></p>
<p>m_ids ：当前MySQL中所有的<strong>活跃</strong>（<strong>指未提交的</strong>）的事务的ID。</p>
<p>min_trx_id：表示m_ids 中最小的事务ID。、</p>
<p>max_trx_id：表示生成ReadView时系统应该分配给下一个事物的ID。、</p>
<p>creator_trx_id：生成该ReadView的ID。</p>
<p><strong>ReadView如何判断哪个版本可用？</strong></p>
<ul>
<li>trx_id == creator_trx_id    如果事务ID等于当前生成ReadView的vreator_trx_id ，那么可以访问这个版本。</li>
<li>trx_id  &lt; mix_trx_id 事务ID小于当前ReadView中的最小的活跃事务的ID，说明该事务是已经提交的了事务。那么可以访问。</li>
<li>trx_id  &gt; max_trx_id 事务ID大于当前ReadView中的要分配的事务的ID，说明max_trx_id  是创建ReadView之后生成的ID，已经超出版本链的事务的ID，所以无法读取。</li>
<li>min_trx_id  &lt;=  trx_id  &lt;= max_trx_id 分两种情况：<ul>
<li>① 当trx_id   在min_trx_id   中，说明是活跃的事务的ID，未提交的事务，那么不能访问当前版本。</li>
<li>②当trx_id  不在min_trx_id   中，说明不是活跃的事务的ID，而且小于系统下一个事务的ID，那么可以访问当前版本。</li>
</ul>
</li>
</ul>
<h2 id="MVCC如何实现RR-（可重复读）和RC（读已提交）的？"><a href="#MVCC如何实现RR-（可重复读）和RC（读已提交）的？" class="headerlink" title="MVCC如何实现RR （可重复读）和RC（读已提交）的？"></a>MVCC如何实现RR （可重复读）和RC（读已提交）的？</h2><p><strong>实现RC</strong></p>
<p>RC生成ReadView的事迹是每次select查询的时候就会生成一个ReadView，他是以每个select查询为单位的，比如一个事务中有两个select语句，那么这两个select就会生成两个ReadView，所以在一个事务中就可以读取到其他事务已经提交的数据，就会产生不可重复读的问题。</p>
<p><strong>实现RR</strong></p>
<p>RR 生成ReadView 是根据事务来生成，他是以每个事务为单位生成的。在一个事务中不管有多少查询语句，查询的ReadView还是同一个，所以只能读取到当前版本的数据，就可以解决不可重复读的问题。</p>
<p>InndDB 解决幻读：是通过间隙锁，间隙锁锁住一段范围，所以其他事务无法对这段范围的数据进行才做插入删除，所以就不存在幻读的问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerCompose知识总结</title>
    <url>/2021/09/29/DockerCompose%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、DockerCompose理解"><a href="#一、DockerCompose理解" class="headerlink" title="一、DockerCompose理解"></a>一、DockerCompose理解</h1><blockquote>
<p><a href="https://docs.docker.com/compose/">Docker Compose</a> is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.</p>
<p>The <em>big</em> advantage of using Compose is you can define your application stack in a file, keep it at the root of your project repo (it’s now version controlled), and easily enable someone else to contribute to your project. Someone would only need to clone your repo and start the compose app. In fact, you might see quite a few projects on GitHub/GitLab doing exactly this now.</p>
</blockquote>
<a id="more"></a>

<p>Docker compose 是来管理多个容器的一个工具。</p>
<h2 id="1、安装Docker-Compose"><a href="#1、安装Docker-Compose" class="headerlink" title="1、安装Docker Compose"></a>1、安装Docker Compose</h2><p><a href="https://github.com/docker/compose/releases/download/v2.0.0/docker-compose-linux-amd64">Docker-compose地址</a></p>
<h3 id="1-1-创建cli-plugins-目录"><a href="#1-1-创建cli-plugins-目录" class="headerlink" title="1.1 创建cli-plugins 目录"></a>1.1 创建cli-plugins 目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在github上下载最新版docker-compose ,放在 docker安装用户家目录下 ：root/.docker/cli-plugins</span></span><br><span class="line"></span><br><span class="line">cd .docker</span><br><span class="line">mkdir cli-plugins</span><br></pre></td></tr></table></figure>
<h3 id="1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose"><a href="#1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose" class="headerlink" title="1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose"></a>1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在root/.docker/cli-plugins 目录下</span></span><br><span class="line">mv docker-compose-linux-amd64 docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-3-添加执行权限"><a href="#1-3-添加执行权限" class="headerlink" title="1.3 添加执行权限"></a>1.3 添加执行权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x root/.docker/cli-plugins/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-4-安装低版本"><a href="#1-4-安装低版本" class="headerlink" title="1.4 安装低版本"></a>1.4 安装低版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> docker-compose --version</span><br></pre></td></tr></table></figure>


<p><strong>v2.0.0版本命令为 <code>docker compose </code>中间没有横杠</strong></p>
<h2 id="2、Docker-Componse-官网示例（创建一个Python-web应用）："><a href="#2、Docker-Componse-官网示例（创建一个Python-web应用）：" class="headerlink" title="2、Docker Componse 官网示例（创建一个Python web应用）："></a>2、Docker Componse 官网示例（创建一个Python web应用）：</h2><h3 id="2-1、创建app-py"><a href="#2-1、创建app-py" class="headerlink" title="2.1、创建app.py"></a>2.1、创建<code>app.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span>():</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure>


<h3 id="2-2、创建包文件夹-requirements-txt："><a href="#2-2、创建包文件夹-requirements-txt：" class="headerlink" title="2.2、创建包文件夹 requirements.txt："></a>2.2、创建包文件夹 <code>requirements.txt</code>：</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建Dockerfile文件"><a href="#2-3-创建Dockerfile文件" class="headerlink" title="2.3 创建Dockerfile文件"></a>2.3 创建<code>Dockerfile</code>文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建-docker-compose-yml文件-："><a href="#2-4-创建-docker-compose-yml文件-：" class="headerlink" title="2.4 创建 docker-compose.yml文件 ："></a>2.4 创建 <code>docker-compose.yml</code>文件 ：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-5-在-docker-compose-yml-目录下运行命令"><a href="#2-5-在-docker-compose-yml-目录下运行命令" class="headerlink" title="2.5 在 docker-compose.yml 目录下运行命令"></a>2.5 在 <code>docker-compose.yml</code> 目录下运行命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose up	</span><br></pre></td></tr></table></figure>


<p>出现错误 ：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-29_19-51-36.png"></p>
<p>解决：在Dockerfile中添加下面这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完整的Dockerfile：</span></span><br><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-5-运行成功"><a href="#2-5-运行成功" class="headerlink" title="2.5 运行成功"></a>2.5 运行成功</h3><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-29_20-48-16.png"></p>
<h1 id="二、docker-compose-命令详解"><a href="#二、docker-compose-命令详解" class="headerlink" title="二、docker compose 命令详解"></a>二、docker compose 命令详解</h1><p>结合docker compose 部署多个服务</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line"><span class="comment">#  web:</span></span><br><span class="line"><span class="comment">#    # 用来使用自定义的Dockerfile ，</span></span><br><span class="line"><span class="comment">#    # 使用自己构建的镜像，然后在运行容器</span></span><br><span class="line"><span class="comment">#    build:</span></span><br><span class="line"><span class="comment">#      # 启动服务是先将制定的Dockerfile 构建一个镜像。</span></span><br><span class="line"><span class="comment">#      context: .   #这个路径可以是相对的或者绝对的。一般是dockercompose.yml的当前路径</span></span><br><span class="line"><span class="comment">#      dockerfile:</span></span><br><span class="line"><span class="comment">#    expose: # 对外暴露端口</span></span><br><span class="line"><span class="comment">#      - &quot;8000&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    depends_on:  # 代表这个容器必须依赖其他的容器才能启动（服务名）</span></span><br><span class="line"><span class="comment">#      - my_tomcat2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - &quot;8000:8000&quot;   # 制定映射容器内端口</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    networks:</span></span><br><span class="line"><span class="comment">#      - hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_tomcat2: <span class="comment"># 服务器名称</span></span><br><span class="line">    container_name: tomcat2   <span class="comment"># 自定义容器名称  docker run --name</span></span><br><span class="line">    image: tomcat   <span class="comment"># 镜像名称</span></span><br><span class="line">    restart: always</span><br><span class="line">    ports: <span class="comment">#  端口建议使用字符串    docker run -p</span></span><br><span class="line">      - <span class="string">&quot;8082:8080&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment">#      - /opt/webapps:/usr/local/tomcat/webapps # 自定义路径映射</span></span><br><span class="line">      - <span class="string">&quot;./env/webapps:/usr/local/tomcat/webapps&quot;</span> <span class="comment">#使用数据库名映射</span></span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    depends_on: <span class="comment"># 代表这个容器必须依赖其他的容器才能启动（服务名）</span></span><br><span class="line">      - my_mysql</span><br><span class="line">      - my_redis</span><br><span class="line"></span><br><span class="line">    <span class="keyword">healthcheck</span><span class="bash">: <span class="comment"># 通过命令检测容器是否正常运行</span></span></span><br><span class="line">      test: [ <span class="string">&quot;CMD&quot;</span>,<span class="string">&quot;curl&quot;</span>,<span class="string">&quot;-f&quot;</span>,<span class="string">&quot;http://localhost&quot;</span> ]</span><br><span class="line">      interval: <span class="number">1</span>m30s</span><br><span class="line">      timeout: <span class="number">10</span>s</span><br><span class="line">      retries: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    ulimits:   # 用来修改容器内部的最大进程数</span></span><br><span class="line"><span class="comment">#      nproc: 65535</span></span><br><span class="line"><span class="comment">#      nofile:</span></span><br><span class="line"><span class="comment">#        soft: 20000</span></span><br><span class="line"><span class="comment">#        hard: 40000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    sysctls:   # 用来修改容器内部内核参数，并不是必须的，有些容器启动收到操作系统参数限制需要用到这个命令</span></span><br><span class="line"><span class="comment">#      - net.core.somaxconn=1024</span></span><br><span class="line"><span class="comment">#      - net.ipv4.tcp_syncookies=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_mysql:</span><br><span class="line">    image: mysql:<span class="number">5.7</span></span><br><span class="line">    container_name: mysql</span><br><span class="line">    privileged: true</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./env/mysql/conf.d:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      - <span class="string">&quot;./env/mysql/mysqldata:/var/lib/mysql&quot;</span></span><br><span class="line">      - <span class="string">&quot;./env/mysql/mysqllogs:/logs&quot;</span></span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#      MYSQL_ROOT_PASSWORD: &quot;123456&quot;</span></span><br><span class="line"><span class="comment">#      TZ: Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">    env_file:  <span class="comment"># 将环境变量中的值设置在文件中  必须是以.env 结尾的文件   必须要是键值对的形式或者A=B的形式</span></span><br><span class="line">      - ./<span class="keyword">env</span>/mysql/mysql.<span class="keyword">env</span>    <span class="comment"># 这个文件中就写   MYSQL_ROOT_PASSWORD: &quot;123456&quot;就可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># environment和env_file 写一个就可以</span></span><br><span class="line"></span><br><span class="line">    command:</span><br><span class="line">      --wait_timeout=<span class="number">31536000</span></span><br><span class="line">      --interactive_timeout=<span class="number">31536000</span></span><br><span class="line">      --max_connections=<span class="number">1000</span></span><br><span class="line">      --default-authentication-plugin=mysql_native_password</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  my_redis:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;6379&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/data:/data</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/conf:/usr/local/etc/redis</span><br><span class="line">      - ./<span class="keyword">env</span>/redis/logs:/logs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意 redis.conf 中的 daemonize no   要设置为前台运行。</span></span><br><span class="line">    <span class="comment">#要不然运行了docker compose up , redis自动关闭</span></span><br><span class="line">    command: redis-server /usr/local/etc/redis/redis.conf</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  nginx:</span><br><span class="line">    container_name: nginx</span><br><span class="line">    restart: always</span><br><span class="line">    image: nginx:<span class="number">1.11</span>.<span class="number">6</span>-alpine</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">      - <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/logs:/var/log/nginx</span><br><span class="line">      - ./<span class="keyword">env</span>/nginx/www:/var/www</span><br><span class="line">      - /etc/letsencrypt:/etc/letsencrypt</span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># compose 中运行 portainer</span></span><br><span class="line">  portainer:</span><br><span class="line">    image: portainer/portainer</span><br><span class="line">    container_name: portainer</span><br><span class="line">    volumes:</span><br><span class="line">      - /var/<span class="keyword">run</span><span class="bash">/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      - /opt/portainer/data:/data</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">8000</span>:<span class="number">8000</span></span><br><span class="line">      - <span class="number">9000</span>:<span class="number">9000</span></span><br><span class="line">    networks:</span><br><span class="line">      - hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#volumes:</span></span><br><span class="line"><span class="comment">#  tomcat1webapps:   # 声明指定的卷名，compose会自动加上docker-compose.yml 的外层目录名</span></span><br><span class="line"><span class="comment">#    external:   # 使用自定义的卷名，前提必须存在：需要手动执行docker volume create tomcatwebapps</span></span><br><span class="line"><span class="comment">#      false</span></span><br><span class="line"><span class="comment">#  webapps:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">networks:   <span class="comment"># 声明上面创建的 hello 网桥</span></span><br><span class="line">  hello:</span><br><span class="line">    external:   <span class="comment"># 使用自定义的网桥，前提必须存在 ：需要手动执行docker networks create -d bridge hello</span></span><br><span class="line">      false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker compose up                ：启动所有服务</span></span><br><span class="line">    <span class="comment">#   -f  ：指定dockercompose.yml 文件</span></span><br><span class="line">    <span class="comment">#   -p  ：指项目名称</span></span><br><span class="line">    <span class="comment">#   -d  ：设置所有服务后台运行</span></span><br><span class="line"><span class="comment">#   docker compose down         ：关闭dcokercompose所有服务，会移除网络，不会移除数据卷</span></span><br><span class="line"><span class="comment">#   docker compose exec  [服务名]  ：进入服务对应的容器</span></span><br><span class="line"><span class="comment">#   docker compose ps           ：列出所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose restart   [服务名]  ：列出所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose rm   [服务名]  ：列出所有的容器</span></span><br><span class="line">    <span class="comment"># -f 强制删除</span></span><br><span class="line">    <span class="comment"># -v 删除服务对应容器挂载的数据卷</span></span><br><span class="line"><span class="comment">#   docker compose start   [服务名]  ：启动所有的容器</span></span><br><span class="line"><span class="comment">#   docker compose stop   [服务名]  ：停止所有的容器 （不会移除网络）</span></span><br><span class="line"><span class="comment">#   docker compose top   [服务名]  ：查看所有容器内运行的进程</span></span><br><span class="line"><span class="comment">#   docker compose unpause   [服务名]  ：将挂起的服务恢复</span></span><br><span class="line"><span class="comment">#   docker compose pause   [服务名]  ：挂起某一个服务</span></span><br><span class="line"><span class="comment">#   docker compose logs   [服务名]  ：查看所有服务的日志</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="三、安装Portainer是Docker可视化软件"><a href="#三、安装Portainer是Docker可视化软件" class="headerlink" title="三、安装Portainer是Docker可视化软件"></a>三、安装Portainer是Docker可视化软件</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">docker pull portainer/portainer</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 9000:9000 --name=portainer --restart=always -v /opt/portainer/data:/data -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载汉化版  指定汉化版镜像</span></span><br><span class="line"></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --name=portainer -p 9000:9000 --restart=always -d  --rm  -v /var/run/docker.sock:/var/run/docker.sock -v /opt/portainer/data:/data registry.cn-shenzhen.aliyuncs.com/infrastlabs/portainer-cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问公网IP <span class="doctag">xxx:</span>9000   设置默认密码 ：至少八位</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker、Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerSwarm理解</title>
    <url>/2021/09/29/DockerSwarm%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>​                    </p>
<a id="more"></a>

<h1 id="一、DockerSwarm理解"><a href="#一、DockerSwarm理解" class="headerlink" title="一、DockerSwarm理解"></a>一、DockerSwarm理解</h1><blockquote>
<p>官网解释：</p>
<p>Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.</p>
<p>Docker Engine 1.12 引入了 swarm 模式，使您能够创建一个由一个或多个 Docker 引擎组成的集群，称为 swarm。 swarm 由一个或多个节点组成：在 swarm 模式下运行 Docker Engine 1.12 或更高版本的物理或虚拟机。</p>
</blockquote>
<p><a href="https://docs.docker.com/engine/swarm/">官网地址</a></p>
<p><img src="https://tc.chaizz.com/tc/swarm-diagram.png"></p>
<h2 id="1、Swarm-中有两种类型的节点："><a href="#1、Swarm-中有两种类型的节点：" class="headerlink" title="1、Swarm 中有两种类型的节点："></a>1、Swarm 中有两种类型的节点：</h2><h3 id="1-1、managers-的作用"><a href="#1-1、managers-的作用" class="headerlink" title="1.1、managers 的作用"></a>1.1、managers 的作用</h3><ul>
<li>维护集群状态</li>
<li>集群调度</li>
<li>给集群提供API</li>
</ul>
<p>Swarm 使用Raft来保证分布式一致性。</p>
<blockquote>
<p><a href="https://raft.github.io/">Raft </a>是一种更为简单方便易于理解的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/1372646">分布式算法</a>，主要解决了分布式中的一致性问题。相比传统的<a href="https://baike.baidu.com/item/Paxos%E7%AE%97%E6%B3%95/6632960">Paxos算法</a>，Raft将大量的计算问题分解成为了一些简单的相对<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%AB%8B/3259">独立</a>的子问题。</p>
<p>相比于传统的一致性算法Paxos，Raft有一些自己的独特的特性。比如增加了强领导性，优化了领导的选举过程，在成员发生变化之后依然能够很好的进行工作。</p>
</blockquote>
<p>三个管理器的群体最多可以容忍一个管理器的损失。<br>一个五管理器群可以容忍最大同时丢失两个管理器节点。<br>N 个管理器集群最多可以容忍 (N-1)/2 个管理器的丢失。<br>Docker 建议一个集群最多有七个管理器节点。</p>
<p>在一些分布式任务重，节点个数往往是奇数。是为了能够成功选举出领导，如果是偶数肯能会有得票一致的情况。</p>
<h3 id="1-2、workers"><a href="#1-2、workers" class="headerlink" title="1.2、workers"></a>1.2、workers</h3><p>worker 节点 就是docekr引擎的实例，他的唯一的目的就是执行容器。worker节点不参与 Raft 分布式状态，不做出调度决策，也不为群模式 HTTP API 提供服务。</p>
<h1 id="二、创建集群"><a href="#二、创建集群" class="headerlink" title="二、创建集群"></a>二、创建集群</h1><h2 id="1、初始化集群"><a href="#1、初始化集群" class="headerlink" title="1、初始化集群"></a>1、初始化集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化主节点，使用主节点创建不同类型的节点令牌</span></span><br><span class="line">docker swarm init --advertise-addr 内网地址</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建manager令牌</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建worker令牌</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入一个节点</span></span><br><span class="line">docker swarm join ---token 令牌</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看节点名称</span></span><br><span class="line">docker node ls</span><br></pre></td></tr></table></figure>


<h1 id="三、Docker-服务弹性扩容"><a href="#三、Docker-服务弹性扩容" class="headerlink" title="三、Docker 服务弹性扩容"></a>三、Docker 服务弹性扩容</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Swarm manager 节点下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个服务，具备扩缩容的功能</span></span><br><span class="line">docker service create -p 8888:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接启动三个副本。</span></span><br><span class="line">docker service update --replicas 3 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker、Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Dcoker知识总结</title>
    <url>/2021/09/27/Docker%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production.</p>
</blockquote>
<a id="more"></a>

<h1 id="一、Docker-是什么"><a href="#一、Docker-是什么" class="headerlink" title="一、Docker 是什么"></a>一、Docker 是什么</h1><h2 id="1、Docker-简介"><a href="#1、Docker-简介" class="headerlink" title="1、Docker 简介"></a>1、Docker 简介</h2><p> Docker 是一个用于开发、传送和运行应用程序的开放平台。Docker 使您能够将应用程序与基础设施分开，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产中运行代码之间的延迟。</p>
<p>Docker是基于Google的Go语言开发的。</p>
<h2 id="2、Dcoker-能干什么？"><a href="#2、Dcoker-能干什么？" class="headerlink" title="2、Dcoker 能干什么？"></a>2、Dcoker 能干什么？</h2><p>Docker 能方便的将开发环境打包起来，包括Python、Nginx 、Redis、Mysql、Tomcat等等的开发环境只需要一次部署，然后将他们打包为镜像，接下来只需要拿着这个镜像在不同的服务器中的docker中运行即可得到一个全新的与之前部署的环境完全一样的环境。有点类似于布尔玛的万能胶囊，只是有点..</p>
<h1 id="二、Docker与虚拟机的区别"><a href="#二、Docker与虚拟机的区别" class="headerlink" title="二、Docker与虚拟机的区别"></a>二、Docker与虚拟机的区别</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/271846374">https://zhuanlan.zhihu.com/p/271846374</a></p>
</blockquote>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_16-03-32.png"></p>
<p>传统的虚拟机技术：由于虚拟机是把这个系统内核、系统依赖、硬件资源配置全部打包，组成一个新的系统。他是在硬件的基础上实现虚拟化。所以虚拟机占用的资源比较大，切换比较耗时。</p>
<p>Docker技术：它是直接运行在宿主机上，是系统层面的虚拟化，他不需要自己拥有单独的内核，也没有打包硬件资源，所以他是很轻便的，而且每个容器之间是相互隔离的，类似于一个沙箱。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级·</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘空间</td>
<td>一般为几十MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>操作系统</td>
<td>与宿主机共享OS</td>
<td>在宿主机上运行虚拟机的OS</td>
</tr>
</tbody></table>
<p>Docker的优点：</p>
<ul>
<li>对系统资源能够更高效的利用。</li>
<li>启动速度更快。</li>
<li>一致的运行环境。</li>
<li>维护和扩展更加的容易。</li>
<li>应用更快的交付与部署</li>
</ul>
<h1 id="三、Docker-的基本组成"><a href="#三、Docker-的基本组成" class="headerlink" title="三、Docker 的基本组成"></a>三、Docker 的基本组成</h1><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_16-23-06.png"></p>
<h2 id="Docker的三大组件："><a href="#Docker的三大组件：" class="headerlink" title="Docker的三大组件："></a>Docker的三大组件：</h2><h3 id="1、镜像："><a href="#1、镜像：" class="headerlink" title="1、镜像："></a>1、镜像：</h3><p>Docker的镜像好比一个文件模板（分层的），有各种各样的模板，这个模板就是一些具体的应用以及对应的资源。比如说一个Nginx 镜像 就是一个包含Nginx的模板。他需要在一个Ubuntu或者其他系统镜像上安装那么就是一个可运行的Nginx镜像。</p>
<h3 id="2、容器："><a href="#2、容器：" class="headerlink" title="2、容器："></a>2、容器：</h3><p>容器类似于一个沙箱，是基于镜像来创建的，多个镜像可以组成一个容器，他是独立运行的，可以启动、暂停、删除容器等操作。</p>
<h3 id="3、仓库："><a href="#3、仓库：" class="headerlink" title="3、仓库："></a>3、仓库：</h3><p>仓库就是用来存放镜像的地方，这个概念和git是一样的，有共有仓库和私有仓库。</p>
<h1 id="四、Dcoker的安装与卸载"><a href="#四、Dcoker的安装与卸载" class="headerlink" title="四、Dcoker的安装与卸载"></a>四、Dcoker的安装与卸载</h1><h2 id="1、Ubuntu-18-04-手动安装下安装"><a href="#1、Ubuntu-18-04-手动安装下安装" class="headerlink" title="1、Ubuntu 18.04 手动安装下安装"></a>1、Ubuntu 18.04 手动安装下安装</h2><blockquote>
<p>安装前提：</p>
<p>系统：Ubuntu 18.04 LTS   </p>
<p>系统内核 ：4.15.0-136-generic</p>
</blockquote>
<p>具体的操作系统根据Docker的<a href="https://docs.docker.com/engine/install/ubuntu/">官网</a>来选择不同的安装方法。</p>
<h3 id="1、卸载旧版本"><a href="#1、卸载旧版本" class="headerlink" title="1、卸载旧版本"></a>1、卸载旧版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
<h3 id="2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库"><a href="#2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库" class="headerlink" title="2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库"></a>2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"> </span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>
<h3 id="3、添加Docker官方的GPG密钥"><a href="#3、添加Docker官方的GPG密钥" class="headerlink" title="3、添加Docker官方的GPG密钥"></a>3、添加Docker官方的GPG密钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、设置稳定存储库"><a href="#4、设置稳定存储库" class="headerlink" title="4、设置稳定存储库"></a>4、设置稳定存储库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h3 id="5、安装Docker"><a href="#5、安装Docker" class="headerlink" title="5、安装Docker"></a>5、安装Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<h3 id="6、验证是否安装成功"><a href="#6、验证是否安装成功" class="headerlink" title="6、验证是否安装成功"></a>6、验证是否安装成功</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<h3 id="7、卸载Docker"><a href="#7、卸载Docker" class="headerlink" title="7、卸载Docker"></a>7、卸载Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>
<h3 id="8、配置阿里云镜像加速"><a href="#8、配置阿里云镜像加速" class="headerlink" title="8、配置阿里云镜像加速"></a>8、配置阿里云镜像加速</h3><p>直接在阿里云首页搜索<strong>容器镜像服务</strong>，登录注册后 –&gt; 进入镜像工具 –&gt; 镜像加速器。具体页面如下：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_17-03-26.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://1xxxxxx5.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2、官网也提供了一种方便的脚本安装方法："><a href="#2、官网也提供了一种方便的脚本安装方法：" class="headerlink" title="2、官网也提供了一种方便的脚本安装方法："></a>2、官网也提供了一种方便的脚本安装方法：</h2><h3 id="1、只需要两条命令："><a href="#1、只需要两条命令：" class="headerlink" title="1、只需要两条命令："></a>1、只需要两条命令：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line"></span><br><span class="line">sudo sh test-docker.sh</span><br></pre></td></tr></table></figure>
<p>运行第一条命令后可能会出现以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to get.docker.com:443</span><br></pre></td></tr></table></figure>
<p>原因大概就是无法访问外国的网站，加个提子就行。</p>
<p>接下来运行 执行脚本命令。即可等待自动安装。</p>
<p>使用以下命令可查看 在执行命令过程中运行了那些命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DRY_RUN=1 sh ./get-docker.sh</span><br></pre></td></tr></table></figure>
<h3 id="2、安装完毕后检查docker是否启动"><a href="#2、安装完毕后检查docker是否启动" class="headerlink" title="2、安装完毕后检查docker是否启动"></a>2、安装完毕后检查docker是否启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<h3 id="3、启动docker"><a href="#3、启动docker" class="headerlink" title="3、启动docker"></a>3、启动docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="4、安装完毕后查看是否正确安装：-提示docker的一些信息"><a href="#4、安装完毕后查看是否正确安装：-提示docker的一些信息" class="headerlink" title="4、安装完毕后查看是否正确安装：(提示docker的一些信息)"></a>4、安装完毕后查看是否正确安装：(提示docker的一些信息)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info </span><br></pre></td></tr></table></figure>
<h3 id="5、设置docker开机自动启动"><a href="#5、设置docker开机自动启动" class="headerlink" title="5、设置docker开机自动启动"></a>5、设置docker开机自动启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure>
<h3 id="6、建立docker组-将root用户加入docker组-（此步骤可做可不做）"><a href="#6、建立docker组-将root用户加入docker组-（此步骤可做可不做）" class="headerlink" title="6、建立docker组 将root用户加入docker组 （此步骤可做可不做）"></a>6、建立docker组 将root用户加入docker组 （此步骤可做可不做）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd docker</span><br><span class="line"></span><br><span class="line">usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<h3 id="7、重启docker"><a href="#7、重启docker" class="headerlink" title="7、重启docker"></a>7、重启docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="8、配置镜像加速与上面一致"><a href="#8、配置镜像加速与上面一致" class="headerlink" title="8、配置镜像加速与上面一致"></a>8、配置镜像加速与上面一致</h3><h3 id="9、安装docker-compose-v2"><a href="#9、安装docker-compose-v2" class="headerlink" title="9、安装docker-compose v2"></a>9、安装docker-compose v2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录  针对所有用户</span></span><br><span class="line">mkdir -p /usr/local/lib/docker/cli-plugins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者在家目录下创建  针对当前用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /.docker/cli-plugins</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载二进制版本文件 地址：https://github.com/docker/compose/releases</span></span><br><span class="line">wget https://github.com/docker/compose/releases/download/v2.1.1/docker-compose-linux-x86_64 -O docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为可执行文件</span></span><br><span class="line">chmod +x /usr/local/lib/docker/cli-plugins/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否安装成功</span></span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure>






<h1 id="五、Docker-基本命令"><a href="#五、Docker-基本命令" class="headerlink" title="五、Docker 基本命令"></a>五、Docker 基本命令</h1><p><a href="https://docs.docker.com/reference/">Docker 官网文档命令</a></p>
<h2 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示docker版本</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助信息</span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h2 id="2、镜像基础命令"><a href="#2、镜像基础命令" class="headerlink" title="2、镜像基础命令"></a>2、镜像基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">-a   显示全部的镜像</span><br><span class="line">-q   只显示全部的镜像ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索镜像</span></span><br><span class="line">docker search &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line">--filter=starts==300   根据镜像starts搜索，大于3000的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像，如果不写版本默认拉取最新版</span></span><br><span class="line">docker pull &lt;镜像名&gt;[:tag]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定镜像版本</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的镜像  （可删除多个镜像）</span></span><br><span class="line">docker rmi &lt;镜像ID&gt;   &lt;镜像ID&gt;   &lt;镜像ID&gt; </span><br><span class="line">-f  强制删除</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除全部的镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3、容器基础命令"><a href="#3、容器基础命令" class="headerlink" title="3、容器基础命令"></a>3、容器基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建容器并启动</span></span><br><span class="line">docker run [--options] images</span><br><span class="line"></span><br><span class="line">--name=&quot;Name&quot;   给容器起别名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过后台的方式启动的时候，在使用docker ps 发现没有正在运行的容器，是因为docker发现前台没有使用当前容器就会自动杀死当前容器。</span> </span><br><span class="line">-d             后台方式启动 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-it            使用交互方式运行，进入容器查看内容</span><br><span class="line">-p             指定容器的端口    8080:8080</span><br><span class="line">	-p IP:主机端口：容器端口 (常用)</span><br><span class="line">	-p 主机端口：容器端口 (常用)</span><br><span class="line">	-p 容器端口</span><br><span class="line">	</span><br><span class="line">-P             随机指定端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前所有正在运行的容器</span></span><br><span class="line">dcoker ps</span><br><span class="line"></span><br><span class="line">-a             列出当前所有正在运行的容器和历史运行的容器</span><br><span class="line">-n=?           列出最近运行的容器</span><br><span class="line">-q             只显示容器的ID</span><br><span class="line"></span><br><span class="line">-v </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">直接停止容器并退出容器</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">不停止容器并退出容器</span></span><br><span class="line">ctrl + p + q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定容器</span></span><br><span class="line">dcoker rm 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除所有容器</span></span><br><span class="line">dcoker rm -f  %(dcoker ps -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">docker start 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器</span></span><br><span class="line">docker restart 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制停止容器</span></span><br><span class="line">docker kill 容器ID</span><br></pre></td></tr></table></figure>
<h2 id="4、其他常用命令"><a href="#4、其他常用命令" class="headerlink" title="4、其他常用命令"></a>4、其他常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看docker日志</span></span><br><span class="line">docker logs  -tf --tail 10 容器ID</span><br><span class="line"></span><br><span class="line">-t            显示时间戳</span><br><span class="line">-f            跟踪日志输出</span><br><span class="line">--tail 10     输出指定行数       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器进程信息</span></span><br><span class="line">docker top 容器ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器的元数据</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (以交互式，进入容器开启一个新的终端)</span></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (进入正在运行的命令终端，如果没有进入默认终端)</span></span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从容器内拷贝文件到宿主机上</span></span><br><span class="line">docker cp 容器Id:文件路径  目的主机路径 </span><br></pre></td></tr></table></figure>


<h1 id="六、运行常见服务容器"><a href="#六、运行常见服务容器" class="headerlink" title="六、运行常见服务容器"></a>六、运行常见服务容器</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建MySQL配制间文件以及数据文件挂载目录</span></span></span><br><span class="line">mkdir /opt/mysqldata</span><br><span class="line">mkdir /opt/mysqlconf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取指定版本镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行容器</span></span><br><span class="line">docker run --name mysql-name -p 3307:3306 --restart=always -v /opt/mysql_volume/mysqldata:/var/lib/mysql -v /opt/mysql_volume/mysqllogs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 --character-set-server=utf8mb4</span><br></pre></td></tr></table></figure>


<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建Redis配制间文件以及数据文件挂载目录</span></span></span><br><span class="line">mkdir /opt/redisdata    存放redis rdb 持久化的数据</span><br><span class="line">mkdir /opt/redisconf   # 存放redis 的配置文件 redis.conf  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取指定版本镜像</span></span><br><span class="line">docker pull redis:5.0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis 配置文件</span> </span><br><span class="line"></span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 6388</span><br><span class="line">appendonly yes</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定配置文件启动</span></span><br><span class="line">docker run -d --name redis-name -p 6388:6388 --restart=always -v /opt/redis_volume/redisdata:/data -v /opt/redis_volume/redisconf:/usr/local/etc/redis -e TZ=Asia/Shanghai redis:5.0.1 redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>


<h2 id="Elasticsearch-、Kibana"><a href="#Elasticsearch-、Kibana" class="headerlink" title="Elasticsearch 、Kibana"></a>Elasticsearch 、Kibana</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建网桥 ， 可以不用。</span></span><br><span class="line">docker network create somenetwork</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  -e <span class="string">&quot;discovery.type=single-node&quot;</span>   以单节点的形式启动 ， 可以不加</span></span><br><span class="line">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag</span><br></pre></td></tr></table></figure>


<p>使用docker ps 查看，发现elasticsearch没有正在运行， 使用docker logs -f  容器ID 提示一下错误：大致就是没有足够的内存供 Java 运行时环境继续使用。</p>
<p><img src="https://tc.chaizz.com/497261de494511ec9d7c5254006b8f1d.png"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开文件</span></span><br><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在末尾加上  值为262144或者更大。</span></span><br><span class="line">vm.max_map_count = 262144</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存 启用</span></span><br><span class="line">sysctl -p </span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂在数据和配置文件  （单节点启动）</span></span><br><span class="line"></span><br><span class="line">docker pull elasticsearch:7.14.2</span><br><span class="line"></span><br><span class="line">docker run -d --restart=always --name elasticsearch -p 9200:9200 -p 9300:9300  -v esdata:/usr/share/elasticsearch/data -v esconfig:/usr/share/elasticsearch/config -v esplugins:/usr/share/elasticsearch/plugins -e &quot;discovery.type=single-node&quot; elasticsearch:7.14.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>下载 Kibana </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.14.2</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name kibana -p 5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://101.35.188.40:9200&quot; -e &quot;I18N_LOCALE=zh-CN&quot; kibana:7.14.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将kibana的配置文件挂载出来，在配置文件中连接elasticsearch</span></span><br><span class="line">docker run -d --restart=always --name kibana -p 5601:5601 -v kibanaconf:/usr/share/kibana/config -e &quot;I18N_LOCALE=zh-CN&quot; kibana:7.14.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker、Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora设置七牛云图床</title>
    <url>/2021/09/26/Typora%E8%AE%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<a id="more"></a>

<blockquote>
<p>Markdown是一种<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/52671915">轻量级标记语言</a>，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的<a href="https://baike.baidu.com/item/%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/9862288">纯文本格式</a>编写文档，然后转换成有效的<a href="https://baike.baidu.com/item/XHTML/316621">XHTML</a>（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
<p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如<a href="https://baike.baidu.com/item/GitHub/10145341">GitHub</a>、<a href="https://baike.baidu.com/item/Reddit/1272010">Reddit</a>、<a href="https://baike.baidu.com/item/Diaspora/10726893">Diaspora</a>、[Stack Exchange](<a href="https://baike.baidu.com/item/Stack">https://baike.baidu.com/item/Stack</a> Exchange/13777796)、<a href="https://baike.baidu.com/item/OpenStreetMap/3171606">OpenStreetMap</a> 、<a href="https://baike.baidu.com/item/SourceForge/6562141">SourceForge</a>、<a href="https://baike.baidu.com/item/%E7%AE%80%E4%B9%A6/5782216">简书</a>等，甚至还能被使用来撰写<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E4%B9%A6/346054">电子书</a>。</p>
</blockquote>
<h1 id="一、设置前提："><a href="#一、设置前提：" class="headerlink" title="一、设置前提："></a>一、设置前提：</h1><p>Typora 版本：0.11.8|<br>已注册七牛云账号：</p>
<ul>
<li>秘钥AK ：virqOxxxxxxxxxxxxxxxxxxxxxxxxMnNIK</li>
<li>秘钥SK：dDFGSasdfxxxxxxxxxxxxxxxxxxxiZiOVu</li>
<li>存储空间名称：cz-tuchuang</li>
<li>自定义域名：<a href="https://tc.chaizz.com/">https://tc.chaizz.com</a></li>
<li>存储区域代码：我的是华北  所以就是 ：z0<br><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-26_19-22-09.png"></li>
</ul>
<h1 id="二、开始设置"><a href="#二、开始设置" class="headerlink" title="二、开始设置"></a>二、开始设置</h1><p>打开Typora  偏好设置–&gt; 图像 –&gt;插入图片时… –&gt; 上传服务 –&gt; 选择 上传图片。</p>
<p>打开Typora  偏好设置–&gt; 图像 –&gt;上传服务设定 –&gt; 上传服务 –&gt; 选择 PicGo-Core (command line)。</p>
<p>点击<strong>下载或更新</strong>按钮，会提示下载一个PicGo插件，等待下载完成点击<strong>打开配置文件</strong>，打开以后默认是空的。复制下面代码覆盖打开的文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;qiniu&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;qiniu&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;accessKey&quot;</span>: <span class="string">&quot;virqOxxxxxxxxxxxxxxxxxIK&quot;</span>,  <span class="comment">// 你的七牛云AK</span></span><br><span class="line">			<span class="attr">&quot;secretKey&quot;</span>: <span class="string">&quot;dDFGSxxxxxxxxxxxxxxxxxVu&quot;</span>,  <span class="comment">// 你的七牛云SK</span></span><br><span class="line">			<span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;cz-tuchuang&quot;</span>,                  <span class="comment">// 你的七牛云存储空间名</span></span><br><span class="line">			<span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://tc.chaizz.com&quot;</span>,           <span class="comment">// 你的七牛云自定义域名</span></span><br><span class="line">			<span class="attr">&quot;area&quot;</span>: <span class="string">&quot;z1&quot;</span>,                             <span class="comment">// 存储区域编号</span></span><br><span class="line">			<span class="attr">&quot;options&quot;</span>: <span class="string">&quot;&quot;</span>,                            <span class="comment">// 网址后缀,可不填</span></span><br><span class="line">			<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;tc/&quot;</span>,                            <span class="comment">// 自定义存储路径，比如 img/ 可不填</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	<span class="attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来点击 <strong>验证图片上传选项</strong> 按钮。上传成功会提示图下图所示：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-26_19-35-24.png"></p>
<p>点击OK ，重启Typora上传图片即可上传到七牛云了。</p>
]]></content>
      <categories>
        <category>写作工具</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识巩固</title>
    <url>/2021/09/26/Redis%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<p>​                </p>
<a id="more"></a>

<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
</blockquote>
<h1 id="一、Redis-安装"><a href="#一、Redis-安装" class="headerlink" title="一、Redis 安装"></a>一、Redis 安装</h1><p>安装前提：Linux 系统 ubuntu 18.04  / Redis 版本：<a href="https://download.redis.io/releases/redis-6.2.5.tar.gz">6.2.5</a><br>1、检查系统是否安装了gcc 编译器。如果已经安装了 则会显示gcc 的版本号信息，如果没有安装，则使用系统的包管理器安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 gcc</span></span><br><span class="line">sudo apt-get install gcc </span><br></pre></td></tr></table></figure>

<p>2、在Redis官网下载Redis压缩包并解压。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.5.tar.gz</span><br><span class="line">tar -zxvf redis-6.2.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、进入解压后的Redis目录，编译安装Redis。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.5</span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>

<p>4、Redis 默认安装在Linux的usr/local/bin 目录下。</p>
<p>5、启动Redis 。（这种方式是在前台运行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line">    # 后台运行 ，首先更改Redis的配置文件（redis.conf），找到daemonize no 将 no 改为yes 。然后再启动Redis 即可在后台运行。</span><br></pre></td></tr></table></figure>


<h1 id="二、Redis-基础命令"><a href="#二、Redis-基础命令" class="headerlink" title="二、Redis 基础命令"></a>二、Redis 基础命令</h1><p>Redis<a href="http://redis.cn/commands.html">的命令文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择Redis数据库 一共0到15 16个数据库，默认使用0数据库。</span></span><br><span class="line">select 0-15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前库所有的key</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断key是否存在</span></span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的类型</span></span><br><span class="line">type key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除key</span></span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据value选择非阻塞删除（异步删除）</span></span><br><span class="line">unlink key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为给定的key 设置超时时间 （以秒为单位）</span></span><br><span class="line">expire key 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的过期时间 （获取的值为-1:代表永不过期，-2：已经过期）</span></span><br><span class="line">ttl key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看库中的key的数量</span></span><br><span class="line">dbsise</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空当前库</span></span><br><span class="line">flushdb </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通杀全部库</span></span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>

<h1 id="三、Redis-五大常用数据类型"><a href="#三、Redis-五大常用数据类型" class="headerlink" title="三、Redis 五大常用数据类型"></a>三、Redis 五大常用数据类型</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h2><p>String是Redis常用的基本类型，对应的格式是一个key对应一个value，String是二进制安全的，意味着string可以存储任意的类型，包括图片或者序列化的对象。一个Redis中String类型value的值最多可以是512M。</p>
<h3 id="1-1-String-的基本命令"><a href="#1-1-String-的基本命令" class="headerlink" title="1.1 String 的基本命令"></a>1.1 String 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置key value</span></span><br><span class="line">set &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的值</span></span><br><span class="line">get &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的长度</span></span><br><span class="line">strlen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key value   只有key不存在时 设置key的值</span></span><br><span class="line">setnx &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增1</span></span><br><span class="line">incr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增自定义的大小（值为负数则相反）</span></span><br><span class="line">incrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减1</span></span><br><span class="line">decr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减自定义大小 （值为负数则相反）</span></span><br><span class="line">decrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value</span></span><br><span class="line">mset &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value  (当且仅当所有的key都不存在，才能设置成功)</span></span><br><span class="line">msetnx &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取值的范围  （起始位置，结束位置 都包括在内）</span></span><br><span class="line">getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用新的value覆盖key存储的value,索引从0开始</span></span><br><span class="line">setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key的过期时间 ,单位是秒</span></span><br><span class="line">setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以新换旧，设置了新的值，同时获得旧值</span></span><br><span class="line">getset &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-String-的数据结构"><a href="#1-2-String-的数据结构" class="headerlink" title="1.2 String 的数据结构"></a>1.2 String 的数据结构</h3><p>String 的数据结构为简单的动态的字符串（Simple Dynamic String 缩写SDS），是可以修改的字符串，采用预分配冗余空间的方式，来减少内存的频繁分配。<br><img src="https://tc.chaizz.com/44e5fba2450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h2><p>List 是简单的字符串列表，按照插入的顺序排序，可以添加一个元素到字符串的头部或者尾部。他的底层实际上十个双向链表，对两端的操作性能很高，通过索引下标操作中间的节点性能比较差。</p>
<h3 id="2-1-List的基本命令"><a href="#2-1-List的基本命令" class="headerlink" title="2.1 List的基本命令"></a>2.1 List的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从左边插入一个或者多个值， 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">lpush &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右边插入一个或者多个值 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">rpush  &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值  值在键在 ，值光键亡</span></span><br><span class="line">lpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值 值在键在 ，值光键亡</span></span><br><span class="line">rpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key1列表右边取一个值，放到key2左边</span></span><br><span class="line">rpoplpush &lt;key1&gt; &lt;key2&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照索引下标获取元素 （从左到右）  0 -1 ：代表获取所有的值</span></span><br><span class="line">lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据索引下标获取元素，</span>    </span><br><span class="line">lindex &lt;key&gt; &lt;index&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表长度</span></span><br><span class="line">llen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在value的前/后面插入新的value</span></span><br><span class="line">linsert &lt;key&gt; before/after &lt;value&gt; &lt;new value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边删除第n个value   (从左到右)</span></span><br><span class="line">lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将列表key 下标为index的值替换为value</span></span><br><span class="line">lset &lt;key&gt;  &lt;index&gt;  &lt;value&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-List-的数据结构"><a href="#2-2-List-的数据结构" class="headerlink" title="2.2 List 的数据结构"></a>2.2 List 的数据结构</h3><p>List 的数据结构为quicklist。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。他将所有的元素紧挨着一块存储，分配的是一块连续的内存。<br>当数据量比较多的时候，才会改为quicklist，因为普通的链表需要的附加的指针空间更大，会比较浪费空间。<br>比如列表里面存储的只是Int的类型的数据，结构上还需要两个额外的指针：prev和next。<br><img src="https://tc.chaizz.com/4e0057b4450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist 使用双向指针串起来，这样既满足了插入删除性能，又不会出现太大的空间冗余。如上图所示。</p>
<h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h2><h3 id="3-1-Set的基本命令"><a href="#3-1-Set的基本命令" class="headerlink" title="3.1  Set的基本命令"></a>3.1  Set的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素添加到集合key中，已经存在的member元素将会被忽略</span></span><br><span class="line">sadd &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出该集合的所有值</span></span><br><span class="line">smembers &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断集合key是否有该value值，存在为1 不存在为0</span></span><br><span class="line">sismember &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该集合的元素个数</span></span><br><span class="line">scard &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合的某些个元素</span></span><br><span class="line">srem &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  随机丛集中吐出一个值，会从该集合中删除</span></span><br><span class="line">spop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 随机从该集合中取出n个值, 不会从该集合中删除</span></span><br><span class="line">srandmember &lt;key&gt; &lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把集合中一个值移动到另一个集合中</span></span><br><span class="line">smove &lt;key1&gt; &lt;key2&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的交集元素</span></span><br><span class="line">sinter &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的并集元素</span></span><br><span class="line">sunion &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  返回两个集合的差集元素（key1 中的 不包括Key2中的）</span></span><br><span class="line">sdiff &lt;key1&gt; &lt;key2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Set-的数据结构"><a href="#3-2-Set-的数据结构" class="headerlink" title="3.2 Set 的数据结构"></a>3.2 Set 的数据结构</h3><p>Set 的数据结构是dict字典，字典是使用哈希表实现的。所有的value 都指向同一个内部的值。</p>
<h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4 Hash"></a>4 Hash</h2><h3 id="4-1-Hash的基本命令"><a href="#4-1-Hash的基本命令" class="headerlink" title="4.1 Hash的基本命令"></a>4.1 Hash的基本命令</h3><p>Redis 的Hash是一个键值对集合，是一个String类型的field和value 的映射表，Hash特别适合存储对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给key集合中的field 键赋值value</span></span><br><span class="line">hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key集合field中取出value</span></span><br><span class="line">hget &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置<span class="built_in">hash</span>的值</span></span><br><span class="line">hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; &lt;field3&gt; &lt;value3&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看<span class="built_in">hash</span>表key中,给定域field 是否存在 ，存在返回1 不存在返回0</span></span><br><span class="line">hxists &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的field</span></span><br><span class="line">hkeys &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的value</span></span><br><span class="line">hvals &lt;keys&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值加上增量1 -1</span> </span><br><span class="line">hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值设置为value 当且仅当该域不存在</span></span><br><span class="line">hsetnx  &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-Hsh-的数据结构"><a href="#4-2-Hsh-的数据结构" class="headerlink" title="4.2 Hsh 的数据结构"></a>4.2 Hsh 的数据结构</h3><p>Hash 类型对应的数据机构有两种：ziplist （压缩列表） 和 hashlist（哈希列表） ，当field-value 的长度较短且个数较少的时候，使用ziplist，否则使用hashlist。</p>
<h2 id="5-ZSet"><a href="#5-ZSet" class="headerlink" title="5 ZSet"></a>5 ZSet</h2><p>Redis的有序集合和Set 类似，是一个没有重复元素的字符串集合，不同之处是有序集合的每个成员都关联了一个<strong>评分</strong>，这个<strong>评分</strong>被用来按照从最低到最高的方式排序集合中的成员，<strong>集合的成员是唯一的，但是评分可以重复。</strong></p>
<p>因为元素是有序的，所以可以很快的根据评分或者次序来获得一个范围的元素。</p>
<p>访问集合中的元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="5-1-ZSet-的基命令"><a href="#5-1-ZSet-的基命令" class="headerlink" title="5.1 ZSet 的基命令"></a>5.1 ZSet 的基命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素及其其score值加入到有序集key当中</span></span><br><span class="line">zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，下标在 &lt;start&gt; &lt;stop&gt; 之间的元素, 带 withscores可以让分数一起和值返回到结果集</span></span><br><span class="line">zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，所有的score值介于min 和max 之间 （包括min 或者 max）的成员，有序集成员按照score值递增(从小到大依次排列)</span></span><br><span class="line">zrangebyscore &lt;key &gt; &lt;min&gt; &lt;max&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，改为由大到小排列</span></span><br><span class="line">zrangebyscore &lt;key&gt; &lt;max&gt; &lt;min&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为元素的score加上增量</span></span><br><span class="line">zinceby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除该集合下 指定值的元素</span></span><br><span class="line">zrem &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计该集合，分数区间的元素个数</span></span><br><span class="line">zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该值在集合中的排名， 从0开始</span></span><br><span class="line">zrank &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Zset-的数据结构"><a href="#5-2-Zset-的数据结构" class="headerlink" title="5.2 Zset 的数据结构"></a>5.2 Zset 的数据结构</h3><p>SortedSet 是Redis的一个特别的数据结构，他的底层使用了两个数据结构。</p>
<ol>
<li>hash，hash 的作用就是关联元素value和权重score，保障元素value的唯一性们可以通过元素value找到相应的score。</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素的列表。</li>
</ol>
<h2 id="6-Bitmaps"><a href="#6-Bitmaps" class="headerlink" title="6  Bitmaps"></a>6  Bitmaps</h2><p>BItmaps 本身并不是一种数据类型，实际上他就是字符串，key-value ,但是他可以对字符串进行位操作。<br>Bitmaps 单独提供了一套目命令，所以在Redis 中使用Bitmaps和使用字符串方法不一样，可以吧Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1数组的下标在Bitmaps中叫偏移量。</p>
<h3 id="6-1-Bitmaps-的基本命令"><a href="#6-1-Bitmaps-的基本命令" class="headerlink" title="6.1  Bitmaps 的基本命令"></a>6.1  Bitmaps 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  设置Bitmaps 中某个偏移量的值 0 或 1， offset的偏移量从0开始</span></span><br><span class="line">setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取Bitmaps中某个偏移量的值</span></span><br><span class="line">getbit &lt;key&gt; &lt;offset&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计字符串被设置为1的Bit数,一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start end 参数，可以让计数只在特定的位上进行，start和end都可以使用负值，比如-1表示最后一位,-2表示倒数第二个，start 和end是指bit组的字节下标数，二者皆包含。</span></span><br><span class="line">bitcount &lt;key&gt; &lt;start&gt; &lt;end&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> bitop  是一个复合操作，他可以做多个bitmaps的and （交集）、or（并集）、not (非)、xor（异或）操作，并将结果保存在destkey中。</span></span><br><span class="line">bitop  and/or/not/xor &lt;destkey&gt; &lt;key&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7  HyperLogLog"></a>7  HyperLogLog</h2><h3 id="7-1-HyperLogLog-的基本命令"><a href="#7-1-HyperLogLog-的基本命令" class="headerlink" title="7.1 HyperLogLog 的基本命令"></a>7.1 HyperLogLog 的基本命令</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常大的时候计算基数所需要空间总是固定的，并且是很小的。<br>在Redis里面每个HyperLogLog 键只需要花费12KB内存，就可以计算接近2^64个不同的基数，这和计算基数时元素越多消耗内存就越多的集合形成鲜明对比。<br>但是HyperLogLog 只会根据输入元素计算基数，而不会存储输入数据本身，所以HyperLogLog并不能像集合那样返回输入的各个元素。<br>什么是基数？<br>比如数据集：{1、3、5、7、5、7、9} 那么这个数据集的基数就是：{1、3、5、7、9} 基数（不重复元素）为5。基数估计 就是在误差可以收的范围内快速计算基数。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定元素到 HyperLogLog  中</span></span><br><span class="line">pfadd &lt;key&gt; &lt;element&gt; &lt;element&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的近似基数  可以计算多个key，</span></span><br><span class="line">pfcount &lt;key&gt;  [key key ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个key合并后的结果存储在另一个key中。</span></span><br><span class="line">pfmerge &lt;key&gt;  &lt;key1&gt;  &lt;key2&gt;</span><br></pre></td></tr></table></figure>



<h2 id="8-Geospatial"><a href="#8-Geospatial" class="headerlink" title="8 Geospatial"></a>8 Geospatial</h2><p>Redis 3.2 中增加对GEO类型的支持，GEO是Geographic地理信息的缩写。该类型就是元素的二维坐标，在地图上就是经纬度，Redis基于该类型提供了经纬度设置，范围查询。距离查询。经纬度Hash等操作。</p>
<h3 id="8-1-Geospatial的基本命令"><a href="#8-1-Geospatial的基本命令" class="headerlink" title="8.1 Geospatial的基本命令"></a>8.1 Geospatial的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加地理位置 经度 纬度 名称, 两级无法添加，一般会下载城市经纬度数据，直接导入。有效的经度从-180 到180 纬度 -85.05112878 到 85.05112878 ,超出范围会返回错误。</span></span><br><span class="line">geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;  &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取指定地区的坐标值</span></span><br><span class="line">geopos &lt;key&gt; &lt;member&gt; [member]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取两个位置的直线距离，单位有 m km ft(英尺) mi (英里) ，不指定为单位 默认是 m (米)</span></span><br><span class="line">geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; m/km/ft/mi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以给定的经纬度为中心，找出某一半径内的元素</span></span><br><span class="line">georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius m/km/ft/mi</span><br></pre></td></tr></table></figure>

<h1 id="四、Redis-的事务操作"><a href="#四、Redis-的事务操作" class="headerlink" title="四、Redis 的事务操作"></a>四、Redis 的事务操作</h1><p>Redis 的事务 是一个单独的隔离的操作，事务中所有的命令都会序列化、按顺序的执行，事务在执行过程中，不会被其他的客户端发送过来的命令请求打断。<br>Redis的事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p>
<p>从输入Multi 开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过Discard来放弃组队。</p>
<p><img src="https://tc.chaizz.com/5c2866ec450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="1-Redis-事务的错误处理"><a href="#1-Redis-事务的错误处理" class="headerlink" title="1  Redis 事务的错误处理"></a>1  Redis 事务的错误处理</h2><h3 id="1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"><a href="#1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。" class="headerlink" title="1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"></a>1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。</h3><p><strong><img src="https://tc.chaizz.com/62e8c936450e11ec9d7c5254006b8f1d.png"></strong></p>
<h3 id="1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"><a href="#1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。" class="headerlink" title="1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"></a>1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。</h3><p><img src="https://tc.chaizz.com/6a3b5302450e11ec9d7c5254006b8f1d.png"> </p>
<h3 id="1-3-Redis的事务冲突，以及解决办法。"><a href="#1-3-Redis的事务冲突，以及解决办法。" class="headerlink" title="1.3 Redis的事务冲突，以及解决办法。"></a>1.3 Redis的事务冲突，以及解决办法。</h3><h4 id="1-3-1-悲观锁"><a href="#1-3-1-悲观锁" class="headerlink" title="1.3.1 悲观锁"></a>1.3.1 悲观锁</h4><p>每次去获取数据都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人就只能等到锁释放才能能拿到数据。传统的关系型数据库很多地方都用到了悲观锁：比如行锁、表锁、读锁、写锁等。</p>
<p><img src="https://tc.chaizz.com/751786ec450e11ec9d7c5254006b8f1d.png"></p>
<h4 id="1-3-2-乐观锁"><a href="#1-3-2-乐观锁" class="headerlink" title="1.3.2 乐观锁"></a>1.3.2 乐观锁</h4><p>每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有更新这数据，可以使用版本号等机制。乐观锁适用于多读的场景，这样可以以高吞吐量，Redis 就是利用这用check-and-set的机制实现事务的。实际应用场景：例如买票，很多人都可以抢到，但是付款只有一个人可以付款成功。</p>
<p><img src="https://tc.chaizz.com/7bd4e6be450e11ec9d7c5254006b8f1d.png"></p>
<p>在Redis 中使用乐观锁<br>在执行Multi 之前先执行 watch key 可以监听一个或者多个key，如果事务执行之前这个key被其他的命令所修改，那么事务将会被打断。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给Redis加乐观锁</span></span><br><span class="line">watch key </span><br></pre></td></tr></table></figure>
<h3 id="1-4-Redis-事务的三特性"><a href="#1-4-Redis-事务的三特性" class="headerlink" title="1.4 Redis 事务的三特性"></a>1.4 Redis 事务的三特性</h3><h4 id="1-4-1单独的隔离操作"><a href="#1-4-1单独的隔离操作" class="headerlink" title="1.4.1单独的隔离操作"></a>1.4.1单独的隔离操作</h4><p>事务中所有的命令都会序列化，按照顺序执行，事务在执行过程中没不会被其他的可短短发送来的命令请求打断。</p>
<h4 id="1-4-2-没有隔离级别的概念"><a href="#1-4-2-没有隔离级别的概念" class="headerlink" title="1.4.2 没有隔离级别的概念"></a>1.4.2 没有隔离级别的概念</h4><p>队列中的命令没有提交之前都不会被实际的执行，因为事务提交之前（exec）任何指令都不会被执行。</p>
<h4 id="1-4-3-不保证原子性"><a href="#1-4-3-不保证原子性" class="headerlink" title="1.4.3 不保证原子性"></a>1.4.3 不保证原子性</h4><p>事务中如果有一天命令执行失败，其他的命令仍然会被执行，不会回滚。</p>
<h1 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h1><h2 id="1-RDB-（Redis-Database）-方式"><a href="#1-RDB-（Redis-Database）-方式" class="headerlink" title="1  RDB （Redis Database） 方式"></a>1  RDB （Redis Database） 方式</h2><p>在指定<strong>时间间隔内</strong>将内存中的<strong>数据集快照</strong>写入磁盘，也就是快照，它恢复是将快照文件直接读到内存里面。（在Redis 的配置文件内设置时间间隔）<strong>RDB 默认开启。</strong></p>
<p>备份是如何执行的：<br>Redis 会单独的创建一个fork子进程来持久化，会先将数据写入一个临时文件中，等持久化过程都结束了，在用这个临时文件替换上次持久化的文件，整个过程主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据的恢复，且对于数据的完整性要求不那么敏感，那么RDB的方式要比AOF的方式更加的额高效，RDB的缺点就是<strong>最后一次持久化的数据可能会丢失。</strong></p>
<p>fork的作用就是复制一个与当前进程一样的进程，新的进程的所有的数据（变量，程序计数器等）都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件解释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查数据完整性、默认值 yes 在存储跨照后让Redis 使用CRC64算法来对数据进行校验。但是这样做会损失大约10%的性能。推荐开启。</span></span><br><span class="line">rdbchecksum  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis 无法写入磁盘的时候，直接关掉Redis的写操作，推荐yes</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 压缩文件</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将数据写入磁盘的时间间隔， 默认 六十分钟1次、五分钟一百次、一分钟一万次</span></span><br><span class="line">save 300 100</span><br></pre></td></tr></table></figure>



<p>RDB的优势：</p>
<ul>
<li>适合大规模数据的恢复。</li>
<li>对数据完整性和一致性要求不高时使用。</li>
<li>节省磁盘空间。</li>
<li>回恢复度快。</li>
</ul>
<p>RDB的劣势：</p>
<ul>
<li>在写入临时快照的时候，数据被克隆了一份，大致两倍的膨胀性需要考虑。</li>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据量庞大还是比较消耗性能。</li>
<li>在备份周期在一低昂时间间隔内做一次备份，所以如果Redis以外关掉，就会丢失最后一次快照的修改。</li>
</ul>
<p>RDB的备份恢复：<br>默认Redis启动会自动将Redis的快照文件（dump.rdb）读取到内存中。手动恢复的话只需要将快照文件复制到Redis启动目录下。</p>
<h2 id="2-AOF（Append-Only-File）方式"><a href="#2-AOF（Append-Only-File）方式" class="headerlink" title="2  AOF（Append Only File）方式"></a>2  AOF（Append Only File）方式</h2><p>以日志的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的所有<strong>写/修改/删除指令记录下来（读操作不记录）</strong>，只许追加文件但是不可以改文件，Redis启动之初，会自动读取范围见重新构建数据，换言之Redis重启的话就会根据日志文件的内容将写指令重头到尾在执行一遍，以完成数据的恢复工作。<strong>AOF默认不开启。</strong></p>
<p>开启AOF：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认为no 不开启， 将其改为yes 开启。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果RDB和AOF同时开启，Redis 默认会读取AOF的配置文件来恢复数据。</strong> </p>
<p>AOF 异常修复：<br>如果遇到AOF文件损坏，通过 redis-check-aof   –fix  appendonly.aof 进行恢复。</p>
<p>AOF的同步频率设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置AOF的同步频率 。</span></span><br><span class="line">	always：始终同步。</span><br><span class="line">	everysec ：每秒同步，每秒记入日志一次，如果宕机当前秒的数据可能会丢失。</span><br><span class="line">	no：redis 不主动同步，把同步的时机交给操作系统。</span><br><span class="line">appendfsync always   </span><br></pre></td></tr></table></figure>

<p>Rewrite 压缩<br>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过设置的阈值时，Redis回启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p>重写的原理：<br>AOF文件持续增长而过大时， 会fork 出一条新的进程将文件重写（也是先写临时文件最后在rename）Redis4.0后的版本重写，实际上就是把RDB的快照，以二进制的形式附在新的aof的头部，作为已有的历史数据，替换掉原来的流水操作。</p>
<p>AOF持久化的流程：</p>
<ul>
<li>客户端的请求命令会被append追加到AOF的缓冲区内。</li>
<li>AOF缓冲区根据AOF持久化策略（always/everysec/no）将操作sync同步到磁盘中的.aof文件中去。</li>
<li>AOF文件大小超过重写策略或者手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。</li>
</ul>
<h1 id="六、Redis主从复制"><a href="#六、Redis主从复制" class="headerlink" title="六、Redis主从复制"></a>六、Redis主从复制</h1><p><img src="https://tc.chaizz.com/84964932450e11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Redis 主从复制配置文件设置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 丛机配置文件主要用户读操作，所以 aof 以及edb配置相关关掉即可。</span></span><br><span class="line"></span><br><span class="line">requirepass  &quot;admin.123&quot;  　　#设置redis登录密码</span><br><span class="line"></span><br><span class="line">masterauth  &quot;admin.123&quot; 　　#主从认证密码，否则主从不能同步</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在某个从机中配置为从机：这种设置从服务器是暂时的，重启之后就又会变成主服务器。</span></span><br><span class="line">slaveof ip port</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在主服务器中使用命令查看主从信息：</span></span><br><span class="line">info relication</span><br></pre></td></tr></table></figure>

<p><img src="https://tc.chaizz.com/9167c1cc450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="1-主从复制的原理："><a href="#1-主从复制的原理：" class="headerlink" title="1 主从复制的原理："></a>1 主从复制的原理：</h2><ul>
<li>当从服务器连接上主服务器上以后，从服务器向主服务器发送数据同步消息即一个sync命令。</li>
<li>主服务器接到从服务器送过来的同步消息，把主服务器的数据进行持久化，把RDB文件发送到从服务器，从服务器拿到RDB进行读取。（从服务器主动请求同步）</li>
<li>全量复制：从服务器在接受数据库数据后将其存盘并加载到内存中。</li>
<li>增量复制：主服务器将新的所有收集到的修改的命令依次传输给从服务器完成同步。</li>
</ul>
<h2 id="2-主从复制之薪火相传"><a href="#2-主从复制之薪火相传" class="headerlink" title="2 主从复制之薪火相传"></a>2 主从复制之薪火相传</h2><p>Redis 主从模式为 一个主，其他的为从。其中第三个从为第二个从的主，类似于排队的节点，每一节点都是前面的从。也可以多个从节点。 </p>
<p><img src="https://tc.chaizz.com/9c1ab480450e11ec9d7c5254006b8f1d.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置方法：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在从服务器中配置他的从服务器</span></span><br><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure>
<h2 id="3-Redis主从之反客为主"><a href="#3-Redis主从之反客为主" class="headerlink" title="3  Redis主从之反客为主"></a>3  Redis主从之反客为主</h2><p>反客为主在薪火相传的基础上给某个从服务器加上能够变为主服务器的命令。使其能够在主服务器挂掉的时候充当主服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若果想让从服务器在主服务器挂掉之后自动变为主服务器设置方法： 需要手动操作，全自动实现 需要使用哨兵模式</span></span><br><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>


<h2 id="4-Redis主从之哨兵模式"><a href="#4-Redis主从之哨兵模式" class="headerlink" title="4 Redis主从之哨兵模式"></a>4 Redis主从之哨兵模式</h2><p>配置哨兵模式：<br><strong>定义配置文件 senttinel.conf   （文件名不能错） 文件内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mymaster 是为监控对象起的名称， 1 代表至少有多少个哨兵同意迁徙的数量。</span></span><br><span class="line">sentinel monitor mymaster IP PORT 1</span><br></pre></td></tr></table></figure>
<p>哨兵故障恢复：<br>从下线的主服务器的从服务器中挑选一个将其转成主服务器。选择的条件依次为：1. 优先级最靠前的。2. 选择偏移量最大的，3. 选择runid 最小的。</p>
<p>挑选出新的主服务器后sentinel 向原先的主服务器的从服务器发送slaveof 命令，复制新的master，当已经下线的主服务器上线时，sentinel 向其发送slaveof 命令让其成为新主的从。</p>
<p>优先级在Redis.conf 中默认：replica-priority 100 值越小 优先级越高。<br>偏移量是指获取原主机数据最全的。<br>每个Redis示例启动后都会随机生成一个40位runid。</p>
<h1 id="七、Redis-集群"><a href="#七、Redis-集群" class="headerlink" title="七、Redis 集群"></a>七、Redis 集群</h1><p>Redis 的主从模式，薪火相传。主机宕机，会导致IP的地址变化，应用程序中配置需要修改对应主机啊的地址没端口等信息。之前通过代理主机来解决，Redis 3.0 提供了解决方案，就是无中心化集群方案。</p>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个Redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区，来提供一定程度的可用性，：即使集群中有部分节点失效或者无法进行通讯，集群也能够继续处理命令请求。</p>
<h2 id="1-Redis-集群配置"><a href="#1-Redis-集群配置" class="headerlink" title="1 Redis 集群配置"></a>1 Redis 集群配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 包含redis主配置文件</span></span><br><span class="line">include /myredis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置pid文件位置 (注意区别每个节点文件名要不一致)</span></span><br><span class="line">pidfile /var/run/redis-6379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置持久化文件名  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群配置</span></span><br><span class="line">cluster-enabled  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置当前节点的配置文件的名字  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置失联时间</span>   </span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保集群配置文件没有出错，查看Redis 服务是否正常启动，以及Redis对应的几点文件是否生成。</span></span><br></pre></td></tr></table></figure>
<p><strong><img src="https://tc.chaizz.com/a51f728c450e11ec9d7c5254006b8f1d.png"></strong></p>
<p>以上配置生成了Redis的集群节点，但是还没有将每个节点相结合。以下操作将各个节点结合配置为集群。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果是低版本Redis需要安装ruby环境，此版本不需要安装。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先进入到解压后Redis目录中</span></span><br><span class="line">cd /opt/redis-6.2.5/src</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行合并集群命令。</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处使用本机地址 生产环境使用本机IP地址</span></span><br><span class="line">1： 表示一个主节点对应一个从节点 </span><br><span class="line"></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6389 127.0.0.1:6390 127.0.0.1:6391</span><br></pre></td></tr></table></figure>
<p>设置成功如下图所示：<br><img src="https://tc.chaizz.com/abdb9a88450e11ec9d7c5254006b8f1d.png"></p>
<h2 id="2-Redis-集群连接"><a href="#2-Redis-集群连接" class="headerlink" title="2 Redis 集群连接"></a>2 Redis 集群连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 集群连接</span> </span><br><span class="line">redis-cli -c -p 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群节点信息</span></span><br><span class="line">cluster nodes </span><br></pre></td></tr></table></figure>

<p><img src="https://tc.chaizz.com/b7277e5c450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 如何分配至少三个主节点？</p>
<p>首先分配原则尽量保证，每个主数据库运行在不同的IP地址中，每个从库和主库不在同一个IP地址中。</p>
<p>什么是slots？</p>
<p>当Redis集群设置成功后会提示 ： <code>All 16384 slots covered</code>，代表一个集群包含16384个插槽，数据库的每个键都会存储到这些个插槽中去，集群使用公式 CRC16(key)%16384 来计算key属于那个插槽，其中CRC16(key) 用于计算key的CRC16校验和。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算集群的中的key的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的插槽值</span></span><br><span class="line">cluster keyslot &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算插槽值里面有多少个key ,只能查看自己插槽中的key值</span></span><br><span class="line">cluster countkeysinslot &lt;slot&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回count个slot中的键 ,返回插槽中的键的数量。</span></span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt; </span><br></pre></td></tr></table></figure>

<h2 id="3-故障恢复"><a href="#3-故障恢复" class="headerlink" title="3 故障恢复"></a>3 故障恢复</h2><p>Redis 集群中的某个主服务宕机，他的从服务器会直接成为主服务器，来保持运行。（通过配置文件的失联时间来判断是和否能够正常使用：cluster-node-timeout 15000）<br>如果Redis的集群中的某个节点的主从全部挂掉，他的情况 需要根据配置文件来说明：</p>
<ul>
<li>如果配置文件中的<code>cluster-require-full-coverage</code> 的值为 <code>yes</code> ， 则整个集群都挂掉。</li>
<li>如果值为 <code>no</code> 则该插槽服务挂掉，无法写入读取数据，但是不会影响其他的集群节点。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>部署YoloV5</title>
    <url>/2021/07/10/%E9%83%A8%E7%BD%B2YoloV5/</url>
    <content><![CDATA[<p>​                                    </p>
<a id="more"></a>

<p>一、安装Ubuntu 20.04 系统。</p>
<p>二、更换Ubuntu 源为国内源。（尽量不要用阿里源）</p>
<p>三、升级包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update	</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>四、下载Nvidia 驱动。<a href="https://www.nvidia.cn/content/DriverDownload-March2009/confirmation.php?url=/XFree86/Linux-x86_64/460.84/NVIDIA-Linux-x86_64-460.84.run&lang=cn&type=TITAN">下载地址</a>。根据自己的显卡查找驱动。</p>
<ul>
<li><p>禁用nouveau驱动</p>
<ul>
<li><p>编辑 /etc/modprobe.d/blacklist-nouveau.conf </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure></li>
<li><p>接下来然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</span><br></pre></td></tr></table></figure></li>
<li><p>然后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>提示gcc 问题：</p>
</li>
</ul>
</li>
<li><p>直接安装  <code>sudo apt-get install gcc g++</code></p>
</li>
</ul>
<p>提示make问题：</p>
<ul>
<li>直接安装 <code>sudo apt-get install  make</code></li>
</ul>
<p>五、安装CUDA。（需要根据pytorch 的版本选择CUDA版本。这里选择的是CUDA 11.1）  下载地址：<a href="https://developer.nvidia.com/cuda-11.1.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=2004&target_type=runfilelocal">CUDA地址</a>。</p>
<p>官网安装步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run</span><br><span class="line">sudo sh cuda_11.1.0_455.23.05_linux.run</span><br></pre></td></tr></table></figure>
<p>接下来按照提示输入。</p>
<p>选择安装界面：因为上面已经安装过驱动，所以取消选择第一个 driver ，然后选中 按下回车。</p>
<p>配置CUDA环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.1/lib64</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-11.1/bin</span><br><span class="line">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda-11.1</span><br><span class="line">source  ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>验证是CUDA否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line">输出CUDA版本即安装成功</span><br></pre></td></tr></table></figure>
<p>六、安装CUDNN。 下载地址：<a href>CUDNN</a> 。 需要登录账户 。</p>
<p>七、配置Python 虚拟环境 （Pyenv）</p>
<ul>
<li><p>安装步骤</p>
<ul>
<li><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git	</span><br><span class="line">git clone https://github.com/yyuu/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure></li>
<li><p>打开环境变量</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">输入以下内容：</span></span><br><span class="line">export PATH=~/.pyenv/bin:$PATH</span><br><span class="line">export PYENV_ROOT=~/.pyenv</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">刷新环境变量</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>查看可安装的Python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure></li>
<li><p>安装指定版本的Python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.8.5</span><br></pre></td></tr></table></figure></li>
<li><p>更新数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure></li>
<li><p>切换python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xxx表示要切换的版本</span><br><span class="line">**有三种切换方式 glocal local shell**</span><br><span class="line">　　1. glocal 全局环境,在未再次使用 glocal切换环境之前，一直使用此环境。</span><br><span class="line">　　2. local 本次登录环境。重启后，则环境失效，并返回当前glocal的环境。</span><br><span class="line">　　3. shell 局部（临时）环境。关闭命令行窗口，则环境失效，并返回当前glocal的环境。</span><br><span class="line">pyenv glocal xxx  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>卸载已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall xxx</span><br></pre></td></tr></table></figure></li>
<li><p>安装virtualenv   创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-virtualenv.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-virtualenv</span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cho &#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.7.0 yolo385</span><br></pre></td></tr></table></figure></li>
<li><p>删除虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;.pyenv&#x2F;versions&#x2F;env370</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p>八、安装pytorch</p>
<p>torch 官网 ：<a href="https://pytorch.org/">torch</a></p>
<p>按照自己的配置选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install torch&#x3D;&#x3D;1.9.0+cu111 torchvision&#x3D;&#x3D;0.10.0+cu111 torchaudio&#x3D;&#x3D;0.9.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</span><br></pre></td></tr></table></figure>
<p>出现 not import _lzma :</p>
<p>解决办法 ：重新安装pandas</p>
]]></content>
      <categories>
        <category>YoloV5</category>
      </categories>
      <tags>
        <tag>YoloV5</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装RabbitMQ</title>
    <url>/2021/07/10/Ubuntu%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<p>​                       </p>
<a id="more"></a>      

<blockquote>
<p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>均有与代理接口通讯的<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>库。</p>
</blockquote>
<p>安装前提：首先需要安装Erlang</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install erlang-nox</span><br></pre></td></tr></table></figure>
<p>1、 使用apt-get 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>2、安装完毕配置文件默认在：/etc/rabbitmq/ 下。</p>
<p><strong>如果已经安装了redis ,再启动之前现将redis 启动。</strong></p>
<p>操作命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-server start</span><br><span class="line">sudo rabbitmq-server stop</span><br><span class="line">sudo rabbitmq-server restart</span><br><span class="line">sudo rabbitmqctl status</span><br></pre></td></tr></table></figure>
<p>3、创建用户</p>
<p>创建用户名为： admin  密码：admin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl add_user  admin  admin  </span><br></pre></td></tr></table></figure>
<p>设置用户标签 为：administrator  （添加远程访问必须为 ：administrator  ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
<p>设置当前 / 虚拟主机下的权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一个“.*”用于配置资产实体的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第二个“.*”表示对实体的写权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第三个“.*” 用于读取物理的权限</span></span><br><span class="line">sudo rabbitmqctl  set_permissions -p / admin &#x27;.*&#x27; &#x27;.*&#x27; &#x27;.*&#x27;</span><br></pre></td></tr></table></figure>
<p>4、列出集群中的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>
<p>5、删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_user &#39;用户名&#39;</span><br></pre></td></tr></table></figure>
<p>6、撤销用户在虚拟主机中的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl clear_permissions -p &quot;custom-vhost&quot;  &quot;用户名&quot;</span><br></pre></td></tr></table></figure>
<p>7、看虚拟主机列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_vhosts</span><br></pre></td></tr></table></figure>
<p>8、每个rabbitmqctl权限管理操作的范围仅限于单个虚拟主机。</p>
<p>授予用户对所有虚拟主机的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for v in $(rabbitmqctl list_vhosts --silent); do rabbitmqctl set_permissions -p $v &quot;a-user&quot; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;; done</span><br></pre></td></tr></table></figure>


<p>设置RabbitMQ可以远程访问</p>
<p>在/etc/rabbitmq/rabbitmq-env.conf 中添加以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">loopback_users=none</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda3安装虚拟环境</title>
    <url>/2021/05/09/Miniconda3%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>​                   </p>
<a id="more"></a>

<p>创建虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n [name] python=版本 -y </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 激活环境</span></span><br><span class="line">conda activate name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭环境</span></span><br><span class="line">deactivate </span><br></pre></td></tr></table></figure>
<p>在对应的环境中安装包 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install xxx</span><br><span class="line">conda install xxx</span><br></pre></td></tr></table></figure>
<p>运行jupyter notebook 遇到错误 </p>
<ul>
<li>提示无法导入某个包</li>
</ul>
<p>问题原因：</p>
<p>jupyter notebook 使用的还是原来的python 包，无法使用新的虚拟环境的包。</p>
<p>点击 jupyter notebook 的new 查看是否能够找到新创建的环境。</p>
<p><img src="https://tc.chaizz.com/Snipaste_2021-05-08_18-59-42.png"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipykernel在虚拟环境下安装 ipykernel。</span></span><br><span class="line">conda install -n 环境名称 ipykernel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将创建的新的虚拟环境，添加到核心。</span></span><br><span class="line">python -m ipykernel install --user --name 环境名称 --display-name &quot;环境名称&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来重新打开 jupyter notebook即可。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行代码时提示：内核似乎已经死了 . 它会自动重启 。</li>
</ul>
<p>问题原因：</p>
<p>再学习DIVE INTO DEEP LEARNING 这本书中的代码时，运行某一段输出图表的内容的时候，提示内核似乎已经死了 . 它会自动重启 。 无法输出图表。</p>
<p>在Pycharm 上提示的错误为 ：</p>
<p><img src="https://tc.chaizz.com/Snipaste_2021-05-08_19-10-19.png"></p>
<p>解决办法：</p>
<p>在代码前导入以下代码即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;KMP_DUPLICATE_LIB_OK&#x27;</span>] = <span class="string">&#x27;TRUE&#x27;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p><a href="https://blog.csdn.net/qq_43382616/article/details/108642590">jupyter notebook无法使用conda环境的模块</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/scar2016/article/details/115710308">jupyter notebook内核挂掉了，需要重启</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Miniconda</category>
      </categories>
      <tags>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat连接Oracle数据库</title>
    <url>/2021/05/09/%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>Navicat连接Oracle出现错误信息 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">oracle library is not loaded</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>Navicat版本 ：12.1.11</p>
<p>Navicat 连接Oracle数据库需要配下载Oracle 官方提供的插件 ：<a href="https://www.oracle.com/database/technologies/instant-client/downloads.html">instantclient_19_9</a>，选择自己的系统（我的是windows），将此文件下载解压后放在Navicat安装文件路径下。</p>
<p>然后打开Navicat 的 ：工具-&gt;选项-&gt;环境-&gt;OCI 如下图所示。</p>
<p><img src="https://tc.chaizz.com/3b0b7af0e15211eb9d7c5254006b8f1d.png"></p>
<p>将instantclient_19_9 路径下的oci.dll 文件路径复制到此路径下。</p>
<p>接下来重启Navicat 即可。</p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Navicat、Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装Apex</title>
    <url>/2021/04/24/Centos7%E5%AE%89%E8%A3%85Apex/</url>
    <content><![CDATA[<p>封面图片由<a href="https://pixabay.com/zh/users/khirulislam898-12875647/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">MD KHIRUL ISLAM</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">Pixabay</a>上发布。</p>
<a id="more"></a>

<h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><blockquote>
<p>系统：Centos 7.6</p>
<p>所需 文件：java jdk  、 tomcat9 、Oracle 19c、   Ords 20.4 、 apex 20.2</p>
</blockquote>
<p>安装高版本的JDK和Tomcat会导致出现下面这个问题。建议选择低版本进行安装，低版本和高版本安装大致方法一直，或者采用以下脚本执行。</p>
<p><img src="https://tc.chaizz.com/%E6%89%93%E5%BC%80ords%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98.png"></p>
<h3 id="一、脚本文件方式安装JDK和tomcat"><a href="#一、脚本文件方式安装JDK和tomcat" class="headerlink" title="一、脚本文件方式安装JDK和tomcat"></a>一、脚本文件方式安装JDK和tomcat</h3><p>该脚本文件来自 ：<a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用于安装tomcat</span></span><br><span class="line">JAVA_VER=271</span><br><span class="line">JAVA_DIR=/usr/local/jdk</span><br><span class="line">TOMCAT_VER=9.0.45</span><br><span class="line">Pro=tomcat</span><br><span class="line">CATALINA_HOME=/usr/local/$Pro</span><br><span class="line">[ ! -d /software/ ] &amp;&amp; mkdir /software</span><br><span class="line"><span class="meta">#</span><span class="bash">安装依赖包</span></span><br><span class="line">install_java()&#123;</span><br><span class="line">    cd /software</span><br><span class="line">    #卸载openjdk</span><br><span class="line">    m=`rpm -qa |grep openjdk |wc -l`</span><br><span class="line">    [ $m -ne 0 ] &amp;&amp; rpm -qa |grep openjdk |xargs rpm -e</span><br><span class="line">    #安装java</span><br><span class="line">    if [ ! -f jdk-8u$JAVA_VER-linux-x64.tar.gz ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[31m请手动下载jdk到/software\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    else</span><br><span class="line">        tar xf jdk-8u$JAVA_VER-linux-x64.tar.gz</span><br><span class="line">        [ ! -d $JAVA_DIR ] &amp;&amp; mv jdk1.8.0_$JAVA_VER $JAVA_DIR</span><br><span class="line">        n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; /etc/profile |wc -l`</span><br><span class="line">        if [ $n -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo &quot;JAVA_HOME=$JAVA_DIR&quot; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/jre/lib&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;export JAVA_HOME PATH CLASSPATH&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            source /etc/profile</span><br><span class="line">        else</span><br><span class="line">            source /etc/profile</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">    java -version</span><br><span class="line">    if [ $? -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[36mjdk安装完成\033[0m&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\033[31mjdk安装失败\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装tomcat</span></span><br><span class="line">install_tomcat()&#123;</span><br><span class="line">    #下载tomcat</span><br><span class="line">    [ ! -f apache-tomcat-$TOMCAT_VER.tar.gz ] &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v$TOMCAT_VER/bin/apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    #解压</span><br><span class="line">    [ ! -d apache-tomcat-$TOMCAT_VER ] &amp;&amp; tar xf apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    [ ! -d $CATALINA_HOME ] &amp;&amp; mv apache-tomcat-$TOMCAT_VER $CATALINA_HOME</span><br><span class="line">    #设置环境变量</span><br><span class="line">    n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; $CATALINA_HOME/bin/catalina.sh |wc -l`</span><br><span class="line">    if [ $n -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        sed -i &quot;124a JAVA_HOME=$&#123;JAVA_DIR&#125;&quot; $CATALINA_HOME/bin/catalina.sh</span><br><span class="line">    fi</span><br><span class="line">    #配置启动脚本</span><br><span class="line">    cat &gt; /etc/systemd/system/$Pro\.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Apache Tomcat 9 Servlet Container</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Type=forking</span><br><span class="line">LimitNOFILE=131070</span><br><span class="line">Environment=CATALINA_PID=$&#123;CATALINA_HOME&#125;/bin/tomcat.pid</span><br><span class="line">Environment=CATALINA_HOME=$&#123;CATALINA_HOME&#125;</span><br><span class="line">Environment=CATALINA_BASE=$&#123;CATALINA_HOME&#125;</span><br><span class="line">ExecStart=$&#123;CATALINA_HOME&#125;/bin/startup.sh</span><br><span class="line">ExecStop=$&#123;CATALINA_HOME&#125;/bin/shutdown.sh</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    #tomcat开机启动</span><br><span class="line">    systemctl daemon-reload &amp;&amp; systemctl enable $Pro</span><br><span class="line"></span><br><span class="line">    if [ `systemctl status $Pro | grep &#x27;running&#x27;| wc -l` -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        systemctl start $Pro</span><br><span class="line">        if [ $? -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo -e &quot;\033[36m$Pro安装完毕\033[0m&quot;</span><br><span class="line">        else</span><br><span class="line">            echo -e &quot;\03331m$Pro安装失败\033[0m&quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_java</span><br><span class="line">install_tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将此脚本复制到系统制定目录下，在根目录下创建/software 。并将JDK 和 tomcat 包放在/software下。</p>
<p>将此脚本文件设置为可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 filename.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后执行此文件</span></span><br><span class="line">sh filename.sh </span><br></pre></td></tr></table></figure>
<p>如果显示以下错误：则表示脚本文件中存在乱码。</p>
<p><img src="https://ae01.alicdn.com/kf/U42528946957d48ff8d31a1fd8b4a3034I.jpg"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 vim -b  模式打开文件</span></span><br><span class="line">vim -b filename.sh</span><br></pre></td></tr></table></figure>
<p>打开发现如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U3b6e1138b0b742eea8f46daa886d3296w.jpg"></p>
<p>快速处理办法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\r//g&#x27; filename.sh</span><br></pre></td></tr></table></figure>
<p>接下来再打开就可以执行了。</p>
<p>等待程序运行完毕即可。</p>
<h3 id="一、安装java和tomcat环境。"><a href="#一、安装java和tomcat环境。" class="headerlink" title="一、安装java和tomcat环境。"></a>一、安装java和tomcat环境。</h3><p>1、下载java SE <a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html">文件下载地址</a>，本次选择的是java SE 16 版本。tomcat 版本10.0.5<a href="https://tomcat.apache.org/download-10.cgi">文件下载地址</a>。</p>
<p>将下载的压缩包挤压到指定文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压文件</span></span><br><span class="line">tar -zxvf jdk-16_linux-x64_bin.tar</span><br></pre></td></tr></table></figure>
<p>2、设置环境变量</p>
<p>以下是<em>错误的配置</em>：（在终端输入java -version 没有问题 但是运行tomcat 会出现提示启动成功，但是后台服务不启动。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/var/oracle/jdk-16</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>原因： 因为是使用JDK16，是新版的JDK，网上查找的答案，说是从11开始就不会自动生成jre文件了。</p>
<p>可用的java 环境变量配置如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/var/oracle/jdk-16/</span><br><span class="line">JRE_HOME=$JAVA_HOME</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib</span><br><span class="line">PATH=$JRE_HOME/bin:$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>
<p>将JRE_HOME的路径设置为 JAVA_HOME的路径，即可解决。但是启动tomcat的时候，日志文件会打印一些列NOTE。如下图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U0185a411b5804effb0c78bcf086a09b2g.jpg"></p>
<p>此问题不影响tomcat使用，目前未解决。</p>
<p>3、测试是否安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在终端输入以下命令，测试java是否安装成功，如提示java 版本信息，代表已经安装成功。</span></span><br><span class="line">java -version </span><br></pre></td></tr></table></figure>
<p>4、安装tomcat。</p>
<p>将tomcat 解压至指定文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf  apache-tomcat-10.0.5.tar</span><br><span class="line">mv /apache-tomcat-10.0.5  /var/oracle/tomcat</span><br></pre></td></tr></table></figure>
<p>配置tomcat 环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CATALINA_BASE=/var/oracle/tomcat</span><br><span class="line">PATH=$CATALINA_BASE/bin:$PATH</span><br><span class="line">export PATH CATALINA_BASE</span><br></pre></td></tr></table></figure>
<p>tomcat 的启动命令在 /tomcat/bin/start.sh 可直接启动即可。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./start.sh </span><br></pre></td></tr></table></figure>
<p>查看tomcat是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat</span><br></pre></td></tr></table></figure>
<p>启动成功如下图所示</p>
<p><img src="https://ae01.alicdn.com/kf/Ud8527b3539e34383867eff8fd2b89cb3E.jpg"></p>
<p>如果以上java 的环境变量设置不对的话，会导致tomcat 无法启动。虽然提示tomcat启动成功，但是后并没有该服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">此时终端输入验证是否启动成功</span></span><br><span class="line">curl http://ip:8080</span><br></pre></td></tr></table></figure>
<p>如未显示tomcat启动页面HTML，可排查防火墙，是否开启了8080端口 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查防火墙是否启动</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如未开启 则开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查80端口 是否被开启，如开启 则提示  “8080/tcp”</span> </span><br><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如未开启 则需要开启，开启成功会提示 “success”</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证开启的8080端口是否生效， 如果生效则提示 “yes”</span></span><br><span class="line">firewall-cmd --zone=public --query-port=8080/tcp</span><br></pre></td></tr></table></figure>
<p>8080端口开放，再次访问 IP:8080  即可看到tomcat访问成功信息。 </p>
<h3 id="二、安装oracle"><a href="#二、安装oracle" class="headerlink" title="二、安装oracle"></a>二、安装oracle</h3><p>1、以上Java jdk 和 tomcat 安装完毕以后安装 oracle 。</p>
<p>2、在根目录下创建oracle 安装文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;oracle  </span><br></pre></td></tr></table></figure>
<p>3、切换到该目录下执行以下安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先执行</span> </span><br><span class="line">yum localinstall  oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">等待执行结束，在执行</span></span><br><span class="line">yum localinstall oracle-database-ee-19c-1.0-1.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>中途卡断 可重新安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用yum命令 查询更刚刚安装的包, 找到Oracle的包名</span></span><br><span class="line">yum list installed shell</span><br><span class="line"><span class="meta">#</span><span class="bash">先使用以下命令卸载已安装的包。</span></span><br><span class="line">yum remove oracle-database-preinstall-19c-1.0-1.el7.x86_64</span><br><span class="line">yum remove oracle-database-ee-19c-1.0-1.x86_64</span><br></pre></td></tr></table></figure>
<p>4、过一段时间安装完毕成功会提示如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/Ua0442ba6df124404871dd091810d949e2.jpg"></p>
<p>oracle 的安装文件地址为：/opt/oracle   默认配置文件路径为：/etc/sysconfig/oracledb_ORCLCDB-19c.conf</p>
<p>5、接下来初始化数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c configure</span><br></pre></td></tr></table></figure>
<p>等待数据库初始化。过程中切记不用中断操作。初始化时间可能会很长。只要后台服务还在就说明没问题。</p>
<p>6、切换至Oracle 用户 修改数据库系统账户密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su oracle </span><br><span class="line"><span class="meta">#</span><span class="bash">登录数据库</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#修改sys 和 <span class="keyword">system</span> 的密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> sys identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">system</span> identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line">shutdown immediate;</span><br><span class="line"></span><br><span class="line">startup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;</span><br><span class="line"></span><br><span class="line">startup;</span><br></pre></td></tr></table></figure>
<p>7、配置数据库的环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">在最下面添加以下内容：</span></span><br><span class="line">export ORACLE_HOME=/opt/oracle/product/19c/dbhome_1</span><br><span class="line">export ORACLE_SID=ORCLCDB</span><br><span class="line">export PATH=$PATH:/opt/oracle/product/19c/dbhome_1/bin</span><br><span class="line">export NLS_LANG=American_America.AL32UTF8</span><br></pre></td></tr></table></figure>
<p>8、启动停止oracle</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c start</span><br><span class="line"></span><br><span class="line">/etc/init.d/oracledb_ORCLCDB-19c stop</span><br></pre></td></tr></table></figure>


<h3 id="三、安装apex"><a href="#三、安装apex" class="headerlink" title="三、安装apex"></a>三、安装apex</h3><p>1、解压apex的压缩包</p>
<p>使用oracle 用户需要将 apex保存的文件富裕oracle 权限。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R oracle:dba /var/oracle/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压到当前文件夹下</span></span><br><span class="line">unzip -q apex_20.2.zip </span><br></pre></td></tr></table></figure>
<p>2、进入oracle数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、登录数据库</span></span><br><span class="line">sqlplus / as sysdba  </span><br></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按顺序执行以下代码</span></span><br><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;   </span><br><span class="line"></span><br><span class="line"><span class="comment">--3、设置系统默认表空间</span></span><br><span class="line"><span class="variable">@apexins</span>.<span class="keyword">sql</span> APEX APEX TEMP <span class="operator">/</span>i<span class="operator">/</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">--接下来等待安装 ，会持续一段时间....。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--4、创建 apex 实例管理员</span></span><br><span class="line"><span class="variable">@apxchpwd</span>.<span class="keyword">sql</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码必须包含：(!&quot;#$%&amp;()``*+,-/:;?_) 和 至少一个大写字母。</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">--5、 修改APEX_PUBLIC_USER 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> APEX_PUBLIC_USER ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -6、 修改flows_files 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> flows_files ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"><span class="variable">@apex</span>_rest_config.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10       </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_LISTENER <span class="keyword">user</span>: Test123_</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11        </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_REST_PUBLIC_USER <span class="keyword">user</span>: Test123_</span><br><span class="line">            </span><br></pre></td></tr></table></figure>


<p>3、汉化apex </p>
<p>切换到，apex/builder/zh-cn/ 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、 登录sql</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、设置CURRENT_SCHEMA </span></span><br><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> <span class="built_in">CURRENT_SCHEMA</span> <span class="operator">=</span> APEX_200200;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、加载sql</span></span><br><span class="line"><span class="variable">@load</span>_zh<span class="operator">-</span>cn.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等待一段时间即可...</span></span><br></pre></td></tr></table></figure>


<h3 id="四、安装ords"><a href="#四、安装ords" class="headerlink" title="四、安装ords"></a>四、安装ords</h3><p>1、解压文件到当前目录下</p>
<p>2、执行ords安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ords.war install advanced</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来选择会提示输入：</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">This Oracle REST Data Services instance has not yet been configured.</span><br><span class="line">Please complete the following prompts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter the location to store configuration data: /opt/ords/config  # 配置存储路径</span><br><span class="line">Specify the database connection type to use.</span><br><span class="line">Enter number for [1] Basic  [2] TNS  [3] Custom URL [1]:1    </span><br><span class="line">Enter the name of the database server [localhost]:localhost  </span><br><span class="line">Enter the database listen port [1521]:1520                   </span><br><span class="line">Enter 1 to specify the database service name, or 2 to specify the database SID [1]:1</span><br><span class="line">Enter the database service name:ORCLPDB1</span><br><span class="line">Enter 1 if you want to verify/install Oracle REST Data Services schema or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for ORDS_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Xisland2020</span><br><span class="line">Requires to login with administrator privileges to verify Oracle REST Data Services schema.</span><br><span class="line"></span><br><span class="line">Enter the administrator username:SYS                #oracle数据库账号</span><br><span class="line">Enter the database password for SYS AS SYSDBA:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Connecting to database user: SYS AS SYSDBA url: jdbc:oracle:thin:@//localhost:1521/ORCLPDB1</span><br><span class="line"></span><br><span class="line">Retrieving information.</span><br><span class="line">Enter 1 if you want to install ORDS or 2 to skip this step [1]:1</span><br><span class="line">Enter the default tablespace for ORDS_METADATA [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_METADATA [TEMP]:TEMP</span><br><span class="line">Enter the default tablespace for ORDS_PUBLIC_USER [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_PUBLIC_USER [TEMP]:TEMP</span><br><span class="line">Enter 1 if you want to use PL/SQL Gateway or 2 to skip this step.</span><br><span class="line">If using Oracle Application Express or migrating from mod_plsql then you must enter 1 [1]:1</span><br><span class="line">Enter the PL/SQL Gateway database user name [APEX_PUBLIC_USER]:APEX_PUBLIC_USER</span><br><span class="line">Enter the database password for APEX_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter 1 to specify passwords for Application Express RESTful Services database users (APEX_LISTENER, APEX_REST_PUBLIC_USER) or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for APEX_LISTENER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter the database password for APEX_REST_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter a number to select a feature to enable:</span><br><span class="line">   [1] SQL Developer Web  (Enables all features)</span><br><span class="line">   [2] REST Enabled SQL</span><br><span class="line">   [3] Database API</span><br><span class="line">   [4] REST Enabled SQL and Database API</span><br><span class="line">   [5] None</span><br><span class="line">Choose [1]:1</span><br><span class="line">2021-02-02T08:45:42.287Z INFO        reloaded pools: []</span><br><span class="line">Installing Oracle REST Data Services version 20.4.1.r0131644</span><br><span class="line">... Log file written to /root/ords_install_core_2021-02-02_164542_00395.log</span><br><span class="line">... Verified database prerequisites</span><br><span class="line">... Created Oracle REST Data Services proxy user</span><br><span class="line">... Created Oracle REST Data Services schema</span><br><span class="line">... Granted privileges to Oracle REST Data Services</span><br><span class="line">... Created Oracle REST Data Services database objects</span><br><span class="line">... Log file written to /root/ords_install_datamodel_2021-02-02_164559_00321.log</span><br><span class="line">... Log file written to /root/ords_install_apex_2021-02-02_164600_00696.log</span><br><span class="line">Completed installation for Oracle REST Data Services version 20.4.1.r0131644. Elapsed time: 00:00:19.722 </span><br><span class="line"></span><br><span class="line">Enter 1 if you wish to start in standalone mode or 2 to exit [1]:2</span><br></pre></td></tr></table></figure>
<p>至此ords安装配置结束。</p>
<h3 id="五、部署到tomcat-上"><a href="#五、部署到tomcat-上" class="headerlink" title="五、部署到tomcat 上"></a>五、部署到tomcat 上</h3><p>1、将apex 的静态文件放到tomcat的webapps 下。 路径为你的apex 安装路径：/var/oracle/apex/images</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -a /var/oracle/apex/images/* /var/oracle/apache-tomcat-10.0.5/webapps/apex</span><br></pre></td></tr></table></figure>
<p>2、将ords.war 包 复制到tomcat 的web apｐｓ下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;var&#x2F;oracle&#x2F;ords&#x2F;ords.war &#x2F;var&#x2F;oracle&#x2F;apache-tomcat-10.0.5&#x2F;webapps&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="六、使用nginx-代理"><a href="#六、使用nginx-代理" class="headerlink" title="六、使用nginx 代理"></a>六、使用nginx 代理</h3><p>Nginx 的server配置文件为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 域名;</span><br><span class="line">    </span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Origin &quot;&quot; ;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_connect_timeout 120s;</span><br><span class="line">        proxy_read_timeout    120s;</span><br><span class="line">        proxy_send_timeout    120s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重启nginx 即可。</p>
<h3 id="七、完成"><a href="#七、完成" class="headerlink" title="七、完成"></a>七、完成</h3><p>浏览器输入域名即可打开APEX登录页面。</p>
<p>创建的密码相关：</p>
<ul>
<li><p>apex 创建实例 用户名：admin</p>
</li>
<li><p>密码：Test123_</p>
</li>
<li><p>APEX_LISTENER  user：Test1123_</p>
</li>
<li><p>数据库用户sys密码：test12</p>
</li>
<li><p>数据库用户system密码：test123</p>
</li>
</ul>
<p>参考文章：</p>
<blockquote>
<p><a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_41092687/article/details/89879061">https://blog.csdn.net/weixin_41092687/article/details/89879061</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_39400984/article/details/98104599">https://blog.csdn.net/qq_39400984/article/details/98104599</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/xzm5708796/article/details/88344074">https://blog.csdn.net/xzm5708796/article/details/88344074</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS7、ORACLE APEX</tag>
      </tags>
  </entry>
  <entry>
    <title>Python代码规范（pep8/Google-style）</title>
    <url>/2021/03/19/Python%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88pep8-Google-style%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>Guido van Rossum（吉多·范罗苏姆，Python 创始人 ）说过，代码的阅读频率远高于编写代码的频率。</p>
</blockquote>
<p>毕竟，即使是在编写代码的时候，你也需要对代码进行反复阅读和调试，来确认代码能够按照期望运行。</p>
<p>本文来自极客时间规范篇学习总结。</p>
<a id="more"></a>

<h2 id="PEP8规范："><a href="#PEP8规范：" class="headerlink" title="PEP8规范："></a>PEP8规范：</h2><p>PEP 是 Python Enhancement Proposal 的缩写，翻译过来叫“Python 增强规范”。正如我们写文章，会有句式、标点、段落格式、开头缩进等标准的规范一样，Python 书写自然也有一套较为官方的规范。PEP 8 就是这样一种规范，它存在的意义，就是让 Python 更易阅读，换句话，增强代码可读性。</p>
<h3 id="缩进规范"><a href="#缩进规范" class="headerlink" title="缩进规范"></a>缩进规范</h3><p>Python 和 C++ / Java 最大的不同在于，后者完全使用大括号来区分代码块，而前者依靠不同行和不同的缩进来进行分块。</p>
<p>Python 的缩进其实可以写成很多种，Tab、双空格、四空格、空格和 Tab 混合等。而 PEP 8 规范告诉我们，<strong>请选择四个空格的缩进，不要使用 Tab，更不要 Tab 和空格混着用。</strong></p>
<p>第二个要注意的是，<strong>每行最大长度请限制在 79 个字符</strong>。</p>
<p>这个原则主要有两个优点：</p>
<ol>
<li>很多工程师在编程的时候，习惯一个屏幕并列竖排展示多个源代码。如果某个源代码的某些行过长，你就需要拖动横向滚动条来阅读，或者需要软回车将本行内容放入下一行，这就极大地影响了编码和阅读效率。</li>
<li>需要有一定经验的编程经验后更容易理解：因为当代码的嵌套层数过高，比如超过三层之后，一行的内容就很容易超过 79 个字符了。所以，这条规定另一方面也在制约着程序员，不要写迭代过深的代码，而是要思考继续把代码分解成其他函数或逻辑块，来优化自己的代码结构。</li>
</ol>
<h3 id="空行规范"><a href="#空行规范" class="headerlink" title="空行规范"></a>空行规范</h3><p>Python 中的空行对 Python 解释器的执行没有影响，但对阅读体验有很深刻的影响。</p>
<p>PEP 8 规定，<strong>全局的类和函数的上方需要空两个空行，而类的函数之间需要空一个空行。</strong>当然，函数内部也可以使用空行，和英语的段落一样，用来区分不同意群之间的代码块。但是记住最多空一行，千万不要滥用。</p>
<p>另外，Python 本身允许把多行合并为一行，使用分号隔开，但这是 PEP 8 不推荐的做法。所以，即使是使用控制语句 if / while / for，你的执行语句哪怕只有一行命令，也请另起一行，这样可以更大程度提升阅读效率。至于代码的尾部，每个代码文件的最后一行为空行，并且只有这一个空行。</p>
<h3 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h3><p>我们再来看一下，代码块中，每行语句中空格的使用。函数的参数列表中，调用函数的参数列表中会出现逗号，请注意逗号后要跟一个空格，这是英语的使用习惯，也能让每个参数独立阅读，更清晰。同理，冒号经常被用来初始化字典，冒号后面也要跟一个空格。另外，Python 中我们可以使用#进行单独注释，请记得要在#后、注释前加一个空格。对于操作符，例如+，-，*，/，&amp;，|，=，==，!=，请在两边都保留空格。不过与此对应，括号内的两端并不需要空格。</p>
<h3 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h3><p>接下来我们说说文档规范。先来看看最常用的 import 函数。</p>
<p>首先，所有 import 尽量放在开头，这个没什么说的，毕竟到处 import 会让人很难看清楚文件之间的依赖关系，运行时 import 也可能会导致潜在的效率问题和其他风险。</p>
<p>其次，不要使用 import 一次导入多个模块。虽然我们可以在一行中 import 多个模块，并用逗号分隔，但请不要这么做。import time, os 是 PEP 8 不推荐的做法。</p>
<p>如果你采用 <code>from module import func</code> 这样的语句，请确保 func 在本文件中不会出现命名冲突。不过，你其实可以通过<code> from module import func as new_func</code> 来进行重命名，从而避免冲突。</p>
<h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>有句话这么说：错误的注释，不如没有注释。所以，当你改动代码的时候，一定要注意检查周围的注释是否需要更新。</p>
<p>对于大的逻辑块，我们可以在最开始相同的缩进处以 # 开始写注释。即使是注释，你也应该把它当成完整的文章来书写。如果英文注释，请注意开头大写及结尾标点，注意避免语法错误和逻辑错误，同时精简要表达的意思。中文注释也是同样的要求。一份优秀的代码，离不开优秀的注释。</p>
<p>至于行注释，如空格规范中所讲，我们可以在一行后面跟两个空格，然后以 # 开头加入注释。不过，请注意，行注释并不是很推荐的方式。</p>
<h3 id="文档描述"><a href="#文档描述" class="headerlink" title="文档描述"></a>文档描述</h3><p>docstring 的写法，它是用三个双引号开始、三个双引号结尾。我们首先用一句话简单说明这个函数做什么，然后跟一段话来详细解释；再往后是参数列表、参数格式、返回值格式。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>“计算机科学的两件难事：缓存失效和命名。”命名对程序员来说，是一个不算省心的事。</p>
<ol>
<li>变量命名。变量名请拒绝使用 a b c d 这样毫无意义的单字符，我们应该使用能够代表其意思的变量名。一般来说，变量使用小写，通过下划线串联起来，例如：data_format、input_spec、image_data_set。唯一可以使用单字符的地方是迭代，比如 for i in range(n) 这种，为了精简可以使用。如果是类的私有变量，请记得前面增加两个下划线。</li>
<li>常量命名，最好的做法是全部大写，并通过下划线连接，例如：WAIT_TIME、SERVER_ADDRESS、PORT_NUMBER。</li>
<li>函数名，也使用小写的方式，通过下划线连接起来，例如：launch_nuclear_missile()、check_input_validation()。</li>
<li>类名，则应该首字母大写，然后合并起来，例如：class SpatialDropout2D()、class FeatureSet()。</li>
</ol>
<p>总之，不要过于吝啬一个变量名的长度。当然，在合理描述这个变量背后代表的对象后，一定的精简能力也是必要的。</p>
<h3 id="代码分解技巧"><a href="#代码分解技巧" class="headerlink" title="代码分解技巧"></a>代码分解技巧</h3><p>编程中一个核心思想是，不写重复代码。重复代码大概率可以通过使用条件、循环、构造函数和类来解决。而另一个核心思想则是，减少迭代层数，尽可能让 Python 代码扁平化，毕竟，人的大脑无法处理过多的栈操作。</p>
<p>一个函数的粒度应该尽可能细，不要让一个函数做太多的事情。所以，对待一个复杂的函数，我们需要尽可能地把它拆分成几个功能简单的函数，然后合并起来。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pep8，Google style</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter-notebook的安装与基本使用</title>
    <url>/2021/03/13/Jupyter-notebook%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​              </p>
<a id="more"></a>

<blockquote>
<h4 id="The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more"><a href="#The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more" class="headerlink" title="The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more."></a>The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.</h4></blockquote>
<p>以上为Jupyter notebook 的官方解释。</p>
<blockquote>
<p>Jupyter Notebook是一个开源Web应用程序，可让您创建和共享包含实时代码，方程式，可视化效果和叙述文本的文档。 用途包括：数据清理和转换，数值模拟，统计建模，数据可视化，机器学习等.</p>
</blockquote>
<h2 id="一、windows下安装Jupyter-notebook"><a href="#一、windows下安装Jupyter-notebook" class="headerlink" title="一、windows下安装Jupyter notebook"></a>一、windows下安装Jupyter notebook</h2><p>Jupyter notebook 是基于Python 的首先要安装Python环境，或者直接安装Anaconda（直接包含Python和Jupyter notebook）。以上环境省略自行安装。</p>
<h3 id="在Python环境下直接安装。（最好是新版本Python）"><a href="#在Python环境下直接安装。（最好是新版本Python）" class="headerlink" title="在Python环境下直接安装。（最好是新版本Python）"></a>在Python环境下直接安装。（最好是新版本Python）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>
<p>等待命令安装完毕，如果比较慢的话，建议更换Python的源为清华或者淘宝网易的源下载安装速度会快很多。</p>
<h3 id="启动Jupyter-notebook"><a href="#启动Jupyter-notebook" class="headerlink" title="启动Jupyter notebook"></a>启动Jupyter notebook</h3><p>系统会自动启动浏览器，打开本地的8888端口。（端口没有被占用的情况下。如果被占用端口号会自动加一，启动多个Jupyter notebook应用，端口号也会自动向后加一来启动多个应用。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook </span><br></pre></td></tr></table></figure>
<p>如果在使用过程中关闭了当前终端，应用也会随之无法连接，无法使用Jupyter notebook应用。</p>
<p>如果要以不同的端口号启动Jupyter notebook应用，使用一下的方式启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook --port 8899</span><br></pre></td></tr></table></figure>
<h2 id="二、Jupyter-notebook-界面"><a href="#二、Jupyter-notebook-界面" class="headerlink" title="二、Jupyter notebook 界面"></a>二、Jupyter notebook 界面</h2><p>Jupyter notebook 的默认存储文件的地址为当前用户的文件路径。每个人里面的文件都不太一样。</p>
<h3 id="更改默认的存储路径。"><a href="#更改默认的存储路径。" class="headerlink" title="更改默认的存储路径。"></a>更改默认的存储路径。</h3><p>Jupyter notebook  的默认的配置文件在当前用户下的一个隐藏文件（以.jupyter开头的文件）文件下名为jupyter_notebook_config.py 即为jupyter notebook 的配置文件。</p>
<p>打开文件搜索找到 <code>c.NotebookApp.notebook_dir</code> 开头的配置，即是存储文件路径的配置。只需要将你想要修改的路径添加并取消注释即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir &#x3D; &#39;C:&#x2F;Users&#x2F;xxx&#x2F;Desktop&#x2F;Project&#x2F;Jupyter Notebook&#39;</span><br></pre></td></tr></table></figure>
<p>重启启动 Jupyter notebook。此时页面文件目录是空的。</p>
<h2 id="三、使用-Jupyter-notebook"><a href="#三、使用-Jupyter-notebook" class="headerlink" title="三、使用 Jupyter notebook"></a>三、使用 Jupyter notebook</h2><p>新建一个页面。 点击右上角的 new 按钮可以新建一个工程文件或者文本文件或者文件夹。</p>
<p><img src="https://tc.chaizz.com/717fe24c4ade11ec9d7c5254006b8f1d.png"></p>
<p>例如 新建一个python3文件。新页面样式如图所示。</p>
<p><img src="https://tc.chaizz.com/7fcf69304ade11ec9d7c5254006b8f1d.png"></p>
<p>可在单元格（cell）中输入代码并执行。</p>
<h2 id="四、Jupyter-notebook-快捷键"><a href="#四、Jupyter-notebook-快捷键" class="headerlink" title="四、Jupyter notebook 快捷键"></a>四、Jupyter notebook 快捷键</h2><p>A：在当前单元格的上方添加一行单元格</p>
<p>B：在当前单元格的下方添加一行单元格</p>
<p>M：选中单元格将单元格代码格式改为Markdown格式</p>
<p>Y：选中单元格将单元格代码格式改为代码格式</p>
<p>X：剪切当前单元格</p>
<p>V：在当前单元格下方粘贴复制或者剪切的单元格</p>
<p>Enter：在当前单元格换行</p>
<p>Shift+Enter：代码模式下执行当前单元格代码</p>
<p>shift+V：在当前单元格上方粘贴复制或者剪切的单元格</p>
<p>D D ：连续两个D 删除当前单元格</p>
<p>Z：撤销删除单元格</p>
<p>还有很多快捷键按H都可以找到。</p>
<h2 id="五、Jupyter-notebook-插件"><a href="#五、Jupyter-notebook-插件" class="headerlink" title="五、Jupyter notebook 插件"></a>五、Jupyter notebook 插件</h2><p>在安装插件之前首先需要安装<strong>jupyter_contrib_nbextensions</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用 jupyter_contrib_nbextensions</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure>
<p>此时 Jupyter notebook 界面就会出现一个新的菜单栏。</p>
<p><img src="https://tc.chaizz.com/8a881e4e4ade11ec9d7c5254006b8f1d.png"></p>
<p>选中此按钮进入配置插件的页面。</p>
<p>取消勾选此按钮。否则无法选择插件。</p>
<p><img src="https://tc.chaizz.com/941816a84ade11ec9d7c5254006b8f1d.png"></p>
<p>推荐插件：</p>
<ul>
<li><strong>Notify</strong> ：能在任务处理完后及时向你发送通知</li>
<li><strong>Hinterland</strong> ：自动补全代码</li>
<li><strong>Codefolding</strong>  ：折叠代码</li>
<li><strong>Table of Contents(2)</strong>  ：自动生成导航目录</li>
<li><strong>Autopep8</strong> ：自动格式化代码。（需要安装python库：autopep8）</li>
<li><strong>ExecuteTime</strong> ：显示单元格的运行时间和耗时 </li>
<li><strong>Split Cells Notebook</strong> ：类似于多窗口编辑，将单行排列的单元格放置为多行排列。</li>
<li><strong>Collapsible Headings</strong> ：折叠单元格</li>
</ul>
]]></content>
      <tags>
        <tag>Jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件目录</title>
    <url>/2021/02/02/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
</ul>
<a id="more"></a>

<ul>
<li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</li>
<li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
<p><img src="/2021/02/02/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/linuxfile.jpg"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装mysql-python插件</title>
    <url>/2021/02/02/Ubuntu%E5%AE%89%E8%A3%85mysql-python%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="运行FLASk-提示-：ERROR-flask-app-No-module-named-MySQLdb"><a href="#运行FLASk-提示-：ERROR-flask-app-No-module-named-MySQLdb" class="headerlink" title="运行FLASk 提示 ：ERROR:flask.app:No module named MySQLdb"></a>运行FLASk 提示 ：ERROR:flask.app:No module named MySQLdb</h4><a id="more"></a>

<h3 id="1-安装-mysql-python"><a href="#1-安装-mysql-python" class="headerlink" title="1.安装 mysql-python"></a>1.安装 mysql-python</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install mysql-python</span><br></pre></td></tr></table></figure>
<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p><img src="/2021/02/02/Ubuntu%E5%AE%89%E8%A3%85mysql-python%E6%8F%92%E4%BB%B6/snipaste_20190917_205355.jpg" alt="snipaste_20190917_205355"></p>
<h3 id="接下来安装依赖包"><a href="#接下来安装依赖包" class="headerlink" title="接下来安装依赖包"></a>接下来安装依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
<h3 id="如果还是不行安装依赖"><a href="#如果还是不行安装依赖" class="headerlink" title="如果还是不行安装依赖"></a>如果还是不行安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install python-MySQLdb</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu、Mysql-Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.5源码安装postgresql-12</title>
    <url>/2021/02/02/Centos7-5%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85postgresql-12/</url>
    <content><![CDATA[<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><ol>
<li><p>首先安装readline 和readline-devel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install readline </span><br><span class="line">yum install readline-devel</span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ol>
<p>虽然已经安装了readline，但是不安装readlene-devel 在执行 <code>./configure --prefix=/opt/postgresql</code> 的时候会提示，<code>configure: error: readline library not found</code>。</p>
<ol start="2">
<li><p>接下来在执行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/postgresql</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li><p>将postgresql 加入环境变量，打开文件 /etc/profile  在末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PG_HOME=/opt/postgresql  #为安装postgresql的地址</span><br><span class="line">export PATH=$PG_HOME/bin:$PATH</span><br><span class="line">source /etc/profile    #更新环境变量</span><br></pre></td></tr></table></figure></li>
<li><p>创建postgresql 的用户以及用户组 可创建可不创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd postgresql   #创建用户组</span><br><span class="line">useradd -G postgresql postgresql   #创建用户</span><br><span class="line">passwd ********    #设置密码  </span><br></pre></td></tr></table></figure>
</li>
<li><p>初始数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl -D /opt/postgresdata initdb&#x27; #初始化数据库</span><br><span class="line">su postgresql   ：使用这个用户进行操作</span><br><span class="line">/opt/postgresdata：地址为存放初始化的文件路径可自定义，   这个文件的用户权限要为 postgresql可操作</span><br><span class="line">pg_ctl  ：postgresql 的控制器，可以对postgresql 进行启动停止等操作</span><br></pre></td></tr></table></figure>
<p>执行以上语句后会再  /opt/postgresdata 路径下生成一些文件</p>
<p><img src="/2021/02/02/Centos7-5%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85postgresql-12/postgresql0.jpg"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>postmaster.pid</td>
<td>首行记录了进程PID</td>
</tr>
<tr>
<td>serverlog</td>
<td>数据库日志</td>
</tr>
<tr>
<td>postgresql.conf</td>
<td>主配置文件(可做定制</td>
</tr>
<tr>
<td>pg_hba.conf</td>
<td>鉴权相关文件</td>
</tr>
<tr>
<td>PG_VERSION</td>
<td>当前主版本号</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>启动数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl start -D /opt/postgredata -l serverlog&#x27;</span><br></pre></td></tr></table></figure>

</li>
<li><p>设置远程访问,在 pg_hba.conf文文件末尾加上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">host all all 0.0.0.0/0 md5</span><br></pre></td></tr></table></figure></li>
<li><p>为了让 postgresql用户可以远程访问，可以通过 psql 设置密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user postgresql with password &#39;*********&#39;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="9">
<li><p>开启远程访问，默认情况下 postgresql 仅仅监听本机的端口，需要编辑 <strong>/opt/postgredata/ postgresql.conf</strong> 文件开启远程IP的访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_addresses &#x3D; &#39;*&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果需要定制端口，可以执行脚本：</span></span><br><span class="line">postgres -p 5430 -D /opt/postgredata &gt;serverlog 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">检查进程是否存活：</span></span><br><span class="line">netstat -nlp |grep `head -1 /opt/postgredata/postmaster.pid`</span><br><span class="line"><span class="meta">#</span><span class="bash">停止数据库进程</span></span><br><span class="line">kill -INT `head -1 /opt/postgredata/postmaster.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>配置自启动</p>
<p>找到源码目录中 <strong><em>contrib/start-scripts/linux\</em></strong>脚本文件，拷贝为 <strong>/etc/init.d/postgressql</strong>。修改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序所在目录</span></span><br><span class="line">prefix=/opt/postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据目录</span></span><br><span class="line">PGDATA=&quot;/opt/postgredata&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行用户</span></span><br><span class="line">PGUSER=postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">PGLOG=&quot;$PGDATA/serverlog&quot;</span><br></pre></td></tr></table></figure>
<p>设置执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/init.d/postgressql		</span><br></pre></td></tr></table></figure>

<p>此后，执行以下命令可以方便的启停服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//手动启动服务</span><br><span class="line">service postgressql start</span><br><span class="line"></span><br><span class="line">//查看服务状态</span><br><span class="line">service postgressql status</span><br><span class="line"></span><br><span class="line">//手动停止服务</span><br><span class="line">service postgressql stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机启动 ,执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add postgressql</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p> <a href="https://www.postgresql.org/download/linux/redhat/">官网安装教程地址</a></p>
<p>安装完成会自动创建一个用户为：postgres  </p>
<p>首先使用管理员用户修改密码，然后登录以后，运行psql 即可使用，</p>
<p>允许远程访问，yum安装的ppostgresql 的配置文件在<code>/var/lib/pgsql/12/data</code> 目录下</p>
<p>修改配置文件 <code>postgresql.conf</code> 将 <code>listen_addresses = &#39;localhost&#39; </code>改为 <code>listen_addresses = &#39;*&#39; </code></p>
<p>然后在修改 <code>pg_hba_conf</code> 在最后一行添加 <code>host all  all  0.0.0.0/0  md5</code>  允许所有IIP访问， 如果限定IP,将0.0.0.0 改为指定IP。</p>
<p>重启命令postgresql  ：<code>systemctl restart postgresql-12</code></p>
<p>参考材料：<a href> https://www.cnblogs.com/littleatp/p/10542137.html </a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Centos、Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>Python压缩图片作为缩略图</title>
    <url>/2021/02/02/Python%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<p>将图片压缩，作为缩略图，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFile</span><br><span class="line">ImageFile.LOAD_TRUNCATED_IMAGES = <span class="literal">True</span>    <span class="comment">#   OSError: image file is truncated   图像被截断错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize_by_size</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;按照生成图片文件大小进行处理(单位KB)&quot;&quot;&quot;</span></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">        im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">        size_tmp = os.path.getsize(infile)</span><br><span class="line">        q = <span class="number">100</span></span><br><span class="line">        <span class="keyword">while</span> size_tmp &gt; <span class="number">10240</span> <span class="keyword">and</span> q &gt; <span class="number">0</span>:</span><br><span class="line">            out = im.resize(im.size, Image.ANTIALIAS)</span><br><span class="line">            out.save(outfile, quality=q)</span><br><span class="line">            size_tmp = os.path.getsize(outfile)</span><br><span class="line">            q -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> q == <span class="number">100</span>:</span><br><span class="line">            shutil.copy(infile,outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equal_img</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    修改大小</span></span><br><span class="line"><span class="string">    :param cls:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.startswith(<span class="string">&#x27;thumbnail&#x27;</span>) <span class="keyword">or</span> file_name.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 判断是不是图片。不是的话，忽略</span></span><br><span class="line">        <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>,<span class="string">&#x27;JPEG&#x27;</span>]:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&#x27;file_name：&#x27;,outfilename)</span></span><br><span class="line">            outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">            <span class="comment"># print(u&#x27;path：&#x27;,outfile)</span></span><br><span class="line">            im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">            width = im.size[<span class="number">0</span>]   <span class="comment"># 获取宽度</span></span><br><span class="line">            height = im.size[<span class="number">1</span>]   <span class="comment"># 获取高度</span></span><br><span class="line">            print(<span class="string">u&#x27;width：height：&#x27;</span>,width,height)</span><br><span class="line">            <span class="keyword">if</span> width &lt;= <span class="number">200</span>:</span><br><span class="line">                shutil.copy(infile,outfile)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coe = <span class="built_in">float</span>(<span class="string">&#x27;%.2f&#x27;</span>%(<span class="number">200</span>/width))   <span class="comment">#保留两位小数可能是0.00，</span></span><br><span class="line">                print(<span class="string">u&#x27;coe：&#x27;</span>,coe)</span><br><span class="line">                <span class="keyword">if</span> coe &lt;= <span class="number">0</span>:</span><br><span class="line">                    coe = <span class="number">0.15</span></span><br><span class="line">                <span class="keyword">if</span> im.mode == <span class="string">&quot;P&quot;</span>:</span><br><span class="line">                    im = im.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">                out = im.resize((<span class="built_in">int</span>(width*coe), <span class="built_in">int</span>(height*coe)), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">                out.save(outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gci</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="comment">#遍历filepath下所有文件，包括子目录</span></span><br><span class="line">    files = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> fi <span class="keyword">in</span> files:</span><br><span class="line">        fi_d = os.path.join(filepath,fi)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(fi_d):</span><br><span class="line">            gci(fi_d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># resize_by_size(os.path.join(filepath,fi_d))</span></span><br><span class="line">            equal_img(os.path.join(filepath,fi_d))</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归遍历/root目录下所有文件</span></span><br><span class="line"><span class="comment"># gci(&#x27;/var/local/www/edu_online1/media/works&#x27;)</span></span><br><span class="line"><span class="comment"># gci(&#x27;/root/www/edu_online1/media/works/13360067818/tradition&#x27;)  #正式</span></span><br><span class="line">gci(<span class="string">&#x27;/root/www/edu_online1/media/works/13265647342/udict/1552525240000/䤋&#x27;</span>)  <span class="comment">#正式</span></span><br><span class="line"><span class="comment"># gci(r&#x27;F:\desktop\䤋&#x27;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python、压缩图片</tag>
      </tags>
  </entry>
  <entry>
    <title>flaskshell创建索引出错</title>
    <url>/2021/02/02/flaskshell%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>遇到的问题：flask 环境中使用 flask shell  使用flask Whoosh 创建索引失败</p>
<a id="more"></a>

<h3 id="解决办法-："><a href="#解决办法-：" class="headerlink" title="解决办法 ："></a>解决办法 ：</h3><pre><code>export FLASK_APP=manage.py
flask shell 
</code></pre>
<p>然后导出 flask 创建的whoosh的whoosh对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 项目内的文件 import whoosh</span><br><span class="line">whoosh.create_index()</span><br></pre></td></tr></table></figure>

<p>​    </p>
]]></content>
      <categories>
        <category>Flak</category>
      </categories>
      <tags>
        <tag>Flask、shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python + Elestatcsearch</title>
    <url>/2021/02/02/Python-Elestatcsearch/</url>
    <content><![CDATA[<blockquote>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p> ElasticSearch是一个基于<a href="https://baike.baidu.com/item/Lucene/6753302">Lucene</a>的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353">云计算</a>中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。 </p>
<a id="more"></a>

<h2 id="有关概念"><a href="#有关概念" class="headerlink" title="有关概念"></a>有关概念</h2><p>cluster：代表一个<a href="https://baike.baidu.com/item/%E9%9B%86%E7%BE%A4">集群</a>，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</p>
<p>shards：代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</p>
<p>replicas：代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的<a href="https://baike.baidu.com/item/%E5%AE%B9%E9%94%99%E6%80%A7">容错性</a>，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</p>
<p>recovery：代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</p>
<p>river：代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。</p>
<p>gateway：代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分布式文件系统</a>，Hadoop的HDFS和amazon的s3<a href="https://baike.baidu.com/item/%E4%BA%91%E5%AD%98%E5%82%A8">云存储</a>服务。</p>
<p>discovery.zen：代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%92%AD">多播</a>协议来进行节点之间的通信，同时也支持<a href="https://baike.baidu.com/item/%E7%82%B9%E5%AF%B9%E7%82%B9">点对点</a>的交互。</p>
<p>Transport：代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、<a href="https://baike.baidu.com/item/thrift">thrift</a>、servlet、memcached、zeroMQ等的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">传输协议</a>（通过<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6">插件</a>方式集成）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Elestaticsearch</category>
      </categories>
      <tags>
        <tag>Elestaticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>两台linux 互相传输文件</title>
    <url>/2021/02/02/%E4%B8%A4%E5%8F%B0linux-%E4%BA%92%E7%9B%B8%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>​                 </p>
<a id="more"></a>

<blockquote>
<h4 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h4><h6 id="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"><a href="#rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。" class="headerlink" title="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"></a>rsync是linux系统下的数据<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a><a href="https://baike.baidu.com/item/%E5%A4%87%E4%BB%BD">备份</a>工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。</h6><h5 id="它的特性如下："><a href="#它的特性如下：" class="headerlink" title="它的特性如下："></a>它的特性如下：</h5><ul>
<li><p>可以<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a>保存整个目录树和文件系统。</p>
</li>
<li><p>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</p>
</li>
<li><p>无须特殊权限即可安装。</p>
</li>
<li><p>快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync 在传输数据的过程中可以实行压缩及<a href="https://baike.baidu.com/item/%E8%A7%A3%E5%8E%8B%E7%BC%A9">解压缩</a>操作，因此可以使用更少的带宽。</p>
</li>
<li><p>安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。</p>
</li>
<li><p>支持匿名传输，以方便进行网站镜像。 </p>
</li>
</ul>
</blockquote>
<h4 id="1、Rsync参数说明"><a href="#1、Rsync参数说明" class="headerlink" title="1、Rsync参数说明"></a>1、Rsync参数说明</h4><ol>
<li><p>使用 rsync + ssh 进行加密传输  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh /home/ubuntu/remote_test ubuntu@193.112.102.63:/home/ubuntu/remote_test</span><br></pre></td></tr></table></figure></li>
<li><p>参数设置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v, --verbose 详细模式输出</span><br><span class="line">   -q, --quiet 精简输出模式</span><br><span class="line">   -c, --checksum 打开校验开关，强制对文件传输进行校验</span><br><span class="line">   -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span><br><span class="line">   -r, --recursive 对子目录以递归模式处理</span><br><span class="line">   -R, --relative 使用相对路径信息</span><br><span class="line">   -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">   --backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">   -suffix&#x3D;SUFFIX 定义备份文件前缀</span><br><span class="line">   -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)</span><br><span class="line">   -l, --links 保留软链结</span><br><span class="line">   -L, --copy-links 像对待常规文件一样处理软链接</span><br><span class="line">   --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链接</span><br><span class="line">   --safe-links 忽略指向SRC路径目录树以外的链接</span><br><span class="line">   -H, --hard-links 保留硬链接</span><br><span class="line">   -p, --perms 保持文件权限</span><br><span class="line">   -o, --owner 保持文件属主信息</span><br><span class="line">   -g, --group 保持文件属组信息</span><br><span class="line">   -D, --devices 保持设备文件信息</span><br><span class="line">   -t, --times 保持文件时间信息</span><br><span class="line">   -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间</span><br><span class="line">   -n, --dry-run显示哪些文件将被传输</span><br><span class="line">   -W, --whole-file 拷贝文件，不进行增量检测</span><br><span class="line">   -x, --one-file-system 不要跨越文件系统边界</span><br><span class="line">   -B, --block-size&#x3D;SIZE 检验算法使用的块尺寸，默认是700字节</span><br><span class="line">   -e, --rsh&#x3D;COMMAND 指定使用rsh、ssh方式进行数据同步</span><br><span class="line">   --rsync-path&#x3D;PATH 指定远程服务器上的rsync命令所在路径信息</span><br><span class="line">   -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件</span><br><span class="line">   --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件</span><br><span class="line">   --delete 删除那些DST中SRC没有的文件</span><br><span class="line">   --delete-excluded 同样删除接收端那些被该选项指定排除的文件</span><br><span class="line">   --delete-after 传输结束以后再删除</span><br><span class="line">   --ignore-errors 即使出现IO错误也进行删除</span><br><span class="line">   --max-delete&#x3D;NUM 最多删除NUM个文件</span><br><span class="line">   --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span><br><span class="line">   --force 强制删除目录，即使不为空</span><br><span class="line">   --numeric-ids 不将数字的用户和组ID匹配为用户名和组名</span><br><span class="line">   --timeout&#x3D;TIME IP超时时间，单位为秒</span><br><span class="line">   -I, --ignore-times 不跳过那些有同样的时间和长度的文件</span><br><span class="line">   --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间</span><br><span class="line">   --modify-window&#x3D;NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0</span><br><span class="line">   -T --temp-dir&#x3D;DIR 在DIR中创建临时文件</span><br><span class="line">   --compare-dest&#x3D;DIR 同样比较DIR中的文件来决定是否需要备份</span><br><span class="line">   -P 等同于 --partial</span><br><span class="line">   --progress 显示备份过程</span><br><span class="line">   -z, --compress 对备份的文件在传输时进行压缩处理</span><br><span class="line">   --exclude&#x3D;PATTERN 指定排除不需要传输的文件模式</span><br><span class="line">   --include&#x3D;PATTERN 指定不排除而需要传输的文件模式</span><br><span class="line">   --exclude-from&#x3D;FILE 排除FILE中指定模式的文件</span><br><span class="line">   --include-from&#x3D;FILE 不排除FILE指定模式匹配的文件</span><br><span class="line">   --version 打印版本信息</span><br><span class="line">   --address 绑定到特定的地址</span><br><span class="line">   --config&#x3D;FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件</span><br><span class="line">   --port&#x3D;PORT 指定其他的rsync服务端口</span><br><span class="line">   --blocking-io 对远程shell使用阻塞IO</span><br><span class="line">   -stats 给出某些文件的传输状态</span><br><span class="line">   --progress 在传输时显示传输过程</span><br><span class="line">   --log-format&#x3D;formAT 指定日志文件格式</span><br><span class="line">   --password-file&#x3D;FILE 从FILE中得到密码</span><br><span class="line">   --bwlimit&#x3D;KBPS 限制I&#x2F;O带宽，KBytes per second</span><br><span class="line">   -h, --help 显示帮助信息</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2、目的"><a href="#2、目的" class="headerlink" title="2、目的"></a>2、目的</h4><ul>
<li><p>实现两台服务器之间做增量备份。A服务器作为服务端，B服务器作为客户端。</p>
</li>
<li><p>B服务器每天定时将某个目录下产生的文件发送到A服务器中。</p>
</li>
</ul>
<h4 id="3、操作方法"><a href="#3、操作方法" class="headerlink" title="3、操作方法"></a>3、操作方法</h4><p>在A服务器中安装 rsync ，查看服务器是否安装rsync。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync --version</span><br><span class="line">#显示如下  代表已经安装  版本为：3.1.1  (确保两台服务器之前安装的版本的一致，不一致可能造成无法同步数据)</span><br><span class="line">rsync  version 3.1.2  protocol version 31</span><br><span class="line">Copyright (C) 1996-2015 by Andrew Tridgell, Wayne Davison, and others.</span><br><span class="line">Web site: http:&#x2F;&#x2F;rsync.samba.org&#x2F;</span><br><span class="line">Capabilities:</span><br><span class="line">    64-bit files, 64-bit inums, 64-bit timestamps, 64-bit long ints,</span><br><span class="line">    socketpairs, hardlinks, symlinks, IPv6, batchfiles, inplace,</span><br><span class="line">    append, ACLs, xattrs, iconv, symtimes, prealloc</span><br><span class="line"></span><br><span class="line">rsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you</span><br><span class="line">are welcome to redistribute it under certain conditions.  See the GNU</span><br><span class="line">General Public Licence for details.</span><br></pre></td></tr></table></figure>
<p>两边都安装完成了以后，就可以使用了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh 001 ubuntu@193.112.102.63:/home/ubuntu/remote_test   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ssh模式连接 需要输入密码</span></span><br></pre></td></tr></table></figure>
<h5 id="1-将A服务器作为服务端"><a href="#1-将A服务器作为服务端" class="headerlink" title="1. 将A服务器作为服务端"></a>1. 将A服务器作为服务端</h5><p>编辑文件 <code>/etc/vi /etc/rsyncd.conf</code>默认不存在， 直接创建 。编辑输入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务端配置文件 (和上面一样)</span></span><br><span class="line">motd file = /etc/rsyncd.motd</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsyncd.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line">[workspace]  #模块名 在客户端需要用到</span><br><span class="line">path = /devdata/backres   #需要备份的路径</span><br><span class="line">comment = Test</span><br><span class="line">uid = root   #使用的用户</span><br><span class="line">gid = root   #同上 </span><br><span class="line">read only = false   #是否可写</span><br><span class="line">auth users = root   #验证的用户</span><br><span class="line">secrets file = /etc/rsyncd.pass   #密码文件  文件的权限：600</span><br><span class="line">transfer logging = yes   #日志输出</span><br><span class="line">hosts allow=123.207.165.19   #允许的可短的IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建密码文件 在上述的conf文件中，倒数第三行。内容为当前用户名以及密码 。格式：user：password。密码文件拥有用户必须为当前用户 ubuntu 且权限必须为 600</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu:123456</span><br></pre></td></tr></table></figure>
<p>查看rsync 状态 ： <code>service rsync status</code>。 重启rsync服务： <code>service rsync restart</code></p>
<h5 id="2-将b服务器作为客户端"><a href="#2-将b服务器作为客户端" class="headerlink" title="2. 将b服务器作为客户端"></a>2. 将b服务器作为客户端</h5><p>客户端不需要设置太多内容可直接运行命令，不过需要手动输入密码，可将密码存在一个文件内，使用<code>--password-file=FILE</code> 进行从文件中读取密码。这个文件路径任意。文件内容只包含服务端密码即可。但是必须为root用户拥有且权限为600。</p>
<p>使用命令 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rsync -aqr --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数解释：</span></span><br><span class="line">-a：--archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，</span><br><span class="line">-q：--quiet 精简输出模式</span><br><span class="line">-r：--recursive 对子目录以递归模式处理</span><br><span class="line">workspace：即服务端的模块名</span><br></pre></td></tr></table></figure>
<h5 id="3-设置定时任务"><a href="#3-设置定时任务" class="headerlink" title="3. 设置定时任务"></a>3. 设置定时任务</h5><p>使用ubuntu 的crontab </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>第一次打开会选择的编辑器，一般选择vim,输入数字即可。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Select an editor.  To change later, run &#x27;select-editor&#x27;.</span><br><span class="line">  1. /bin/ed</span><br><span class="line">  2. /bin/nano        &lt;---- easiest</span><br><span class="line">  3. /usr/bin/vim.basic</span><br><span class="line">  4. /usr/bin/vim.tiny</span><br></pre></td></tr></table></figure>
<p>定时任务格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* * * * * command    </span><br><span class="line">用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</span><br><span class="line">minute hour day month week command</span><br><span class="line">其中：</span><br><span class="line">minute：表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</span><br><span class="line">/ 斜杠代表频率 例如：</span><br><span class="line">如果想每分钟都执行一次的话就采用默认的 * * * * *</span><br><span class="line">如果想每五分钟执行一次可以 */5 * * * * </span><br><span class="line">如果是每两个小时执行一次的话 那就是 *  */2 * * *来设置;</span><br></pre></td></tr></table></figure>
<p>在定时任务中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">30 23 * * * sudo rsync -r --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br><span class="line"><span class="meta">#</span><span class="bash">表示 在每天的23:30 进行数据备份</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN的工作原理</title>
    <url>/2021/02/01/CDN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="CDN访问的两个阶段"><a href="#CDN访问的两个阶段" class="headerlink" title="CDN访问的两个阶段"></a>CDN访问的两个阶段</h3><ul>
<li>1.域名解析</li>
<li>2.内容请求</li>
</ul>
<a id="more"></a>

<h3 id="使用CDN得两种方式："><a href="#使用CDN得两种方式：" class="headerlink" title="使用CDN得两种方式："></a>使用CDN得两种方式：</h3><ul>
<li>手工上传静态资源文件到CDN</li>
<li>tongguo Tengine 把本机的静态资源开放发哦web上，CDN自动回流到Tengine。</li>
</ul>
<h4 id="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"><a href="#以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。" class="headerlink" title="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"></a>以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。</h4><ul>
<li>生成静态文件上传到阿里元OSS。</li>
<li>配置CDN域名，回源地址指向OSS Bucket，配置Referer 防盗链的白名单。</li>
<li>配置OSS Buket 的匿名可以读。</li>
<li>设置STATIC_URL， 直接指向CDN地址，同时注释掉 OssStaticStorage。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP、前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之美：dajngo的常用插件</title>
    <url>/2021/02/01/Django%E4%B9%8B%E7%BE%8E%EF%BC%9Adajngo%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://django-debug-toolbar.readthedocs.io/en/latest/">django_debug_toolbar </a>：提供一个可以查看debug信息的面板（包括SQL执行时间，页面耗时）</p>
</li>
<li><p><a href="https://github.com/jazzband/django-silk">django-silk</a>：django性能瓶颈分析</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><a href="https://simpleui.72wo.com/docs/simpleui/doc.html">Simple-UI</a> ：于Element UI 和 VUE 的django admin 主题。</li>
</ul>
<ul>
<li><a href="https://django-haystack.readthedocs.io/en/master/">haystack django</a> ：模块化搜索方案</li>
</ul>
<ul>
<li><a href="https://github.com/django-notifications/django-notifications">django-notifications</a>：发送消息通知插件</li>
</ul>
<ul>
<li><a href="https://github.com/agusmakmun/django-markdown-editor">django markdown editor</a> ：Markdown 编辑器</li>
</ul>
<ul>
<li><a href="https://github.com/django-crispy-forms/django-crispy-forms">django-crispy-forms</a>：Crispy 表单，以一种非常优雅的、干净的方式来创建表单。</li>
</ul>
<ul>
<li><a href="https://github.com/mbi/django-simple-captcha">django-simple-captcha</a>：Django验证码</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django、后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 8.0 连接数据库错误</title>
    <url>/2021/02/01/Mysql%208.0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h4 id="Mysql-8-0-连接数据库出现-The-user-specified-as-a-definer-‘mysql-infoschema‘-‘localhost‘-does-not-exist"><a href="#Mysql-8-0-连接数据库出现-The-user-specified-as-a-definer-‘mysql-infoschema‘-‘localhost‘-does-not-exist" class="headerlink" title="Mysql 8.0 连接数据库出现 The user specified as a definer (‘mysql.infoschema‘@‘localhost‘) does not exist"></a>Mysql 8.0 连接数据库出现 The user specified as a definer (‘mysql.infoschema‘@‘localhost‘) does not exist</h4><a id="more"></a>

<p>解决办法：</p>
<ol>
<li><p>重新创建该用户（mysql.infoschema）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;mysql.infoschema&#x27;</span> @ <span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;password &#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>给用户赋予权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;mysql.infoschema&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>刷新数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql、后端</tag>
      </tags>
  </entry>
</search>
