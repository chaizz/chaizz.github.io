<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>迭代思维与MVP产品的规划方法</title>
    <url>/2021/02/04/%E8%BF%AD%E4%BB%A3%E6%80%9D%E7%BB%B4%E4%B8%8EMVP%E4%BA%A7%E5%93%81%E7%9A%84%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="快速迭代的价值与挑战"><a href="#快速迭代的价值与挑战" class="headerlink" title="快速迭代的价值与挑战"></a>快速迭代的价值与挑战</h3><p>快速迭代：以天或者小时为单位，持续的完善产品，交付到用户的循环过程</p>
<a id="more"></a>

<h4 id="快速迭代的价值："><a href="#快速迭代的价值：" class="headerlink" title="快速迭代的价值："></a>快速迭代的价值：</h4><ul>
<li>时间是最大的成本，机会转瞬即逝，赢得市场先机。</li>
<li>快速验证需求，减少不对用户产生价值的投入（Fail fast, Fail better）。</li>
<li>快速验证方案，提高研发效率。</li>
<li>加速反馈回路，给到团队和自己及时的激励。</li>
</ul>
<h4 id="快速迭代的挑战："><a href="#快速迭代的挑战：" class="headerlink" title="快速迭代的挑战："></a>快速迭代的挑战：</h4><ul>
<li>产品设计者：能梳理清楚业务流程，抓住用户的重点需求，能把客户需求转换为系统的需求。</li>
<li>开发者：充分理解用户需求，有足够的能力，能用简洁的方案来设计出易维护的系统。</li>
</ul>
<h4 id="根本挑战："><a href="#根本挑战：" class="headerlink" title="根本挑战："></a>根本挑战：</h4><ul>
<li><p>市场、用户、技术、环境变化太快，产品开发跟不上节奏。</p>
</li>
<li><p>几乎不能从一开始就设计一个完美的，能够使用未来长时间变化的方案</p>
</li>
<li><p>几乎没有人愿意承认，自己没有足够的力（或条件）设计一个完美的产品（系统）。</p>
</li>
</ul>
<h3 id="OOPD-方法识别产品的核心功能"><a href="#OOPD-方法识别产品的核心功能" class="headerlink" title="OOPD 方法识别产品的核心功能"></a>OOPD 方法识别产品的核心功能</h3><p>OOPD：Online and Offline integrated Product Development  </p>
<p><img src="/2021/02/04/迭代思维与MVP产品的规划方法/OOPD.png"></p>
<p>OOPD迭代的原则：</p>
<ul>
<li>自助原则：做自己的产品，自己用自己的产品，吃自己的狗食。</li>
<li>0day：找到明确的核心问题，拆解目标，抓住核心的问题，忽略掉一切细节，0day发布。</li>
<li>时限原则：设定时限，挑战自我，不给自己写BUG的时间。</li>
<li>不完美原则：不做完美的产品。（没有完美的产品，不去为了完美而浪费宝贵的资源）</li>
<li>谦卑原则：能够看到自己的局限性，获取用户反馈，持续迭代，听取用户的声音。</li>
</ul>
<p>MVP：minimum viable product 最小可用产品</p>
<ul>
<li>内裤原则 ： MVP 包括了产品的轮廓，核心的功能，让业务可以运转。</li>
<li>优先线下：能够走线下的 优先走线下的流程，让核心的功能先跑起来，快速的做用户验证和方案验证。</li>
<li>MVP的核心：忽略掉一切技术的细枝末节，做最合适的假设和简化，使用最短的时间开发出来。</li>
</ul>
<p>迭代思维最强大的是产品思维逻辑，互联网唯快不破的秘诀。</p>
<h3 id="如何做好技术方案设计与工作拆解"><a href="#如何做好技术方案设计与工作拆解" class="headerlink" title="如何做好技术方案设计与工作拆解"></a>如何做好技术方案设计与工作拆解</h3><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h4><ul>
<li>做技术方案设计的前提条件<ul>
<li>有明确的的用户场景，用户如何和产品进行交互，期望拿到什么预期结果。</li>
<li>有清晰定义的业务流程</li>
</ul>
</li>
</ul>
<p><img src="/2021/02/04/迭代思维与MVP产品的规划方法/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.png"></p>
<ul>
<li><p>用什么工具设计？</p>
<ul>
<li>Visual Paradigm</li>
<li>Lucid Chart</li>
<li>Visio</li>
<li>Gliffy</li>
<li>Draw.io</li>
<li>Astash</li>
<li>StarUML</li>
<li>…..</li>
</ul>
<p>推荐使用<strong>白纸</strong>，不用工具就是最好的工具。</p>
</li>
<li><p>产出的技术方案文档要素</p>
<ul>
<li>产品背景（用户场景、产品目标、引用到的业务流畅、产品需求文档）</li>
<li>要解决的问题列表，系统不解决的问题列表，系统的限制。</li>
<li>对于问题的不同的解决方案的对比，阐述各个主要的问题如何被解决。</li>
<li>所选的整体的流程图（序列图），模块关系图，重要的接口，实体的概念定义。</li>
<li>除了功能之外的其他方面的设计，包括安全、性能、可维护性、稳定性、监控、扩展性、易用性等。</li>
</ul>
</li>
</ul>
<h4 id="工作拆解"><a href="#工作拆解" class="headerlink" title="工作拆解"></a>工作拆解</h4><p>​    任何事情，只要把它拆解的够细，都能够完成它。</p>
<ul>
<li>工作拆解的原则：<ul>
<li>优先级：主流程上，不确定的工作先完成（建议提前一个迭代做调研）。</li>
<li>核心流程优先：核心工作优先，先把主流程跑通。</li>
<li>依赖：减少不同人之间的工作依赖，并且保持团队工作拆解的透明，预留20%Buffer。</li>
<li>拆解粒度：拆解到每项子任务0.5-1天的粒度，最长不要超过两天。</li>
</ul>
</li>
</ul>
<h3 id="如何保证交付质量和可持续迭代"><a href="#如何保证交付质量和可持续迭代" class="headerlink" title="如何保证交付质量和可持续迭代"></a>如何保证交付质量和可持续迭代</h3><p>定义好产品需求，产品需求从根本上决定了产品的质量。</p>
<p>系统上有整体架构方案的设计，评估，评审，系统决定了软件实现的质量。</p>
<p>工程的角度持续交付的最佳实践推荐：</p>
<ul>
<li> Code Review：每一次提交都有CR，每次commit 代码量控制在200行y以内。尽量频繁的commit。</li>
<li>单元集成：项目开始简历单元测试的机制，在持续集成中自动运行。</li>
<li>自动化回归：对预发/线上系统做KPI/页面自动化测试（Postman/Robot Framework）</li>
<li>使用CICD机制对心痛进行自动化的打包，测试，部署，线上验证。</li>
<li>发布过程做到可监控，可回滚。</li>
<li>对于大量用户使用的产品，使用灰度机制。</li>
<li>架构上对于意外的并发访问，进行限流，降级。</li>
<li>架构上使用配置开关，对系统功能能提供实时的开启/关闭的服务。</li>
<li>对产品简历A/B Test 机制，通过数据快速对比不同的版本，不同的方案。</li>
<li>自动化所有的事情，代码化所有过程：代码化配置，代码化部署流程，代码化基础设置。<ul>
<li>声明式API，CICD Pipeline，K8S，Helm , Terraform</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>快速迭代、OOPD</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQLMVCC机制</title>
    <url>/2021/10/08/MysqlMVCC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>​       </p>
<a id="more"></a>

<blockquote>
<p>数据库事务的四大特性：</p>
<p>原子性：atomicity 是通过undo log 来实现的。</p>
<p>一致性：consistency  原子性、隔离性、持久性来共同保持一致性。</p>
<p>隔离性：isolation 通过加锁以及MVCC来实现的。</p>
<p>持久性：durability 是通过redo log 实现的。</p>
</blockquote>
<h1 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h1><p>MVCC（Multi - Version - Concurrency - Control）全称是<strong>多版本并发控制</strong>。主要是为了提高数据库的并发性能。MVCC只在<strong>读已提交</strong>和<strong>可重复读</strong>的两个事务级别下有效。主要是用于处理读请求。</p>
<h1 id="MySQL的快照读和当前读是什么？"><a href="#MySQL的快照读和当前读是什么？" class="headerlink" title="MySQL的快照读和当前读是什么？"></a>MySQL的快照读和当前读是什么？</h1><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>他读取数据库记录都是当前最新的版本，会对当前读取的数据进行加锁，防止其他的事务对数据修改，属于悲观锁的一种。</p>
<p>以下操作都是当前读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select lock in share mode # (共享锁)</span><br><span class="line"></span><br><span class="line">select for update  #(排他锁)</span><br><span class="line"></span><br><span class="line">update # (排他锁)</span><br><span class="line"></span><br><span class="line">insert #(排它锁)</span><br><span class="line"></span><br><span class="line">delete  #(排它锁)</span><br><span class="line"></span><br><span class="line"># 串行化事务隔离级别</span><br></pre></td></tr></table></figure>


<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>快照读是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。           </p>
<p>首先MySQL一条记录里面包含三个隐藏列：<strong>row_id</strong>、<strong>trx_id</strong>、<strong>roll_pointer</strong>以及<strong>ReadView</strong>。</p>
<ul>
<li>row_id ：MySQL的B+树索引特性要求每个表必须要有一个主键。如果没有设置的话，会自动寻找第一个不包含NULL的唯一索引列作为主键。如果还是找不到，就会在这个DB_ROW_ID上自动生成一个唯一值，以此来当作主键。</li>
<li>trx_id：自增的事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID（DELETE语句被当做是UPDATE语句的特殊情况，后面会进行说明）</li>
<li>roll_pointer：回滚指针，通过它可以将不同的版本串联起来，形成版本链。相当于链表的next指针。</li>
<li></li>
</ul>
<h3 id="一张图理解undo-log"><a href="#一张图理解undo-log" class="headerlink" title="一张图理解undo log"></a>一张图理解undo log</h3><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-10-08_22-43-53.png"></p>
<p>以上图中最新的记录name为赵六，他指向前一个版本name为王五，依次类推，王五的上一个版本是李四，李四的上一版本是张三。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p><strong>ReadView的作用？</strong></p>
<p>就是根据事务ID查找对应的数据。那些事务应该读取到那些数据。</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-10-08_22-56-42.png"></p>
<p>m_ids ：当前MySQL中所有的<strong>活跃</strong>（<strong>指未提交的</strong>）的事务的ID。</p>
<p>min_trx_id：表示m_ids 中最小的事务ID。、</p>
<p>max_trx_id：表示生成ReadView时系统应该分配给下一个事物的ID。、</p>
<p>creator_trx_id：生成该ReadView的ID。</p>
<p><strong>ReadView如何判断哪个版本可用？</strong></p>
<ul>
<li>trx_id == creator_trx_id    如果事务ID等于当前生成ReadView的vreator_trx_id ，那么可以访问这个版本。</li>
<li>trx_id  &lt; mix_trx_id 事务ID小于当前ReadView中的最小的活跃事务的ID，说明该事务是已经提交的了事务。那么可以访问。</li>
<li>trx_id  &gt; max_trx_id 事务ID大于当前ReadView中的要分配的事务的ID，说明max_trx_id  是创建ReadView之后生成的ID，已经超出版本链的事务的ID，所以无法读取。</li>
<li>min_trx_id  &lt;=  trx_id  &lt;= max_trx_id 分两种情况：<ul>
<li>① 当trx_id   在min_trx_id   中，说明是活跃的事务的ID，未提交的事务，那么不能访问当前版本。</li>
<li>②当trx_id  不在min_trx_id   中，说明不是活跃的事务的ID，而且小于系统下一个事务的ID，那么可以访问当前版本。</li>
</ul>
</li>
</ul>
<h2 id="MVCC如何实现RR-（可重复读）和RC（读已提交）的？"><a href="#MVCC如何实现RR-（可重复读）和RC（读已提交）的？" class="headerlink" title="MVCC如何实现RR （可重复读）和RC（读已提交）的？"></a>MVCC如何实现RR （可重复读）和RC（读已提交）的？</h2><p><strong>实现RC</strong></p>
<p>RC生成ReadView的事迹是每次select查询的时候就会生成一个ReadView，他是以每个select查询为单位的，比如一个事务中有两个select语句，那么这两个select就会生成两个ReadView，所以在一个事务中就可以读取到其他事务已经提交的数据，就会产生不可重复读的问题。</p>
<p><strong>实现RR</strong></p>
<p>RR 生成ReadView 是根据事务来生成，他是以每个事务为单位生成的。在一个事务中不管有多少查询语句，查询的ReadView还是同一个，所以只能读取到当前版本的数据，就可以解决不可重复读的问题。</p>
<p>InndDB 解决幻读：是通过间隙锁，间隙锁锁住一段范围，所以其他事务无法对这段范围的数据进行才做插入删除，所以就不存在幻读的问题。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerSwarm理解</title>
    <url>/2021/09/29/DockerSwarm%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、DockerSwarm理解"><a href="#一、DockerSwarm理解" class="headerlink" title="一、DockerSwarm理解"></a>一、DockerSwarm理解</h1><blockquote>
<p>官网解释：</p>
<p>Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.</p>
<p>Docker Engine 1.12 引入了 swarm 模式，使您能够创建一个由一个或多个 Docker 引擎组成的集群，称为 swarm。 swarm 由一个或多个节点组成：在 swarm 模式下运行 Docker Engine 1.12 或更高版本的物理或虚拟机。</p>
</blockquote>
<a id="more"></a>

<p><a href="https://docs.docker.com/engine/swarm/">官网地址</a></p>
<p><img src="https://tc.chaizz.com/tc/swarm-diagram.png"></p>
<h2 id="1、Swarm-中有两种类型的节点："><a href="#1、Swarm-中有两种类型的节点：" class="headerlink" title="1、Swarm 中有两种类型的节点："></a>1、Swarm 中有两种类型的节点：</h2><h3 id="1-1、managers-的作用"><a href="#1-1、managers-的作用" class="headerlink" title="1.1、managers 的作用"></a>1.1、managers 的作用</h3><ul>
<li>维护集群状态</li>
<li>集群调度</li>
<li>给集群提供API</li>
</ul>
<p>Swarm 使用Raft来保证分布式一致性。</p>
<blockquote>
<p><a href="https://raft.github.io/">Raft </a>是一种更为简单方便易于理解的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/1372646">分布式算法</a>，主要解决了分布式中的一致性问题。相比传统的<a href="https://baike.baidu.com/item/Paxos%E7%AE%97%E6%B3%95/6632960">Paxos算法</a>，Raft将大量的计算问题分解成为了一些简单的相对<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%AB%8B/3259">独立</a>的子问题。</p>
<p>相比于传统的一致性算法Paxos，Raft有一些自己的独特的特性。比如增加了强领导性，优化了领导的选举过程，在成员发生变化之后依然能够很好的进行工作。</p>
</blockquote>
<p>三个管理器的群体最多可以容忍一个管理器的损失。<br>一个五管理器群可以容忍最大同时丢失两个管理器节点。<br>N 个管理器集群最多可以容忍 (N-1)/2 个管理器的丢失。<br>Docker 建议一个集群最多有七个管理器节点。</p>
<p>在一些分布式任务重，节点个数往往是奇数。是为了能够成功选举出领导，如果是偶数肯能会有得票一致的情况。</p>
<h3 id="1-2、workers"><a href="#1-2、workers" class="headerlink" title="1.2、workers"></a>1.2、workers</h3><p>worker 节点 就是docekr引擎的实例，他的唯一的目的就是执行容器。worker节点不参与 Raft 分布式状态，不做出调度决策，也不为群模式 HTTP API 提供服务。</p>
<h1 id="二、创建集群"><a href="#二、创建集群" class="headerlink" title="二、创建集群"></a>二、创建集群</h1><h2 id="1、初始化集群"><a href="#1、初始化集群" class="headerlink" title="1、初始化集群"></a>1、初始化集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化主节点，使用主节点创建不同类型的节点令牌</span></span><br><span class="line">docker swarm init --advertise-addr 内网地址</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建manager令牌</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建worker令牌</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入一个节点</span></span><br><span class="line">docker swarm join ---token 令牌</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看节点名称</span></span><br><span class="line">docker node ls</span><br></pre></td></tr></table></figure>


<h1 id="三、Docker-服务弹性扩容"><a href="#三、Docker-服务弹性扩容" class="headerlink" title="三、Docker 服务弹性扩容"></a>三、Docker 服务弹性扩容</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Swarm manager 节点下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个服务，具备扩缩容的功能</span></span><br><span class="line">docker service create -p 8888:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接启动三个副本。</span></span><br><span class="line">docker service update --replicas 3 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker、Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerCompose理解</title>
    <url>/2021/09/29/DockerCompose%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、DockerCompose理解"><a href="#一、DockerCompose理解" class="headerlink" title="一、DockerCompose理解"></a>一、DockerCompose理解</h1><blockquote>
<p><a href="https://docs.docker.com/compose/">Docker Compose</a> is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.</p>
<p>The <em>big</em> advantage of using Compose is you can define your application stack in a file, keep it at the root of your project repo (it’s now version controlled), and easily enable someone else to contribute to your project. Someone would only need to clone your repo and start the compose app. In fact, you might see quite a few projects on GitHub/GitLab doing exactly this now.</p>
</blockquote>
<a id="more"></a>

<p>Docker compose 是来管理多个容器的一个工具。</p>
<h2 id="1、安装Docker-Compose"><a href="#1、安装Docker-Compose" class="headerlink" title="1、安装Docker Compose"></a>1、安装Docker Compose</h2><p><a href="https://github.com/docker/compose/releases/download/v2.0.0/docker-compose-linux-amd64">Docker-compose地址</a></p>
<h3 id="1-1-创建cli-plugins-目录"><a href="#1-1-创建cli-plugins-目录" class="headerlink" title="1.1 创建cli-plugins 目录"></a>1.1 创建cli-plugins 目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在github上下载最新版docker-compose ,放在 docker安装用户家目录下 ：root/.docker/cli-plugins</span></span><br><span class="line"></span><br><span class="line">cd .docker</span><br><span class="line">mkdir cli-plugins</span><br></pre></td></tr></table></figure>
<h3 id="1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose"><a href="#1-2-将下载的docker-compose-linux-amd64-改名为-docker-compose" class="headerlink" title="1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose"></a>1.2 将下载的docker-compose-linux-amd64  改名为 docker-compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在root/.docker/cli-plugins 目录下</span></span><br><span class="line">mv docker-compose-linux-amd64 docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-3-添加执行权限"><a href="#1-3-添加执行权限" class="headerlink" title="1.3 添加执行权限"></a>1.3 添加执行权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x root/.docker/cli-plugins/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="1-4-安装低版本"><a href="#1-4-安装低版本" class="headerlink" title="1.4 安装低版本"></a>1.4 安装低版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> docker-compose --version</span><br></pre></td></tr></table></figure>


<p><strong>v2.0.0版本命令为 <code>docker compose </code>中间没有横杠</strong></p>
<h2 id="2、Docker-Componse-官网示例（创建一个Python-web应用）："><a href="#2、Docker-Componse-官网示例（创建一个Python-web应用）：" class="headerlink" title="2、Docker Componse 官网示例（创建一个Python web应用）："></a>2、Docker Componse 官网示例（创建一个Python web应用）：</h2><h3 id="2-1、创建app-py"><a href="#2-1、创建app-py" class="headerlink" title="2.1、创建app.py"></a>2.1、创建<code>app.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span>():</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure>


<h3 id="2-2、创建包文件夹-requirements-txt："><a href="#2-2、创建包文件夹-requirements-txt：" class="headerlink" title="2.2、创建包文件夹 requirements.txt："></a>2.2、创建包文件夹 <code>requirements.txt</code>：</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建Dockerfile文件"><a href="#2-3-创建Dockerfile文件" class="headerlink" title="2.3 创建Dockerfile文件"></a>2.3 创建<code>Dockerfile</code>文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建-docker-compose-yml文件-："><a href="#2-4-创建-docker-compose-yml文件-：" class="headerlink" title="2.4 创建 docker-compose.yml文件 ："></a>2.4 创建 <code>docker-compose.yml</code>文件 ：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-5-在-docker-compose-yml-目录下运行命令"><a href="#2-5-在-docker-compose-yml-目录下运行命令" class="headerlink" title="2.5 在 docker-compose.yml 目录下运行命令"></a>2.5 在 <code>docker-compose.yml</code> 目录下运行命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker compose up	</span><br></pre></td></tr></table></figure>


<p>出现错误 ：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-29_19-51-36.png"></p>
<p>解决：在Dockerfile中添加下面这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完整的Dockerfile：</span></span><br><span class="line"></span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line">RUN sed -i -e &#x27;s/http:/https:/&#x27; /etc/apk/repositories</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">ENV FLASK_RUN_HOST=0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定清华源  下载快</span></span><br><span class="line">RUN pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --no-cache-dir -r requirements.txt</span><br><span class="line">EXPOSE 5000</span><br><span class="line">COPY . .</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-5-运行成功"><a href="#2-5-运行成功" class="headerlink" title="2.5 运行成功"></a>2.5 运行成功</h3><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-29_20-48-16.png"></p>
]]></content>
      <tags>
        <tag>Docker、Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Dcoker知识总结</title>
    <url>/2021/09/27/Docker%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production.</p>
</blockquote>
<a id="more"></a>

<h1 id="一、Docker-是什么"><a href="#一、Docker-是什么" class="headerlink" title="一、Docker 是什么"></a>一、Docker 是什么</h1><h2 id="1、Docker-简介"><a href="#1、Docker-简介" class="headerlink" title="1、Docker 简介"></a>1、Docker 简介</h2><p> Docker 是一个用于开发、传送和运行应用程序的开放平台。Docker 使您能够将应用程序与基础设施分开，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产中运行代码之间的延迟。</p>
<p>Docker是基于Google的Go语言开发的。</p>
<h2 id="2、Dcoker-能干什么？"><a href="#2、Dcoker-能干什么？" class="headerlink" title="2、Dcoker 能干什么？"></a>2、Dcoker 能干什么？</h2><p>Docker 能方便的将开发环境打包起来，包括Python、Nginx 、Redis、Mysql、Tomcat等等的开发环境只需要一次部署，然后将他们打包为镜像，接下来只需要拿着这个镜像在不同的服务器中的docker中运行即可得到一个全新的与之前部署的环境完全一样的环境。有点类似于布尔玛的万能胶囊，只是有点..</p>
<h1 id="二、Docker与虚拟机的区别"><a href="#二、Docker与虚拟机的区别" class="headerlink" title="二、Docker与虚拟机的区别"></a>二、Docker与虚拟机的区别</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/271846374">https://zhuanlan.zhihu.com/p/271846374</a></p>
</blockquote>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_16-03-32.png"></p>
<p>传统的虚拟机技术：由于虚拟机是把这个系统内核、系统依赖、硬件资源配置全部打包，组成一个新的系统。他是在硬件的基础上实现虚拟化。所以虚拟机占用的资源比较大，切换比较耗时。</p>
<p>Docker技术：它是直接运行在宿主机上，是系统层面的虚拟化，他不需要自己拥有单独的内核，也没有打包硬件资源，所以他是很轻便的，而且每个容器之间是相互隔离的，类似于一个沙箱。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级·</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘空间</td>
<td>一般为几十MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>操作系统</td>
<td>与宿主机共享OS</td>
<td>在宿主机上运行虚拟机的OS</td>
</tr>
</tbody></table>
<p>Docker的优点：</p>
<ul>
<li>对系统资源能够更高效的利用。</li>
<li>启动速度更快。</li>
<li>一致的运行环境。</li>
<li>维护和扩展更加的容易。</li>
<li>应用更快的交付与部署</li>
</ul>
<h1 id="三、Docker-的基本组成"><a href="#三、Docker-的基本组成" class="headerlink" title="三、Docker 的基本组成"></a>三、Docker 的基本组成</h1><p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_16-23-06.png"></p>
<h2 id="Docker的三大组件："><a href="#Docker的三大组件：" class="headerlink" title="Docker的三大组件："></a>Docker的三大组件：</h2><h3 id="1、镜像："><a href="#1、镜像：" class="headerlink" title="1、镜像："></a>1、镜像：</h3><p>Docker的镜像好比一个文件模板（分层的），有各种各样的模板，这个模板就是一些具体的应用以及对应的资源。比如说一个Nginx 镜像 就是一个包含Nginx的模板。他需要在一个Ubuntu或者其他系统镜像上安装那么就是一个可运行的Nginx镜像。</p>
<h3 id="2、容器："><a href="#2、容器：" class="headerlink" title="2、容器："></a>2、容器：</h3><p>容器类似于一个沙箱，是基于镜像来创建的，多个镜像可以组成一个容器，他是独立运行的，可以启动、暂停、删除容器等操作。</p>
<h3 id="3、仓库："><a href="#3、仓库：" class="headerlink" title="3、仓库："></a>3、仓库：</h3><p>仓库就是用来存放镜像的地方，这个概念和git是一样的，有共有仓库和私有仓库。</p>
<h1 id="四、Dcoker的安装与卸载-Ubuntu-18-04"><a href="#四、Dcoker的安装与卸载-Ubuntu-18-04" class="headerlink" title="四、Dcoker的安装与卸载(Ubuntu 18.04)"></a>四、Dcoker的安装与卸载(Ubuntu 18.04)</h1><blockquote>
<p>安装前提：</p>
<p>系统：Ubuntu 18.04 LTS   </p>
<p>系统内核 ：4.15.0-136-generic</p>
</blockquote>
<p>具体的操作系统根据Docker的<a href="https://docs.docker.com/engine/install/ubuntu/">官网</a>来选择不同的安装方法。</p>
<h2 id="1、卸载旧版本"><a href="#1、卸载旧版本" class="headerlink" title="1、卸载旧版本"></a>1、卸载旧版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>
<h2 id="2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库"><a href="#2、更新-apt-包索引并安装包以允许-apt-通过-HTTPS-使用存储库" class="headerlink" title="2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库"></a>2、更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"> </span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>
<h2 id="3、添加Docker官方的GPG密钥"><a href="#3、添加Docker官方的GPG密钥" class="headerlink" title="3、添加Docker官方的GPG密钥"></a>3、添加Docker官方的GPG密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4、设置稳定存储库"><a href="#4、设置稳定存储库" class="headerlink" title="4、设置稳定存储库"></a>4、设置稳定存储库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h2 id="5、安装Docker"><a href="#5、安装Docker" class="headerlink" title="5、安装Docker"></a>5、安装Docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<h2 id="6、验证是否安装成功"><a href="#6、验证是否安装成功" class="headerlink" title="6、验证是否安装成功"></a>6、验证是否安装成功</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<h2 id="7、卸载Docker"><a href="#7、卸载Docker" class="headerlink" title="7、卸载Docker"></a>7、卸载Docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>
<h2 id="8、配置阿里云镜像加速"><a href="#8、配置阿里云镜像加速" class="headerlink" title="8、配置阿里云镜像加速"></a>8、配置阿里云镜像加速</h2><p>直接在阿里云首页搜索<strong>容器镜像服务</strong>，登录注册后 –&gt; 进入镜像工具 –&gt; 镜像加速器。具体页面如下：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-27_17-03-26.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://1xxxxxx5.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="五、Docker-基本命令"><a href="#五、Docker-基本命令" class="headerlink" title="五、Docker 基本命令"></a>五、Docker 基本命令</h1><p><a href="https://docs.docker.com/reference/">Docker 官网文档命令</a></p>
<h2 id="1、帮助命令："><a href="#1、帮助命令：" class="headerlink" title="1、帮助命令："></a>1、帮助命令：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示docker版本</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助信息</span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h2 id="2、镜像基础命令"><a href="#2、镜像基础命令" class="headerlink" title="2、镜像基础命令"></a>2、镜像基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">-a   显示全部的镜像</span><br><span class="line">-q   只显示全部的镜像ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索镜像</span></span><br><span class="line">docker search &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line">--filter=starts==300   根据镜像starts搜索，大于3000的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像，如果不写版本默认拉取最新版</span></span><br><span class="line">docker pull &lt;镜像名&gt;[:tag]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定镜像版本</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的镜像  （可删除多个镜像）</span></span><br><span class="line">docker rmi &lt;镜像ID&gt;   &lt;镜像ID&gt;   &lt;镜像ID&gt; </span><br><span class="line">-f  强制删除</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除全部的镜像</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3、容器基础命令"><a href="#3、容器基础命令" class="headerlink" title="3、容器基础命令"></a>3、容器基础命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建容器并启动</span></span><br><span class="line">docker run [--options] images</span><br><span class="line"></span><br><span class="line">--name=&quot;Name&quot;   给容器起别名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过后台的方式启动的时候，在使用docker ps 发现没有正在运行的容器，是因为docker发现前台没有使用当前容器就会自动杀死当前容器。</span> </span><br><span class="line">-d             后台方式启动 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-it            使用交互方式运行，进入容器查看内容</span><br><span class="line">-p             指定容器的端口    8080:8080</span><br><span class="line">	-p IP:主机端口：容器端口 (常用)</span><br><span class="line">	-p 主机端口：容器端口 (常用)</span><br><span class="line">	-p 容器端口</span><br><span class="line">	</span><br><span class="line">-P             随机指定端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前所有正在运行的容器</span></span><br><span class="line">dcoker ps</span><br><span class="line"></span><br><span class="line">-a             列出当前所有正在运行的容器和历史运行的容器</span><br><span class="line">-n=?           列出最近运行的容器</span><br><span class="line">-q             只显示容器的ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">直接停止容器并退出容器</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">不停止容器并退出容器</span></span><br><span class="line">ctrl + p + q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定容器</span></span><br><span class="line">dcoker rm 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除所有容器</span></span><br><span class="line">dcoker rm -f  %(dcoker ps -aq)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 强制删除所有容器</span></span></span><br><span class="line">dcoker ps -aq|xargs docker rm </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">docker start 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器</span></span><br><span class="line">docker restart 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制停止容器</span></span><br><span class="line">docker kill 容器ID</span><br></pre></td></tr></table></figure>
<h2 id="4、其他常用命令"><a href="#4、其他常用命令" class="headerlink" title="4、其他常用命令"></a>4、其他常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看docker日志</span></span><br><span class="line">docker logs  -tf --tail 10 容器ID</span><br><span class="line"></span><br><span class="line">-t            显示时间戳</span><br><span class="line">-f            跟踪日志输出</span><br><span class="line">--tail 10     输出指定行数       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器进程信息</span></span><br><span class="line">docker top 容器ID</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器的元数据</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (以交互式，进入容器开启一个新的终端)</span></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入当前正在运行的容器  (进入正在运行的命令终端，如果没有进入默认终端)</span></span><br><span class="line">docker attach 容器ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从容器内拷贝文件到宿主机上</span></span><br><span class="line">docker cp 容器Id:文件路径  目的主机路径 </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker、Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora设置七牛云图床</title>
    <url>/2021/09/26/Typora%E8%AE%BE%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>Markdown是一种<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/52671915">轻量级标记语言</a>，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的<a href="https://baike.baidu.com/item/%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/9862288">纯文本格式</a>编写文档，然后转换成有效的<a href="https://baike.baidu.com/item/XHTML/316621">XHTML</a>（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
<p>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如<a href="https://baike.baidu.com/item/GitHub/10145341">GitHub</a>、<a href="https://baike.baidu.com/item/Reddit/1272010">Reddit</a>、<a href="https://baike.baidu.com/item/Diaspora/10726893">Diaspora</a>、[Stack Exchange](<a href="https://baike.baidu.com/item/Stack">https://baike.baidu.com/item/Stack</a> Exchange/13777796)、<a href="https://baike.baidu.com/item/OpenStreetMap/3171606">OpenStreetMap</a> 、<a href="https://baike.baidu.com/item/SourceForge/6562141">SourceForge</a>、<a href="https://baike.baidu.com/item/%E7%AE%80%E4%B9%A6/5782216">简书</a>等，甚至还能被使用来撰写<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E4%B9%A6/346054">电子书</a>。</p>
</blockquote>
<a id="more"></a>


<h1 id="一、设置前提："><a href="#一、设置前提：" class="headerlink" title="一、设置前提："></a>一、设置前提：</h1><p>Typora 版本：0.11.8|<br>已注册七牛云账号：</p>
<ul>
<li>秘钥AK ：virqOxxxxxxxxxxxxxxxxxxxxxxxxMnNIK</li>
<li>秘钥SK：dDFGSasdfxxxxxxxxxxxxxxxxxxxiZiOVu</li>
<li>存储空间名称：cz-tuchuang</li>
<li>自定义域名：<a href="https://tc.chaizz.com/">https://tc.chaizz.com</a></li>
<li>存储区域代码：我的是华北  所以就是 ：z0<br><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-26_19-22-09.png"></li>
</ul>
<h1 id="二、开始设置"><a href="#二、开始设置" class="headerlink" title="二、开始设置"></a>二、开始设置</h1><p>打开Typora  偏好设置–&gt; 图像 –&gt;插入图片时… –&gt; 上传服务 –&gt; 选择 上传图片。</p>
<p>打开Typora  偏好设置–&gt; 图像 –&gt;上传服务设定 –&gt; 上传服务 –&gt; 选择 PicGo-Core (command line)。</p>
<p>点击<strong>下载或更新</strong>按钮，会提示下载一个PicGo插件，等待下载完成点击<strong>打开配置文件</strong>，打开以后默认是空的。复制下面代码覆盖打开的文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;qiniu&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;qiniu&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;accessKey&quot;</span>: <span class="string">&quot;virqOxxxxxxxxxxxxxxxxxIK&quot;</span>,  <span class="comment">// 你的七牛云AK</span></span><br><span class="line">			<span class="attr">&quot;secretKey&quot;</span>: <span class="string">&quot;dDFGSxxxxxxxxxxxxxxxxxVu&quot;</span>,  <span class="comment">// 你的七牛云SK</span></span><br><span class="line">			<span class="attr">&quot;bucket&quot;</span>: <span class="string">&quot;cz-tuchuang&quot;</span>,                  <span class="comment">// 你的七牛云存储空间名</span></span><br><span class="line">			<span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://tc.chaizz.com&quot;</span>,           <span class="comment">// 你的七牛云自定义域名</span></span><br><span class="line">			<span class="attr">&quot;area&quot;</span>: <span class="string">&quot;z1&quot;</span>,                             <span class="comment">// 存储区域编号</span></span><br><span class="line">			<span class="attr">&quot;options&quot;</span>: <span class="string">&quot;&quot;</span>,                            <span class="comment">// 网址后缀,可不填</span></span><br><span class="line">			<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;tc/&quot;</span>,                            <span class="comment">// 自定义存储路径，比如 img/ 可不填</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	<span class="attr">&quot;picgoPlugins&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来点击 <strong>验证图片上传选项</strong> 按钮。上传成功会提示图下图所示：</p>
<p><img src="https://tc.chaizz.com/tc/Snipaste_2021-09-26_19-35-24.png"></p>
<p>点击OK ，重启Typora上传图片即可上传到七牛云了。</p>
]]></content>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识巩固</title>
    <url>/2021/09/26/Redis%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p>
</blockquote>
<a id="more"></a>

<h1 id="一、Redis-安装"><a href="#一、Redis-安装" class="headerlink" title="一、Redis 安装"></a>一、Redis 安装</h1><p>安装前提：Linux 系统 ubuntu 18.04  / Redis 版本：<a href="https://download.redis.io/releases/redis-6.2.5.tar.gz">6.2.5</a><br>1、检查系统是否安装了gcc 编译器。如果已经安装了 则会显示gcc 的版本号信息，如果没有安装，则使用系统的包管理器安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查版本</span></span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 gcc</span></span><br><span class="line">sudo apt-get install gcc </span><br></pre></td></tr></table></figure>

<p>2、在Redis官网下载Redis压缩包并解压。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.5.tar.gz</span><br><span class="line">tar -zxvf redis-6.2.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、进入解压后的Redis目录，编译安装Redis。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.5</span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>

<p>4、Redis 默认安装在Linux的usr/local/bin 目录下。</p>
<p>5、启动Redis 。（这种方式是在前台运行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line">    # 后台运行 ，首先更改Redis的配置文件（redis.conf），找到daemonize no 将 no 改为yes 。然后再启动Redis 即可在后台运行。</span><br></pre></td></tr></table></figure>


<h1 id="二、Redis-基础命令"><a href="#二、Redis-基础命令" class="headerlink" title="二、Redis 基础命令"></a>二、Redis 基础命令</h1><p>Redis<a href="http://redis.cn/commands.html">的命令文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择Redis数据库 一共0到15 16个数据库，默认使用0数据库。</span></span><br><span class="line">select 0-15</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前库所有的key</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断key是否存在</span></span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的类型</span></span><br><span class="line">type key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除key</span></span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据value选择非阻塞删除（异步删除）</span></span><br><span class="line">unlink key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为给定的key 设置超时时间 （以秒为单位）</span></span><br><span class="line">expire key 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看key的过期时间 （获取的值为-1:代表永不过期，-2：已经过期）</span></span><br><span class="line">ttl key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看库中的key的数量</span></span><br><span class="line">dbsise</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空当前库</span></span><br><span class="line">flushdb </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通杀全部库</span></span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>

<h1 id="三、Redis-五大常用数据类型"><a href="#三、Redis-五大常用数据类型" class="headerlink" title="三、Redis 五大常用数据类型"></a>三、Redis 五大常用数据类型</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1 String"></a>1 String</h2><p>String是Redis常用的基本类型，对应的格式是一个key对应一个value，String是二进制安全的，意味着string可以存储任意的类型，包括图片或者序列化的对象。一个Redis中String类型value的值最多可以是512M。</p>
<h3 id="1-1-String-的基本命令"><a href="#1-1-String-的基本命令" class="headerlink" title="1.1 String 的基本命令"></a>1.1 String 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置key value</span></span><br><span class="line">set &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的值</span></span><br><span class="line">get &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取key的长度</span></span><br><span class="line">strlen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key value   只有key不存在时 设置key的值</span></span><br><span class="line">setnx &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增1</span></span><br><span class="line">incr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值增自定义的大小（值为负数则相反）</span></span><br><span class="line">incrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减1</span></span><br><span class="line">decr &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将key中存储的数字值减自定义大小 （值为负数则相反）</span></span><br><span class="line">decrby &lt;key&gt; &lt;值&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value</span></span><br><span class="line">mset &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性设置多个key value  (当且仅当所有的key都不存在，才能设置成功)</span></span><br><span class="line">msetnx &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; &lt;key&gt; &lt;value&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取值的范围  （起始位置，结束位置 都包括在内）</span></span><br><span class="line">getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用新的value覆盖key存储的value,索引从0开始</span></span><br><span class="line">setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key的过期时间 ,单位是秒</span></span><br><span class="line">setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以新换旧，设置了新的值，同时获得旧值</span></span><br><span class="line">getset &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-String-的数据结构"><a href="#1-2-String-的数据结构" class="headerlink" title="1.2 String 的数据结构"></a>1.2 String 的数据结构</h3><p>String 的数据结构为简单的动态的字符串（Simple Dynamic String 缩写SDS），是可以修改的字符串，采用预分配冗余空间的方式，来减少内存的频繁分配。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv373N59nka6XQv4HPibGI3SYicowtDd8pNMfqz7CpCK2GmECGKrkiap1ibnM3mWUMV43P0ul9EK7G1fg/0?wx_fmt=png"></p>
<h2 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h2><p>List 是简单的字符串列表，按照插入的顺序排序，可以添加一个元素到字符串的头部或者尾部。他的底层实际上十个双向链表，对两端的操作性能很高，通过索引下标操作中间的节点性能比较差。</p>
<h3 id="2-1-List的基本命令"><a href="#2-1-List的基本命令" class="headerlink" title="2.1 List的基本命令"></a>2.1 List的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从左边插入一个或者多个值， 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">lpush &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右边插入一个或者多个值 使用头插法插入，类似栈的先进后出</span></span><br><span class="line">rpush  &lt;key&gt; &lt;value&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值  值在键在 ，值光键亡</span></span><br><span class="line">lpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边获取一个值 值在键在 ，值光键亡</span></span><br><span class="line">rpop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key1列表右边取一个值，放到key2左边</span></span><br><span class="line">rpoplpush &lt;key1&gt; &lt;key2&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照索引下标获取元素 （从左到右）  0 -1 ：代表获取所有的值</span></span><br><span class="line">lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据索引下标获取元素，</span>    </span><br><span class="line">lindex &lt;key&gt; &lt;index&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表长度</span></span><br><span class="line">llen &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在value的前/后面插入新的value</span></span><br><span class="line">linsert &lt;key&gt; before/after &lt;value&gt; &lt;new value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从左边删除第n个value   (从左到右)</span></span><br><span class="line">lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将列表key 下标为index的值替换为value</span></span><br><span class="line">lset &lt;key&gt;  &lt;index&gt;  &lt;value&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-List-的数据结构"><a href="#2-2-List-的数据结构" class="headerlink" title="2.2 List 的数据结构"></a>2.2 List 的数据结构</h3><p>List 的数据结构为quicklist。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。他将所有的元素紧挨着一块存储，分配的是一块连续的内存。<br>当数据量比较多的时候，才会改为quicklist，因为普通的链表需要的附加的指针空间更大，会比较浪费空间。<br>比如列表里面存储的只是Int的类型的数据，结构上还需要两个额外的指针：prev和next。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqv373N59nka6XQv4HPibGI3SDybtb3JtpFKmrL3pEEV8FPBrRKLCQTKInUPpYLLianynDwwWMLiaMEWQ/0?wx_fmt=png"></p>
<p>Redis 将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist 使用双向指针串起来，这样既满足了插入删除性能，又不会出现太大的空间冗余。如上图所示。</p>
<h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h2><h3 id="3-1-Set的基本命令"><a href="#3-1-Set的基本命令" class="headerlink" title="3.1  Set的基本命令"></a>3.1  Set的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素添加到集合key中，已经存在的member元素将会被忽略</span></span><br><span class="line">sadd &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出该集合的所有值</span></span><br><span class="line">smembers &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断集合key是否有该value值，存在为1 不存在为0</span></span><br><span class="line">sismember &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该集合的元素个数</span></span><br><span class="line">scard &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合的某些个元素</span></span><br><span class="line">srem &lt;key&gt; &lt;value&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  随机丛集中吐出一个值，会从该集合中删除</span></span><br><span class="line">spop &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 随机从该集合中取出n个值, 不会从该集合中删除</span></span><br><span class="line">srandmember &lt;key&gt; &lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把集合中一个值移动到另一个集合中</span></span><br><span class="line">smove &lt;key1&gt; &lt;key2&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的交集元素</span></span><br><span class="line">sinter &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回两个集合的并集元素</span></span><br><span class="line">sunion &lt;key1&gt; &lt;key2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  返回两个集合的差集元素（key1 中的 不包括Key2中的）</span></span><br><span class="line">sdiff &lt;key1&gt; &lt;key2&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Set-的数据结构"><a href="#3-2-Set-的数据结构" class="headerlink" title="3.2 Set 的数据结构"></a>3.2 Set 的数据结构</h3><p>Set 的数据结构是dict字典，字典是使用哈希表实现的。所有的value 都指向同一个内部的值。</p>
<h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4 Hash"></a>4 Hash</h2><h3 id="4-1-Hash的基本命令"><a href="#4-1-Hash的基本命令" class="headerlink" title="4.1 Hash的基本命令"></a>4.1 Hash的基本命令</h3><p>Redis 的Hash是一个键值对集合，是一个String类型的field和value 的映射表，Hash特别适合存储对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给key集合中的field 键赋值value</span></span><br><span class="line">hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从key集合field中取出value</span></span><br><span class="line">hget &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置<span class="built_in">hash</span>的值</span></span><br><span class="line">hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; &lt;field3&gt; &lt;value3&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看<span class="built_in">hash</span>表key中,给定域field 是否存在 ，存在返回1 不存在返回0</span></span><br><span class="line">hxists &lt;key1&gt; &lt;field&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的field</span></span><br><span class="line">hkeys &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出该集合所有的value</span></span><br><span class="line">hvals &lt;keys&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值加上增量1 -1</span> </span><br><span class="line">hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为<span class="built_in">hash</span> 表 key 中的域 field的值设置为value 当且仅当该域不存在</span></span><br><span class="line">hsetnx  &lt;key&gt; &lt;field&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-Hsh-的数据结构"><a href="#4-2-Hsh-的数据结构" class="headerlink" title="4.2 Hsh 的数据结构"></a>4.2 Hsh 的数据结构</h3><p>Hash 类型对应的数据机构有两种：ziplist （压缩列表） 和 hashlist（哈希列表） ，当field-value 的长度较短且个数较少的时候，使用ziplist，否则使用hashlist。</p>
<h2 id="5-ZSet"><a href="#5-ZSet" class="headerlink" title="5 ZSet"></a>5 ZSet</h2><p>Redis的有序集合和Set 类似，是一个没有重复元素的字符串集合，不同之处是有序集合的每个成员都关联了一个<strong>评分</strong>，这个<strong>评分</strong>被用来按照从最低到最高的方式排序集合中的成员，<strong>集合的成员是唯一的，但是评分可以重复。</strong></p>
<p>因为元素是有序的，所以可以很快的根据评分或者次序来获得一个范围的元素。</p>
<p>访问集合中的元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="5-1-ZSet-的基命令"><a href="#5-1-ZSet-的基命令" class="headerlink" title="5.1 ZSet 的基命令"></a>5.1 ZSet 的基命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个member元素及其其score值加入到有序集key当中</span></span><br><span class="line">zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，下标在 &lt;start&gt; &lt;stop&gt; 之间的元素, 带 withscores可以让分数一起和值返回到结果集</span></span><br><span class="line">zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回有序集key中，所有的score值介于min 和max 之间 （包括min 或者 max）的成员，有序集成员按照score值递增(从小到大依次排列)</span></span><br><span class="line">zrangebyscore &lt;key &gt; &lt;min&gt; &lt;max&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，改为由大到小排列</span></span><br><span class="line">zrangebyscore &lt;key&gt; &lt;max&gt; &lt;min&gt; [withscores] [limiy offset count]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为元素的score加上增量</span></span><br><span class="line">zinceby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除该集合下 指定值的元素</span></span><br><span class="line">zrem &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计该集合，分数区间的元素个数</span></span><br><span class="line">zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回该值在集合中的排名， 从0开始</span></span><br><span class="line">zrank &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Zset-的数据结构"><a href="#5-2-Zset-的数据结构" class="headerlink" title="5.2 Zset 的数据结构"></a>5.2 Zset 的数据结构</h3><p>SortedSet 是Redis的一个特别的数据结构，他的底层使用了两个数据结构。</p>
<ol>
<li>hash，hash 的作用就是关联元素value和权重score，保障元素value的唯一性们可以通过元素value找到相应的score。</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素的列表。</li>
</ol>
<h2 id="6-Bitmaps"><a href="#6-Bitmaps" class="headerlink" title="6  Bitmaps"></a>6  Bitmaps</h2><p>BItmaps 本身并不是一种数据类型，实际上他就是字符串，key-value ,但是他可以对字符串进行位操作。<br>Bitmaps 单独提供了一套目命令，所以在Redis 中使用Bitmaps和使用字符串方法不一样，可以吧Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1数组的下标在Bitmaps中叫偏移量。</p>
<h3 id="6-1-Bitmaps-的基本命令"><a href="#6-1-Bitmaps-的基本命令" class="headerlink" title="6.1  Bitmaps 的基本命令"></a>6.1  Bitmaps 的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  设置Bitmaps 中某个偏移量的值 0 或 1， offset的偏移量从0开始</span></span><br><span class="line">setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取Bitmaps中某个偏移量的值</span></span><br><span class="line">getbit &lt;key&gt; &lt;offset&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计字符串被设置为1的Bit数,一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start end 参数，可以让计数只在特定的位上进行，start和end都可以使用负值，比如-1表示最后一位,-2表示倒数第二个，start 和end是指bit组的字节下标数，二者皆包含。</span></span><br><span class="line">bitcount &lt;key&gt; &lt;start&gt; &lt;end&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> bitop  是一个复合操作，他可以做多个bitmaps的and （交集）、or（并集）、not (非)、xor（异或）操作，并将结果保存在destkey中。</span></span><br><span class="line">bitop  and/or/not/xor &lt;destkey&gt; &lt;key&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7  HyperLogLog"></a>7  HyperLogLog</h2><h3 id="7-1-HyperLogLog-的基本命令"><a href="#7-1-HyperLogLog-的基本命令" class="headerlink" title="7.1 HyperLogLog 的基本命令"></a>7.1 HyperLogLog 的基本命令</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常大的时候计算基数所需要空间总是固定的，并且是很小的。<br>在Redis里面每个HyperLogLog 键只需要花费12KB内存，就可以计算接近2^64个不同的基数，这和计算基数时元素越多消耗内存就越多的集合形成鲜明对比。<br>但是HyperLogLog 只会根据输入元素计算基数，而不会存储输入数据本身，所以HyperLogLog并不能像集合那样返回输入的各个元素。<br>什么是基数？<br>比如数据集：{1、3、5、7、5、7、9} 那么这个数据集的基数就是：{1、3、5、7、9} 基数（不重复元素）为5。基数估计 就是在误差可以收的范围内快速计算基数。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定元素到 HyperLogLog  中</span></span><br><span class="line">pfadd &lt;key&gt; &lt;element&gt; &lt;element&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的近似基数  可以计算多个key，</span></span><br><span class="line">pfcount &lt;key&gt;  [key key ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个或者多个key合并后的结果存储在另一个key中。</span></span><br><span class="line">pfmerge &lt;key&gt;  &lt;key1&gt;  &lt;key2&gt;</span><br></pre></td></tr></table></figure>



<h2 id="8-Geospatial"><a href="#8-Geospatial" class="headerlink" title="8 Geospatial"></a>8 Geospatial</h2><p>Redis 3.2 中增加对GEO类型的支持，GEO是Geographic地理信息的缩写。该类型就是元素的二维坐标，在地图上就是经纬度，Redis基于该类型提供了经纬度设置，范围查询。距离查询。经纬度Hash等操作。</p>
<h3 id="8-1-Geospatial的基本命令"><a href="#8-1-Geospatial的基本命令" class="headerlink" title="8.1 Geospatial的基本命令"></a>8.1 Geospatial的基本命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加地理位置 经度 纬度 名称, 两级无法添加，一般会下载城市经纬度数据，直接导入。有效的经度从-180 到180 纬度 -85.05112878 到 85.05112878 ,超出范围会返回错误。</span></span><br><span class="line">geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;  &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取指定地区的坐标值</span></span><br><span class="line">geopos &lt;key&gt; &lt;member&gt; [member]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取两个位置的直线距离，单位有 m km ft(英尺) mi (英里) ，不指定为单位 默认是 m (米)</span></span><br><span class="line">geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; m/km/ft/mi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以给定的经纬度为中心，找出某一半径内的元素</span></span><br><span class="line">georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius m/km/ft/mi</span><br></pre></td></tr></table></figure>

<h1 id="四、Redis-的事务操作"><a href="#四、Redis-的事务操作" class="headerlink" title="四、Redis 的事务操作"></a>四、Redis 的事务操作</h1><p>Redis 的事务 是一个单独的隔离的操作，事务中所有的命令都会序列化、按顺序的执行，事务在执行过程中，不会被其他的客户端发送过来的命令请求打断。<br>Redis的事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p>
<p>从输入Multi 开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过Discard来放弃组队。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9UFV0pjZ3VpdibsyZ7GLzTuiaUKKwtyOVHWB2iaY5PAghf0q7TDsKbcbJOg/0?wx_fmt=png"></p>
<h2 id="1-Redis-事务的错误处理"><a href="#1-Redis-事务的错误处理" class="headerlink" title="1  Redis 事务的错误处理"></a>1  Redis 事务的错误处理</h2><h3 id="1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"><a href="#1-1-组队中某个命令出现了报告错误，执行时所有的队列都会被取消。" class="headerlink" title="1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。"></a>1.1 组队中某个命令出现了报告错误，执行时所有的队列都会被取消。</h3><p><strong><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9UOIHOuI4Fem31JzLp88wyibTDl5EJibXIEsQS4oCT4tQ9Pf1LJgeY8eow/0?wx_fmt=png"></strong></p>
<h3 id="1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"><a href="#1-2-组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。" class="headerlink" title="1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。"></a>1.2 组队中所有的命令成功，执行时只有失败的命令失败，其他的命令成功。</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9UbpibUydrdibcsWia3dribXsxgic2MfaJQhib9pJbqFTXlHxc0yOxyqyWOWkA/0?wx_fmt=png"> </p>
<h3 id="1-3-Redis的事务冲突，以及解决办法。"><a href="#1-3-Redis的事务冲突，以及解决办法。" class="headerlink" title="1.3 Redis的事务冲突，以及解决办法。"></a>1.3 Redis的事务冲突，以及解决办法。</h3><h4 id="1-3-1-悲观锁"><a href="#1-3-1-悲观锁" class="headerlink" title="1.3.1 悲观锁"></a>1.3.1 悲观锁</h4><p>每次去获取数据都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人就只能等到锁释放才能能拿到数据。传统的关系型数据库很多地方都用到了悲观锁：比如行锁、表锁、读锁、写锁等。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9UEXxNUKxq7zwSTmJzCMKhCj7ycyOYSULcWzZTZ9ibJpajDnZWRCh0PAQ/0?wx_fmt=png"></p>
<h4 id="1-3-2-乐观锁"><a href="#1-3-2-乐观锁" class="headerlink" title="1.3.2 乐观锁"></a>1.3.2 乐观锁</h4><p>每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有更新这数据，可以使用版本号等机制。乐观锁适用于多读的场景，这样可以以高吞吐量，Redis 就是利用这用check-and-set的机制实现事务的。实际应用场景：例如买票，很多人都可以抢到，但是付款只有一个人可以付款成功。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9UIEZUs23S1wQXIZNC3alQuicn2OicOC3GFhNDSWHVU4VFIUmxnKJiahIMA/0?wx_fmt=png"></p>
<p>在Redis 中使用乐观锁<br>在执行Multi 之前先执行 watch key 可以监听一个或者多个key，如果事务执行之前这个key被其他的命令所修改，那么事务将会被打断。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给Redis加乐观锁</span></span><br><span class="line">watch key </span><br></pre></td></tr></table></figure>
<h3 id="1-4-Redis-事务的三特性"><a href="#1-4-Redis-事务的三特性" class="headerlink" title="1.4 Redis 事务的三特性"></a>1.4 Redis 事务的三特性</h3><h4 id="1-4-1单独的隔离操作"><a href="#1-4-1单独的隔离操作" class="headerlink" title="1.4.1单独的隔离操作"></a>1.4.1单独的隔离操作</h4><p>事务中所有的命令都会序列化，按照顺序执行，事务在执行过程中没不会被其他的可短短发送来的命令请求打断。</p>
<h4 id="1-4-2-没有隔离级别的概念"><a href="#1-4-2-没有隔离级别的概念" class="headerlink" title="1.4.2 没有隔离级别的概念"></a>1.4.2 没有隔离级别的概念</h4><p>队列中的命令没有提交之前都不会被实际的执行，因为事务提交之前（exec）任何指令都不会被执行。</p>
<h4 id="1-4-3-不保证原子性"><a href="#1-4-3-不保证原子性" class="headerlink" title="1.4.3 不保证原子性"></a>1.4.3 不保证原子性</h4><p>事务中如果有一天命令执行失败，其他的命令仍然会被执行，不会回滚。</p>
<h1 id="五、Redis-的持久化机制"><a href="#五、Redis-的持久化机制" class="headerlink" title="五、Redis 的持久化机制"></a>五、Redis 的持久化机制</h1><h2 id="1-RDB-（Redis-Database）-方式"><a href="#1-RDB-（Redis-Database）-方式" class="headerlink" title="1  RDB （Redis Database） 方式"></a>1  RDB （Redis Database） 方式</h2><p>在指定<strong>时间间隔内</strong>将内存中的<strong>数据集快照</strong>写入磁盘，也就是快照，它恢复是将快照文件直接读到内存里面。（在Redis 的配置文件内设置时间间隔）<strong>RDB 默认开启。</strong></p>
<p>备份是如何执行的：<br>Redis 会单独的创建一个fork子进程来持久化，会先将数据写入一个临时文件中，等持久化过程都结束了，在用这个临时文件替换上次持久化的文件，整个过程主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据的恢复，且对于数据的完整性要求不那么敏感，那么RDB的方式要比AOF的方式更加的额高效，RDB的缺点就是<strong>最后一次持久化的数据可能会丢失。</strong></p>
<p>fork的作用就是复制一个与当前进程一样的进程，新的进程的所有的数据（变量，程序计数器等）都和原进程一样，但是是一个全新的进程，并作为原进程的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置文件解释</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查数据完整性、默认值 yes 在存储跨照后让Redis 使用CRC64算法来对数据进行校验。但是这样做会损失大约10%的性能。推荐开启。</span></span><br><span class="line">rdbchecksum  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis 无法写入磁盘的时候，直接关掉Redis的写操作，推荐yes</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 压缩文件</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置将数据写入磁盘的时间间隔， 默认 六十分钟1次、五分钟一百次、一分钟一万次</span></span><br><span class="line">save 300 100</span><br></pre></td></tr></table></figure>



<p>RDB的优势：</p>
<ul>
<li>适合大规模数据的恢复。</li>
<li>对数据完整性和一致性要求不高时使用。</li>
<li>节省磁盘空间。</li>
<li>回恢复度快。</li>
</ul>
<p>RDB的劣势：</p>
<ul>
<li>在写入临时快照的时候，数据被克隆了一份，大致两倍的膨胀性需要考虑。</li>
<li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据量庞大还是比较消耗性能。</li>
<li>在备份周期在一低昂时间间隔内做一次备份，所以如果Redis以外关掉，就会丢失最后一次快照的修改。</li>
</ul>
<p>RDB的备份恢复：<br>默认Redis启动会自动将Redis的快照文件（dump.rdb）读取到内存中。手动恢复的话只需要将快照文件复制到Redis启动目录下。</p>
<h2 id="2-AOF（Append-Only-File）方式"><a href="#2-AOF（Append-Only-File）方式" class="headerlink" title="2  AOF（Append Only File）方式"></a>2  AOF（Append Only File）方式</h2><p>以日志的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的所有<strong>写/修改/删除指令记录下来（读操作不记录）</strong>，只许追加文件但是不可以改文件，Redis启动之初，会自动读取范围见重新构建数据，换言之Redis重启的话就会根据日志文件的内容将写指令重头到尾在执行一遍，以完成数据的恢复工作。<strong>AOF默认不开启。</strong></p>
<p>开启AOF：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认为no 不开启， 将其改为yes 开启。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果RDB和AOF同时开启，Redis 默认会读取AOF的配置文件来恢复数据。</strong> </p>
<p>AOF 异常修复：<br>如果遇到AOF文件损坏，通过 redis-check-aof   –fix  appendonly.aof 进行恢复。</p>
<p>AOF的同步频率设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置AOF的同步频率 。</span></span><br><span class="line">	always：始终同步。</span><br><span class="line">	everysec ：每秒同步，每秒记入日志一次，如果宕机当前秒的数据可能会丢失。</span><br><span class="line">	no：redis 不主动同步，把同步的时机交给操作系统。</span><br><span class="line">appendfsync always   </span><br></pre></td></tr></table></figure>

<p>Rewrite 压缩<br>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过设置的阈值时，Redis回启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof。</p>
<p>重写的原理：<br>AOF文件持续增长而过大时， 会fork 出一条新的进程将文件重写（也是先写临时文件最后在rename）Redis4.0后的版本重写，实际上就是把RDB的快照，以二进制的形式附在新的aof的头部，作为已有的历史数据，替换掉原来的流水操作。</p>
<p>AOF持久化的流程：</p>
<ul>
<li>客户端的请求命令会被append追加到AOF的缓冲区内。</li>
<li>AOF缓冲区根据AOF持久化策略（always/everysec/no）将操作sync同步到磁盘中的.aof文件中去。</li>
<li>AOF文件大小超过重写策略或者手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量。</li>
</ul>
<h1 id="六、Redis主从复制"><a href="#六、Redis主从复制" class="headerlink" title="六、Redis主从复制"></a>六、Redis主从复制</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9U07xA7SuC4tXOu1hx4jdibk0cx9Rpm8NLCYOW66zfXVpmxKBHUAzt73w/0?wx_fmt=png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Redis 主从复制配置文件设置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 丛机配置文件主要用户读操作，所以 aof 以及edb配置相关关掉即可。</span></span><br><span class="line"></span><br><span class="line">requirepass  &quot;admin.123&quot;  　　#设置redis登录密码</span><br><span class="line"></span><br><span class="line">masterauth  &quot;admin.123&quot; 　　#主从认证密码，否则主从不能同步</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在某个从机中配置为从机：这种设置从服务器是暂时的，重启之后就又会变成主服务器。</span></span><br><span class="line">slaveof ip port</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在主服务器中使用命令查看主从信息：</span></span><br><span class="line">info relication</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9UFjZW8heJDLyNU96DpHo4oF5mEKuomCaRYJVd9vvF1UUKZ1pHia9Zffg/0?wx_fmt=png"></p>
<h2 id="1-主从复制的原理："><a href="#1-主从复制的原理：" class="headerlink" title="1 主从复制的原理："></a>1 主从复制的原理：</h2><ul>
<li>当从服务器连接上主服务器上以后，从服务器向主服务器发送数据同步消息即一个sync命令。</li>
<li>主服务器接到从服务器送过来的同步消息，把主服务器的数据进行持久化，把RDB文件发送到从服务器，从服务器拿到RDB进行读取。（从服务器主动请求同步）</li>
<li>全量复制：从服务器在接受数据库数据后将其存盘并加载到内存中。</li>
<li>增量复制：主服务器将新的所有收集到的修改的命令依次传输给从服务器完成同步。</li>
</ul>
<h2 id="2-主从复制之薪火相传"><a href="#2-主从复制之薪火相传" class="headerlink" title="2 主从复制之薪火相传"></a>2 主从复制之薪火相传</h2><p>Redis 主从模式为 一个主，其他的为从。其中第三个从为第二个从的主，类似于排队的节点，每一节点都是前面的从。也可以多个从节点。 </p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvMqiaohxlkSRrib9wmAReT9UmcibF3vNoNpibRKHNyPbowJlK1IzTQd3nnzEDlbkRNeZBIliaIkw0Gykw/0?wx_fmt=png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置方法：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在从服务器中配置他的从服务器</span></span><br><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure>
<h2 id="3-Redis主从之反客为主"><a href="#3-Redis主从之反客为主" class="headerlink" title="3  Redis主从之反客为主"></a>3  Redis主从之反客为主</h2><p>反客为主在薪火相传的基础上给某个从服务器加上能够变为主服务器的命令。使其能够在主服务器挂掉的时候充当主服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若果想让从服务器在主服务器挂掉之后自动变为主服务器设置方法： 需要手动操作，全自动实现 需要使用哨兵模式</span></span><br><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>


<h2 id="4-Redis主从之哨兵模式"><a href="#4-Redis主从之哨兵模式" class="headerlink" title="4 Redis主从之哨兵模式"></a>4 Redis主从之哨兵模式</h2><p>配置哨兵模式：<br><strong>定义配置文件 senttinel.conf   （文件名不能错） 文件内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mymaster 是为监控对象起的名称， 1 代表至少有多少个哨兵同意迁徙的数量。</span></span><br><span class="line">sentinel monitor mymaster IP PORT 1</span><br></pre></td></tr></table></figure>
<p>哨兵故障恢复：<br>从下线的主服务器的从服务器中挑选一个将其转成主服务器。选择的条件依次为：1. 优先级最靠前的。2. 选择偏移量最大的，3. 选择runid 最小的。</p>
<p>挑选出新的主服务器后sentinel 向原先的主服务器的从服务器发送slaveof 命令，复制新的master，当已经下线的主服务器上线时，sentinel 向其发送slaveof 命令让其成为新主的从。</p>
<p>优先级在Redis.conf 中默认：replica-priority 100 值越小 优先级越高。<br>偏移量是指获取原主机数据最全的。<br>每个Redis示例启动后都会随机生成一个40位runid。</p>
<h1 id="七、Redis-集群"><a href="#七、Redis-集群" class="headerlink" title="七、Redis 集群"></a>七、Redis 集群</h1><p>Redis 的主从模式，薪火相传。主机宕机，会导致IP的地址变化，应用程序中配置需要修改对应主机啊的地址没端口等信息。之前通过代理主机来解决，Redis 3.0 提供了解决方案，就是无中心化集群方案。</p>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个Redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区，来提供一定程度的可用性，：即使集群中有部分节点失效或者无法进行通讯，集群也能够继续处理命令请求。</p>
<h2 id="1-Redis-集群配置"><a href="#1-Redis-集群配置" class="headerlink" title="1 Redis 集群配置"></a>1 Redis 集群配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 包含redis主配置文件</span></span><br><span class="line">include /myredis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置pid文件位置 (注意区别每个节点文件名要不一致)</span></span><br><span class="line">pidfile /var/run/redis-6379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置持久化文件名  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群配置</span></span><br><span class="line">cluster-enabled  yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置当前节点的配置文件的名字  (注意区别每个节点文件名要不一致)</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置失联时间</span>   </span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保集群配置文件没有出错，查看Redis 服务是否正常启动，以及Redis对应的几点文件是否生成。</span></span><br></pre></td></tr></table></figure>

<p><strong><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvt75A0zhwIjJVYt0iawbULkibfyUefHibDde1ZAevj0yic5ibibsPevqvWiaVYfKhVZuQ11sibVQyHnJ6I1w/0?wx_fmt=png"></strong></p>
<p>以上配置生成了Redis的集群节点，但是还没有将每个节点相结合。以下操作将各个节点结合配置为集群。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果是低版本Redis需要安装ruby环境，此版本不需要安装。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先进入到解压后Redis目录中</span></span><br><span class="line">cd /opt/redis-6.2.5/src</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行合并集群命令。</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT IP:PORT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处使用本机地址 生产环境使用本机IP地址</span></span><br><span class="line">1： 表示一个主节点对应一个从节点 </span><br><span class="line"></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6389 127.0.0.1:6390 127.0.0.1:6391</span><br></pre></td></tr></table></figure>
<p>设置成功如下图所示：<br><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvt75A0zhwIjJVYt0iawbULkHGC4eYmzqiaTXe5XSSrjIvuQY1BGOyHWSgKibnNP5ibPyZib8lHT5Z5IkQ/0?wx_fmt=png"></p>
<h2 id="2-Redis-集群连接"><a href="#2-Redis-集群连接" class="headerlink" title="2 Redis 集群连接"></a>2 Redis 集群连接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 集群连接</span> </span><br><span class="line">redis-cli -c -p 6379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群节点信息</span></span><br><span class="line">cluster nodes </span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/sHw3tUJQYqvt75A0zhwIjJVYt0iawbULk9ND9c5H579JoJbuiakmO9ic1K11LHBicVaZnfDVLDItpdpNwiadA8oLzpw/0?wx_fmt=png"></p>
<p>Redis 如何分配至少三个主节点？</p>
<p>首先分配原则尽量保证，每个主数据库运行在不同的IP地址中，每个从库和主库不在同一个IP地址中。</p>
<p>什么是slots？</p>
<p>当Redis集群设置成功后会提示 ： <code>All 16384 slots covered</code>，代表一个集群包含16384个插槽，数据库的每个键都会存储到这些个插槽中去，集群使用公式 CRC16(key)%16384 来计算key属于那个插槽，其中CRC16(key) 用于计算key的CRC16校验和。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算集群的中的key的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算key的插槽值</span></span><br><span class="line">cluster keyslot &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算插槽值里面有多少个key ,只能查看自己插槽中的key值</span></span><br><span class="line">cluster countkeysinslot &lt;slot&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回count个slot中的键 ,返回插槽中的键的数量。</span></span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt; </span><br></pre></td></tr></table></figure>

<h2 id="3-故障恢复"><a href="#3-故障恢复" class="headerlink" title="3 故障恢复"></a>3 故障恢复</h2><p>Redis 集群中的某个主服务宕机，他的从服务器会直接成为主服务器，来保持运行。（通过配置文件的失联时间来判断是和否能够正常使用：cluster-node-timeout 15000）<br>如果Redis的集群中的某个节点的主从全部挂掉，他的情况 需要根据配置文件来说明：</p>
<ul>
<li>如果配置文件中的<code>cluster-require-full-coverage</code> 的值为 <code>yes</code> ， 则整个集群都挂掉。</li>
<li>如果值为 <code>no</code> 则该插槽服务挂掉，无法写入读取数据，但是不会影响其他的集群节点。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>部署YoloV5</title>
    <url>/2021/07/10/%E9%83%A8%E7%BD%B2YoloV5/</url>
    <content><![CDATA[<p>​                                    </p>
<a id="more"></a>

<p>一、安装Ubuntu 20.04 系统。</p>
<p>二、更换Ubuntu 源为国内源。（尽量不要用阿里源）</p>
<p>三、升级包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update	</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>四、下载Nvidia 驱动。<a href="https://www.nvidia.cn/content/DriverDownload-March2009/confirmation.php?url=/XFree86/Linux-x86_64/460.84/NVIDIA-Linux-x86_64-460.84.run&lang=cn&type=TITAN">下载地址</a>。根据自己的显卡查找驱动。</p>
<ul>
<li><p>禁用nouveau驱动</p>
<ul>
<li><p>编辑 /etc/modprobe.d/blacklist-nouveau.conf </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset&#x3D;0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure></li>
<li><p>接下来然后执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</span><br></pre></td></tr></table></figure></li>
<li><p>然后重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>提示gcc 问题：</p>
</li>
</ul>
</li>
<li><p>直接安装  <code>sudo apt-get install gcc g++</code></p>
</li>
</ul>
<p>提示make问题：</p>
<ul>
<li>直接安装 <code>sudo apt-get install  make</code></li>
</ul>
<p>五、安装CUDA。（需要根据pytorch 的版本选择CUDA版本。这里选择的是CUDA 11.1）  下载地址：<a href="https://developer.nvidia.com/cuda-11.1.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=2004&target_type=runfilelocal">CUDA地址</a>。</p>
<p>官网安装步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run</span><br><span class="line">sudo sh cuda_11.1.0_455.23.05_linux.run</span><br></pre></td></tr></table></figure>
<p>接下来按照提示输入。</p>
<p>选择安装界面：因为上面已经安装过驱动，所以取消选择第一个 driver ，然后选中 按下回车。</p>
<p>配置CUDA环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.1/lib64</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-11.1/bin</span><br><span class="line">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda-11.1</span><br><span class="line">source  ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>验证是CUDA否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br><span class="line">输出CUDA版本即安装成功</span><br></pre></td></tr></table></figure>
<p>六、安装CUDNN。 下载地址：<a href>CUDNN</a> 。 需要登录账户 。</p>
<p>七、配置Python 虚拟环境 （Pyenv）</p>
<ul>
<li><p>安装步骤</p>
<ul>
<li><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git	</span><br><span class="line">git clone https://github.com/yyuu/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure></li>
<li><p>打开环境变量</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash">输入以下内容：</span></span><br><span class="line">export PATH=~/.pyenv/bin:$PATH</span><br><span class="line">export PYENV_ROOT=~/.pyenv</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">刷新环境变量</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>查看可安装的Python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure></li>
<li><p>安装指定版本的Python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv install 3.8.5</span><br></pre></td></tr></table></figure></li>
<li><p>更新数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure></li>
<li><p>切换python版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xxx表示要切换的版本</span><br><span class="line">**有三种切换方式 glocal local shell**</span><br><span class="line">　　1. glocal 全局环境,在未再次使用 glocal切换环境之前，一直使用此环境。</span><br><span class="line">　　2. local 本次登录环境。重启后，则环境失效，并返回当前glocal的环境。</span><br><span class="line">　　3. shell 局部（临时）环境。关闭命令行窗口，则环境失效，并返回当前glocal的环境。</span><br><span class="line">pyenv glocal xxx  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>卸载已经安装的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall xxx</span><br></pre></td></tr></table></figure></li>
<li><p>安装virtualenv   创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pyenv&#x2F;pyenv-virtualenv.git $(pyenv root)&#x2F;plugins&#x2F;pyenv-virtualenv</span><br></pre></td></tr></table></figure></li>
<li><p>添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cho &#39;eval &quot;$(pyenv virtualenv-init -)&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>创建虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.7.0 yolo385</span><br></pre></td></tr></table></figure></li>
<li><p>删除虚拟环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;.pyenv&#x2F;versions&#x2F;env370</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p>八、安装pytorch</p>
<p>torch 官网 ：<a href="https://pytorch.org/">torch</a></p>
<p>按照自己的配置选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install torch&#x3D;&#x3D;1.9.0+cu111 torchvision&#x3D;&#x3D;0.10.0+cu111 torchaudio&#x3D;&#x3D;0.9.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</span><br></pre></td></tr></table></figure>
<p>出现 not import _lzma :</p>
<p>解决办法 ：重新安装pandas</p>
]]></content>
      <tags>
        <tag>YoloV5</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装RabbitMQ</title>
    <url>/2021/07/10/Ubuntu%E5%AE%89%E8%A3%85RabbitMQ/</url>
    <content><![CDATA[<p>​        </p>
<blockquote>
<p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131">编程语言</a>均有与代理接口通讯的<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>库。</p>
</blockquote>
<p>​                                    </p>
<a id="more"></a>

<p>安装前提：首先需要安装Erlang</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install erlang-nox</span><br></pre></td></tr></table></figure>
<p>1、 使用apt-get 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>2、安装完毕配置文件默认在：/etc/rabbitmq/ 下。</p>
<p><strong>如果已经安装了redis ,再启动之前现将redis 启动。</strong></p>
<p>操作命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-server start</span><br><span class="line">sudo rabbitmq-server stop</span><br><span class="line">sudo rabbitmq-server restart</span><br><span class="line">sudo rabbitmqctl status</span><br></pre></td></tr></table></figure>
<p>3、创建用户</p>
<p>创建用户名为： admin  密码：admin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl add_user  admin  admin  </span><br></pre></td></tr></table></figure>
<p>设置用户标签 为：administrator  （添加远程访问必须为 ：administrator  ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
<p>设置当前 / 虚拟主机下的权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一个“.*”用于配置资产实体的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第二个“.*”表示对实体的写权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">第三个“.*” 用于读取物理的权限</span></span><br><span class="line">sudo rabbitmqctl  set_permissions -p / admin &#x27;.*&#x27; &#x27;.*&#x27; &#x27;.*&#x27;</span><br></pre></td></tr></table></figure>
<p>4、列出集群中的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>
<p>5、删除用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_user &#39;用户名&#39;</span><br></pre></td></tr></table></figure>
<p>6、撤销用户在虚拟主机中的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl clear_permissions -p &quot;custom-vhost&quot;  &quot;用户名&quot;</span><br></pre></td></tr></table></figure>
<p>7、看虚拟主机列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_vhosts</span><br></pre></td></tr></table></figure>
<p>8、每个rabbitmqctl权限管理操作的范围仅限于单个虚拟主机。</p>
<p>授予用户对所有虚拟主机的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for v in $(rabbitmqctl list_vhosts --silent); do rabbitmqctl set_permissions -p $v &quot;a-user&quot; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;; done</span><br></pre></td></tr></table></figure>


<p>设置RabbitMQ可以远程访问</p>
<p>在/etc/rabbitmq/rabbitmq-env.conf 中添加以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">loopback_users=none</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda3安装虚拟环境</title>
    <url>/2021/05/09/Miniconda3%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>​                   </p>
<a id="more"></a>

<p>创建虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n [name] python=版本 -y </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 激活环境</span></span><br><span class="line">conda activate name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭环境</span></span><br><span class="line">deactivate </span><br></pre></td></tr></table></figure>
<p>在对应的环境中安装包 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install xxx</span><br><span class="line">conda install xxx</span><br></pre></td></tr></table></figure>
<p>运行jupyter notebook 遇到错误 </p>
<ul>
<li>提示无法导入某个包</li>
</ul>
<p>问题原因：</p>
<p>jupyter notebook 使用的还是原来的python 包，无法使用新的虚拟环境的包。</p>
<p>点击 jupyter notebook 的new 查看是否能够找到新创建的环境。</p>
<p><img src="https://tc.chaizz.com/Snipaste_2021-05-08_18-59-42.png"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ipykernel在虚拟环境下安装 ipykernel。</span></span><br><span class="line">conda install -n 环境名称 ipykernel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将创建的新的虚拟环境，添加到核心。</span></span><br><span class="line">python -m ipykernel install --user --name 环境名称 --display-name &quot;环境名称&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来重新打开 jupyter notebook即可。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>运行代码时提示：内核似乎已经死了 . 它会自动重启 。</li>
</ul>
<p>问题原因：</p>
<p>再学习DIVE INTO DEEP LEARNING 这本书中的代码时，运行某一段输出图表的内容的时候，提示内核似乎已经死了 . 它会自动重启 。 无法输出图表。</p>
<p>在Pycharm 上提示的错误为 ：</p>
<p><img src="https://tc.chaizz.com/Snipaste_2021-05-08_19-10-19.png"></p>
<p>解决办法：</p>
<p>在代码前导入以下代码即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;KMP_DUPLICATE_LIB_OK&#x27;</span>] = <span class="string">&#x27;TRUE&#x27;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p><a href="https://blog.csdn.net/qq_43382616/article/details/108642590">jupyter notebook无法使用conda环境的模块</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/scar2016/article/details/115710308">jupyter notebook内核挂掉了，需要重启</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat连接Oracle数据库</title>
    <url>/2021/05/09/%E8%BF%9E%E6%8E%A5Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>Navicat连接Oracle出现错误信息 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">oracle library is not loaded</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>Navicat版本 ：12.1.11</p>
<p>Navicat 连接Oracle数据库需要配下载Oracle 官方提供的插件 ：<a href="https://www.oracle.com/database/technologies/instant-client/downloads.html">instantclient_19_9</a>，选择自己的系统（我的是windows），将此文件下载解压后放在Navicat安装文件路径下。</p>
<p>然后打开Navicat 的 ：工具-&gt;选项-&gt;环境-&gt;OCI 如下图所示。</p>
<p><img src="https://tc.chaizz.com/3b0b7af0e15211eb9d7c5254006b8f1d.png"></p>
<p>将instantclient_19_9 路径下的oci.dll 文件路径复制到此路径下。</p>
<p>接下来重启Navicat 即可。</p>
]]></content>
      <tags>
        <tag>Navicat、Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装Apex</title>
    <url>/2021/04/24/Centos7%E5%AE%89%E8%A3%85Apex/</url>
    <content><![CDATA[<p>封面图片由<a href="https://pixabay.com/zh/users/khirulislam898-12875647/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">MD KHIRUL ISLAM</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4679928">Pixabay</a>上发布。</p>
<a id="more"></a>

<h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><blockquote>
<p>系统：Centos 7.6</p>
<p>所需 文件：java jdk  、 tomcat9 、Oracle 19c、   Ords 20.4 、 apex 20.2</p>
</blockquote>
<p>安装高版本的JDK和Tomcat会导致出现下面这个问题。建议选择低版本进行安装，低版本和高版本安装大致方法一直，或者采用以下脚本执行。</p>
<p><img src="https://tc.chaizz.com/%E6%89%93%E5%BC%80ords%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98.png"></p>
<h3 id="一、脚本文件方式安装JDK和tomcat"><a href="#一、脚本文件方式安装JDK和tomcat" class="headerlink" title="一、脚本文件方式安装JDK和tomcat"></a>一、脚本文件方式安装JDK和tomcat</h3><p>该脚本文件来自 ：<a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用于安装tomcat</span></span><br><span class="line">JAVA_VER=271</span><br><span class="line">JAVA_DIR=/usr/local/jdk</span><br><span class="line">TOMCAT_VER=9.0.45</span><br><span class="line">Pro=tomcat</span><br><span class="line">CATALINA_HOME=/usr/local/$Pro</span><br><span class="line">[ ! -d /software/ ] &amp;&amp; mkdir /software</span><br><span class="line"><span class="meta">#</span><span class="bash">安装依赖包</span></span><br><span class="line">install_java()&#123;</span><br><span class="line">    cd /software</span><br><span class="line">    #卸载openjdk</span><br><span class="line">    m=`rpm -qa |grep openjdk |wc -l`</span><br><span class="line">    [ $m -ne 0 ] &amp;&amp; rpm -qa |grep openjdk |xargs rpm -e</span><br><span class="line">    #安装java</span><br><span class="line">    if [ ! -f jdk-8u$JAVA_VER-linux-x64.tar.gz ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[31m请手动下载jdk到/software\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    else</span><br><span class="line">        tar xf jdk-8u$JAVA_VER-linux-x64.tar.gz</span><br><span class="line">        [ ! -d $JAVA_DIR ] &amp;&amp; mv jdk1.8.0_$JAVA_VER $JAVA_DIR</span><br><span class="line">        n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; /etc/profile |wc -l`</span><br><span class="line">        if [ $n -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo &quot;JAVA_HOME=$JAVA_DIR&quot; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/jre/lib&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            echo &#x27;export JAVA_HOME PATH CLASSPATH&#x27; &gt;&gt; /etc/profile</span><br><span class="line">            source /etc/profile</span><br><span class="line">        else</span><br><span class="line">            source /etc/profile</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">    java -version</span><br><span class="line">    if [ $? -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\033[36mjdk安装完成\033[0m&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\033[31mjdk安装失败\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装tomcat</span></span><br><span class="line">install_tomcat()&#123;</span><br><span class="line">    #下载tomcat</span><br><span class="line">    [ ! -f apache-tomcat-$TOMCAT_VER.tar.gz ] &amp;&amp; wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v$TOMCAT_VER/bin/apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    #解压</span><br><span class="line">    [ ! -d apache-tomcat-$TOMCAT_VER ] &amp;&amp; tar xf apache-tomcat-$TOMCAT_VER.tar.gz</span><br><span class="line">    [ ! -d $CATALINA_HOME ] &amp;&amp; mv apache-tomcat-$TOMCAT_VER $CATALINA_HOME</span><br><span class="line">    #设置环境变量</span><br><span class="line">    n=`grep &quot;JAVA_HOME=$JAVA_DIR&quot; $CATALINA_HOME/bin/catalina.sh |wc -l`</span><br><span class="line">    if [ $n -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        sed -i &quot;124a JAVA_HOME=$&#123;JAVA_DIR&#125;&quot; $CATALINA_HOME/bin/catalina.sh</span><br><span class="line">    fi</span><br><span class="line">    #配置启动脚本</span><br><span class="line">    cat &gt; /etc/systemd/system/$Pro\.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Apache Tomcat 9 Servlet Container</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Type=forking</span><br><span class="line">LimitNOFILE=131070</span><br><span class="line">Environment=CATALINA_PID=$&#123;CATALINA_HOME&#125;/bin/tomcat.pid</span><br><span class="line">Environment=CATALINA_HOME=$&#123;CATALINA_HOME&#125;</span><br><span class="line">Environment=CATALINA_BASE=$&#123;CATALINA_HOME&#125;</span><br><span class="line">ExecStart=$&#123;CATALINA_HOME&#125;/bin/startup.sh</span><br><span class="line">ExecStop=$&#123;CATALINA_HOME&#125;/bin/shutdown.sh</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    #tomcat开机启动</span><br><span class="line">    systemctl daemon-reload &amp;&amp; systemctl enable $Pro</span><br><span class="line"></span><br><span class="line">    if [ `systemctl status $Pro | grep &#x27;running&#x27;| wc -l` -eq 0 ]</span><br><span class="line">    then</span><br><span class="line">        systemctl start $Pro</span><br><span class="line">        if [ $? -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">            echo -e &quot;\033[36m$Pro安装完毕\033[0m&quot;</span><br><span class="line">        else</span><br><span class="line">            echo -e &quot;\03331m$Pro安装失败\033[0m&quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_java</span><br><span class="line">install_tomcat</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将此脚本复制到系统制定目录下，在根目录下创建/software 。并将JDK 和 tomcat 包放在/software下。</p>
<p>将此脚本文件设置为可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 filename.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后执行此文件</span></span><br><span class="line">sh filename.sh </span><br></pre></td></tr></table></figure>
<p>如果显示以下错误：则表示脚本文件中存在乱码。</p>
<p><img src="https://ae01.alicdn.com/kf/U42528946957d48ff8d31a1fd8b4a3034I.jpg"></p>
<p>解决办法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 vim -b  模式打开文件</span></span><br><span class="line">vim -b filename.sh</span><br></pre></td></tr></table></figure>
<p>打开发现如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U3b6e1138b0b742eea8f46daa886d3296w.jpg"></p>
<p>快速处理办法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\r//g&#x27; filename.sh</span><br></pre></td></tr></table></figure>
<p>接下来再打开就可以执行了。</p>
<p>等待程序运行完毕即可。</p>
<h3 id="一、安装java和tomcat环境。"><a href="#一、安装java和tomcat环境。" class="headerlink" title="一、安装java和tomcat环境。"></a>一、安装java和tomcat环境。</h3><p>1、下载java SE <a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html">文件下载地址</a>，本次选择的是java SE 16 版本。tomcat 版本10.0.5<a href="https://tomcat.apache.org/download-10.cgi">文件下载地址</a>。</p>
<p>将下载的压缩包挤压到指定文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压文件</span></span><br><span class="line">tar -zxvf jdk-16_linux-x64_bin.tar</span><br></pre></td></tr></table></figure>
<p>2、设置环境变量</p>
<p>以下是<em>错误的配置</em>：（在终端输入java -version 没有问题 但是运行tomcat 会出现提示启动成功，但是后台服务不启动。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/var/oracle/jdk-16</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>原因： 因为是使用JDK16，是新版的JDK，网上查找的答案，说是从11开始就不会自动生成jre文件了。</p>
<p>可用的java 环境变量配置如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/var/oracle/jdk-16/</span><br><span class="line">JRE_HOME=$JAVA_HOME</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib</span><br><span class="line">PATH=$JRE_HOME/bin:$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>
<p>将JRE_HOME的路径设置为 JAVA_HOME的路径，即可解决。但是启动tomcat的时候，日志文件会打印一些列NOTE。如下图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/U0185a411b5804effb0c78bcf086a09b2g.jpg"></p>
<p>此问题不影响tomcat使用，目前未解决。</p>
<p>3、测试是否安装成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在终端输入以下命令，测试java是否安装成功，如提示java 版本信息，代表已经安装成功。</span></span><br><span class="line">java -version </span><br></pre></td></tr></table></figure>
<p>4、安装tomcat。</p>
<p>将tomcat 解压至指定文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf  apache-tomcat-10.0.5.tar</span><br><span class="line">mv /apache-tomcat-10.0.5  /var/oracle/tomcat</span><br></pre></td></tr></table></figure>
<p>配置tomcat 环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CATALINA_BASE=/var/oracle/tomcat</span><br><span class="line">PATH=$CATALINA_BASE/bin:$PATH</span><br><span class="line">export PATH CATALINA_BASE</span><br></pre></td></tr></table></figure>
<p>tomcat 的启动命令在 /tomcat/bin/start.sh 可直接启动即可。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./start.sh </span><br></pre></td></tr></table></figure>
<p>查看tomcat是否启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat</span><br></pre></td></tr></table></figure>
<p>启动成功如下图所示</p>
<p><img src="https://ae01.alicdn.com/kf/Ud8527b3539e34383867eff8fd2b89cb3E.jpg"></p>
<p>如果以上java 的环境变量设置不对的话，会导致tomcat 无法启动。虽然提示tomcat启动成功，但是后并没有该服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">此时终端输入验证是否启动成功</span></span><br><span class="line">curl http://ip:8080</span><br></pre></td></tr></table></figure>
<p>如未显示tomcat启动页面HTML，可排查防火墙，是否开启了8080端口 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查防火墙是否启动</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如未开启 则开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查80端口 是否被开启，如开启 则提示  “8080/tcp”</span> </span><br><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如未开启 则需要开启，开启成功会提示 “success”</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证开启的8080端口是否生效， 如果生效则提示 “yes”</span></span><br><span class="line">firewall-cmd --zone=public --query-port=8080/tcp</span><br></pre></td></tr></table></figure>
<p>8080端口开放，再次访问 IP:8080  即可看到tomcat访问成功信息。 </p>
<h3 id="二、安装oracle"><a href="#二、安装oracle" class="headerlink" title="二、安装oracle"></a>二、安装oracle</h3><p>1、以上Java jdk 和 tomcat 安装完毕以后安装 oracle 。</p>
<p>2、在根目录下创建oracle 安装文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;oracle  </span><br></pre></td></tr></table></figure>
<p>3、切换到该目录下执行以下安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先执行</span> </span><br><span class="line">yum localinstall  oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">等待执行结束，在执行</span></span><br><span class="line">yum localinstall oracle-database-ee-19c-1.0-1.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>中途卡断 可重新安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用yum命令 查询更刚刚安装的包, 找到Oracle的包名</span></span><br><span class="line">yum list installed shell</span><br><span class="line"><span class="meta">#</span><span class="bash">先使用以下命令卸载已安装的包。</span></span><br><span class="line">yum remove oracle-database-preinstall-19c-1.0-1.el7.x86_64</span><br><span class="line">yum remove oracle-database-ee-19c-1.0-1.x86_64</span><br></pre></td></tr></table></figure>
<p>4、过一段时间安装完毕成功会提示如图所示。</p>
<p><img src="https://ae01.alicdn.com/kf/Ua0442ba6df124404871dd091810d949e2.jpg"></p>
<p>oracle 的安装文件地址为：/opt/oracle   默认配置文件路径为：/etc/sysconfig/oracledb_ORCLCDB-19c.conf</p>
<p>5、接下来初始化数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c configure</span><br></pre></td></tr></table></figure>
<p>等待数据库初始化。过程中切记不用中断操作。初始化时间可能会很长。只要后台服务还在就说明没问题。</p>
<p>6、切换至Oracle 用户 修改数据库系统账户密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su oracle </span><br><span class="line"><span class="meta">#</span><span class="bash">登录数据库</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#修改sys 和 <span class="keyword">system</span> 的密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> sys identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">system</span> identified <span class="keyword">by</span> test123;</span><br><span class="line"></span><br><span class="line">shutdown immediate;</span><br><span class="line"></span><br><span class="line">startup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;</span><br><span class="line"></span><br><span class="line">startup;</span><br></pre></td></tr></table></figure>
<p>7、配置数据库的环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">在最下面添加以下内容：</span></span><br><span class="line">export ORACLE_HOME=/opt/oracle/product/19c/dbhome_1</span><br><span class="line">export ORACLE_SID=ORCLCDB</span><br><span class="line">export PATH=$PATH:/opt/oracle/product/19c/dbhome_1/bin</span><br><span class="line">export NLS_LANG=American_America.AL32UTF8</span><br></pre></td></tr></table></figure>
<p>8、启动停止oracle</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_ORCLCDB-19c start</span><br><span class="line"></span><br><span class="line">/etc/init.d/oracledb_ORCLCDB-19c stop</span><br></pre></td></tr></table></figure>


<h3 id="三、安装apex"><a href="#三、安装apex" class="headerlink" title="三、安装apex"></a>三、安装apex</h3><p>1、解压apex的压缩包</p>
<p>使用oracle 用户需要将 apex保存的文件富裕oracle 权限。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R oracle:dba /var/oracle/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压到当前文件夹下</span></span><br><span class="line">unzip -q apex_20.2.zip </span><br></pre></td></tr></table></figure>
<p>2、进入oracle数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、登录数据库</span></span><br><span class="line">sqlplus / as sysdba  </span><br></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按顺序执行以下代码</span></span><br><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;   </span><br><span class="line"></span><br><span class="line"><span class="comment">--3、设置系统默认表空间</span></span><br><span class="line"><span class="variable">@apexins</span>.<span class="keyword">sql</span> APEX APEX TEMP <span class="operator">/</span>i<span class="operator">/</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">--接下来等待安装 ，会持续一段时间....。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--4、创建 apex 实例管理员</span></span><br><span class="line"><span class="variable">@apxchpwd</span>.<span class="keyword">sql</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码必须包含：(!&quot;#$%&amp;()``*+,-/:;?_) 和 至少一个大写字母。</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">--5、 修改APEX_PUBLIC_USER 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> APEX_PUBLIC_USER ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -6、 修改flows_files 用户密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> flows_files ACCOUNT UNLOCK IDENTIFIED <span class="keyword">BY</span> Test123_;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DBMS_NETWORK_ACL_ADMIN.APPEND_HOST_ACE(</span><br><span class="line">host <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">ace <span class="operator">=</span><span class="operator">&gt;</span> xs$ace_type(privilege_list <span class="operator">=</span><span class="operator">&gt;</span> xs$name_list(<span class="string">&#x27;connect&#x27;</span>),</span><br><span class="line">principal_name <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;APEX_200200&#x27;</span>,</span><br><span class="line">principal_type <span class="operator">=</span><span class="operator">&gt;</span> xs_acl.ptype_db));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"><span class="variable">@apex</span>_rest_config.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10       </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_LISTENER <span class="keyword">user</span>: Test123_</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 11        </span></span><br><span class="line">Enter a password <span class="keyword">for</span> the APEX_REST_PUBLIC_USER <span class="keyword">user</span>: Test123_</span><br><span class="line">            </span><br></pre></td></tr></table></figure>


<p>3、汉化apex </p>
<p>切换到，apex/builder/zh-cn/ 目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、 登录sql</span></span><br><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2、通过 alter session 切换容器为ORCLPDB1模式。</span></span><br><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> container <span class="operator">=</span> ORCLPDB1;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3、设置CURRENT_SCHEMA </span></span><br><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> <span class="built_in">CURRENT_SCHEMA</span> <span class="operator">=</span> APEX_200200;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4、加载sql</span></span><br><span class="line"><span class="variable">@load</span>_zh<span class="operator">-</span>cn.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等待一段时间即可...</span></span><br></pre></td></tr></table></figure>


<h3 id="四、安装ords"><a href="#四、安装ords" class="headerlink" title="四、安装ords"></a>四、安装ords</h3><p>1、解压文件到当前目录下</p>
<p>2、执行ords安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ords.war install advanced</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来选择会提示输入：</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">This Oracle REST Data Services instance has not yet been configured.</span><br><span class="line">Please complete the following prompts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter the location to store configuration data: /opt/ords/config  # 配置存储路径</span><br><span class="line">Specify the database connection type to use.</span><br><span class="line">Enter number for [1] Basic  [2] TNS  [3] Custom URL [1]:1    </span><br><span class="line">Enter the name of the database server [localhost]:localhost  </span><br><span class="line">Enter the database listen port [1521]:1520                   </span><br><span class="line">Enter 1 to specify the database service name, or 2 to specify the database SID [1]:1</span><br><span class="line">Enter the database service name:ORCLPDB1</span><br><span class="line">Enter 1 if you want to verify/install Oracle REST Data Services schema or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for ORDS_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Xisland2020</span><br><span class="line">Requires to login with administrator privileges to verify Oracle REST Data Services schema.</span><br><span class="line"></span><br><span class="line">Enter the administrator username:SYS                #oracle数据库账号</span><br><span class="line">Enter the database password for SYS AS SYSDBA:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Connecting to database user: SYS AS SYSDBA url: jdbc:oracle:thin:@//localhost:1521/ORCLPDB1</span><br><span class="line"></span><br><span class="line">Retrieving information.</span><br><span class="line">Enter 1 if you want to install ORDS or 2 to skip this step [1]:1</span><br><span class="line">Enter the default tablespace for ORDS_METADATA [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_METADATA [TEMP]:TEMP</span><br><span class="line">Enter the default tablespace for ORDS_PUBLIC_USER [SYSAUX]:SYSAUX</span><br><span class="line">Enter the temporary tablespace for ORDS_PUBLIC_USER [TEMP]:TEMP</span><br><span class="line">Enter 1 if you want to use PL/SQL Gateway or 2 to skip this step.</span><br><span class="line">If using Oracle Application Express or migrating from mod_plsql then you must enter 1 [1]:1</span><br><span class="line">Enter the PL/SQL Gateway database user name [APEX_PUBLIC_USER]:APEX_PUBLIC_USER</span><br><span class="line">Enter the database password for APEX_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter 1 to specify passwords for Application Express RESTful Services database users (APEX_LISTENER, APEX_REST_PUBLIC_USER) or 2 to skip this step [1]:1</span><br><span class="line">Enter the database password for APEX_LISTENER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter the database password for APEX_REST_PUBLIC_USER:Test123_</span><br><span class="line">Confirm password:Test123_</span><br><span class="line">Enter a number to select a feature to enable:</span><br><span class="line">   [1] SQL Developer Web  (Enables all features)</span><br><span class="line">   [2] REST Enabled SQL</span><br><span class="line">   [3] Database API</span><br><span class="line">   [4] REST Enabled SQL and Database API</span><br><span class="line">   [5] None</span><br><span class="line">Choose [1]:1</span><br><span class="line">2021-02-02T08:45:42.287Z INFO        reloaded pools: []</span><br><span class="line">Installing Oracle REST Data Services version 20.4.1.r0131644</span><br><span class="line">... Log file written to /root/ords_install_core_2021-02-02_164542_00395.log</span><br><span class="line">... Verified database prerequisites</span><br><span class="line">... Created Oracle REST Data Services proxy user</span><br><span class="line">... Created Oracle REST Data Services schema</span><br><span class="line">... Granted privileges to Oracle REST Data Services</span><br><span class="line">... Created Oracle REST Data Services database objects</span><br><span class="line">... Log file written to /root/ords_install_datamodel_2021-02-02_164559_00321.log</span><br><span class="line">... Log file written to /root/ords_install_apex_2021-02-02_164600_00696.log</span><br><span class="line">Completed installation for Oracle REST Data Services version 20.4.1.r0131644. Elapsed time: 00:00:19.722 </span><br><span class="line"></span><br><span class="line">Enter 1 if you wish to start in standalone mode or 2 to exit [1]:2</span><br></pre></td></tr></table></figure>
<p>至此ords安装配置结束。</p>
<h3 id="五、部署到tomcat-上"><a href="#五、部署到tomcat-上" class="headerlink" title="五、部署到tomcat 上"></a>五、部署到tomcat 上</h3><p>1、将apex 的静态文件放到tomcat的webapps 下。 路径为你的apex 安装路径：/var/oracle/apex/images</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -a /var/oracle/apex/images/* /var/oracle/apache-tomcat-10.0.5/webapps/apex</span><br></pre></td></tr></table></figure>
<p>2、将ords.war 包 复制到tomcat 的web apｐｓ下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;var&#x2F;oracle&#x2F;ords&#x2F;ords.war &#x2F;var&#x2F;oracle&#x2F;apache-tomcat-10.0.5&#x2F;webapps&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="六、使用nginx-代理"><a href="#六、使用nginx-代理" class="headerlink" title="六、使用nginx 代理"></a>六、使用nginx 代理</h3><p>Nginx 的server配置文件为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 域名;</span><br><span class="line">    </span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Origin &quot;&quot; ;</span><br><span class="line">        proxy_set_header X-Forwarded-Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_connect_timeout 120s;</span><br><span class="line">        proxy_read_timeout    120s;</span><br><span class="line">        proxy_send_timeout    120s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重启nginx 即可。</p>
<h3 id="七、完成"><a href="#七、完成" class="headerlink" title="七、完成"></a>七、完成</h3><p>浏览器输入域名即可打开APEX登录页面。</p>
<p>创建的密码相关：</p>
<ul>
<li><p>apex 创建实例 用户名：admin</p>
</li>
<li><p>密码：Test123_</p>
</li>
<li><p>APEX_LISTENER  user：Test1123_</p>
</li>
<li><p>数据库用户sys密码：test12</p>
</li>
<li><p>数据库用户system密码：test123</p>
</li>
</ul>
<p>参考文章：</p>
<blockquote>
<p><a href="https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=5a6332d51b4e56dff1cdc98af238b0f0&amp;type=note</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_41092687/article/details/89879061">https://blog.csdn.net/weixin_41092687/article/details/89879061</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_39400984/article/details/98104599">https://blog.csdn.net/qq_39400984/article/details/98104599</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/xzm5708796/article/details/88344074">https://blog.csdn.net/xzm5708796/article/details/88344074</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>CentOS7、ORACLE APEX</tag>
      </tags>
  </entry>
  <entry>
    <title>Python代码规范（pep8/Google-style）</title>
    <url>/2021/03/19/Python%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88pep8-Google-style%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>Guido van Rossum（吉多·范罗苏姆，Python 创始人 ）说过，代码的阅读频率远高于编写代码的频率。</p>
</blockquote>
<p>毕竟，即使是在编写代码的时候，你也需要对代码进行反复阅读和调试，来确认代码能够按照期望运行。</p>
<p>本文来自极客时间规范篇学习总结。</p>
<a id="more"></a>

<h2 id="PEP8规范："><a href="#PEP8规范：" class="headerlink" title="PEP8规范："></a>PEP8规范：</h2><p>PEP 是 Python Enhancement Proposal 的缩写，翻译过来叫“Python 增强规范”。正如我们写文章，会有句式、标点、段落格式、开头缩进等标准的规范一样，Python 书写自然也有一套较为官方的规范。PEP 8 就是这样一种规范，它存在的意义，就是让 Python 更易阅读，换句话，增强代码可读性。</p>
<h3 id="缩进规范"><a href="#缩进规范" class="headerlink" title="缩进规范"></a>缩进规范</h3><p>Python 和 C++ / Java 最大的不同在于，后者完全使用大括号来区分代码块，而前者依靠不同行和不同的缩进来进行分块。</p>
<p>Python 的缩进其实可以写成很多种，Tab、双空格、四空格、空格和 Tab 混合等。而 PEP 8 规范告诉我们，<strong>请选择四个空格的缩进，不要使用 Tab，更不要 Tab 和空格混着用。</strong></p>
<p>第二个要注意的是，<strong>每行最大长度请限制在 79 个字符</strong>。</p>
<p>这个原则主要有两个优点：</p>
<ol>
<li>很多工程师在编程的时候，习惯一个屏幕并列竖排展示多个源代码。如果某个源代码的某些行过长，你就需要拖动横向滚动条来阅读，或者需要软回车将本行内容放入下一行，这就极大地影响了编码和阅读效率。</li>
<li>需要有一定经验的编程经验后更容易理解：因为当代码的嵌套层数过高，比如超过三层之后，一行的内容就很容易超过 79 个字符了。所以，这条规定另一方面也在制约着程序员，不要写迭代过深的代码，而是要思考继续把代码分解成其他函数或逻辑块，来优化自己的代码结构。</li>
</ol>
<h3 id="空行规范"><a href="#空行规范" class="headerlink" title="空行规范"></a>空行规范</h3><p>Python 中的空行对 Python 解释器的执行没有影响，但对阅读体验有很深刻的影响。</p>
<p>PEP 8 规定，<strong>全局的类和函数的上方需要空两个空行，而类的函数之间需要空一个空行。</strong>当然，函数内部也可以使用空行，和英语的段落一样，用来区分不同意群之间的代码块。但是记住最多空一行，千万不要滥用。</p>
<p>另外，Python 本身允许把多行合并为一行，使用分号隔开，但这是 PEP 8 不推荐的做法。所以，即使是使用控制语句 if / while / for，你的执行语句哪怕只有一行命令，也请另起一行，这样可以更大程度提升阅读效率。至于代码的尾部，每个代码文件的最后一行为空行，并且只有这一个空行。</p>
<h3 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h3><p>我们再来看一下，代码块中，每行语句中空格的使用。函数的参数列表中，调用函数的参数列表中会出现逗号，请注意逗号后要跟一个空格，这是英语的使用习惯，也能让每个参数独立阅读，更清晰。同理，冒号经常被用来初始化字典，冒号后面也要跟一个空格。另外，Python 中我们可以使用#进行单独注释，请记得要在#后、注释前加一个空格。对于操作符，例如+，-，*，/，&amp;，|，=，==，!=，请在两边都保留空格。不过与此对应，括号内的两端并不需要空格。</p>
<h3 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h3><p>接下来我们说说文档规范。先来看看最常用的 import 函数。</p>
<p>首先，所有 import 尽量放在开头，这个没什么说的，毕竟到处 import 会让人很难看清楚文件之间的依赖关系，运行时 import 也可能会导致潜在的效率问题和其他风险。</p>
<p>其次，不要使用 import 一次导入多个模块。虽然我们可以在一行中 import 多个模块，并用逗号分隔，但请不要这么做。import time, os 是 PEP 8 不推荐的做法。</p>
<p>如果你采用 <code>from module import func</code> 这样的语句，请确保 func 在本文件中不会出现命名冲突。不过，你其实可以通过<code> from module import func as new_func</code> 来进行重命名，从而避免冲突。</p>
<h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>有句话这么说：错误的注释，不如没有注释。所以，当你改动代码的时候，一定要注意检查周围的注释是否需要更新。</p>
<p>对于大的逻辑块，我们可以在最开始相同的缩进处以 # 开始写注释。即使是注释，你也应该把它当成完整的文章来书写。如果英文注释，请注意开头大写及结尾标点，注意避免语法错误和逻辑错误，同时精简要表达的意思。中文注释也是同样的要求。一份优秀的代码，离不开优秀的注释。</p>
<p>至于行注释，如空格规范中所讲，我们可以在一行后面跟两个空格，然后以 # 开头加入注释。不过，请注意，行注释并不是很推荐的方式。</p>
<h3 id="文档描述"><a href="#文档描述" class="headerlink" title="文档描述"></a>文档描述</h3><p>docstring 的写法，它是用三个双引号开始、三个双引号结尾。我们首先用一句话简单说明这个函数做什么，然后跟一段话来详细解释；再往后是参数列表、参数格式、返回值格式。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>“计算机科学的两件难事：缓存失效和命名。”命名对程序员来说，是一个不算省心的事。</p>
<ol>
<li>变量命名。变量名请拒绝使用 a b c d 这样毫无意义的单字符，我们应该使用能够代表其意思的变量名。一般来说，变量使用小写，通过下划线串联起来，例如：data_format、input_spec、image_data_set。唯一可以使用单字符的地方是迭代，比如 for i in range(n) 这种，为了精简可以使用。如果是类的私有变量，请记得前面增加两个下划线。</li>
<li>常量命名，最好的做法是全部大写，并通过下划线连接，例如：WAIT_TIME、SERVER_ADDRESS、PORT_NUMBER。</li>
<li>函数名，也使用小写的方式，通过下划线连接起来，例如：launch_nuclear_missile()、check_input_validation()。</li>
<li>类名，则应该首字母大写，然后合并起来，例如：class SpatialDropout2D()、class FeatureSet()。</li>
</ol>
<p>总之，不要过于吝啬一个变量名的长度。当然，在合理描述这个变量背后代表的对象后，一定的精简能力也是必要的。</p>
<h3 id="代码分解技巧"><a href="#代码分解技巧" class="headerlink" title="代码分解技巧"></a>代码分解技巧</h3><p>编程中一个核心思想是，不写重复代码。重复代码大概率可以通过使用条件、循环、构造函数和类来解决。而另一个核心思想则是，减少迭代层数，尽可能让 Python 代码扁平化，毕竟，人的大脑无法处理过多的栈操作。</p>
<p>一个函数的粒度应该尽可能细，不要让一个函数做太多的事情。所以，对待一个复杂的函数，我们需要尽可能地把它拆分成几个功能简单的函数，然后合并起来。</p>
]]></content>
      <tags>
        <tag>pep8，Google style</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter-notebook的安装与基本使用</title>
    <url>/2021/03/13/Jupyter-notebook%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<h4 id="The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more"><a href="#The-Jupyter-Notebook-is-an-open-source-web-application-that-allows-you-to-create-and-share-documents-that-contain-live-code-equations-visualizations-and-narrative-text-Uses-include-data-cleaning-and-transformation-numerical-simulation-statistical-modeling-data-visualization-machine-learning-and-much-more" class="headerlink" title="The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more."></a>The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.</h4></blockquote>
<p>以上为Jupyter notebook 的官方解释。</p>
<blockquote>
<p>Jupyter Notebook是一个开源Web应用程序，可让您创建和共享包含实时代码，方程式，可视化效果和叙述文本的文档。 用途包括：数据清理和转换，数值模拟，统计建模，数据可视化，机器学习等.</p>
</blockquote>
<a id="more"></a>

<h2 id="一、windows下安装Jupyter-notebook"><a href="#一、windows下安装Jupyter-notebook" class="headerlink" title="一、windows下安装Jupyter notebook"></a>一、windows下安装Jupyter notebook</h2><p>Jupyter notebook 是基于Python 的首先要安装Python环境，或者直接安装Anaconda（直接包含Python和Jupyter notebook）。以上环境省略自行安装。</p>
<ol>
<li>在Python环境下直接安装。（最好是新版本Python）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure>
<p>等待命令安装完毕，如果比较慢的话，建议更换Python的源为清华或者淘宝网易的源下载安装速度会快很多。</p>
<ol start="2">
<li>启动Jupyter notebook , 系统会自动启动浏览器，打开本地的8888端口。（端口没有被占用的情况下。如果被占用端口号会自动加一，启动多个Jupyter notebook应用，端口号也会自动向后加一来启动多个应用。）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook </span><br></pre></td></tr></table></figure>
<p>如果在使用过程中关闭了当前终端，应用也会随之无法连接，无法使用Jupyter notebook应用。</p>
<ol start="3">
<li>如果要以不同的端口号启动Jupyter notebook应用，使用一下的方式启动。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">jupyter notebook --port 8899</span><br></pre></td></tr></table></figure>
<h2 id="二、Jupyter-notebook-界面"><a href="#二、Jupyter-notebook-界面" class="headerlink" title="二、Jupyter notebook 界面"></a>二、Jupyter notebook 界面</h2><ol>
<li><p>如图所示打开Jupyter notebook 的初始界面为：</p>
<p><img src="/2021/03/13/Jupyter-notebook的安装与基本使用/Snipaste_2021-03-13_12-08-09.png"></p>
<p>Jupyter notebook 的默认存储文件的地址为当前用户的文件路径。每个人里面的文件都不太一样。</p>
</li>
<li><p>更改默认的存储路径。</p>
<p>Jupyter notebook  的默认的配置文件在当前用户下的一个隐藏文件（以.jupyter开头的文件）文件下名为jupyter_notebook_config.py 即为jupyter notebook 的配置文件。</p>
<p>打开文件搜索找到 <code>c.NotebookApp.notebook_dir</code> 开头的配置，即是存储文件路径的配置。只需要将你想要修改的路径添加并取消注释即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir &#x3D; &#39;C:&#x2F;Users&#x2F;xxx&#x2F;Desktop&#x2F;Project&#x2F;Jupyter Notebook&#39;</span><br></pre></td></tr></table></figure>
<p>重启启动 Jupyter notebook。此时页面文件目录是空的。</p>
</li>
</ol>
<h2 id="三、使用-Jupyter-notebook"><a href="#三、使用-Jupyter-notebook" class="headerlink" title="三、使用 Jupyter notebook"></a>三、使用 Jupyter notebook</h2><ol>
<li><p>新建一个页面。 点击右上角的 new 按钮可以新建一个工程文件或者文本文件或者文件夹。</p>
<p><img src="/2021/03/13/Jupyter-notebook的安装与基本使用/Snipaste_2021-03-13_12-23-24.png"></p>
<p>例如 新建一个python3文件。新页面样式如图所示。</p>
<p><img src="/2021/03/13/Jupyter-notebook的安装与基本使用/Snipaste_2021-03-13_12-25-08.png"></p>
<p>可在单元格（cell）中输入代码并执行。</p>
</li>
</ol>
<h2 id="四、Jupyter-notebook-快捷键"><a href="#四、Jupyter-notebook-快捷键" class="headerlink" title="四、Jupyter notebook 快捷键"></a>四、Jupyter notebook 快捷键</h2><p>A：在当前单元格的上方添加一行单元格</p>
<p>B：在当前单元格的下方添加一行单元格</p>
<p>M：选中单元格将单元格代码格式改为Markdown格式</p>
<p>Y：选中单元格将单元格代码格式改为代码格式</p>
<p>X：剪切当前单元格</p>
<p>V：在当前单元格下方粘贴复制或者剪切的单元格</p>
<p>Enter：在当前单元格换行</p>
<p>Shift+Enter：代码模式下执行当前单元格代码</p>
<p>shift+V：在当前单元格上方粘贴复制或者剪切的单元格</p>
<p>D D ：连续两个D 删除当前单元格</p>
<p>Z：撤销删除单元格</p>
<p>还有很多快捷键按H都可以找到。</p>
<h2 id="五、Jupyter-notebook-插件"><a href="#五、Jupyter-notebook-插件" class="headerlink" title="五、Jupyter notebook 插件"></a>五、Jupyter notebook 插件</h2><ol>
<li><p>在安装插件之前首先需要安装<strong>jupyter_contrib_nbextensions</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在windows shell 终端输入：</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用 jupyter_contrib_nbextensions</span></span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure>
<p>此时 Jupyter notebook 界面就会出现一个新的菜单栏。</p>
<p><img src="/2021/03/13/Jupyter-notebook的安装与基本使用/Snipaste_2021-03-13_13-06-58.png"></p>
<p>选中此按钮进入配置插件的页面。</p>
<p>取消勾选此按钮。否则无法选择插件。</p>
<p><img src="/2021/03/13/Jupyter-notebook的安装与基本使用/Snipaste_2021-03-13_13-08-31.png"></p>
<p>推荐插件：</p>
<ul>
<li><strong>Notify</strong> ：能在任务处理完后及时向你发送通知</li>
<li><strong>Hinterland</strong> ：自动补全代码</li>
<li><strong>Codefolding</strong>  ：折叠代码</li>
<li><strong>Table of Contents(2)</strong>  ：自动生成导航目录</li>
<li><strong>Autopep8</strong> ：自动格式化代码。（需要安装python库：autopep8）</li>
<li><strong>ExecuteTime</strong> ：显示单元格的运行时间和耗时 </li>
<li><strong>Split Cells Notebook</strong> ：类似于多窗口编辑，将单行排列的单元格放置为多行排列。</li>
<li><strong>Collapsible Headings</strong> ：折叠单元格</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Jupyter notebook、Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件目录</title>
    <url>/2021/02/02/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><strong>/bin</strong>：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>/boot：</strong><br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
</ul>
<a id="more"></a>

<ul>
<li><p><strong>/dev ：</strong><br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>/etc：</strong><br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>/home</strong>：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</li>
<li><p><strong>/lib</strong>：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong>：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong>：<br> 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong>：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong>：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong>：<br> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：</p>
<p> 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong>：<br>这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>/usr</strong>：<br> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
</li>
<li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
<p><img src="/2021/02/02/Linux文件目录/linuxfile.jpg"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装mysql-python插件</title>
    <url>/2021/02/02/Ubuntu%E5%AE%89%E8%A3%85mysql-python%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="运行FLASk-提示-：ERROR-flask-app-No-module-named-MySQLdb"><a href="#运行FLASk-提示-：ERROR-flask-app-No-module-named-MySQLdb" class="headerlink" title="运行FLASk 提示 ：ERROR:flask.app:No module named MySQLdb"></a>运行FLASk 提示 ：ERROR:flask.app:No module named MySQLdb</h4><a id="more"></a>

<h3 id="1-安装-mysql-python"><a href="#1-安装-mysql-python" class="headerlink" title="1.安装 mysql-python"></a>1.安装 mysql-python</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install mysql-python</span><br></pre></td></tr></table></figure>
<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p><img src="/2021/02/02/Ubuntu安装mysql-python插件/snipaste_20190917_205355.jpg" alt="snipaste_20190917_205355"></p>
<h3 id="接下来安装依赖包"><a href="#接下来安装依赖包" class="headerlink" title="接下来安装依赖包"></a>接下来安装依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
<h3 id="如果还是不行安装依赖"><a href="#如果还是不行安装依赖" class="headerlink" title="如果还是不行安装依赖"></a>如果还是不行安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install python-MySQLdb</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Ubuntu、Mysql-Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.5源码安装postgresql-12</title>
    <url>/2021/02/02/Centos7-5%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85postgresql-12/</url>
    <content><![CDATA[<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><ol>
<li><p>首先安装readline 和readline-devel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install readline </span><br><span class="line">yum install readline-devel</span><br></pre></td></tr></table></figure>
<a id="more"></a>

</li>
</ol>
<p>虽然已经安装了readline，但是不安装readlene-devel 在执行 <code>./configure --prefix=/opt/postgresql</code> 的时候会提示，<code>configure: error: readline library not found</code>。</p>
<ol start="2">
<li><p>接下来在执行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/opt/postgresql</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li><p>将postgresql 加入环境变量，打开文件 /etc/profile  在末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PG_HOME=/opt/postgresql  #为安装postgresql的地址</span><br><span class="line">export PATH=$PG_HOME/bin:$PATH</span><br><span class="line">source /etc/profile    #更新环境变量</span><br></pre></td></tr></table></figure></li>
<li><p>创建postgresql 的用户以及用户组 可创建可不创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd postgresql   #创建用户组</span><br><span class="line">useradd -G postgresql postgresql   #创建用户</span><br><span class="line">passwd ********    #设置密码  </span><br></pre></td></tr></table></figure>
</li>
<li><p>初始数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl -D /opt/postgresdata initdb&#x27; #初始化数据库</span><br><span class="line">su postgresql   ：使用这个用户进行操作</span><br><span class="line">/opt/postgresdata：地址为存放初始化的文件路径可自定义，   这个文件的用户权限要为 postgresql可操作</span><br><span class="line">pg_ctl  ：postgresql 的控制器，可以对postgresql 进行启动停止等操作</span><br></pre></td></tr></table></figure>
<p>执行以上语句后会再  /opt/postgresdata 路径下生成一些文件</p>
<p><img src="/2021/02/02/Centos7-5源码安装postgresql-12/postgresql0.jpg"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>postmaster.pid</td>
<td>首行记录了进程PID</td>
</tr>
<tr>
<td>serverlog</td>
<td>数据库日志</td>
</tr>
<tr>
<td>postgresql.conf</td>
<td>主配置文件(可做定制</td>
</tr>
<tr>
<td>pg_hba.conf</td>
<td>鉴权相关文件</td>
</tr>
<tr>
<td>PG_VERSION</td>
<td>当前主版本号</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>启动数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su postgresql -c &#x27;pg_ctl start -D /opt/postgredata -l serverlog&#x27;</span><br></pre></td></tr></table></figure>

</li>
<li><p>设置远程访问,在 pg_hba.conf文文件末尾加上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">host all all 0.0.0.0/0 md5</span><br></pre></td></tr></table></figure></li>
<li><p>为了让 postgresql用户可以远程访问，可以通过 psql 设置密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user postgresql with password &#39;*********&#39;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="9">
<li><p>开启远程访问，默认情况下 postgresql 仅仅监听本机的端口，需要编辑 <strong>/opt/postgredata/ postgresql.conf</strong> 文件开启远程IP的访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_addresses &#x3D; &#39;*&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果需要定制端口，可以执行脚本：</span></span><br><span class="line">postgres -p 5430 -D /opt/postgredata &gt;serverlog 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash">检查进程是否存活：</span></span><br><span class="line">netstat -nlp |grep `head -1 /opt/postgredata/postmaster.pid`</span><br><span class="line"><span class="meta">#</span><span class="bash">停止数据库进程</span></span><br><span class="line">kill -INT `head -1 /opt/postgredata/postmaster.pid`</span><br></pre></td></tr></table></figure></li>
<li><p>配置自启动</p>
<p>找到源码目录中 <strong><em>contrib/start-scripts/linux\</em></strong>脚本文件，拷贝为 <strong>/etc/init.d/postgressql</strong>。修改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序所在目录</span></span><br><span class="line">prefix=/opt/postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据目录</span></span><br><span class="line">PGDATA=&quot;/opt/postgredata&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行用户</span></span><br><span class="line">PGUSER=postgresql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">PGLOG=&quot;$PGDATA/serverlog&quot;</span><br></pre></td></tr></table></figure>
<p>设置执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/init.d/postgressql		</span><br></pre></td></tr></table></figure>

<p>此后，执行以下命令可以方便的启停服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//手动启动服务</span><br><span class="line">    service postgressql start</span><br><span class="line">    </span><br><span class="line">    //查看服务状态</span><br><span class="line">    service postgressql status</span><br><span class="line">    </span><br><span class="line">    //手动停止服务</span><br><span class="line">    service postgressql stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机启动 ,执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add postgressql</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p> <a href="https://www.postgresql.org/download/linux/redhat/">官网安装教程地址</a></p>
<p>安装完成会自动创建一个用户为：postgres  </p>
<p>首先使用管理员用户修改密码，然后登录以后，运行psql 即可使用，</p>
<p>允许远程访问，yum安装的ppostgresql 的配置文件在<code>/var/lib/pgsql/12/data</code> 目录下</p>
<p>修改配置文件 <code>postgresql.conf</code> 将 <code>listen_addresses = &#39;localhost&#39; </code>改为 <code>listen_addresses = &#39;*&#39; </code></p>
<p>然后在修改 <code>pg_hba_conf</code> 在最后一行添加 <code>host all  all  0.0.0.0/0  md5</code>  允许所有IIP访问， 如果限定IP,将0.0.0.0 改为指定IP。</p>
<p>重启命令postgresql  ：<code>systemctl restart postgresql-12</code></p>
<p>参考材料：<a href> https://www.cnblogs.com/littleatp/p/10542137.html </a></p>
]]></content>
      <tags>
        <tag>Centos、Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>Python压缩图片作为缩略图</title>
    <url>/2021/02/02/Python%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<p>将图片压缩，作为缩略图，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFile</span><br><span class="line">ImageFile.LOAD_TRUNCATED_IMAGES = <span class="literal">True</span>    <span class="comment">#   OSError: image file is truncated   图像被截断错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize_by_size</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;按照生成图片文件大小进行处理(单位KB)&quot;&quot;&quot;</span></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">        im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">        size_tmp = os.path.getsize(infile)</span><br><span class="line">        q = <span class="number">100</span></span><br><span class="line">        <span class="keyword">while</span> size_tmp &gt; <span class="number">10240</span> <span class="keyword">and</span> q &gt; <span class="number">0</span>:</span><br><span class="line">            out = im.resize(im.size, Image.ANTIALIAS)</span><br><span class="line">            out.save(outfile, quality=q)</span><br><span class="line">            size_tmp = os.path.getsize(outfile)</span><br><span class="line">            q -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> q == <span class="number">100</span>:</span><br><span class="line">            shutil.copy(infile,outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equal_img</span>(<span class="params">infile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    修改大小</span></span><br><span class="line"><span class="string">    :param cls:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    file_name = infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> file_name.startswith(<span class="string">&#x27;thumbnail&#x27;</span>) <span class="keyword">or</span> file_name.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 判断是不是图片。不是的话，忽略</span></span><br><span class="line">        <span class="keyword">if</span> file_name.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;JPG&#x27;</span>,<span class="string">&#x27;PNG&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>,<span class="string">&#x27;JPEG&#x27;</span>]:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outfilename = <span class="string">&#x27;thumbnail&#x27;</span> + infile.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(&#x27;file_name：&#x27;,outfilename)</span></span><br><span class="line">            outfile = <span class="string">&#x27;/&#x27;</span>.join(infile.split(<span class="string">&#x27;/&#x27;</span>)[:-<span class="number">1</span>]) + <span class="string">&#x27;/&#x27;</span> + outfilename</span><br><span class="line">            <span class="comment"># print(u&#x27;path：&#x27;,outfile)</span></span><br><span class="line">            im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">            width = im.size[<span class="number">0</span>]   <span class="comment"># 获取宽度</span></span><br><span class="line">            height = im.size[<span class="number">1</span>]   <span class="comment"># 获取高度</span></span><br><span class="line">            print(<span class="string">u&#x27;width：height：&#x27;</span>,width,height)</span><br><span class="line">            <span class="keyword">if</span> width &lt;= <span class="number">200</span>:</span><br><span class="line">                shutil.copy(infile,outfile)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coe = <span class="built_in">float</span>(<span class="string">&#x27;%.2f&#x27;</span>%(<span class="number">200</span>/width))   <span class="comment">#保留两位小数可能是0.00，</span></span><br><span class="line">                print(<span class="string">u&#x27;coe：&#x27;</span>,coe)</span><br><span class="line">                <span class="keyword">if</span> coe &lt;= <span class="number">0</span>:</span><br><span class="line">                    coe = <span class="number">0.15</span></span><br><span class="line">                <span class="keyword">if</span> im.mode == <span class="string">&quot;P&quot;</span>:</span><br><span class="line">                    im = im.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">                out = im.resize((<span class="built_in">int</span>(width*coe), <span class="built_in">int</span>(height*coe)), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">                out.save(outfile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gci</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="comment">#遍历filepath下所有文件，包括子目录</span></span><br><span class="line">    files = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> fi <span class="keyword">in</span> files:</span><br><span class="line">        fi_d = os.path.join(filepath,fi)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(fi_d):</span><br><span class="line">            gci(fi_d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># resize_by_size(os.path.join(filepath,fi_d))</span></span><br><span class="line">            equal_img(os.path.join(filepath,fi_d))</span><br><span class="line"></span><br><span class="line"><span class="comment">#递归遍历/root目录下所有文件</span></span><br><span class="line"><span class="comment"># gci(&#x27;/var/local/www/edu_online1/media/works&#x27;)</span></span><br><span class="line"><span class="comment"># gci(&#x27;/root/www/edu_online1/media/works/13360067818/tradition&#x27;)  #正式</span></span><br><span class="line">gci(<span class="string">&#x27;/root/www/edu_online1/media/works/13265647342/udict/1552525240000/䤋&#x27;</span>)  <span class="comment">#正式</span></span><br><span class="line"><span class="comment"># gci(r&#x27;F:\desktop\䤋&#x27;)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python、压缩图片</tag>
      </tags>
  </entry>
  <entry>
    <title>flaskshell创建索引出错</title>
    <url>/2021/02/02/flaskshell%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>遇到的问题：flask 环境中使用 flask shell  使用flask Whoosh 创建索引失败</p>
<a id="more"></a>

<h3 id="解决办法-："><a href="#解决办法-：" class="headerlink" title="解决办法 ："></a>解决办法 ：</h3><pre><code>export FLASK_APP=manage.py
flask shell 
</code></pre>
<p>然后导出 flask 创建的whoosh的whoosh对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 项目内的文件 import whoosh</span><br><span class="line">whoosh.create_index()</span><br></pre></td></tr></table></figure>

<p>​    </p>
]]></content>
      <tags>
        <tag>Flask、shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python + Elestatcsearch</title>
    <url>/2021/02/02/Python-Elestatcsearch/</url>
    <content><![CDATA[<blockquote>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p> ElasticSearch是一个基于<a href="https://baike.baidu.com/item/Lucene/6753302">Lucene</a>的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353">云计算</a>中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。 </p>
<a id="more"></a>

<h2 id="有关概念"><a href="#有关概念" class="headerlink" title="有关概念"></a>有关概念</h2><p>cluster：代表一个<a href="https://baike.baidu.com/item/%E9%9B%86%E7%BE%A4">集群</a>，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</p>
<p>shards：代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</p>
<p>replicas：代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的<a href="https://baike.baidu.com/item/%E5%AE%B9%E9%94%99%E6%80%A7">容错性</a>，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</p>
<p>recovery：代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</p>
<p>river：代表es的一个数据源，也是其它存储方式（如：数据库）同步数据到es的一个方法。它是以插件方式存在的一个es服务，通过读取river中的数据并把它索引到es中，官方的river有couchDB的，RabbitMQ的，Twitter的，Wikipedia的。</p>
<p>gateway：代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分布式文件系统</a>，Hadoop的HDFS和amazon的s3<a href="https://baike.baidu.com/item/%E4%BA%91%E5%AD%98%E5%82%A8">云存储</a>服务。</p>
<p>discovery.zen：代表es的自动发现节点机制，es是一个基于p2p的系统，它先通过广播寻找存在的节点，再通过<a href="https://baike.baidu.com/item/%E5%A4%9A%E6%92%AD">多播</a>协议来进行节点之间的通信，同时也支持<a href="https://baike.baidu.com/item/%E7%82%B9%E5%AF%B9%E7%82%B9">点对点</a>的交互。</p>
<p>Transport：代表es内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、<a href="https://baike.baidu.com/item/thrift">thrift</a>、servlet、memcached、zeroMQ等的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">传输协议</a>（通过<a href="https://baike.baidu.com/item/%E6%8F%92%E4%BB%B6">插件</a>方式集成）。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Elestaticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>两台linux 互相传输文件</title>
    <url>/2021/02/02/%E4%B8%A4%E5%8F%B0linux-%E4%BA%92%E7%9B%B8%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<h4 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h4><h6 id="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"><a href="#rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote-Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。" class="headerlink" title="rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。"></a>rsync是linux系统下的数据<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a><a href="https://baike.baidu.com/item/%E5%A4%87%E4%BB%BD">备份</a>工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步。</h6><h5 id="它的特性如下："><a href="#它的特性如下：" class="headerlink" title="它的特性如下："></a>它的特性如下：</h5><ul>
<li>可以<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F">镜像</a>保存整个目录树和文件系统。</li>
<li>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</li>
<li>无须特殊权限即可安装。</li>
</ul>
<a id="more"></a>

<ul>
<li>快速：第一次同步时 rsync 会复制全部内容，但在下一次只传输修改过的文件。rsync 在传输数据的过程中可以实行压缩及<a href="https://baike.baidu.com/item/%E8%A7%A3%E5%8E%8B%E7%BC%A9">解压缩</a>操作，因此可以使用更少的带宽。</li>
<li>安全：可以使用scp、ssh等方式来传输文件，当然也可以通过直接的socket连接。</li>
<li>支持匿名传输，以方便进行网站镜像。 </li>
</ul>
</blockquote>
<h4 id="1、Rsync参数说明"><a href="#1、Rsync参数说明" class="headerlink" title="1、Rsync参数说明"></a>1、Rsync参数说明</h4><ol>
<li><p>使用 rsync + ssh 进行加密传输  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh /home/ubuntu/remote_test ubuntu@193.112.102.63:/home/ubuntu/remote_test</span><br></pre></td></tr></table></figure></li>
<li><p>参数设置  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v, --verbose 详细模式输出</span><br><span class="line">   -q, --quiet 精简输出模式</span><br><span class="line">   -c, --checksum 打开校验开关，强制对文件传输进行校验</span><br><span class="line">   -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span><br><span class="line">   -r, --recursive 对子目录以递归模式处理</span><br><span class="line">   -R, --relative 使用相对路径信息</span><br><span class="line">   -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">   --backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">   -suffix&#x3D;SUFFIX 定义备份文件前缀</span><br><span class="line">   -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)</span><br><span class="line">   -l, --links 保留软链结</span><br><span class="line">   -L, --copy-links 像对待常规文件一样处理软链接</span><br><span class="line">   --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链接</span><br><span class="line">   --safe-links 忽略指向SRC路径目录树以外的链接</span><br><span class="line">   -H, --hard-links 保留硬链接</span><br><span class="line">   -p, --perms 保持文件权限</span><br><span class="line">   -o, --owner 保持文件属主信息</span><br><span class="line">   -g, --group 保持文件属组信息</span><br><span class="line">   -D, --devices 保持设备文件信息</span><br><span class="line">   -t, --times 保持文件时间信息</span><br><span class="line">   -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间</span><br><span class="line">   -n, --dry-run显示哪些文件将被传输</span><br><span class="line">   -W, --whole-file 拷贝文件，不进行增量检测</span><br><span class="line">   -x, --one-file-system 不要跨越文件系统边界</span><br><span class="line">   -B, --block-size&#x3D;SIZE 检验算法使用的块尺寸，默认是700字节</span><br><span class="line">   -e, --rsh&#x3D;COMMAND 指定使用rsh、ssh方式进行数据同步</span><br><span class="line">   --rsync-path&#x3D;PATH 指定远程服务器上的rsync命令所在路径信息</span><br><span class="line">   -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件</span><br><span class="line">   --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件</span><br><span class="line">   --delete 删除那些DST中SRC没有的文件</span><br><span class="line">   --delete-excluded 同样删除接收端那些被该选项指定排除的文件</span><br><span class="line">   --delete-after 传输结束以后再删除</span><br><span class="line">   --ignore-errors 即使出现IO错误也进行删除</span><br><span class="line">   --max-delete&#x3D;NUM 最多删除NUM个文件</span><br><span class="line">   --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span><br><span class="line">   --force 强制删除目录，即使不为空</span><br><span class="line">   --numeric-ids 不将数字的用户和组ID匹配为用户名和组名</span><br><span class="line">   --timeout&#x3D;TIME IP超时时间，单位为秒</span><br><span class="line">   -I, --ignore-times 不跳过那些有同样的时间和长度的文件</span><br><span class="line">   --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间</span><br><span class="line">   --modify-window&#x3D;NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0</span><br><span class="line">   -T --temp-dir&#x3D;DIR 在DIR中创建临时文件</span><br><span class="line">   --compare-dest&#x3D;DIR 同样比较DIR中的文件来决定是否需要备份</span><br><span class="line">   -P 等同于 --partial</span><br><span class="line">   --progress 显示备份过程</span><br><span class="line">   -z, --compress 对备份的文件在传输时进行压缩处理</span><br><span class="line">   --exclude&#x3D;PATTERN 指定排除不需要传输的文件模式</span><br><span class="line">   --include&#x3D;PATTERN 指定不排除而需要传输的文件模式</span><br><span class="line">   --exclude-from&#x3D;FILE 排除FILE中指定模式的文件</span><br><span class="line">   --include-from&#x3D;FILE 不排除FILE指定模式匹配的文件</span><br><span class="line">   --version 打印版本信息</span><br><span class="line">   --address 绑定到特定的地址</span><br><span class="line">   --config&#x3D;FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件</span><br><span class="line">   --port&#x3D;PORT 指定其他的rsync服务端口</span><br><span class="line">   --blocking-io 对远程shell使用阻塞IO</span><br><span class="line">   -stats 给出某些文件的传输状态</span><br><span class="line">   --progress 在传输时显示传输过程</span><br><span class="line">   --log-format&#x3D;formAT 指定日志文件格式</span><br><span class="line">   --password-file&#x3D;FILE 从FILE中得到密码</span><br><span class="line">   --bwlimit&#x3D;KBPS 限制I&#x2F;O带宽，KBytes per second</span><br><span class="line">   -h, --help 显示帮助信息</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2、目的"><a href="#2、目的" class="headerlink" title="2、目的"></a>2、目的</h4><ul>
<li><p>实现两台服务器之间做增量备份。A服务器作为服务端，B服务器作为客户端。</p>
</li>
<li><p>B服务器每天定时将某个目录下产生的文件发送到A服务器中。</p>
</li>
</ul>
<h4 id="3、操作方法"><a href="#3、操作方法" class="headerlink" title="3、操作方法"></a>3、操作方法</h4><p>在A服务器中安装 rsync ，查看服务器是否安装rsync。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync --version</span><br><span class="line">#显示如下  代表已经安装  版本为：3.1.1  (确保两台服务器之前安装的版本的一致，不一致可能造成无法同步数据)</span><br><span class="line">rsync  version 3.1.2  protocol version 31</span><br><span class="line">Copyright (C) 1996-2015 by Andrew Tridgell, Wayne Davison, and others.</span><br><span class="line">Web site: http:&#x2F;&#x2F;rsync.samba.org&#x2F;</span><br><span class="line">Capabilities:</span><br><span class="line">    64-bit files, 64-bit inums, 64-bit timestamps, 64-bit long ints,</span><br><span class="line">    socketpairs, hardlinks, symlinks, IPv6, batchfiles, inplace,</span><br><span class="line">    append, ACLs, xattrs, iconv, symtimes, prealloc</span><br><span class="line"></span><br><span class="line">rsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you</span><br><span class="line">are welcome to redistribute it under certain conditions.  See the GNU</span><br><span class="line">General Public Licence for details.</span><br></pre></td></tr></table></figure>
<p>两边都安装完成了以后，就可以使用了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avzhe ssh 001 ubuntu@193.112.102.63:/home/ubuntu/remote_test   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ssh模式连接 需要输入密码</span></span><br></pre></td></tr></table></figure>
<h5 id="1-将A服务器作为服务端"><a href="#1-将A服务器作为服务端" class="headerlink" title="1. 将A服务器作为服务端"></a>1. 将A服务器作为服务端</h5><p>编辑文件 <code>/etc/vi /etc/rsyncd.conf</code>默认不存在， 直接创建 。编辑输入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务端配置文件 (和上面一样)</span></span><br><span class="line">motd file = /etc/rsyncd.motd</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsyncd.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line">[workspace]  #模块名 在客户端需要用到</span><br><span class="line">path = /devdata/backres   #需要备份的路径</span><br><span class="line">comment = Test</span><br><span class="line">uid = root   #使用的用户</span><br><span class="line">gid = root   #同上 </span><br><span class="line">read only = false   #是否可写</span><br><span class="line">auth users = root   #验证的用户</span><br><span class="line">secrets file = /etc/rsyncd.pass   #密码文件  文件的权限：600</span><br><span class="line">transfer logging = yes   #日志输出</span><br><span class="line">hosts allow=123.207.165.19   #允许的可短的IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建密码文件 在上述的conf文件中，倒数第三行。内容为当前用户名以及密码 。格式：user：password。密码文件拥有用户必须为当前用户 ubuntu 且权限必须为 600</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu:123456</span><br></pre></td></tr></table></figure>
<p>查看rsync 状态 ： <code>service rsync status</code>。 重启rsync服务： <code>service rsync restart</code></p>
<h5 id="2-将b服务器作为客户端"><a href="#2-将b服务器作为客户端" class="headerlink" title="2. 将b服务器作为客户端"></a>2. 将b服务器作为客户端</h5><p>客户端不需要设置太多内容可直接运行命令，不过需要手动输入密码，可将密码存在一个文件内，使用<code>--password-file=FILE</code> 进行从文件中读取密码。这个文件路径任意。文件内容只包含服务端密码即可。但是必须为root用户拥有且权限为600。</p>
<p>使用命令 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rsync -aqr --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数解释：</span></span><br><span class="line">-a：--archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，</span><br><span class="line">-q：--quiet 精简输出模式</span><br><span class="line">-r：--recursive 对子目录以递归模式处理</span><br><span class="line">workspace：即服务端的模块名</span><br></pre></td></tr></table></figure>
<h5 id="3-设置定时任务"><a href="#3-设置定时任务" class="headerlink" title="3. 设置定时任务"></a>3. 设置定时任务</h5><p>使用ubuntu 的crontab </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>第一次打开会选择的编辑器，一般选择vim,输入数字即可。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Select an editor.  To change later, run &#x27;select-editor&#x27;.</span><br><span class="line">  1. /bin/ed</span><br><span class="line">  2. /bin/nano        &lt;---- easiest</span><br><span class="line">  3. /usr/bin/vim.basic</span><br><span class="line">  4. /usr/bin/vim.tiny</span><br></pre></td></tr></table></figure>
<p>定时任务格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* * * * * command    </span><br><span class="line">用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</span><br><span class="line">minute hour day month week command</span><br><span class="line">其中：</span><br><span class="line">minute：表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</span><br><span class="line">/ 斜杠代表频率 例如：</span><br><span class="line">如果想每分钟都执行一次的话就采用默认的 * * * * *</span><br><span class="line">如果想每五分钟执行一次可以 */5 * * * * </span><br><span class="line">如果是每两个小时执行一次的话 那就是 *  */2 * * *来设置;</span><br></pre></td></tr></table></figure>
<p>在定时任务中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">30 23 * * * sudo rsync -r --password-file=/home/ubuntu/remote_test/rsyncd.pass /home/ubuntu/remote_test ubuntu@193.112.22.194::workspace</span><br><span class="line"><span class="meta">#</span><span class="bash">表示 在每天的23:30 进行数据备份</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN的工作原理</title>
    <url>/2021/02/01/CDN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="CDN访问的两个阶段"><a href="#CDN访问的两个阶段" class="headerlink" title="CDN访问的两个阶段"></a>CDN访问的两个阶段</h3><ul>
<li>1.域名解析</li>
<li>2.内容请求</li>
</ul>
<a id="more"></a>

<h3 id="使用CDN得两种方式："><a href="#使用CDN得两种方式：" class="headerlink" title="使用CDN得两种方式："></a>使用CDN得两种方式：</h3><ul>
<li>手工上传静态资源文件到CDN</li>
<li>tongguo Tengine 把本机的静态资源开放发哦web上，CDN自动回流到Tengine。</li>
</ul>
<h4 id="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"><a href="#以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。" class="headerlink" title="以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。"></a>以手工上传静态文件为例：Django其用户CDN静态资源加速的步骤。</h4><ul>
<li>生成静态文件上传到阿里元OSS。</li>
<li>配置CDN域名，回源地址指向OSS Bucket，配置Referer 防盗链的白名单。</li>
<li>配置OSS Buket 的匿名可以读。</li>
<li>设置STATIC_URL， 直接指向CDN地址，同时注释掉 OssStaticStorage。</li>
</ul>
]]></content>
      <tags>
        <tag>HTTP、前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Django之美：dajngo的常用插件</title>
    <url>/2021/02/01/Django%E4%B9%8B%E7%BE%8E%EF%BC%9Adajngo%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://django-debug-toolbar.readthedocs.io/en/latest/">django_debug_toolbar </a>：提供一个可以查看debug信息的面板（包括SQL执行时间，页面耗时）</p>
</li>
<li><p><a href="https://github.com/jazzband/django-silk">django-silk</a>：django性能瓶颈分析</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><a href="https://simpleui.72wo.com/docs/simpleui/doc.html">Simple-UI</a> ：于Element UI 和 VUE 的django admin 主题。</li>
</ul>
<ul>
<li><a href="https://django-haystack.readthedocs.io/en/master/">haystack django</a> ：模块化搜索方案</li>
</ul>
<ul>
<li><a href="https://github.com/django-notifications/django-notifications">django-notifications</a>：发送消息通知插件</li>
</ul>
<ul>
<li><a href="https://github.com/agusmakmun/django-markdown-editor">django markdown editor</a> ：Markdown 编辑器</li>
</ul>
<ul>
<li><a href="https://github.com/django-crispy-forms/django-crispy-forms">django-crispy-forms</a>：Crispy 表单，以一种非常优雅的、干净的方式来创建表单。</li>
</ul>
<ul>
<li><a href="https://github.com/mbi/django-simple-captcha">django-simple-captcha</a>：Django验证码</li>
</ul>
]]></content>
      <tags>
        <tag>Django、后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 8.0 连接数据库错误</title>
    <url>/2021/02/01/Mysql%208.0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h4 id="Mysql-8-0-连接数据库出现-The-user-specified-as-a-definer-‘mysql-infoschema‘-‘localhost‘-does-not-exist"><a href="#Mysql-8-0-连接数据库出现-The-user-specified-as-a-definer-‘mysql-infoschema‘-‘localhost‘-does-not-exist" class="headerlink" title="Mysql 8.0 连接数据库出现 The user specified as a definer (‘mysql.infoschema‘@‘localhost‘) does not exist"></a>Mysql 8.0 连接数据库出现 The user specified as a definer (‘mysql.infoschema‘@‘localhost‘) does not exist</h4><a id="more"></a>

<p>解决办法：</p>
<ol>
<li><p>重新创建该用户（mysql.infoschema）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;mysql.infoschema&#x27;</span> @ <span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;password &#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>给用户赋予权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;mysql.infoschema&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>刷新数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Mysql、后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 面试题</title>
    <url>/2021/02/01/%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>1、对字典d = {‘a’: 24, ‘b’: 53, ‘d’: 56, ‘h’: 7}  按照字典中的value值排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted(d.items(), key&#x3D;lambda x: x[0])</span><br></pre></td></tr></table></figure>
<p>2、反转字符串 “aSter”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;aSter&#39;[::-1])</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>3、按照list1 中的元素的由从大到小排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">50</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>&#125;]</span><br><span class="line"><span class="built_in">sorted</span>(list1, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># reverse=True   由大到小  sorted排序默认由小到大</span></span><br></pre></td></tr></table></figure>
<p>4、常用的字符串格式化有哪些？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="comment"># 1.占位符 %s</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;%s，你好!&quot;</span> % name</span><br><span class="line"><span class="comment"># 2. format</span></span><br><span class="line">str2 = <span class="string">&quot;&#123;&#125;， 你好!&quot;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure>
<p>5、 下面代码的输出结果是什么 ？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]	</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">list</span>[<span class="number">10</span>:])    </span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>输出结果是空  不会产生IndexError错误，尝试用超出成员个数的Index来获取某个列表的成员，</p>
<p>6、写一个列表生成式产生一个等差为11的等差数列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([x*<span class="number">11</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>
<p>7、给定两个列表怎么找出他们相同的元素和不同的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list2 = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>(list1)</span><br><span class="line">set2 = <span class="built_in">set</span>(list2)</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line">print(set1 ^ set2)</span><br></pre></td></tr></table></figure>
<p>8、python代码实现删除一个list的重复的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]</span><br><span class="line">print(<span class="built_in">set</span>(list1))</span><br></pre></td></tr></table></figure>
<p>9、列举字符串、列表、元祖、字典的五个常用的用法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串：replace、strip、split、reverse、upper、lower、join</span></span><br><span class="line"><span class="comment">#列表：append、pop、insert、remove、count、index</span></span><br><span class="line"><span class="comment"># 元祖：index、count、len()、dir()</span></span><br><span class="line"><span class="comment"># 字典：get、keys、values、popitems、clear、uodate、items</span></span><br></pre></td></tr></table></figure>
<p>10、什么是反射 ？ 以及他的应用场景。</p>
<p>反射就是通过字符串的形式式去对象中访问或操作这个未知的属性或变量，是一种基于字符串的事件驱动。</p>
<p>在面向对象中把对象能够访问、查询、修改自身的状态或者行为称之为反射。</p>
<p>在python中，可以通过字符串的的形式来操作对象的属性。这种行为称之为python中的反射。</p>
<p>python 实现反射的手段：</p>
<p>是通过四个内置函数来实现：<strong>hasattr(object,name)</strong>  <strong>getattr(object,name,default=None) ** **setattr(x,y,v) ** **delattr(x,y)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断对象中是否有这个方法或变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s正在交谈&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;laowang&quot;</span>)        </span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;talk&quot;</span>))    <span class="comment"># True。因为存在talk方法</span></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;name&quot;</span>))    <span class="comment"># True。因为存在name变量</span></span><br><span class="line">print(<span class="built_in">hasattr</span>(p,<span class="string">&quot;abc&quot;</span>))     <span class="comment"># False。因为不存在abc方法或变量</span></span><br></pre></td></tr></table></figure>
<p>反射的好处 ：</p>
<p>实现可插拔机制、动态导入模块（基于反射原理，获取当前的模块的成员）</p>
<p>11、简述Python的深浅拷贝 ，详细见<a href="https://zhuanlan.zhihu.com/p/54011712">链接</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy() ： 浅拷贝，仅仅拷贝数据集合的第一层</span></span><br><span class="line"><span class="comment"># deepcopy() : 深拷贝，拷贝数据集合的所有层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="number">1</span>:<span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====赋值=====&quot;</span>)</span><br><span class="line">b=a</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====浅拷贝=====&quot;</span>)</span><br><span class="line">b=copy.copy(a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;=====深拷贝=====&quot;</span>)</span><br><span class="line">b=copy.deepcopy(a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#结果：</span></span><br><span class="line">=====赋值=====</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line">=====浅拷贝=====</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"><span class="number">2145919592320</span></span><br><span class="line">=====深拷贝=====</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="number">1</span>: <span class="number">2</span>&#125;]</span><br><span class="line"><span class="number">2145919592448</span></span><br><span class="line"><span class="number">2145919532928</span></span><br></pre></td></tr></table></figure>
<p>12、Python的垃圾回收机制。  <a href="https://zhuanlan.zhihu.com/p/83251959">链接</a></p>
<ul>
<li><p>引用计数</p>
<p>在python中每一个对象的的核心就是一个结构体PyObject，他的内部有有一个引用计数器（（ob_refcnt）），程序在运行的过程中他会湿湿的更新 引用计数器（ob_refcnt）的值，来反映当前对象的名称数量，当某个对象的引用计数为零的时候，那么他的内存就会被释放掉。</p>
<ul>
<li>导致引用计数加一的情况有 ：对象被创建、对象被引用、对象被作为参数传入一个函数中、对象存储在容器中。</li>
<li>导致引用计数减一的情况有：对象别名被显示销毁 del、对象别名被赋予新的对象、一个对象离开他的作用域、对象所在的容器被销毁或者是从容器中删除对象<br>我们可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数(注意，这里getrefcount()本身会使得引用计数加一)</li>
</ul>
<p>我们还可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数(注意，这里getrefcount()本身会使得引用计数加一)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<p>引用计数的优点：</p>
<ul>
<li><p>高效、实现逻辑简单、具备实时性，一旦一个对象的引用计数归零，内存就直接释放了。</p>
<p>引用计数的缺点：</p>
</li>
<li><p>逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。</p>
</li>
<li><p>可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。</p>
</li>
<li><p>循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。</p>
</li>
</ul>
</li>
<li><p>标记-清除</p>
<p>他是解决容器对象可能产生的循环引用的问题。</p>
<p>不改动真实的而引用计数，而是将引用计数复制一份副本，改动改对象引用的副本，对于副本做得任何改动都不影响生命对象整体的维护。</p>
<p>标记清除的步骤：</p>
<ul>
<li>标记阶段：遍历所有的对象，如果是科可达的（reachable）也就是说还有对象在引用他，那么就标记该对象可达。</li>
</ul>
</li>
<li><p>清除阶段：再次遍历对象，如果发现某个对象不是可达的，就将其回收。</p>
</li>
<li><p>分代回收</p>
<p>在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过**“分代回收”(Generational Collection)**以空间换时间的方法提高垃圾回收效率。</p>
<p>分代回收是基于这样的一个统计事实，<strong>对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。</strong></p>
<p><strong>总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</strong></p>
</li>
</ul>
<p>13、如何打乱一个排好序的lisit对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">random.shuffle(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<p>14、从0-99这100个数中随即取出十个数字 要求不能重复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.sample(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">99</span>),k=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>15、Python如何捕获异常、处理异常 、抛出异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#捕获异常：</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#处理异常：</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#else:不发生异常执行的语句</span></span><br><span class="line"><span class="comment">#finally：无论是否发生异常都执行的语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># raise Exception   抛出异常</span></span><br></pre></td></tr></table></figure>
<p>16、python递归的大层数</p>
<p>最大为998</p>
<p>17、列表推导式和生成器表达式[i% 2 for iinrange(10)] 和 [i%2 for i in range(10)] 输出的结果分别是什么？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print([i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line">print((i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p>18、 什么是闭包？</p>
<p>指的是定义在一个函数内部的函数 ，被外层函数包裹着。其特点是可以访问到外层函数的名字。<br>闭包”有两种不同的方式，第一种是在函数内部就“直接调用了”；第二种是“返回一个函数名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种形式  在外层函数中直接调用内层函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mark</span>(<span class="params">name</span>):</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">weight</span>):</span></span><br><span class="line">        weight += <span class="number">1</span></span><br><span class="line">        print(name, weight)</span><br><span class="line"></span><br><span class="line">    func(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mark(<span class="string">&#x27;塞拉斯&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种形式:在外层函数中返回内层函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span>(<span class="params">name</span>):</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">height</span>):</span></span><br><span class="line">        height += <span class="number">1</span></span><br><span class="line">        print(name, num, height)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = maker(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">a(<span class="number">999</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># “闭包”的作用——保存函数的状态信息，使函数的局部变量信息依然可以保存下来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Maker</span>(<span class="params">step</span>):</span>  <span class="comment"># 包装器</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span>  <span class="comment"># 内部函数</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num  <span class="comment"># nonlocal关键字的作用和前面的local是一样的，如果不使用该关键字，则不能在中内部函数改变“外部变量”的值</span></span><br><span class="line">        num = num + step  <span class="comment"># 改变外部变量的值（如果只是访问外部变量，则不需要适用nonlocal）</span></span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =====================================#</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line">func2 = Maker(<span class="number">3</span>)  <span class="comment"># 调用外部包装器</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">5</span>):</span><br><span class="line">    func2()  <span class="comment"># 调用内部函数4次 输出的结果是 4、7、10、13</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这就是“闭包”的最大的作用——保存局部信息不被销毁。</span></span><br></pre></td></tr></table></figure>


<p>19、Python 2 和3 的区别</p>
<p>1、 print 由python2的表达式改 为 python3的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prtint()</span><br></pre></td></tr></table></figure>


<p>2、除法 python2会截断，获得正数，python3 会获得浮点数。</p>
<p>3、python2 声明unicode 使用 u’a’， python3 直接 声明：’a’</p>
<p>4、python3 含有解包操作 。a，b , *c  =  range(10)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a，b , *c  =  <span class="built_in">range</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>5、限定关键字参数 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">	retunr a + b + c</span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">    </span><br><span class="line">*后面的参数，必须指定参数名</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b, *, c</span>):</span></span><br><span class="line">    	retunr a + b + c</span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)) </span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>6、python2 range返回的是一个列表 python3返回的是一个range对象</p>
<p>7、python3 新增</p>
<ul>
<li>yield from 链接子生成器</li>
<li>asyncio 内置库， async/await 原生协程支持异步编程</li>
<li>新增的内置库：enum、mock、asyncio、ipaddress、concurrent.futures</li>
</ul>
<p>20、python的传递参数：</p>
<p>共享传参传递的是引用的副本。即不是拷贝到额值也不是操作的内存。是根据传参的对象是可变的还是不可变的进行区分，对于不可变对象，表现是拷贝的值，然后修改新的值。对于不可变对象来说可以直接修改它的值。</p>
<p>21、python 异常捕获为什么不继承baseException,而是继承Exception：因为baseException下有keyboardinterrupt 异常，如果继承baseException 键盘的ctrl + C 就不起作用。所以自定义异常只要继承baseException 就可以。</p>
<p>22、Python 的性能分析，GIL的影响</p>
<ul>
<li><p>GIL的影响</p>
<ul>
<li>同一个时间只能有一个线程执行字节码</li>
<li>CPU密集型程序难以利用多核优势</li>
<li>IO期间会释放GIL，对IO密集型影响不大</li>
</ul>
</li>
<li><p>如何规避GIL的影响</p>
<ul>
<li>CPU密集型可以使用对进程+进程池</li>
<li>IO密集型使用多线程/协程</li>
<li>cpython 扩展</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python、后端、面试</tag>
      </tags>
  </entry>
</search>
