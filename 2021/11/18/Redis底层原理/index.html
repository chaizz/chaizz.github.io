<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Redis底层原理 |
    
    由来同一梦</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-Redis底层原理" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  Redis底层原理
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2021/11/18/Redis%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2021-11-18T01:31:33.000Z" itemprop="datePublished">2021-11-18</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/Redis/">Redis</a>
</div>

      &emsp;<i class="fe fe-bar-chart"></i> <span class="post-count">1.5k</span>字
      &emsp;<i class="fe fe-clock"></i> <span class="post-count">6</span>分钟
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
<div class="article-gallery">
  <div class="article-gallery-photos">
    
    
    <img src="https://tc.chaizz.com/Snipaste_2021-09-26_19-50-26.png" itemprop="image">
    
    
  </div>
</div>

      
      <a id="more"></a>

<h1 id="Redis-数据结构底层实现"><a href="#Redis-数据结构底层实现" class="headerlink" title="Redis 数据结构底层实现"></a>Redis 数据结构底层实现</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Redis 是由C实现的，所以Redis的String字符串是由C语言中的String改进而来的。</p>
<p>在C语言中，C的一个字符串是由数组组成的，”sdasd\0”，在C语言中一个字符串是由\0 结尾，但是在Redis中，String类型可以存储任意数据类型，所以使用\0结尾容易发生截断。所以在Redis中实现了一个简单动态字符串 （SDS &gt; simple dynamic string）来存储数据。</p>
<p>SDS ：他自定义了一个数据长度来代表数据的长度，在Redis 内部定义了多种 sdshdr5、sdshdr8、sdshdr16。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct__attribute__ ((__packed__)) sdshdr5&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flages;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct__attribute__ ((__packed__)) sdshdr8&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> len;</span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flages;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://tc.chaizz.com/61cb3042481111ec9d7c5254006b8f1d.png"></p>
<p><img src="https://tc.chaizz.com/a48dbb8e481111ec9d7c5254006b8f1d.png"></p>
<p>如上图，在底层sdshdr5 是这样定义的：==一个flags 占用一个字节，它又有八bit，前三位表示数据类型，后五位描述数据长度。buffer 是存储的实际数据。==</p>
<p>Redis 数据扩容：内部实现就是将原本的数据长度成倍的扩容，</p>
<p>比如原本的数据长度            len：7  </p>
<p>实际的数据长度                    buf [5] ：”aaaaa”</p>
<p>空闲的数据长度                    free：2</p>
<p>现在需要将数据改为 “ aaaaaaaa”  数据长度为8。 那么数据就会变成如下这样：</p>
<p>新的的数据长度                    len：7 * 2 = 14  </p>
<p>实际的数据长度                    buf [8] ：”aaaaaaaa”</p>
<p>空闲的数据长度                    free：6</p>
<p>所以这样情况下不需要重新分配新内存空间。其中Redis的字符串在复制结束的时候也会自动的加上\0字符，也是为了兼容C语言的一个字符操作的库。</p>
<h2 id="Redis底层数据结构的编码"><a href="#Redis底层数据结构的编码" class="headerlink" title="Redis底层数据结构的编码"></a>Redis底层数据结构的编码</h2><p>当我们在使用 set、 hset 、lpush 这些api去设置Redis 的键值的时候，Redis 会根据我们设置的值的不同在内部采用不同的编码格式。当我们在存储一些不同的值的时候，Redis底层也会自动给我们做一些优化。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 不同长度不同类型的数据</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set longstr aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set shortstr aaa</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set intvalue 100</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding shortstr</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding longstr</span><br><span class="line">&quot;raw&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding intvalue</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们在查看他们的类型的时候都是String</span> </span><br><span class="line">127.0.0.1:6379&gt; type intvalue</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type longstr</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type shortstr</span><br><span class="line">string</span><br></pre></td></tr></table></figure>


<p>当Value的值小于等于44时，string的编码是 embstr ，大于44是raw。</p>
<p>为什么是44呢？</p>
<p>CPU从内存中拿数据时，是有一个缓存行的概念， 最少的拿的数据长度是64个字节 （64 Byte）。</p>
<p>在Redisobject 中 占了16个字节（16 Byte）</p>
<p>Redis sdshdr8 里面 需要占用4个字节，所以还剩44个字节，Redis为了减少一次缓存IO ， 直接将小于等于44 字节的数据取回来 。所以 超过44个字节就会存储为raw编码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">hash</span> 也有不同的编码格式</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset ahash1 f v</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset ahash f v f2 v2222222222222222222222222222222222222222222222222222222</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; type ahash</span><br><span class="line">hash</span><br><span class="line">127.0.0.1:6379&gt; type ahash1</span><br><span class="line">hash</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding  ahash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; object encoding  ahash1</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpush list1 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; type list1</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; object encoding list1</span><br><span class="line">&quot;quicklist&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>


<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>从同一边放同一边出 就是一个栈的数据结构。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush llist a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop llist</span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>从同一边放另一边出 就是一个类似队列的数据结构。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list1 a b c</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list1</span><br><span class="line">&quot;c&quot;</span><br></pre></td></tr></table></figure>


<p>List 的数据结构是一个双端链表 ：quicklist 。 在Redis 的底层是一个ziplist  更加紧凑的压缩列表。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。他将所有的元素紧挨着一块存储，分配的是一块连续的内存。<br>当数据量比较多的时候，才会改为quicklist，因为普通的链表需要的附加的指针空间更大，会比较浪费空间。<br>比如列表里面存储的只是Int的类型的数据，结构上还需要两个额外的指针：prev和next。<br><img src="https://tc.chaizz.com/4e0057b4450e11ec9d7c5254006b8f1d.png"></p>
<p>Redis 将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist 使用双向指针串起来，这样既满足了插入删除性能，又不会出现太大的空间冗余。如上图所示。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>是一种无序、自动去重的的数据结构（如果是一些整形数（编码为intset），其实是有序的）。</p>
<p>他的底层实现是一个value为null的字典，当数据是整形的时候，set集合会将编码改为intset 数据结构，一下两个条件任意满足时set将使用hashtable 存储数据，</p>
<ul>
<li>元素个数大于set-max-intset-entrires</li>
<li>元素无法用整形表示</li>
</ul>
<p>set-max-intset-entrires （intset最大存储的元素个数）最大为512。超过则用hashtable编码。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>Hash 类型对应的数据机构有两种：ziplist （压缩列表） 和 hashtable（哈希表） ，当field-value 的长度较短且个数较少的时候，使用ziplist，否则使用hashtable。</p>
<p>hash-max-ziplist-entries 512</p>
<p>ziplist 的元素超过512个 将改为hashtable编码</p>
<p>hash-max-zipl;ist-value 64</p>
<p>单个元素大小超过64个字节的时候将改为hashtable</p>
<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>SortedSet 是Redis的一个特别的数据结构，他的底层使用了两个数据结构 ziplist    skiplist。</p>
<ol>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素的列表</li>
</ol>

      
    </div>
    <footer class="article-footer">
        
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

        
          <div style="text-align:center;color: #ccc;font-size:14px;">------------- 本文结束&nbsp;<i class="fe fe-smile"></i>&nbsp;感谢您的阅读 -------------</div>
        

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2021/11/18/MySQL%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      MySQL索引问题
      
    </div>
  </a>
  
  
  <a href="/2021/11/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">面试题汇总</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer" style="text-align:center">

    <ul class="list-inline">
      <li>由来同一梦 &copy; 2023</li>
      
        <li><a href="https://beian.miit.gov.cn/" target="_blank">豫ICP备20008035号-1</a></li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>

      <li>theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>

    <br>
    <span>全站共<span class="post-count">150k</span>字</span>
    <br>
    <div class="powered-by">
  
	&emsp;<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span></span>&emsp;
  
    <i class="fe fe-bookmark"></i>文章访问量:<span id="busuanzi_value_page_pv"></span>
  
</div>

    <br>
    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("01/01/2019 00:00:00");//此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
	setInterval("createtime()",250);
</script>



  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="由来同一梦"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>